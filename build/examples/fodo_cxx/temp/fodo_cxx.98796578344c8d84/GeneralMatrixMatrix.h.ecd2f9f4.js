var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_GENERAL_MATRIX_MATRIX_H"},
{"lineNum":"   11","line":"#define EIGEN_GENERAL_MATRIX_MATRIX_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"../InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"template<typename LhsScalar_, typename RhsScalar_> class level3_blocking;"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"/* Specialization for a row-major destination matrix => simple transposition of the product */"},
{"lineNum":"   22","line":"template<"},
{"lineNum":"   23","line":"  typename Index,"},
{"lineNum":"   24","line":"  typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,"},
{"lineNum":"   25","line":"  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,"},
{"lineNum":"   26","line":"  int ResInnerStride>"},
{"lineNum":"   27","line":"struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,ResInnerStride>"},
{"lineNum":"   28","line":"{"},
{"lineNum":"   29","line":"  typedef gebp_traits<RhsScalar,LhsScalar> Traits;"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"  typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;"},
{"lineNum":"   32","line":"  static EIGEN_STRONG_INLINE void run("},
{"lineNum":"   33","line":"    Index rows, Index cols, Index depth,"},
{"lineNum":"   34","line":"    const LhsScalar* lhs, Index lhsStride,"},
{"lineNum":"   35","line":"    const RhsScalar* rhs, Index rhsStride,"},
{"lineNum":"   36","line":"    ResScalar* res, Index resIncr, Index resStride,"},
{"lineNum":"   37","line":"    ResScalar alpha,"},
{"lineNum":"   38","line":"    level3_blocking<RhsScalar,LhsScalar>& blocking,"},
{"lineNum":"   39","line":"    GemmParallelInfo<Index>* info = 0)"},
{"lineNum":"   40","line":"  {"},
{"lineNum":"   41","line":"    // transpose the product such that the result is column major"},
{"lineNum":"   42","line":"    general_matrix_matrix_product<Index,","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"   43","line":"      RhsScalar, RhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateRhs,"},
{"lineNum":"   44","line":"      LhsScalar, LhsStorageOrder==RowMajor ? ColMajor : RowMajor, ConjugateLhs,"},
{"lineNum":"   45","line":"      ColMajor,ResInnerStride>"},
{"lineNum":"   46","line":"    ::run(cols,rows,depth,rhs,rhsStride,lhs,lhsStride,res,resIncr,resStride,alpha,blocking,info);"},
{"lineNum":"   47","line":"  }"},
{"lineNum":"   48","line":"};"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"/*  Specialization for a col-major destination matrix"},
{"lineNum":"   51","line":" *    => Blocking algorithm following Goto\'s paper */"},
{"lineNum":"   52","line":"template<"},
{"lineNum":"   53","line":"  typename Index,"},
{"lineNum":"   54","line":"  typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,"},
{"lineNum":"   55","line":"  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,"},
{"lineNum":"   56","line":"  int ResInnerStride>"},
{"lineNum":"   57","line":"struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,ResInnerStride>"},
{"lineNum":"   58","line":"{"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"typedef gebp_traits<LhsScalar,RhsScalar> Traits;"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"typedef typename ScalarBinaryOpTraits<LhsScalar, RhsScalar>::ReturnType ResScalar;"},
{"lineNum":"   63","line":"static void run(Index rows, Index cols, Index depth,"},
{"lineNum":"   64","line":"  const LhsScalar* _lhs, Index lhsStride,"},
{"lineNum":"   65","line":"  const RhsScalar* _rhs, Index rhsStride,"},
{"lineNum":"   66","line":"  ResScalar* _res, Index resIncr, Index resStride,"},
{"lineNum":"   67","line":"  ResScalar alpha,"},
{"lineNum":"   68","line":"  level3_blocking<LhsScalar,RhsScalar>& blocking,"},
{"lineNum":"   69","line":"  GemmParallelInfo<Index>* info = 0)"},
{"lineNum":"   70","line":"{","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   71","line":"  typedef const_blas_data_mapper<LhsScalar, Index, LhsStorageOrder> LhsMapper;"},
{"lineNum":"   72","line":"  typedef const_blas_data_mapper<RhsScalar, Index, RhsStorageOrder> RhsMapper;"},
{"lineNum":"   73","line":"  typedef blas_data_mapper<typename Traits::ResScalar, Index, ColMajor,Unaligned,ResInnerStride> ResMapper;"},
{"lineNum":"   74","line":"  LhsMapper lhs(_lhs, lhsStride);"},
{"lineNum":"   75","line":"  RhsMapper rhs(_rhs, rhsStride);"},
{"lineNum":"   76","line":"  ResMapper res(_res, resStride, resIncr);"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"  Index kc = blocking.kc();                   // cache block size along the K direction"},
{"lineNum":"   79","line":"  Index mc = (std::min)(rows,blocking.mc());  // cache block size along the M direction","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   80","line":"  Index nc = (std::min)(cols,blocking.nc());  // cache block size along the N direction","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"  gemm_pack_lhs<LhsScalar, Index, LhsMapper, Traits::mr, Traits::LhsProgress, typename Traits::LhsPacket4Packing, LhsStorageOrder> pack_lhs;"},
{"lineNum":"   83","line":"  gemm_pack_rhs<RhsScalar, Index, RhsMapper, Traits::nr, RhsStorageOrder> pack_rhs;"},
{"lineNum":"   84","line":"  gebp_kernel<LhsScalar, RhsScalar, Index, ResMapper, Traits::mr, Traits::nr, ConjugateLhs, ConjugateRhs> gebp;"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"#ifdef EIGEN_HAS_OPENMP"},
{"lineNum":"   87","line":"  if(info)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   88","line":"  {"},
{"lineNum":"   89","line":"    // this is the parallel version!"},
{"lineNum":"   90","line":"    int tid = omp_get_thread_num();","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   91","line":"    int threads = omp_get_num_threads();","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"    LhsScalar* blockA = blocking.blockA();"},
{"lineNum":"   94","line":"    eigen_internal_assert(blockA!=0);"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"    std::size_t sizeB = kc*nc;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   97","line":"    ei_declare_aligned_stack_constructed_variable(RhsScalar, blockB, sizeB, 0);","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"    // For each horizontal panel of the rhs, and corresponding vertical panel of the lhs..."},
{"lineNum":"  100","line":"    for(Index k=0; k<depth; k+=kc)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  101","line":"    {"},
{"lineNum":"  102","line":"      const Index actual_kc = (std::min)(k+kc,depth)-k; // => rows of B\', and cols of the A\'","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"      // In order to reduce the chance that a thread has to wait for the other,"},
{"lineNum":"  105","line":"      // let\'s start by packing B\'."},
{"lineNum":"  106","line":"      pack_rhs(blockB, rhs.getSubMapper(k,0), actual_kc, nc);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"      // Pack A_k to A\' in a parallel fashion:"},
{"lineNum":"  109","line":"      // each thread packs the sub block A_k,i to A\'_i where i is the thread id."},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"      // However, before copying to A\'_i, we have to make sure that no other thread is still using it,"},
{"lineNum":"  112","line":"      // i.e., we test that info[tid].users equals 0."},
{"lineNum":"  113","line":"      // Then, we set info[tid].users to the number of threads to mark that all other threads are going to use it."},
{"lineNum":"  114","line":"      while(info[tid].users!=0) {}","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  115","line":"      info[tid].users = threads;"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"      pack_lhs(blockA+info[tid].lhs_start*actual_kc, lhs.getSubMapper(info[tid].lhs_start,k), actual_kc, info[tid].lhs_length);","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"      // Notify the other threads that the part A\'_i is ready to go."},
{"lineNum":"  120","line":"      info[tid].sync = k;"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"      // Computes C_i += A\' * B\' per A\'_i"},
{"lineNum":"  123","line":"      for(int shift=0; shift<threads; ++shift)","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  124","line":"      {"},
{"lineNum":"  125","line":"        int i = (tid+shift)%threads;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"        // At this point we have to make sure that A\'_i has been updated by the thread i,"},
{"lineNum":"  128","line":"        // we use testAndSetOrdered to mimic a volatile access."},
{"lineNum":"  129","line":"        // However, no need to wait for the B\' part which has been updated by the current thread!"},
{"lineNum":"  130","line":"        if (shift>0) {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  131","line":"          while(info[i].sync!=k) {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  132","line":"          }"},
{"lineNum":"  133","line":"        }"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"        gebp(res.getSubMapper(info[i].lhs_start, 0), blockA+info[i].lhs_start*actual_kc, blockB, info[i].lhs_length, actual_kc, nc, alpha);","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  136","line":"      }"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"      // Then keep going as usual with the remaining B\'"},
{"lineNum":"  139","line":"      for(Index j=nc; j<cols; j+=nc)","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  140","line":"      {"},
{"lineNum":"  141","line":"        const Index actual_nc = (std::min)(j+nc,cols)-j;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"        // pack B_k,j to B\'"},
{"lineNum":"  144","line":"        pack_rhs(blockB, rhs.getSubMapper(k,j), actual_kc, actual_nc);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"        // C_j += A\' * B\'"},
{"lineNum":"  147","line":"        gebp(res.getSubMapper(0, j), blockA, blockB, rows, actual_kc, actual_nc, alpha);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  148","line":"      }"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"      // Release all the sub blocks A\'_i of A\' for the current thread,"},
{"lineNum":"  151","line":"      // i.e., we simply decrement the number of users by 1"},
{"lineNum":"  152","line":"      for(Index i=0; i<threads; ++i)","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  153","line":"#if !EIGEN_HAS_CXX11_ATOMIC"},
{"lineNum":"  154","line":"        #pragma omp atomic"},
{"lineNum":"  155","line":"#endif"},
{"lineNum":"  156","line":"        info[i].users -= 1;"},
{"lineNum":"  157","line":"    }"},
{"lineNum":"  158","line":"  }"},
{"lineNum":"  159","line":"  else"},
{"lineNum":"  160","line":"#endif // EIGEN_HAS_OPENMP"},
{"lineNum":"  161","line":"  {"},
{"lineNum":"  162","line":"    EIGEN_UNUSED_VARIABLE(info);"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"    // this is the sequential version!"},
{"lineNum":"  165","line":"    std::size_t sizeA = kc*mc;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  166","line":"    std::size_t sizeB = kc*nc;"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"    ei_declare_aligned_stack_constructed_variable(LhsScalar, blockA, sizeA, blocking.blockA());","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  169","line":"    ei_declare_aligned_stack_constructed_variable(RhsScalar, blockB, sizeB, blocking.blockB());","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"    const bool pack_rhs_once = mc!=rows && kc==depth && nc==cols;"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"    // For each horizontal panel of the rhs, and corresponding panel of the lhs..."},
{"lineNum":"  174","line":"    for(Index i2=0; i2<rows; i2+=mc)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  175","line":"    {"},
{"lineNum":"  176","line":"      const Index actual_mc = (std::min)(i2+mc,rows)-i2;","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"      for(Index k2=0; k2<depth; k2+=kc)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  179","line":"      {"},
{"lineNum":"  180","line":"        const Index actual_kc = (std::min)(k2+kc,depth)-k2;","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"        // OK, here we have selected one horizontal panel of rhs and one vertical panel of lhs."},
{"lineNum":"  183","line":"        // => Pack lhs\'s panel into a sequential chunk of memory (L2/L3 caching)"},
{"lineNum":"  184","line":"        // Note that this panel will be read as many times as the number of blocks in the rhs\'s"},
{"lineNum":"  185","line":"        // horizontal panel which is, in practice, a very low number."},
{"lineNum":"  186","line":"        pack_lhs(blockA, lhs.getSubMapper(i2,k2), actual_kc, actual_mc);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"        // For each kc x nc block of the rhs\'s horizontal panel..."},
{"lineNum":"  189","line":"        for(Index j2=0; j2<cols; j2+=nc)","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  190","line":"        {"},
{"lineNum":"  191","line":"          const Index actual_nc = (std::min)(j2+nc,cols)-j2;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"          // We pack the rhs\'s block into a sequential chunk of memory (L2 caching)"},
{"lineNum":"  194","line":"          // Note that this block will be read a very high number of times, which is equal to the number of"},
{"lineNum":"  195","line":"          // micro horizontal panel of the large rhs\'s panel (e.g., rows/12 times)."},
{"lineNum":"  196","line":"          if((!pack_rhs_once) || i2==0)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  197","line":"            pack_rhs(blockB, rhs.getSubMapper(k2,j2), actual_kc, actual_nc);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"          // Everything is packed, we can now call the panel * block kernel:"},
{"lineNum":"  200","line":"          gebp(res.getSubMapper(i2, j2), blockA, blockB, actual_mc, actual_kc, actual_nc, alpha);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  201","line":"        }"},
{"lineNum":"  202","line":"      }"},
{"lineNum":"  203","line":"    }"},
{"lineNum":"  204","line":"  }"},
{"lineNum":"  205","line":"}","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"};"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"/*********************************************************************************"},
{"lineNum":"  210","line":"*  Specialization of generic_product_impl for \"large\" GEMM, i.e.,"},
{"lineNum":"  211","line":"*  implementation of the high level wrapper to general_matrix_matrix_product"},
{"lineNum":"  212","line":"**********************************************************************************/"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"template<typename Scalar, typename Index, typename Gemm, typename Lhs, typename Rhs, typename Dest, typename BlockingType>"},
{"lineNum":"  215","line":"struct gemm_functor"},
{"lineNum":"  216","line":"{"},
{"lineNum":"  217","line":"  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, const Scalar& actualAlpha, BlockingType& blocking)"},
{"lineNum":"  218","line":"    : m_lhs(lhs), m_rhs(rhs), m_dest(dest), m_actualAlpha(actualAlpha), m_blocking(blocking)","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  219","line":"  {}"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"  void initParallelSession(Index num_threads) const"},
{"lineNum":"  222","line":"  {"},
{"lineNum":"  223","line":"    m_blocking.initParallel(m_lhs.rows(), m_rhs.cols(), m_lhs.cols(), num_threads);","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  224","line":"    m_blocking.allocateA();","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  225","line":"  }"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const"},
{"lineNum":"  228","line":"  {"},
{"lineNum":"  229","line":"    if(cols==-1)","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  230","line":"      cols = m_rhs.cols();","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"    Gemm::run(rows, cols, m_lhs.cols(),","class":"lineNoCov","hits":"0","possible_hits":"43",},
{"lineNum":"  233","line":"              &m_lhs.coeffRef(row,0), m_lhs.outerStride(),"},
{"lineNum":"  234","line":"              &m_rhs.coeffRef(0,col), m_rhs.outerStride(),","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  235","line":"              (Scalar*)&(m_dest.coeffRef(row,col)), m_dest.innerStride(), m_dest.outerStride(),","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  236","line":"              m_actualAlpha, m_blocking, info);","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  237","line":"  }"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"  typedef typename Gemm::Traits Traits;"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"  protected:"},
{"lineNum":"  242","line":"    const Lhs& m_lhs;"},
{"lineNum":"  243","line":"    const Rhs& m_rhs;"},
{"lineNum":"  244","line":"    Dest& m_dest;"},
{"lineNum":"  245","line":"    Scalar m_actualAlpha;"},
{"lineNum":"  246","line":"    BlockingType& m_blocking;"},
{"lineNum":"  247","line":"};"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"template<int StorageOrder, typename LhsScalar, typename RhsScalar, int MaxRows, int MaxCols, int MaxDepth, int KcFactor=1,"},
{"lineNum":"  250","line":"bool FiniteAtCompileTime = MaxRows!=Dynamic && MaxCols!=Dynamic && MaxDepth != Dynamic> class gemm_blocking_space;"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"template<typename LhsScalar_, typename RhsScalar_>"},
{"lineNum":"  253","line":"class level3_blocking"},
{"lineNum":"  254","line":"{"},
{"lineNum":"  255","line":"    typedef LhsScalar_ LhsScalar;"},
{"lineNum":"  256","line":"    typedef RhsScalar_ RhsScalar;"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"  protected:"},
{"lineNum":"  259","line":"    LhsScalar* m_blockA;"},
{"lineNum":"  260","line":"    RhsScalar* m_blockB;"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"    Index m_mc;"},
{"lineNum":"  263","line":"    Index m_nc;"},
{"lineNum":"  264","line":"    Index m_kc;"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"  public:"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"    level3_blocking()"},
{"lineNum":"  269","line":"      : m_blockA(0), m_blockB(0), m_mc(0), m_nc(0), m_kc(0)","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  270","line":"    {}"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"    inline Index mc() const { return m_mc; }","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  273","line":"    inline Index nc() const { return m_nc; }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  274","line":"    inline Index kc() const { return m_kc; }","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"    inline LhsScalar* blockA() { return m_blockA; }","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  277","line":"    inline RhsScalar* blockB() { return m_blockB; }","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  278","line":"};"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"template<int StorageOrder, typename LhsScalar_, typename RhsScalar_, int MaxRows, int MaxCols, int MaxDepth, int KcFactor>"},
{"lineNum":"  281","line":"class gemm_blocking_space<StorageOrder,LhsScalar_,RhsScalar_,MaxRows, MaxCols, MaxDepth, KcFactor, true /* == FiniteAtCompileTime */>"},
{"lineNum":"  282","line":"  : public level3_blocking<"},
{"lineNum":"  283","line":"      typename conditional<StorageOrder==RowMajor,RhsScalar_,LhsScalar_>::type,"},
{"lineNum":"  284","line":"      typename conditional<StorageOrder==RowMajor,LhsScalar_,RhsScalar_>::type>"},
{"lineNum":"  285","line":"{"},
{"lineNum":"  286","line":"    enum {"},
{"lineNum":"  287","line":"      Transpose = StorageOrder==RowMajor,"},
{"lineNum":"  288","line":"      ActualRows = Transpose ? MaxCols : MaxRows,"},
{"lineNum":"  289","line":"      ActualCols = Transpose ? MaxRows : MaxCols"},
{"lineNum":"  290","line":"    };"},
{"lineNum":"  291","line":"    typedef typename conditional<Transpose,RhsScalar_,LhsScalar_>::type LhsScalar;"},
{"lineNum":"  292","line":"    typedef typename conditional<Transpose,LhsScalar_,RhsScalar_>::type RhsScalar;"},
{"lineNum":"  293","line":"    typedef gebp_traits<LhsScalar,RhsScalar> Traits;"},
{"lineNum":"  294","line":"    enum {"},
{"lineNum":"  295","line":"      SizeA = ActualRows * MaxDepth,"},
{"lineNum":"  296","line":"      SizeB = ActualCols * MaxDepth"},
{"lineNum":"  297","line":"    };"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"#if EIGEN_MAX_STATIC_ALIGN_BYTES >= EIGEN_DEFAULT_ALIGN_BYTES"},
{"lineNum":"  300","line":"    EIGEN_ALIGN_MAX LhsScalar m_staticA[SizeA];"},
{"lineNum":"  301","line":"    EIGEN_ALIGN_MAX RhsScalar m_staticB[SizeB];"},
{"lineNum":"  302","line":"#else"},
{"lineNum":"  303","line":"    EIGEN_ALIGN_MAX char m_staticA[SizeA * sizeof(LhsScalar) + EIGEN_DEFAULT_ALIGN_BYTES-1];"},
{"lineNum":"  304","line":"    EIGEN_ALIGN_MAX char m_staticB[SizeB * sizeof(RhsScalar) + EIGEN_DEFAULT_ALIGN_BYTES-1];"},
{"lineNum":"  305","line":"#endif"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"  public:"},
{"lineNum":"  308","line":""},
{"lineNum":"  309","line":"    gemm_blocking_space(Index /*rows*/, Index /*cols*/, Index /*depth*/, Index /*num_threads*/, bool /*full_rows = false*/)"},
{"lineNum":"  310","line":"    {"},
{"lineNum":"  311","line":"      this->m_mc = ActualRows;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  312","line":"      this->m_nc = ActualCols;"},
{"lineNum":"  313","line":"      this->m_kc = MaxDepth;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  314","line":"#if EIGEN_MAX_STATIC_ALIGN_BYTES >= EIGEN_DEFAULT_ALIGN_BYTES"},
{"lineNum":"  315","line":"      this->m_blockA = m_staticA;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  316","line":"      this->m_blockB = m_staticB;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  317","line":"#else"},
{"lineNum":"  318","line":"      this->m_blockA = reinterpret_cast<LhsScalar*>((internal::UIntPtr(m_staticA) + (EIGEN_DEFAULT_ALIGN_BYTES-1)) & ~std::size_t(EIGEN_DEFAULT_ALIGN_BYTES-1));"},
{"lineNum":"  319","line":"      this->m_blockB = reinterpret_cast<RhsScalar*>((internal::UIntPtr(m_staticB) + (EIGEN_DEFAULT_ALIGN_BYTES-1)) & ~std::size_t(EIGEN_DEFAULT_ALIGN_BYTES-1));"},
{"lineNum":"  320","line":"#endif"},
{"lineNum":"  321","line":"    }"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"    void initParallel(Index, Index, Index, Index)"},
{"lineNum":"  324","line":"    {}"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"    inline void allocateA() {}"},
{"lineNum":"  327","line":"    inline void allocateB() {}"},
{"lineNum":"  328","line":"    inline void allocateAll() {}"},
{"lineNum":"  329","line":"};"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"template<int StorageOrder, typename LhsScalar_, typename RhsScalar_, int MaxRows, int MaxCols, int MaxDepth, int KcFactor>"},
{"lineNum":"  332","line":"class gemm_blocking_space<StorageOrder,LhsScalar_,RhsScalar_,MaxRows, MaxCols, MaxDepth, KcFactor, false>"},
{"lineNum":"  333","line":"  : public level3_blocking<"},
{"lineNum":"  334","line":"      typename conditional<StorageOrder==RowMajor,RhsScalar_,LhsScalar_>::type,"},
{"lineNum":"  335","line":"      typename conditional<StorageOrder==RowMajor,LhsScalar_,RhsScalar_>::type>"},
{"lineNum":"  336","line":"{"},
{"lineNum":"  337","line":"    enum {"},
{"lineNum":"  338","line":"      Transpose = StorageOrder==RowMajor"},
{"lineNum":"  339","line":"    };"},
{"lineNum":"  340","line":"    typedef typename conditional<Transpose,RhsScalar_,LhsScalar_>::type LhsScalar;"},
{"lineNum":"  341","line":"    typedef typename conditional<Transpose,LhsScalar_,RhsScalar_>::type RhsScalar;"},
{"lineNum":"  342","line":"    typedef gebp_traits<LhsScalar,RhsScalar> Traits;"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"    Index m_sizeA;"},
{"lineNum":"  345","line":"    Index m_sizeB;"},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"  public:"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"    gemm_blocking_space(Index rows, Index cols, Index depth, Index num_threads, bool l3_blocking)"},
{"lineNum":"  350","line":"    {"},
{"lineNum":"  351","line":"      this->m_mc = Transpose ? cols : rows;","class":"lineNoCov","hits":"0","possible_hits":"29",},
{"lineNum":"  352","line":"      this->m_nc = Transpose ? rows : cols;","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  353","line":"      this->m_kc = depth;","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"      if(l3_blocking)"},
{"lineNum":"  356","line":"      {"},
{"lineNum":"  357","line":"        computeProductBlockingSizes<LhsScalar,RhsScalar,KcFactor>(this->m_kc, this->m_mc, this->m_nc, num_threads);"},
{"lineNum":"  358","line":"      }"},
{"lineNum":"  359","line":"      else  // no l3 blocking"},
{"lineNum":"  360","line":"      {"},
{"lineNum":"  361","line":"        Index n = this->m_nc;","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  362","line":"        computeProductBlockingSizes<LhsScalar,RhsScalar,KcFactor>(this->m_kc, this->m_mc, n, num_threads);"},
{"lineNum":"  363","line":"      }"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"      m_sizeA = this->m_mc * this->m_kc;","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  366","line":"      m_sizeB = this->m_kc * this->m_nc;","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  367","line":"    }"},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"    void initParallel(Index rows, Index cols, Index depth, Index num_threads)"},
{"lineNum":"  370","line":"    {"},
{"lineNum":"  371","line":"      this->m_mc = Transpose ? cols : rows;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  372","line":"      this->m_nc = Transpose ? rows : cols;","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  373","line":"      this->m_kc = depth;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"      eigen_internal_assert(this->m_blockA==0 && this->m_blockB==0);"},
{"lineNum":"  376","line":"      Index m = this->m_mc;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  377","line":"      computeProductBlockingSizes<LhsScalar,RhsScalar,KcFactor>(this->m_kc, m, this->m_nc, num_threads);"},
{"lineNum":"  378","line":"      m_sizeA = this->m_mc * this->m_kc;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  379","line":"      m_sizeB = this->m_kc * this->m_nc;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  380","line":"    }"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"    void allocateA()"},
{"lineNum":"  383","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  384","line":"      if(this->m_blockA==0)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  385","line":"        this->m_blockA = aligned_new<LhsScalar>(m_sizeA);","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  386","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"    void allocateB()"},
{"lineNum":"  389","line":"    {"},
{"lineNum":"  390","line":"      if(this->m_blockB==0)"},
{"lineNum":"  391","line":"        this->m_blockB = aligned_new<RhsScalar>(m_sizeB);"},
{"lineNum":"  392","line":"    }"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"    void allocateAll()"},
{"lineNum":"  395","line":"    {"},
{"lineNum":"  396","line":"      allocateA();"},
{"lineNum":"  397","line":"      allocateB();"},
{"lineNum":"  398","line":"    }"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"    ~gemm_blocking_space()"},
{"lineNum":"  401","line":"    {"},
{"lineNum":"  402","line":"      aligned_delete(this->m_blockA, m_sizeA);","class":"lineNoCov","hits":"0","possible_hits":"52",},
{"lineNum":"  403","line":"      aligned_delete(this->m_blockB, m_sizeB);","class":"lineNoCov","hits":"0","possible_hits":"52",},
{"lineNum":"  404","line":"    }"},
{"lineNum":"  405","line":"};"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"} // end namespace internal"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"namespace internal {"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"  412","line":"struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemmProduct>"},
{"lineNum":"  413","line":"  : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemmProduct> >"},
{"lineNum":"  414","line":"{"},
{"lineNum":"  415","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  416","line":"  typedef typename Lhs::Scalar LhsScalar;"},
{"lineNum":"  417","line":"  typedef typename Rhs::Scalar RhsScalar;"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"  typedef internal::blas_traits<Lhs> LhsBlasTraits;"},
{"lineNum":"  420","line":"  typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;"},
{"lineNum":"  421","line":"  typedef typename internal::remove_all<ActualLhsType>::type ActualLhsTypeCleaned;"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"  typedef internal::blas_traits<Rhs> RhsBlasTraits;"},
{"lineNum":"  424","line":"  typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;"},
{"lineNum":"  425","line":"  typedef typename internal::remove_all<ActualRhsType>::type ActualRhsTypeCleaned;"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"  enum {"},
{"lineNum":"  428","line":"    MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)"},
{"lineNum":"  429","line":"  };"},
{"lineNum":"  430","line":""},
{"lineNum":"  431","line":"  typedef generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> lazyproduct;"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"  template<typename Dst>"},
{"lineNum":"  434","line":"  static void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  435","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  436","line":"    // See http://eigen.tuxfamily.org/bz/show_bug.cgi?id=404 for a discussion and helper program"},
{"lineNum":"  437","line":"    // to determine the following heuristic."},
{"lineNum":"  438","line":"    // EIGEN_GEMM_TO_COEFFBASED_THRESHOLD is typically defined to 20 in GeneralProduct.h,"},
{"lineNum":"  439","line":"    // unless it has been specialized by the user or for a given architecture."},
{"lineNum":"  440","line":"    // Note that the condition rhs.rows()>0 was required because lazy product is (was?) not happy with empty inputs."},
{"lineNum":"  441","line":"    // I\'m not sure it is still required."},
{"lineNum":"  442","line":"    if((rhs.rows()+dst.rows()+dst.cols())<EIGEN_GEMM_TO_COEFFBASED_THRESHOLD && rhs.rows()>0)","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  443","line":"      lazyproduct::eval_dynamic(dst, lhs, rhs, internal::assign_op<typename Dst::Scalar,Scalar>());"},
{"lineNum":"  444","line":"    else"},
{"lineNum":"  445","line":"    {"},
{"lineNum":"  446","line":"      dst.setZero();"},
{"lineNum":"  447","line":"      scaleAndAddTo(dst, lhs, rhs, Scalar(1));","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  448","line":"    }"},
{"lineNum":"  449","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"  template<typename Dst>"},
{"lineNum":"  452","line":"  static void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  453","line":"  {"},
{"lineNum":"  454","line":"    if((rhs.rows()+dst.rows()+dst.cols())<EIGEN_GEMM_TO_COEFFBASED_THRESHOLD && rhs.rows()>0)"},
{"lineNum":"  455","line":"      lazyproduct::eval_dynamic(dst, lhs, rhs, internal::add_assign_op<typename Dst::Scalar,Scalar>());"},
{"lineNum":"  456","line":"    else"},
{"lineNum":"  457","line":"      scaleAndAddTo(dst,lhs, rhs, Scalar(1));"},
{"lineNum":"  458","line":"  }"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"  template<typename Dst>"},
{"lineNum":"  461","line":"  static void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  462","line":"  {"},
{"lineNum":"  463","line":"    if((rhs.rows()+dst.rows()+dst.cols())<EIGEN_GEMM_TO_COEFFBASED_THRESHOLD && rhs.rows()>0)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  464","line":"      lazyproduct::eval_dynamic(dst, lhs, rhs, internal::sub_assign_op<typename Dst::Scalar,Scalar>());"},
{"lineNum":"  465","line":"    else"},
{"lineNum":"  466","line":"      scaleAndAddTo(dst, lhs, rhs, Scalar(-1));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  467","line":"  }"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"  template<typename Dest>"},
{"lineNum":"  470","line":"  static void scaleAndAddTo(Dest& dst, const Lhs& a_lhs, const Rhs& a_rhs, const Scalar& alpha)"},
{"lineNum":"  471","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  472","line":"    eigen_assert(dst.rows()==a_lhs.rows() && dst.cols()==a_rhs.cols());"},
{"lineNum":"  473","line":"    if(a_lhs.cols()==0 || a_lhs.rows()==0 || a_rhs.cols()==0)","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  474","line":"      return;"},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"    if (dst.cols() == 1)","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  477","line":"    {"},
{"lineNum":"  478","line":"      // Fallback to GEMV if either the lhs or rhs is a runtime vector"},
{"lineNum":"  479","line":"      typename Dest::ColXpr dst_vec(dst.col(0));"},
{"lineNum":"  480","line":"      return internal::generic_product_impl<Lhs,typename Rhs::ConstColXpr,DenseShape,DenseShape,GemvProduct>","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  481","line":"        ::scaleAndAddTo(dst_vec, a_lhs, a_rhs.col(0), alpha);"},
{"lineNum":"  482","line":"    }"},
{"lineNum":"  483","line":"    else if (dst.rows() == 1)","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  484","line":"    {"},
{"lineNum":"  485","line":"      // Fallback to GEMV if either the lhs or rhs is a runtime vector"},
{"lineNum":"  486","line":"      typename Dest::RowXpr dst_vec(dst.row(0));"},
{"lineNum":"  487","line":"      return internal::generic_product_impl<typename Lhs::ConstRowXpr,Rhs,DenseShape,DenseShape,GemvProduct>","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  488","line":"        ::scaleAndAddTo(dst_vec, a_lhs.row(0), a_rhs, alpha);"},
{"lineNum":"  489","line":"    }"},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"    typename internal::add_const_on_value_type<ActualLhsType>::type lhs = LhsBlasTraits::extract(a_lhs);"},
{"lineNum":"  492","line":"    typename internal::add_const_on_value_type<ActualRhsType>::type rhs = RhsBlasTraits::extract(a_rhs);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"    Scalar actualAlpha = combine_scalar_factors(alpha, a_lhs, a_rhs);"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"    typedef internal::gemm_blocking_space<(Dest::Flags&RowMajorBit) ? RowMajor : ColMajor,LhsScalar,RhsScalar,"},
{"lineNum":"  497","line":"            Dest::MaxRowsAtCompileTime,Dest::MaxColsAtCompileTime,MaxDepthAtCompileTime> BlockingType;"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"    typedef internal::gemm_functor<"},
{"lineNum":"  500","line":"      Scalar, Index,"},
{"lineNum":"  501","line":"      internal::general_matrix_matrix_product<"},
{"lineNum":"  502","line":"        Index,"},
{"lineNum":"  503","line":"        LhsScalar, (ActualLhsTypeCleaned::Flags&RowMajorBit) ? RowMajor : ColMajor, bool(LhsBlasTraits::NeedToConjugate),"},
{"lineNum":"  504","line":"        RhsScalar, (ActualRhsTypeCleaned::Flags&RowMajorBit) ? RowMajor : ColMajor, bool(RhsBlasTraits::NeedToConjugate),"},
{"lineNum":"  505","line":"        (Dest::Flags&RowMajorBit) ? RowMajor : ColMajor,"},
{"lineNum":"  506","line":"        Dest::InnerStrideAtCompileTime>,"},
{"lineNum":"  507","line":"      ActualLhsTypeCleaned, ActualRhsTypeCleaned, Dest, BlockingType> GemmFunctor;"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"    BlockingType blocking(dst.rows(), dst.cols(), lhs.cols(), 1, true);"},
{"lineNum":"  510","line":"    internal::parallelize_gemm<(Dest::MaxRowsAtCompileTime>32 || Dest::MaxRowsAtCompileTime==Dynamic)>","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  511","line":"        (GemmFunctor(lhs, rhs, dst, actualAlpha, blocking), a_lhs.rows(), a_rhs.cols(), a_lhs.cols(), Dest::Flags&RowMajorBit);"},
{"lineNum":"  512","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  513","line":"};"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"} // end namespace internal"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"} // end namespace Eigen"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"#endif // EIGEN_GENERAL_MATRIX_MATRIX_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 90, "covered" : 0,};
var merged_data = [];
