var data = {lines:[
{"lineNum":"    1","line":"/*! \\file cereal.hpp"},
{"lineNum":"    2","line":"    \\brief Main cereal functionality */"},
{"lineNum":"    3","line":"/*"},
{"lineNum":"    4","line":"  Copyright (c) 2014, Randolph Voorhies, Shane Grant"},
{"lineNum":"    5","line":"  All rights reserved."},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"  Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    8","line":"  modification, are permitted provided that the following conditions are met:"},
{"lineNum":"    9","line":"      * Redistributions of source code must retain the above copyright"},
{"lineNum":"   10","line":"        notice, this list of conditions and the following disclaimer."},
{"lineNum":"   11","line":"      * Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   12","line":"        notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   13","line":"        documentation and/or other materials provided with the distribution."},
{"lineNum":"   14","line":"      * Neither the name of cereal nor the"},
{"lineNum":"   15","line":"        names of its contributors may be used to endorse or promote products"},
{"lineNum":"   16","line":"        derived from this software without specific prior written permission."},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"},
{"lineNum":"   19","line":"  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"},
{"lineNum":"   20","line":"  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"},
{"lineNum":"   21","line":"  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES OR SHANE GRANT BE LIABLE FOR ANY"},
{"lineNum":"   22","line":"  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"},
{"lineNum":"   23","line":"  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"},
{"lineNum":"   24","line":"  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"},
{"lineNum":"   25","line":"  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   26","line":"  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   27","line":"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   28","line":"*/"},
{"lineNum":"   29","line":"#ifndef CEREAL_CEREAL_HPP_"},
{"lineNum":"   30","line":"#define CEREAL_CEREAL_HPP_"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"#include <type_traits>"},
{"lineNum":"   33","line":"#include <string>"},
{"lineNum":"   34","line":"#include <memory>"},
{"lineNum":"   35","line":"#include <functional>"},
{"lineNum":"   36","line":"#include <unordered_map>"},
{"lineNum":"   37","line":"#include <unordered_set>"},
{"lineNum":"   38","line":"#include <vector>"},
{"lineNum":"   39","line":"#include <cstddef>"},
{"lineNum":"   40","line":"#include <cstdint>"},
{"lineNum":"   41","line":"#include <functional>"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"#include \"cereal/macros.hpp\""},
{"lineNum":"   44","line":"#include \"cereal/details/traits.hpp\""},
{"lineNum":"   45","line":"#include \"cereal/details/helpers.hpp\""},
{"lineNum":"   46","line":"#include \"cereal/types/base_class.hpp\""},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"namespace cereal"},
{"lineNum":"   49","line":"{"},
{"lineNum":"   50","line":"  // ######################################################################"},
{"lineNum":"   51","line":"  //! Creates a name value pair"},
{"lineNum":"   52","line":"  /*! @relates NameValuePair"},
{"lineNum":"   53","line":"      @ingroup Utility */"},
{"lineNum":"   54","line":"  template <class T> inline"},
{"lineNum":"   55","line":"  NameValuePair<T> make_nvp( std::string const & name, T && value )"},
{"lineNum":"   56","line":"  {"},
{"lineNum":"   57","line":"    return {name.c_str(), std::forward<T>(value)};"},
{"lineNum":"   58","line":"  }"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"  //! Creates a name value pair"},
{"lineNum":"   61","line":"  /*! @relates NameValuePair"},
{"lineNum":"   62","line":"      @ingroup Utility */"},
{"lineNum":"   63","line":"  template <class T> inline"},
{"lineNum":"   64","line":"  NameValuePair<T> make_nvp( const char * name, T && value )"},
{"lineNum":"   65","line":"  {"},
{"lineNum":"   66","line":"    return {name, std::forward<T>(value)};"},
{"lineNum":"   67","line":"  }"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"  //! Creates a name value pair for the variable T with the same name as the variable"},
{"lineNum":"   70","line":"  /*! @relates NameValuePair"},
{"lineNum":"   71","line":"      @ingroup Utility */"},
{"lineNum":"   72","line":"  #define CEREAL_NVP(T) ::cereal::make_nvp(#T, T)"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"  // ######################################################################"},
{"lineNum":"   75","line":"  //! Convenience function to create binary data for both const and non const pointers"},
{"lineNum":"   76","line":"  /*! @param data Pointer to beginning of the data"},
{"lineNum":"   77","line":"      @param size The size in bytes of the data"},
{"lineNum":"   78","line":"      @relates BinaryData"},
{"lineNum":"   79","line":"      @ingroup Utility */"},
{"lineNum":"   80","line":"  template <class T> inline"},
{"lineNum":"   81","line":"  BinaryData<T> binary_data( T && data, size_t size )"},
{"lineNum":"   82","line":"  {"},
{"lineNum":"   83","line":"    return {std::forward<T>(data), size};"},
{"lineNum":"   84","line":"  }"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"  // ######################################################################"},
{"lineNum":"   87","line":"  //! Creates a size tag from some variable."},
{"lineNum":"   88","line":"  /*! Will normally be used to serialize size (e.g. size()) information for"},
{"lineNum":"   89","line":"      variable size containers.  If you have a variable sized container,"},
{"lineNum":"   90","line":"      the very first thing it serializes should be its size, wrapped in"},
{"lineNum":"   91","line":"      a SizeTag."},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"      @relates SizeTag"},
{"lineNum":"   94","line":"      @ingroup Utility */"},
{"lineNum":"   95","line":"  template <class T> inline"},
{"lineNum":"   96","line":"  SizeTag<T> make_size_tag( T && sz )"},
{"lineNum":"   97","line":"  {"},
{"lineNum":"   98","line":"    return {std::forward<T>(sz)};"},
{"lineNum":"   99","line":"  }"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"  // ######################################################################"},
{"lineNum":"  102","line":"  //! Marks data for deferred serialization"},
{"lineNum":"  103","line":"  /*! cereal performs a recursive depth-first traversal of data it serializes. When"},
{"lineNum":"  104","line":"      serializing smart pointers to large, nested, or cyclical data structures, it"},
{"lineNum":"  105","line":"      is possible to encounter a stack overflow from excessive recursion when following"},
{"lineNum":"  106","line":"      a chain of pointers."},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"      Deferment can help in these situations if the data can be serialized separately from"},
{"lineNum":"  109","line":"      the pointers used to traverse the structure. For example, a graph structure can have its"},
{"lineNum":"  110","line":"      nodes serialized before its edges:"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"      @code{.cpp}"},
{"lineNum":"  113","line":"      struct MyEdge"},
{"lineNum":"  114","line":"      {"},
{"lineNum":"  115","line":"        std::shared_ptr<MyNode> connection;"},
{"lineNum":"  116","line":"        int some_value;"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"        template<class Archive>"},
{"lineNum":"  119","line":"        void serialize(Archive & archive)"},
{"lineNum":"  120","line":"        {"},
{"lineNum":"  121","line":"          // when we serialize an edge, we\'ll defer serializing the associated node"},
{"lineNum":"  122","line":"          archive( cereal::defer( connection ),"},
{"lineNum":"  123","line":"                   some_value );"},
{"lineNum":"  124","line":"        }"},
{"lineNum":"  125","line":"      };"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"      struct MyGraphStructure"},
{"lineNum":"  128","line":"      {"},
{"lineNum":"  129","line":"        std::vector<MyEdge> edges;"},
{"lineNum":"  130","line":"        std::vector<MyNodes> nodes;"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"        template<class Archive>"},
{"lineNum":"  133","line":"        void serialize(Archive & archive)"},
{"lineNum":"  134","line":"        {"},
{"lineNum":"  135","line":"          // because of the deferment, we ensure all nodes are fully serialized"},
{"lineNum":"  136","line":"          // before any connection pointers to those nodes are serialized"},
{"lineNum":"  137","line":"          archive( edges, nodes );"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"          // we have to explicitly inform the archive when it is safe to serialize"},
{"lineNum":"  140","line":"          // the deferred data"},
{"lineNum":"  141","line":"          archive.serializeDeferments();"},
{"lineNum":"  142","line":"        }"},
{"lineNum":"  143","line":"      };"},
{"lineNum":"  144","line":"      @endcode"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"      @relates DeferredData"},
{"lineNum":"  147","line":"      @ingroup Utility */"},
{"lineNum":"  148","line":"  template <class T> inline"},
{"lineNum":"  149","line":"  DeferredData<T> defer( T && value )"},
{"lineNum":"  150","line":"  {"},
{"lineNum":"  151","line":"    return {std::forward<T>(value)};"},
{"lineNum":"  152","line":"  }"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"  // ######################################################################"},
{"lineNum":"  155","line":"  //! Called before a type is serialized to set up any special archive state"},
{"lineNum":"  156","line":"  //! for processing some type"},
{"lineNum":"  157","line":"  /*! If designing a serializer that needs to set up any kind of special"},
{"lineNum":"  158","line":"      state or output extra information for a type, specialize this function"},
{"lineNum":"  159","line":"      for the archive type and the types that require the extra information."},
{"lineNum":"  160","line":"      @ingroup Internal */"},
{"lineNum":"  161","line":"  template <class Archive, class T> inline"},
{"lineNum":"  162","line":"  void prologue( Archive & /* archive */, T const & /* data */)"},
{"lineNum":"  163","line":"  { }"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"  //! Called after a type is serialized to tear down any special archive state"},
{"lineNum":"  166","line":"  //! for processing some type"},
{"lineNum":"  167","line":"  /*! @ingroup Internal */"},
{"lineNum":"  168","line":"  template <class Archive, class T> inline"},
{"lineNum":"  169","line":"  void epilogue( Archive & /* archive */, T const & /* data */)"},
{"lineNum":"  170","line":"  { }"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  // ######################################################################"},
{"lineNum":"  173","line":"  //! Special flags for archives"},
{"lineNum":"  174","line":"  /*! AllowEmptyClassElision"},
{"lineNum":"  175","line":"        This allows for empty classes to be serialized even if they do not provide"},
{"lineNum":"  176","line":"        a serialization function.  Classes with no data members are considered to be"},
{"lineNum":"  177","line":"        empty.  Be warned that if this is enabled and you attempt to serialize an"},
{"lineNum":"  178","line":"        empty class with improperly formed serialize or load/save functions, no"},
{"lineNum":"  179","line":"        static error will occur - the error will propogate silently and your"},
{"lineNum":"  180","line":"        intended serialization functions may not be called.  You can manually"},
{"lineNum":"  181","line":"        ensure that your classes that have custom serialization are correct"},
{"lineNum":"  182","line":"        by using the traits is_output_serializable and is_input_serializable"},
{"lineNum":"  183","line":"        in cereal/details/traits.hpp."},
{"lineNum":"  184","line":"      @ingroup Internal */"},
{"lineNum":"  185","line":"  enum Flags { AllowEmptyClassElision = 1 };"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"  // ######################################################################"},
{"lineNum":"  188","line":"  //! Registers a specific Archive type with cereal"},
{"lineNum":"  189","line":"  /*! This registration should be done once per archive.  A good place to"},
{"lineNum":"  190","line":"      put this is immediately following the definition of your archive."},
{"lineNum":"  191","line":"      Archive registration is only strictly necessary if you wish to"},
{"lineNum":"  192","line":"      support pointers to polymorphic data types.  All archives that"},
{"lineNum":"  193","line":"      come with cereal are already registered."},
{"lineNum":"  194","line":"      @ingroup Internal */"},
{"lineNum":"  195","line":"  #define CEREAL_REGISTER_ARCHIVE(Archive)                              \\"},
{"lineNum":"  196","line":"  namespace cereal { namespace detail {                                 \\"},
{"lineNum":"  197","line":"  template <class T, class BindingTag>                                  \\"},
{"lineNum":"  198","line":"  typename polymorphic_serialization_support<Archive, T>::type          \\"},
{"lineNum":"  199","line":"  instantiate_polymorphic_binding( T*, Archive*, BindingTag, adl_tag ); \\"},
{"lineNum":"  200","line":"  } } /* end namespaces */"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"  //! Helper macro to omit unused warning"},
{"lineNum":"  203","line":"  #if defined(__GNUC__)"},
{"lineNum":"  204","line":"    // GCC / clang don\'t want the function"},
{"lineNum":"  205","line":"    #define CEREAL_UNUSED_FUNCTION"},
{"lineNum":"  206","line":"  #else"},
{"lineNum":"  207","line":"    #define CEREAL_UNUSED_FUNCTION static void unused() { (void)version; }"},
{"lineNum":"  208","line":"  #endif"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"  // ######################################################################"},
{"lineNum":"  211","line":"  //! Defines a class version for some type"},
{"lineNum":"  212","line":"  /*! Versioning information is optional and adds some small amount of"},
{"lineNum":"  213","line":"      overhead to serialization.  This overhead will occur both in terms of"},
{"lineNum":"  214","line":"      space in the archive (the version information for each class will be"},
{"lineNum":"  215","line":"      stored exactly once) as well as runtime (versioned serialization functions"},
{"lineNum":"  216","line":"      must check to see if they need to load or store version information)."},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"      Versioning is useful if you plan on fundamentally changing the way some"},
{"lineNum":"  219","line":"      type is serialized in the future.  Versioned serialization functions"},
{"lineNum":"  220","line":"      cannot be used to load non-versioned data."},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"      By default, all types have an assumed version value of zero.  By"},
{"lineNum":"  223","line":"      using this macro, you may change the version number associated with"},
{"lineNum":"  224","line":"      some type.  cereal will then use this value as a second parameter"},
{"lineNum":"  225","line":"      to your serialization functions."},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"      The interface for the serialization functions is nearly identical"},
{"lineNum":"  228","line":"      to non-versioned serialization with the addition of a second parameter,"},
{"lineNum":"  229","line":"      const std::uint32_t version, which will be supplied with the correct"},
{"lineNum":"  230","line":"      version number.  Serializing the version number on a save happens"},
{"lineNum":"  231","line":"      automatically."},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"      Versioning cannot be mixed with non-versioned serialization functions."},
{"lineNum":"  234","line":"      Having both types will result result in a compile time error.  Data"},
{"lineNum":"  235","line":"      serialized without versioning cannot be loaded by a serialization"},
{"lineNum":"  236","line":"      function with added versioning support."},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"      Example interface for versioning on a non-member serialize function:"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"      @code{cpp}"},
{"lineNum":"  241","line":"      CEREAL_CLASS_VERSION( Mytype, 77 ); // register class version"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"      template <class Archive>"},
{"lineNum":"  244","line":"      void serialize( Archive & ar, Mytype & t, const std::uint32_t version )"},
{"lineNum":"  245","line":"      {"},
{"lineNum":"  246","line":"        // When performing a load, the version associated with the class"},
{"lineNum":"  247","line":"        // is whatever it was when that data was originally serialized"},
{"lineNum":"  248","line":"        //"},
{"lineNum":"  249","line":"        // When we save, we\'ll use the version that is defined in the macro"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"        if( version >= some_number )"},
{"lineNum":"  252","line":"          // do this"},
{"lineNum":"  253","line":"        else"},
{"lineNum":"  254","line":"          // do that"},
{"lineNum":"  255","line":"      }"},
{"lineNum":"  256","line":"      @endcode"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"      Interfaces for other forms of serialization functions is similar.  This"},
{"lineNum":"  259","line":"      macro should be placed at global scope."},
{"lineNum":"  260","line":"      @ingroup Utility */"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"  //! On C++17, define the StaticObject as inline to merge the definitions across TUs"},
{"lineNum":"  263","line":"  //! This prevents multiple definition errors when this macro appears in a header file"},
{"lineNum":"  264","line":"  //! included in multiple TUs."},
{"lineNum":"  265","line":"  #ifdef CEREAL_HAS_CPP17"},
{"lineNum":"  266","line":"  #define CEREAL_CLASS_VERSION(TYPE, VERSION_NUMBER)                             \\"},
{"lineNum":"  267","line":"  namespace cereal { namespace detail {                                          \\"},
{"lineNum":"  268","line":"    template <> struct Version<TYPE>                                             \\"},
{"lineNum":"  269","line":"    {                                                                            \\"},
{"lineNum":"  270","line":"      static std::uint32_t registerVersion()                                     \\"},
{"lineNum":"  271","line":"      {                                                                          \\"},
{"lineNum":"  272","line":"        ::cereal::detail::StaticObject<Versions>::getInstance().mapping.emplace( \\"},
{"lineNum":"  273","line":"             std::type_index(typeid(TYPE)).hash_code(), VERSION_NUMBER );        \\"},
{"lineNum":"  274","line":"        return VERSION_NUMBER;                                                   \\"},
{"lineNum":"  275","line":"      }                                                                          \\"},
{"lineNum":"  276","line":"      static inline const std::uint32_t version = registerVersion();             \\"},
{"lineNum":"  277","line":"      CEREAL_UNUSED_FUNCTION                                                     \\"},
{"lineNum":"  278","line":"    }; /* end Version */                                                         \\"},
{"lineNum":"  279","line":"  } } // end namespaces"},
{"lineNum":"  280","line":"  #else"},
{"lineNum":"  281","line":"  #define CEREAL_CLASS_VERSION(TYPE, VERSION_NUMBER)                             \\"},
{"lineNum":"  282","line":"  namespace cereal { namespace detail {                                          \\"},
{"lineNum":"  283","line":"    template <> struct Version<TYPE>                                             \\"},
{"lineNum":"  284","line":"    {                                                                            \\"},
{"lineNum":"  285","line":"      static const std::uint32_t version;                                        \\"},
{"lineNum":"  286","line":"      static std::uint32_t registerVersion()                                     \\"},
{"lineNum":"  287","line":"      {                                                                          \\"},
{"lineNum":"  288","line":"        ::cereal::detail::StaticObject<Versions>::getInstance().mapping.emplace( \\"},
{"lineNum":"  289","line":"             std::type_index(typeid(TYPE)).hash_code(), VERSION_NUMBER );        \\"},
{"lineNum":"  290","line":"        return VERSION_NUMBER;                                                   \\"},
{"lineNum":"  291","line":"      }                                                                          \\"},
{"lineNum":"  292","line":"      CEREAL_UNUSED_FUNCTION                                                     \\"},
{"lineNum":"  293","line":"    }; /* end Version */                                                         \\"},
{"lineNum":"  294","line":"    const std::uint32_t Version<TYPE>::version =                                 \\"},
{"lineNum":"  295","line":"      Version<TYPE>::registerVersion();                                          \\"},
{"lineNum":"  296","line":"  } } // end namespaces"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"  #endif"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"  // ######################################################################"},
{"lineNum":"  301","line":"  //! The base output archive class"},
{"lineNum":"  302","line":"  /*! This is the base output archive for all output archives.  If you create"},
{"lineNum":"  303","line":"      a custom archive class, it should derive from this, passing itself as"},
{"lineNum":"  304","line":"      a template parameter for the ArchiveType."},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"      The base class provides all of the functionality necessary to"},
{"lineNum":"  307","line":"      properly forward data to the correct serialization functions."},
{"lineNum":"  308","line":""},
{"lineNum":"  309","line":"      Individual archives should use a combination of prologue and"},
{"lineNum":"  310","line":"      epilogue functions together with specializations of serialize, save,"},
{"lineNum":"  311","line":"      and load to alter the functionality of their serialization."},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"      @tparam ArchiveType The archive type that derives from OutputArchive"},
{"lineNum":"  314","line":"      @tparam Flags Flags to control advanced functionality.  See the Flags"},
{"lineNum":"  315","line":"                    enum for more information."},
{"lineNum":"  316","line":"      @ingroup Internal */"},
{"lineNum":"  317","line":"  template<class ArchiveType, std::uint32_t Flags = 0>"},
{"lineNum":"  318","line":"  class OutputArchive : public detail::OutputArchiveBase","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  319","line":"  {"},
{"lineNum":"  320","line":"    public:"},
{"lineNum":"  321","line":"      //! Construct the output archive"},
{"lineNum":"  322","line":"      /*! @param derived A pointer to the derived ArchiveType (pass this from the derived archive) */"},
{"lineNum":"  323","line":"      OutputArchive(ArchiveType * const derived) : self(derived), itsCurrentPointerId(1), itsCurrentPolymorphicTypeId(1)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  324","line":"      { }"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"      OutputArchive & operator=( OutputArchive const & ) = delete;"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"      //! Serializes all passed in data"},
{"lineNum":"  329","line":"      /*! This is the primary interface for serializing data with an archive */"},
{"lineNum":"  330","line":"      template <class ... Types> inline"},
{"lineNum":"  331","line":"      ArchiveType & operator()( Types && ... args )"},
{"lineNum":"  332","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"29",},
{"lineNum":"  333","line":"        self->process( std::forward<Types>( args )... );","class":"lineNoCov","hits":"0","possible_hits":"1721",},
{"lineNum":"  334","line":"        return *self;","class":"lineNoCov","hits":"0","possible_hits":"29",},
{"lineNum":"  335","line":"      }"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"      //! Serializes any data marked for deferment using defer"},
{"lineNum":"  338","line":"      /*! This will cause any data wrapped in DeferredData to be immediately serialized */"},
{"lineNum":"  339","line":"      void serializeDeferments()"},
{"lineNum":"  340","line":"      {"},
{"lineNum":"  341","line":"        for( auto & deferment : itsDeferments )"},
{"lineNum":"  342","line":"          deferment();"},
{"lineNum":"  343","line":"      }"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"      /*! @name Boost Transition Layer"},
{"lineNum":"  346","line":"          Functionality that mirrors the syntax for Boost.  This is useful if you are transitioning"},
{"lineNum":"  347","line":"          a large project from Boost to cereal.  The preferred interface for cereal is using operator(). */"},
{"lineNum":"  348","line":"      //! @{"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"      //! Indicates this archive is not intended for loading"},
{"lineNum":"  351","line":"      /*! This ensures compatibility with boost archive types.  If you are transitioning"},
{"lineNum":"  352","line":"          from boost, you can check this value within a member or external serialize function"},
{"lineNum":"  353","line":"          (i.e., Archive::is_loading::value) to disable behavior specific to loading, until"},
{"lineNum":"  354","line":"          you can transition to split save/load or save_minimal/load_minimal functions */"},
{"lineNum":"  355","line":"      using is_loading = std::false_type;"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"      //! Indicates this archive is intended for saving"},
{"lineNum":"  358","line":"      /*! This ensures compatibility with boost archive types.  If you are transitioning"},
{"lineNum":"  359","line":"          from boost, you can check this value within a member or external serialize function"},
{"lineNum":"  360","line":"          (i.e., Archive::is_saving::value) to enable behavior specific to loading, until"},
{"lineNum":"  361","line":"          you can transition to split save/load or save_minimal/load_minimal functions */"},
{"lineNum":"  362","line":"      using is_saving = std::true_type;"},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"      //! Serializes passed in data"},
{"lineNum":"  365","line":"      /*! This is a boost compatability layer and is not the preferred way of using"},
{"lineNum":"  366","line":"          cereal.  If you are transitioning from boost, use this until you can"},
{"lineNum":"  367","line":"          transition to the operator() overload */"},
{"lineNum":"  368","line":"      template <class T> inline"},
{"lineNum":"  369","line":"      ArchiveType & operator&( T && arg )"},
{"lineNum":"  370","line":"      {"},
{"lineNum":"  371","line":"        self->process( std::forward<T>( arg ) );"},
{"lineNum":"  372","line":"        return *self;"},
{"lineNum":"  373","line":"      }"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"      //! Serializes passed in data"},
{"lineNum":"  376","line":"      /*! This is a boost compatability layer and is not the preferred way of using"},
{"lineNum":"  377","line":"          cereal.  If you are transitioning from boost, use this until you can"},
{"lineNum":"  378","line":"          transition to the operator() overload */"},
{"lineNum":"  379","line":"      template <class T> inline"},
{"lineNum":"  380","line":"      ArchiveType & operator<<( T && arg )"},
{"lineNum":"  381","line":"      {"},
{"lineNum":"  382","line":"        self->process( std::forward<T>( arg ) );"},
{"lineNum":"  383","line":"        return *self;"},
{"lineNum":"  384","line":"      }"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"      //! @}"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"      //! Registers a shared pointer with the archive"},
{"lineNum":"  389","line":"      /*! This function is used to track shared pointer targets to prevent"},
{"lineNum":"  390","line":"          unnecessary saves from taking place if multiple shared pointers"},
{"lineNum":"  391","line":"          point to the same data."},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"          @internal"},
{"lineNum":"  394","line":"          @param sharedPointer The shared pointer itself (the adress is taked via get())."},
{"lineNum":"  395","line":"                               The archive takes a copy to prevent the memory location to be freed"},
{"lineNum":"  396","line":"                               as long as the address is used as id. This is needed to prevent CVE-2020-11105."},
{"lineNum":"  397","line":"          @return A key that uniquely identifies the pointer */"},
{"lineNum":"  398","line":"      inline std::uint32_t registerSharedPointer(const std::shared_ptr<const void>& sharedPointer)"},
{"lineNum":"  399","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  400","line":"        void const * addr = sharedPointer.get();","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"        // Handle null pointers by just returning 0"},
{"lineNum":"  403","line":"        if(addr == 0) return 0;","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  404","line":"        itsSharedPointerStorage.push_back(sharedPointer);","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  405","line":""},
{"lineNum":"  406","line":"        auto id = itsSharedPointerMap.find( addr );","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  407","line":"        if( id == itsSharedPointerMap.end() )","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  408","line":"        {"},
{"lineNum":"  409","line":"          auto ptrId = itsCurrentPointerId++;","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  410","line":"          itsSharedPointerMap.insert( {addr, ptrId} );"},
{"lineNum":"  411","line":"          return ptrId | detail::msb_32bit; // mask MSB to be 1","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  412","line":"        }"},
{"lineNum":"  413","line":"        else"},
{"lineNum":"  414","line":"          return id->second;","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  415","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"      //! Registers a polymorphic type name with the archive"},
{"lineNum":"  418","line":"      /*! This function is used to track polymorphic types to prevent"},
{"lineNum":"  419","line":"          unnecessary saves of identifying strings used by the polymorphic"},
{"lineNum":"  420","line":"          support functionality."},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"          @internal"},
{"lineNum":"  423","line":"          @param name The name to associate with a polymorphic type"},
{"lineNum":"  424","line":"          @return A key that uniquely identifies the polymorphic type name */"},
{"lineNum":"  425","line":"      inline std::uint32_t registerPolymorphicType( char const * name )"},
{"lineNum":"  426","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  427","line":"        auto id = itsPolymorphicTypeMap.find( name );","class":"lineNoCov","hits":"0","possible_hits":"54",},
{"lineNum":"  428","line":"        if( id == itsPolymorphicTypeMap.end() )","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  429","line":"        {"},
{"lineNum":"  430","line":"          auto polyId = itsCurrentPolymorphicTypeId++;","class":"lineNoCov","hits":"0","possible_hits":"57",},
{"lineNum":"  431","line":"          itsPolymorphicTypeMap.insert( {name, polyId} );"},
{"lineNum":"  432","line":"          return polyId | detail::msb_32bit; // mask MSB to be 1","class":"lineNoCov","hits":"0","possible_hits":"57",},
{"lineNum":"  433","line":"        }"},
{"lineNum":"  434","line":"        else"},
{"lineNum":"  435","line":"          return id->second;","class":"lineNoCov","hits":"0","possible_hits":"57",},
{"lineNum":"  436","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  437","line":""},
{"lineNum":"  438","line":"    private:"},
{"lineNum":"  439","line":"      //! Serializes data after calling prologue, then calls epilogue"},
{"lineNum":"  440","line":"      template <class T> inline"},
{"lineNum":"  441","line":"      void process( T && head )"},
{"lineNum":"  442","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"52",},
{"lineNum":"  443","line":"        prologue( *self, head );","class":"lineNoCov","hits":"0","possible_hits":"754",},
{"lineNum":"  444","line":"        self->processImpl( head );","class":"lineNoCov","hits":"0","possible_hits":"1695",},
{"lineNum":"  445","line":"        epilogue( *self, head );","class":"lineNoCov","hits":"0","possible_hits":"517",},
{"lineNum":"  446","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"60",},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"      //! Unwinds to process all data"},
{"lineNum":"  449","line":"      template <class T, class ... Other> inline"},
{"lineNum":"  450","line":"      void process( T && head, Other && ... tail )"},
{"lineNum":"  451","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  452","line":"        self->process( std::forward<T>( head ) );","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  453","line":"        self->process( std::forward<Other>( tail )... );","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  454","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"      //! Serialization of a virtual_base_class wrapper"},
{"lineNum":"  457","line":"      /*! \\sa virtual_base_class */"},
{"lineNum":"  458","line":"      template <class T> inline"},
{"lineNum":"  459","line":"      ArchiveType & processImpl(virtual_base_class<T> const & b)"},
{"lineNum":"  460","line":"      {"},
{"lineNum":"  461","line":"        traits::detail::base_class_id id(b.base_ptr);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  462","line":"        if(itsBaseClassSet.count(id) == 0)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  463","line":"        {"},
{"lineNum":"  464","line":"          itsBaseClassSet.insert(id);"},
{"lineNum":"  465","line":"          self->processImpl( *b.base_ptr );"},
{"lineNum":"  466","line":"        }"},
{"lineNum":"  467","line":"        return *self;"},
{"lineNum":"  468","line":"      }"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"      //! Serialization of a base_class wrapper"},
{"lineNum":"  471","line":"      /*! \\sa base_class */"},
{"lineNum":"  472","line":"      template <class T> inline"},
{"lineNum":"  473","line":"      ArchiveType & processImpl(base_class<T> const & b)"},
{"lineNum":"  474","line":"      {"},
{"lineNum":"  475","line":"        self->processImpl( *b.base_ptr );","class":"lineNoCov","hits":"0","possible_hits":"67",},
{"lineNum":"  476","line":"        return *self;"},
{"lineNum":"  477","line":"      }"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"      std::vector<std::function<void(void)>> itsDeferments;"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"      template <class T> inline"},
{"lineNum":"  482","line":"      ArchiveType & processImpl(DeferredData<T> const & d)"},
{"lineNum":"  483","line":"      {"},
{"lineNum":"  484","line":"        std::function<void(void)> deferment( [this, d](){ self->process( d.value ); } );"},
{"lineNum":"  485","line":"        itsDeferments.emplace_back( std::move(deferment) );"},
{"lineNum":"  486","line":""},
{"lineNum":"  487","line":"        return *self;"},
{"lineNum":"  488","line":"      }"},
{"lineNum":"  489","line":""},
{"lineNum":"  490","line":"      //! Helper macro that expands the requirements for activating an overload"},
{"lineNum":"  491","line":"      /*! Requirements:"},
{"lineNum":"  492","line":"            Has the requested serialization function"},
{"lineNum":"  493","line":"            Does not have version and unversioned at the same time"},
{"lineNum":"  494","line":"            Is output serializable AND"},
{"lineNum":"  495","line":"              is specialized for this type of function OR"},
{"lineNum":"  496","line":"              has no specialization at all */"},
{"lineNum":"  497","line":"      #define PROCESS_IF(name)                                                             \\"},
{"lineNum":"  498","line":"      traits::EnableIf<traits::has_##name<T, ArchiveType>::value,                          \\"},
{"lineNum":"  499","line":"                       !traits::has_invalid_output_versioning<T, ArchiveType>::value,      \\"},
{"lineNum":"  500","line":"                       (traits::is_output_serializable<T, ArchiveType>::value &&           \\"},
{"lineNum":"  501","line":"                        (traits::is_specialized_##name<T, ArchiveType>::value ||           \\"},
{"lineNum":"  502","line":"                         !traits::is_specialized<T, ArchiveType>::value))> = traits::sfinae"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"      //! Member serialization"},
{"lineNum":"  505","line":"      template <class T, PROCESS_IF(member_serialize)> inline"},
{"lineNum":"  506","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  507","line":"      {"},
{"lineNum":"  508","line":"        access::member_serialize(*self, const_cast<T &>(t));","class":"lineNoCov","hits":"0","possible_hits":"228",},
{"lineNum":"  509","line":"        return *self;"},
{"lineNum":"  510","line":"      }"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"      //! Non member serialization"},
{"lineNum":"  513","line":"      template <class T, PROCESS_IF(non_member_serialize)> inline"},
{"lineNum":"  514","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  515","line":"      {"},
{"lineNum":"  516","line":"        CEREAL_SERIALIZE_FUNCTION_NAME(*self, const_cast<T &>(t));","class":"lineNoCov","hits":"0","possible_hits":"42",},
{"lineNum":"  517","line":"        return *self;"},
{"lineNum":"  518","line":"      }"},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"      //! Member split (save)"},
{"lineNum":"  521","line":"      template <class T, PROCESS_IF(member_save)> inline"},
{"lineNum":"  522","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  523","line":"      {"},
{"lineNum":"  524","line":"        access::member_save(*self, t);","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  525","line":"        return *self;"},
{"lineNum":"  526","line":"      }"},
{"lineNum":"  527","line":""},
{"lineNum":"  528","line":"      //! Non member split (save)"},
{"lineNum":"  529","line":"      template <class T, PROCESS_IF(non_member_save)> inline"},
{"lineNum":"  530","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  531","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  532","line":"        CEREAL_SAVE_FUNCTION_NAME(*self, t);","class":"lineNoCov","hits":"0","possible_hits":"1304",},
{"lineNum":"  533","line":"        return *self;","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  534","line":"      }"},
{"lineNum":"  535","line":""},
{"lineNum":"  536","line":"      //! Member split (save_minimal)"},
{"lineNum":"  537","line":"      template <class T, PROCESS_IF(member_save_minimal)> inline"},
{"lineNum":"  538","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  539","line":"      {"},
{"lineNum":"  540","line":"        self->process( access::member_save_minimal(*self, t) );"},
{"lineNum":"  541","line":"        return *self;"},
{"lineNum":"  542","line":"      }"},
{"lineNum":"  543","line":""},
{"lineNum":"  544","line":"      //! Non member split (save_minimal)"},
{"lineNum":"  545","line":"      template <class T, PROCESS_IF(non_member_save_minimal)> inline"},
{"lineNum":"  546","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  547","line":"      {"},
{"lineNum":"  548","line":"        self->process( CEREAL_SAVE_MINIMAL_FUNCTION_NAME(*self, t) );","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  549","line":"        return *self;"},
{"lineNum":"  550","line":"      }"},
{"lineNum":"  551","line":""},
{"lineNum":"  552","line":"      //! Empty class specialization"},
{"lineNum":"  553","line":"      template <class T, traits::EnableIf<(Flags & AllowEmptyClassElision),"},
{"lineNum":"  554","line":"                                          !traits::is_output_serializable<T, ArchiveType>::value,"},
{"lineNum":"  555","line":"                                          std::is_empty<T>::value> = traits::sfinae> inline"},
{"lineNum":"  556","line":"      ArchiveType & processImpl(T const &)"},
{"lineNum":"  557","line":"      {"},
{"lineNum":"  558","line":"        return *self;"},
{"lineNum":"  559","line":"      }"},
{"lineNum":"  560","line":""},
{"lineNum":"  561","line":"      //! No matching serialization"},
{"lineNum":"  562","line":"      /*! Invalid if we have invalid output versioning or"},
{"lineNum":"  563","line":"          we are not output serializable, and either"},
{"lineNum":"  564","line":"          don\'t allow empty class ellision or allow it but are not serializing an empty class */"},
{"lineNum":"  565","line":"      template <class T, traits::EnableIf<traits::has_invalid_output_versioning<T, ArchiveType>::value ||"},
{"lineNum":"  566","line":"                                          (!traits::is_output_serializable<T, ArchiveType>::value &&"},
{"lineNum":"  567","line":"                                           (!(Flags & AllowEmptyClassElision) || ((Flags & AllowEmptyClassElision) && !std::is_empty<T>::value)))> = traits::sfinae> inline"},
{"lineNum":"  568","line":"      ArchiveType & processImpl(T const &)"},
{"lineNum":"  569","line":"      {"},
{"lineNum":"  570","line":"        static_assert(traits::detail::count_output_serializers<T, ArchiveType>::value != 0,"},
{"lineNum":"  571","line":"            \"cereal could not find any output serialization functions for the provided type and archive combination. \\n\\n \""},
{"lineNum":"  572","line":"            \"Types must either have a serialize function, load/save pair, or load_minimal/save_minimal pair (you may not mix these). \\n \""},
{"lineNum":"  573","line":"            \"Serialize functions generally have the following signature: \\n\\n \""},
{"lineNum":"  574","line":"            \"template<class Archive> \\n \""},
{"lineNum":"  575","line":"            \"  void serialize(Archive & ar) \\n \""},
{"lineNum":"  576","line":"            \"  { \\n \""},
{"lineNum":"  577","line":"            \"    ar( member1, member2, member3 ); \\n \""},
{"lineNum":"  578","line":"            \"  } \\n\\n \" );"},
{"lineNum":"  579","line":""},
{"lineNum":"  580","line":"        static_assert(traits::detail::count_output_serializers<T, ArchiveType>::value < 2,"},
{"lineNum":"  581","line":"            \"cereal found more than one compatible output serialization function for the provided type and archive combination. \\n\\n \""},
{"lineNum":"  582","line":"            \"Types must either have a serialize function, load/save pair, or load_minimal/save_minimal pair (you may not mix these). \\n \""},
{"lineNum":"  583","line":"            \"Use specialization (see access.hpp) if you need to disambiguate between serialize vs load/save functions.  \\n \""},
{"lineNum":"  584","line":"            \"Note that serialization functions can be inherited which may lead to the aforementioned ambiguities. \\n \""},
{"lineNum":"  585","line":"            \"In addition, you may not mix versioned with non-versioned serialization functions. \\n\\n \");"},
{"lineNum":"  586","line":""},
{"lineNum":"  587","line":"        return *self;"},
{"lineNum":"  588","line":"      }"},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":"      //! Registers a class version with the archive and serializes it if necessary"},
{"lineNum":"  591","line":"      /*! If this is the first time this class has been serialized, we will record its"},
{"lineNum":"  592","line":"          version number and serialize that."},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"          @tparam T The type of the class being serialized */"},
{"lineNum":"  595","line":"      template <class T> inline"},
{"lineNum":"  596","line":"      std::uint32_t registerClassVersion()"},
{"lineNum":"  597","line":"      {"},
{"lineNum":"  598","line":"        static const auto hash = std::type_index(typeid(T)).hash_code();"},
{"lineNum":"  599","line":"        const auto insertResult = itsVersionedTypes.insert( hash );"},
{"lineNum":"  600","line":"        const auto lock = detail::StaticObject<detail::Versions>::lock();"},
{"lineNum":"  601","line":"        const auto version ="},
{"lineNum":"  602","line":"          detail::StaticObject<detail::Versions>::getInstance().find( hash, detail::Version<T>::version );"},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"        if( insertResult.second ) // insertion took place, serialize the version number"},
{"lineNum":"  605","line":"          process( make_nvp<ArchiveType>(\"cereal_class_version\", version) );"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"        return version;"},
{"lineNum":"  608","line":"      }"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"      //! Member serialization"},
{"lineNum":"  611","line":"      /*! Versioning implementation */"},
{"lineNum":"  612","line":"      template <class T, PROCESS_IF(member_versioned_serialize)> inline"},
{"lineNum":"  613","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  614","line":"      {"},
{"lineNum":"  615","line":"        access::member_serialize(*self, const_cast<T &>(t), registerClassVersion<T>());"},
{"lineNum":"  616","line":"        return *self;"},
{"lineNum":"  617","line":"      }"},
{"lineNum":"  618","line":""},
{"lineNum":"  619","line":"      //! Non member serialization"},
{"lineNum":"  620","line":"      /*! Versioning implementation */"},
{"lineNum":"  621","line":"      template <class T, PROCESS_IF(non_member_versioned_serialize)> inline"},
{"lineNum":"  622","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  623","line":"      {"},
{"lineNum":"  624","line":"        CEREAL_SERIALIZE_FUNCTION_NAME(*self, const_cast<T &>(t), registerClassVersion<T>());"},
{"lineNum":"  625","line":"        return *self;"},
{"lineNum":"  626","line":"      }"},
{"lineNum":"  627","line":""},
{"lineNum":"  628","line":"      //! Member split (save)"},
{"lineNum":"  629","line":"      /*! Versioning implementation */"},
{"lineNum":"  630","line":"      template <class T, PROCESS_IF(member_versioned_save)> inline"},
{"lineNum":"  631","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  632","line":"      {"},
{"lineNum":"  633","line":"        access::member_save(*self, t, registerClassVersion<T>());"},
{"lineNum":"  634","line":"        return *self;"},
{"lineNum":"  635","line":"      }"},
{"lineNum":"  636","line":""},
{"lineNum":"  637","line":"      //! Non member split (save)"},
{"lineNum":"  638","line":"      /*! Versioning implementation */"},
{"lineNum":"  639","line":"      template <class T, PROCESS_IF(non_member_versioned_save)> inline"},
{"lineNum":"  640","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  641","line":"      {"},
{"lineNum":"  642","line":"        CEREAL_SAVE_FUNCTION_NAME(*self, t, registerClassVersion<T>());"},
{"lineNum":"  643","line":"        return *self;"},
{"lineNum":"  644","line":"      }"},
{"lineNum":"  645","line":""},
{"lineNum":"  646","line":"      //! Member split (save_minimal)"},
{"lineNum":"  647","line":"      /*! Versioning implementation */"},
{"lineNum":"  648","line":"      template <class T, PROCESS_IF(member_versioned_save_minimal)> inline"},
{"lineNum":"  649","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  650","line":"      {"},
{"lineNum":"  651","line":"        self->process( access::member_save_minimal(*self, t, registerClassVersion<T>()) );"},
{"lineNum":"  652","line":"        return *self;"},
{"lineNum":"  653","line":"      }"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"      //! Non member split (save_minimal)"},
{"lineNum":"  656","line":"      /*! Versioning implementation */"},
{"lineNum":"  657","line":"      template <class T, PROCESS_IF(non_member_versioned_save_minimal)> inline"},
{"lineNum":"  658","line":"      ArchiveType & processImpl(T const & t)"},
{"lineNum":"  659","line":"      {"},
{"lineNum":"  660","line":"        self->process( CEREAL_SAVE_MINIMAL_FUNCTION_NAME(*self, t, registerClassVersion<T>()) );"},
{"lineNum":"  661","line":"        return *self;"},
{"lineNum":"  662","line":"      }"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"    #undef PROCESS_IF"},
{"lineNum":"  665","line":""},
{"lineNum":"  666","line":"    private:"},
{"lineNum":"  667","line":"      ArchiveType * const self;"},
{"lineNum":"  668","line":""},
{"lineNum":"  669","line":"      //! A set of all base classes that have been serialized"},
{"lineNum":"  670","line":"      std::unordered_set<traits::detail::base_class_id, traits::detail::base_class_id_hash> itsBaseClassSet;"},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":"      //! Maps from addresses to pointer ids"},
{"lineNum":"  673","line":"      std::unordered_map<void const *, std::uint32_t> itsSharedPointerMap;"},
{"lineNum":"  674","line":""},
{"lineNum":"  675","line":"      //! Copy of shared pointers used in #itsSharedPointerMap to make sure they are kept alive"},
{"lineNum":"  676","line":"      //  during lifetime of itsSharedPointerMap to prevent CVE-2020-11105."},
{"lineNum":"  677","line":"      std::vector<std::shared_ptr<const void>> itsSharedPointerStorage;"},
{"lineNum":"  678","line":""},
{"lineNum":"  679","line":"      //! The id to be given to the next pointer"},
{"lineNum":"  680","line":"      std::uint32_t itsCurrentPointerId;"},
{"lineNum":"  681","line":""},
{"lineNum":"  682","line":"      //! Maps from polymorphic type name strings to ids"},
{"lineNum":"  683","line":"      std::unordered_map<char const *, std::uint32_t> itsPolymorphicTypeMap;"},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"      //! The id to be given to the next polymorphic type name"},
{"lineNum":"  686","line":"      std::uint32_t itsCurrentPolymorphicTypeId;"},
{"lineNum":"  687","line":""},
{"lineNum":"  688","line":"      //! Keeps track of classes that have versioning information associated with them"},
{"lineNum":"  689","line":"      std::unordered_set<size_type> itsVersionedTypes;"},
{"lineNum":"  690","line":"  }; // class OutputArchive"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"  // ######################################################################"},
{"lineNum":"  693","line":"  //! The base input archive class"},
{"lineNum":"  694","line":"  /*! This is the base input archive for all input archives.  If you create"},
{"lineNum":"  695","line":"      a custom archive class, it should derive from this, passing itself as"},
{"lineNum":"  696","line":"      a template parameter for the ArchiveType."},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"      The base class provides all of the functionality necessary to"},
{"lineNum":"  699","line":"      properly forward data to the correct serialization functions."},
{"lineNum":"  700","line":""},
{"lineNum":"  701","line":"      Individual archives should use a combination of prologue and"},
{"lineNum":"  702","line":"      epilogue functions together with specializations of serialize, save,"},
{"lineNum":"  703","line":"      and load to alter the functionality of their serialization."},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"      @tparam ArchiveType The archive type that derives from InputArchive"},
{"lineNum":"  706","line":"      @tparam Flags Flags to control advanced functionality.  See the Flags"},
{"lineNum":"  707","line":"                    enum for more information."},
{"lineNum":"  708","line":"      @ingroup Internal */"},
{"lineNum":"  709","line":"  template<class ArchiveType, std::uint32_t Flags = 0>"},
{"lineNum":"  710","line":"  class InputArchive : public detail::InputArchiveBase","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  711","line":"  {"},
{"lineNum":"  712","line":"    public:"},
{"lineNum":"  713","line":"      //! Construct the output archive"},
{"lineNum":"  714","line":"      /*! @param derived A pointer to the derived ArchiveType (pass this from the derived archive) */"},
{"lineNum":"  715","line":"      InputArchive(ArchiveType * const derived) :"},
{"lineNum":"  716","line":"        self(derived),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  717","line":"        itsBaseClassSet(),"},
{"lineNum":"  718","line":"        itsSharedPointerMap(),"},
{"lineNum":"  719","line":"        itsPolymorphicTypeMap(),"},
{"lineNum":"  720","line":"        itsVersionedTypes()"},
{"lineNum":"  721","line":"      { }"},
{"lineNum":"  722","line":""},
{"lineNum":"  723","line":"      InputArchive & operator=( InputArchive const & ) = delete;"},
{"lineNum":"  724","line":""},
{"lineNum":"  725","line":"      //! Serializes all passed in data"},
{"lineNum":"  726","line":"      /*! This is the primary interface for serializing data with an archive */"},
{"lineNum":"  727","line":"      template <class ... Types> inline"},
{"lineNum":"  728","line":"      ArchiveType & operator()( Types && ... args )"},
{"lineNum":"  729","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  730","line":"        process( std::forward<Types>( args )... );","class":"lineNoCov","hits":"0","possible_hits":"77",},
{"lineNum":"  731","line":"        return *self;","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  732","line":"      }"},
{"lineNum":"  733","line":""},
{"lineNum":"  734","line":"      //! Serializes any data marked for deferment using defer"},
{"lineNum":"  735","line":"      /*! This will cause any data wrapped in DeferredData to be immediately serialized */"},
{"lineNum":"  736","line":"      void serializeDeferments()"},
{"lineNum":"  737","line":"      {"},
{"lineNum":"  738","line":"        for( auto & deferment : itsDeferments )"},
{"lineNum":"  739","line":"          deferment();"},
{"lineNum":"  740","line":"      }"},
{"lineNum":"  741","line":""},
{"lineNum":"  742","line":"      /*! @name Boost Transition Layer"},
{"lineNum":"  743","line":"          Functionality that mirrors the syntax for Boost.  This is useful if you are transitioning"},
{"lineNum":"  744","line":"          a large project from Boost to cereal.  The preferred interface for cereal is using operator(). */"},
{"lineNum":"  745","line":"      //! @{"},
{"lineNum":"  746","line":""},
{"lineNum":"  747","line":"      //! Indicates this archive is intended for loading"},
{"lineNum":"  748","line":"      /*! This ensures compatibility with boost archive types.  If you are transitioning"},
{"lineNum":"  749","line":"          from boost, you can check this value within a member or external serialize function"},
{"lineNum":"  750","line":"          (i.e., Archive::is_loading::value) to enable behavior specific to loading, until"},
{"lineNum":"  751","line":"          you can transition to split save/load or save_minimal/load_minimal functions */"},
{"lineNum":"  752","line":"      using is_loading = std::true_type;"},
{"lineNum":"  753","line":""},
{"lineNum":"  754","line":"      //! Indicates this archive is not intended for saving"},
{"lineNum":"  755","line":"      /*! This ensures compatibility with boost archive types.  If you are transitioning"},
{"lineNum":"  756","line":"          from boost, you can check this value within a member or external serialize function"},
{"lineNum":"  757","line":"          (i.e., Archive::is_saving::value) to disable behavior specific to loading, until"},
{"lineNum":"  758","line":"          you can transition to split save/load or save_minimal/load_minimal functions */"},
{"lineNum":"  759","line":"      using is_saving = std::false_type;"},
{"lineNum":"  760","line":""},
{"lineNum":"  761","line":"      //! Serializes passed in data"},
{"lineNum":"  762","line":"      /*! This is a boost compatability layer and is not the preferred way of using"},
{"lineNum":"  763","line":"          cereal.  If you are transitioning from boost, use this until you can"},
{"lineNum":"  764","line":"          transition to the operator() overload */"},
{"lineNum":"  765","line":"      template <class T> inline"},
{"lineNum":"  766","line":"      ArchiveType & operator&( T && arg )"},
{"lineNum":"  767","line":"      {"},
{"lineNum":"  768","line":"        self->process( std::forward<T>( arg ) );"},
{"lineNum":"  769","line":"        return *self;"},
{"lineNum":"  770","line":"      }"},
{"lineNum":"  771","line":""},
{"lineNum":"  772","line":"      //! Serializes passed in data"},
{"lineNum":"  773","line":"      /*! This is a boost compatability layer and is not the preferred way of using"},
{"lineNum":"  774","line":"          cereal.  If you are transitioning from boost, use this until you can"},
{"lineNum":"  775","line":"          transition to the operator() overload */"},
{"lineNum":"  776","line":"      template <class T> inline"},
{"lineNum":"  777","line":"      ArchiveType & operator>>( T && arg )"},
{"lineNum":"  778","line":"      {"},
{"lineNum":"  779","line":"        self->process( std::forward<T>( arg ) );"},
{"lineNum":"  780","line":"        return *self;"},
{"lineNum":"  781","line":"      }"},
{"lineNum":"  782","line":""},
{"lineNum":"  783","line":"      //! @}"},
{"lineNum":"  784","line":""},
{"lineNum":"  785","line":"      //! Retrieves a shared pointer given a unique key for it"},
{"lineNum":"  786","line":"      /*! This is used to retrieve a previously registered shared_ptr"},
{"lineNum":"  787","line":"          which has already been loaded."},
{"lineNum":"  788","line":""},
{"lineNum":"  789","line":"          @internal"},
{"lineNum":"  790","line":"          @param id The unique id that was serialized for the pointer"},
{"lineNum":"  791","line":"          @return A shared pointer to the data"},
{"lineNum":"  792","line":"          @throw Exception if the id does not exist */"},
{"lineNum":"  793","line":"      inline std::shared_ptr<void> getSharedPointer(std::uint32_t const id)"},
{"lineNum":"  794","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  795","line":"        if(id == 0) return std::shared_ptr<void>(nullptr);","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  796","line":""},
{"lineNum":"  797","line":"        auto iter = itsSharedPointerMap.find( id );"},
{"lineNum":"  798","line":"        if(iter == itsSharedPointerMap.end())","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  799","line":"          throw Exception(\"Error while trying to deserialize a smart pointer. Could not find id \" + std::to_string(id));","class":"lineNoCov","hits":"0","possible_hits":"51",},
{"lineNum":"  800","line":""},
{"lineNum":"  801","line":"        return iter->second;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  802","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"      //! Registers a shared pointer to its unique identifier"},
{"lineNum":"  805","line":"      /*! After a shared pointer has been allocated for the first time, it should"},
{"lineNum":"  806","line":"          be registered with its loaded id for future references to it."},
{"lineNum":"  807","line":""},
{"lineNum":"  808","line":"          @internal"},
{"lineNum":"  809","line":"          @param id The unique identifier for the shared pointer"},
{"lineNum":"  810","line":"          @param ptr The actual shared pointer */"},
{"lineNum":"  811","line":"      inline void registerSharedPointer(std::uint32_t const id, std::shared_ptr<void> ptr)"},
{"lineNum":"  812","line":"      {"},
{"lineNum":"  813","line":"        std::uint32_t const stripped_id = id & ~detail::msb_32bit;","class":"lineNoCov","hits":"0","possible_hits":"106",},
{"lineNum":"  814","line":"        itsSharedPointerMap[stripped_id] = ptr;","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  815","line":"      }"},
{"lineNum":"  816","line":""},
{"lineNum":"  817","line":"      //! Retrieves the string for a polymorphic type given a unique key for it"},
{"lineNum":"  818","line":"      /*! This is used to retrieve a string previously registered during"},
{"lineNum":"  819","line":"          a polymorphic load."},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"          @internal"},
{"lineNum":"  822","line":"          @param id The unique id that was serialized for the polymorphic type"},
{"lineNum":"  823","line":"          @return The string identifier for the tyep */"},
{"lineNum":"  824","line":"      inline std::string getPolymorphicName(std::uint32_t const id)"},
{"lineNum":"  825","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  826","line":"        auto name = itsPolymorphicTypeMap.find( id );"},
{"lineNum":"  827","line":"        if(name == itsPolymorphicTypeMap.end())","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  828","line":"        {"},
{"lineNum":"  829","line":"          throw Exception(\"Error while trying to deserialize a polymorphic pointer. Could not find type id \" + std::to_string(id));","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  830","line":"        }"},
{"lineNum":"  831","line":"        return name->second;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  832","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  833","line":""},
{"lineNum":"  834","line":"      //! Registers a polymorphic name string to its unique identifier"},
{"lineNum":"  835","line":"      /*! After a polymorphic type has been loaded for the first time, it should"},
{"lineNum":"  836","line":"          be registered with its loaded id for future references to it."},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"          @internal"},
{"lineNum":"  839","line":"          @param id The unique identifier for the polymorphic type"},
{"lineNum":"  840","line":"          @param name The name associated with the tyep */"},
{"lineNum":"  841","line":"      inline void registerPolymorphicName(std::uint32_t const id, std::string const & name)"},
{"lineNum":"  842","line":"      {"},
{"lineNum":"  843","line":"        std::uint32_t const stripped_id = id & ~detail::msb_32bit;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  844","line":"        itsPolymorphicTypeMap.insert( {stripped_id, name} );","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  845","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"    private:"},
{"lineNum":"  848","line":"      //! Serializes data after calling prologue, then calls epilogue"},
{"lineNum":"  849","line":"      template <class T> inline"},
{"lineNum":"  850","line":"      void process( T && head )"},
{"lineNum":"  851","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"40",},
{"lineNum":"  852","line":"        prologue( *self, head );","class":"lineNoCov","hits":"0","possible_hits":"420",},
{"lineNum":"  853","line":"        self->processImpl( head );","class":"lineNoCov","hits":"0","possible_hits":"1470",},
{"lineNum":"  854","line":"        epilogue( *self, head );","class":"lineNoCov","hits":"0","possible_hits":"428",},
{"lineNum":"  855","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"53",},
{"lineNum":"  856","line":""},
{"lineNum":"  857","line":"      //! Unwinds to process all data"},
{"lineNum":"  858","line":"      template <class T, class ... Other> inline"},
{"lineNum":"  859","line":"      void process( T && head, Other && ... tail )"},
{"lineNum":"  860","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  861","line":"        process( std::forward<T>( head ) );"},
{"lineNum":"  862","line":"        process( std::forward<Other>( tail )... );","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  863","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  864","line":""},
{"lineNum":"  865","line":"      //! Serialization of a virtual_base_class wrapper"},
{"lineNum":"  866","line":"      /*! \\sa virtual_base_class */"},
{"lineNum":"  867","line":"      template <class T> inline"},
{"lineNum":"  868","line":"      ArchiveType & processImpl(virtual_base_class<T> & b)"},
{"lineNum":"  869","line":"      {"},
{"lineNum":"  870","line":"        traits::detail::base_class_id id(b.base_ptr);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  871","line":"        if(itsBaseClassSet.count(id) == 0)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  872","line":"        {"},
{"lineNum":"  873","line":"          itsBaseClassSet.insert(id);"},
{"lineNum":"  874","line":"          self->processImpl( *b.base_ptr );"},
{"lineNum":"  875","line":"        }"},
{"lineNum":"  876","line":"        return *self;"},
{"lineNum":"  877","line":"      }"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"      //! Serialization of a base_class wrapper"},
{"lineNum":"  880","line":"      /*! \\sa base_class */"},
{"lineNum":"  881","line":"      template <class T> inline"},
{"lineNum":"  882","line":"      ArchiveType & processImpl(base_class<T> & b)"},
{"lineNum":"  883","line":"      {"},
{"lineNum":"  884","line":"        self->processImpl( *b.base_ptr );","class":"lineNoCov","hits":"0","possible_hits":"62",},
{"lineNum":"  885","line":"        return *self;"},
{"lineNum":"  886","line":"      }"},
{"lineNum":"  887","line":""},
{"lineNum":"  888","line":"      std::vector<std::function<void(void)>> itsDeferments;"},
{"lineNum":"  889","line":""},
{"lineNum":"  890","line":"      template <class T> inline"},
{"lineNum":"  891","line":"      ArchiveType & processImpl(DeferredData<T> const & d)"},
{"lineNum":"  892","line":"      {"},
{"lineNum":"  893","line":"        std::function<void(void)> deferment( [this, d](){ self->process( d.value ); } );"},
{"lineNum":"  894","line":"        itsDeferments.emplace_back( std::move(deferment) );"},
{"lineNum":"  895","line":""},
{"lineNum":"  896","line":"        return *self;"},
{"lineNum":"  897","line":"      }"},
{"lineNum":"  898","line":""},
{"lineNum":"  899","line":"      //! Helper macro that expands the requirements for activating an overload"},
{"lineNum":"  900","line":"      /*! Requirements:"},
{"lineNum":"  901","line":"            Has the requested serialization function"},
{"lineNum":"  902","line":"            Does not have version and unversioned at the same time"},
{"lineNum":"  903","line":"            Is input serializable AND"},
{"lineNum":"  904","line":"              is specialized for this type of function OR"},
{"lineNum":"  905","line":"              has no specialization at all */"},
{"lineNum":"  906","line":"      #define PROCESS_IF(name)                                                              \\"},
{"lineNum":"  907","line":"      traits::EnableIf<traits::has_##name<T, ArchiveType>::value,                           \\"},
{"lineNum":"  908","line":"                       !traits::has_invalid_input_versioning<T, ArchiveType>::value,        \\"},
{"lineNum":"  909","line":"                       (traits::is_input_serializable<T, ArchiveType>::value &&             \\"},
{"lineNum":"  910","line":"                        (traits::is_specialized_##name<T, ArchiveType>::value ||            \\"},
{"lineNum":"  911","line":"                         !traits::is_specialized<T, ArchiveType>::value))> = traits::sfinae"},
{"lineNum":"  912","line":""},
{"lineNum":"  913","line":"      //! Member serialization"},
{"lineNum":"  914","line":"      template <class T, PROCESS_IF(member_serialize)> inline"},
{"lineNum":"  915","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":"  916","line":"      {"},
{"lineNum":"  917","line":"        access::member_serialize(*self, t);","class":"lineNoCov","hits":"0","possible_hits":"210",},
{"lineNum":"  918","line":"        return *self;"},
{"lineNum":"  919","line":"      }"},
{"lineNum":"  920","line":""},
{"lineNum":"  921","line":"      //! Non member serialization"},
{"lineNum":"  922","line":"      template <class T, PROCESS_IF(non_member_serialize)> inline"},
{"lineNum":"  923","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":"  924","line":"      {"},
{"lineNum":"  925","line":"        CEREAL_SERIALIZE_FUNCTION_NAME(*self, t);","class":"lineNoCov","hits":"0","possible_hits":"25",},
{"lineNum":"  926","line":"        return *self;"},
{"lineNum":"  927","line":"      }"},
{"lineNum":"  928","line":""},
{"lineNum":"  929","line":"      //! Member split (load)"},
{"lineNum":"  930","line":"      template <class T, PROCESS_IF(member_load)> inline"},
{"lineNum":"  931","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":"  932","line":"      {"},
{"lineNum":"  933","line":"        access::member_load(*self, t);","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  934","line":"        return *self;"},
{"lineNum":"  935","line":"      }"},
{"lineNum":"  936","line":""},
{"lineNum":"  937","line":"      //! Non member split (load)"},
{"lineNum":"  938","line":"      template <class T, PROCESS_IF(non_member_load)> inline"},
{"lineNum":"  939","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":"  940","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  941","line":"        CEREAL_LOAD_FUNCTION_NAME(*self, t);","class":"lineNoCov","hits":"0","possible_hits":"1213",},
{"lineNum":"  942","line":"        return *self;","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  943","line":"      }"},
{"lineNum":"  944","line":""},
{"lineNum":"  945","line":"      //! Member split (load_minimal)"},
{"lineNum":"  946","line":"      template <class T, PROCESS_IF(member_load_minimal)> inline"},
{"lineNum":"  947","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":"  948","line":"      {"},
{"lineNum":"  949","line":"        using OutArchiveType = typename traits::detail::get_output_from_input<ArchiveType>::type;"},
{"lineNum":"  950","line":"        typename traits::has_member_save_minimal<T, OutArchiveType>::type value;"},
{"lineNum":"  951","line":"        self->process( value );"},
{"lineNum":"  952","line":"        access::member_load_minimal(*self, t, value);"},
{"lineNum":"  953","line":"        return *self;"},
{"lineNum":"  954","line":"      }"},
{"lineNum":"  955","line":""},
{"lineNum":"  956","line":"      //! Non member split (load_minimal)"},
{"lineNum":"  957","line":"      template <class T, PROCESS_IF(non_member_load_minimal)> inline"},
{"lineNum":"  958","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":"  959","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  960","line":"        using OutArchiveType = typename traits::detail::get_output_from_input<ArchiveType>::type;"},
{"lineNum":"  961","line":"        typename traits::has_non_member_save_minimal<T, OutArchiveType>::type value;"},
{"lineNum":"  962","line":"        self->process( value );","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  963","line":"        CEREAL_LOAD_MINIMAL_FUNCTION_NAME(*self, t, value);"},
{"lineNum":"  964","line":"        return *self;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  965","line":"      }"},
{"lineNum":"  966","line":""},
{"lineNum":"  967","line":"      //! Empty class specialization"},
{"lineNum":"  968","line":"      template <class T, traits::EnableIf<(Flags & AllowEmptyClassElision),"},
{"lineNum":"  969","line":"                                          !traits::is_input_serializable<T, ArchiveType>::value,"},
{"lineNum":"  970","line":"                                          std::is_empty<T>::value> = traits::sfinae> inline"},
{"lineNum":"  971","line":"      ArchiveType & processImpl(T const &)"},
{"lineNum":"  972","line":"      {"},
{"lineNum":"  973","line":"        return *self;"},
{"lineNum":"  974","line":"      }"},
{"lineNum":"  975","line":""},
{"lineNum":"  976","line":"      //! No matching serialization"},
{"lineNum":"  977","line":"      /*! Invalid if we have invalid input versioning or"},
{"lineNum":"  978","line":"          we are not input serializable, and either"},
{"lineNum":"  979","line":"          don\'t allow empty class ellision or allow it but are not serializing an empty class */"},
{"lineNum":"  980","line":"      template <class T, traits::EnableIf<traits::has_invalid_input_versioning<T, ArchiveType>::value ||"},
{"lineNum":"  981","line":"                                          (!traits::is_input_serializable<T, ArchiveType>::value &&"},
{"lineNum":"  982","line":"                                           (!(Flags & AllowEmptyClassElision) || ((Flags & AllowEmptyClassElision) && !std::is_empty<T>::value)))> = traits::sfinae> inline"},
{"lineNum":"  983","line":"      ArchiveType & processImpl(T const &)"},
{"lineNum":"  984","line":"      {"},
{"lineNum":"  985","line":"        static_assert(traits::detail::count_input_serializers<T, ArchiveType>::value != 0,"},
{"lineNum":"  986","line":"            \"cereal could not find any input serialization functions for the provided type and archive combination. \\n\\n \""},
{"lineNum":"  987","line":"            \"Types must either have a serialize function, load/save pair, or load_minimal/save_minimal pair (you may not mix these). \\n \""},
{"lineNum":"  988","line":"            \"Serialize functions generally have the following signature: \\n\\n \""},
{"lineNum":"  989","line":"            \"template<class Archive> \\n \""},
{"lineNum":"  990","line":"            \"  void serialize(Archive & ar) \\n \""},
{"lineNum":"  991","line":"            \"  { \\n \""},
{"lineNum":"  992","line":"            \"    ar( member1, member2, member3 ); \\n \""},
{"lineNum":"  993","line":"            \"  } \\n\\n \" );"},
{"lineNum":"  994","line":""},
{"lineNum":"  995","line":"        static_assert(traits::detail::count_input_serializers<T, ArchiveType>::value < 2,"},
{"lineNum":"  996","line":"            \"cereal found more than one compatible input serialization function for the provided type and archive combination. \\n\\n \""},
{"lineNum":"  997","line":"            \"Types must either have a serialize function, load/save pair, or load_minimal/save_minimal pair (you may not mix these). \\n \""},
{"lineNum":"  998","line":"            \"Use specialization (see access.hpp) if you need to disambiguate between serialize vs load/save functions.  \\n \""},
{"lineNum":"  999","line":"            \"Note that serialization functions can be inherited which may lead to the aforementioned ambiguities. \\n \""},
{"lineNum":" 1000","line":"            \"In addition, you may not mix versioned with non-versioned serialization functions. \\n\\n \");"},
{"lineNum":" 1001","line":""},
{"lineNum":" 1002","line":"        return *self;"},
{"lineNum":" 1003","line":"      }"},
{"lineNum":" 1004","line":""},
{"lineNum":" 1005","line":"      //! Befriend for versioning in load_and_construct"},
{"lineNum":" 1006","line":"      template <class A, class B, bool C, bool D, bool E, bool F> friend struct detail::Construct;"},
{"lineNum":" 1007","line":""},
{"lineNum":" 1008","line":"      //! Registers a class version with the archive and serializes it if necessary"},
{"lineNum":" 1009","line":"      /*! If this is the first time this class has been serialized, we will record its"},
{"lineNum":" 1010","line":"          version number and serialize that."},
{"lineNum":" 1011","line":""},
{"lineNum":" 1012","line":"          @tparam T The type of the class being serialized */"},
{"lineNum":" 1013","line":"      template <class T> inline"},
{"lineNum":" 1014","line":"      std::uint32_t loadClassVersion()"},
{"lineNum":" 1015","line":"      {"},
{"lineNum":" 1016","line":"        static const auto hash = std::type_index(typeid(T)).hash_code();"},
{"lineNum":" 1017","line":"        auto lookupResult = itsVersionedTypes.find( hash );"},
{"lineNum":" 1018","line":""},
{"lineNum":" 1019","line":"        if( lookupResult != itsVersionedTypes.end() ) // already exists"},
{"lineNum":" 1020","line":"          return lookupResult->second;"},
{"lineNum":" 1021","line":"        else // need to load"},
{"lineNum":" 1022","line":"        {"},
{"lineNum":" 1023","line":"          std::uint32_t version;"},
{"lineNum":" 1024","line":""},
{"lineNum":" 1025","line":"          process( make_nvp<ArchiveType>(\"cereal_class_version\", version) );"},
{"lineNum":" 1026","line":"          itsVersionedTypes.emplace_hint( lookupResult, hash, version );"},
{"lineNum":" 1027","line":""},
{"lineNum":" 1028","line":"          return version;"},
{"lineNum":" 1029","line":"        }"},
{"lineNum":" 1030","line":"      }"},
{"lineNum":" 1031","line":""},
{"lineNum":" 1032","line":"      //! Member serialization"},
{"lineNum":" 1033","line":"      /*! Versioning implementation */"},
{"lineNum":" 1034","line":"      template <class T, PROCESS_IF(member_versioned_serialize)> inline"},
{"lineNum":" 1035","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":" 1036","line":"      {"},
{"lineNum":" 1037","line":"        const auto version = loadClassVersion<T>();"},
{"lineNum":" 1038","line":"        access::member_serialize(*self, t, version);"},
{"lineNum":" 1039","line":"        return *self;"},
{"lineNum":" 1040","line":"      }"},
{"lineNum":" 1041","line":""},
{"lineNum":" 1042","line":"      //! Non member serialization"},
{"lineNum":" 1043","line":"      /*! Versioning implementation */"},
{"lineNum":" 1044","line":"      template <class T, PROCESS_IF(non_member_versioned_serialize)> inline"},
{"lineNum":" 1045","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":" 1046","line":"      {"},
{"lineNum":" 1047","line":"        const auto version = loadClassVersion<T>();"},
{"lineNum":" 1048","line":"        CEREAL_SERIALIZE_FUNCTION_NAME(*self, t, version);"},
{"lineNum":" 1049","line":"        return *self;"},
{"lineNum":" 1050","line":"      }"},
{"lineNum":" 1051","line":""},
{"lineNum":" 1052","line":"      //! Member split (load)"},
{"lineNum":" 1053","line":"      /*! Versioning implementation */"},
{"lineNum":" 1054","line":"      template <class T, PROCESS_IF(member_versioned_load)> inline"},
{"lineNum":" 1055","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":" 1056","line":"      {"},
{"lineNum":" 1057","line":"        const auto version = loadClassVersion<T>();"},
{"lineNum":" 1058","line":"        access::member_load(*self, t, version);"},
{"lineNum":" 1059","line":"        return *self;"},
{"lineNum":" 1060","line":"      }"},
{"lineNum":" 1061","line":""},
{"lineNum":" 1062","line":"      //! Non member split (load)"},
{"lineNum":" 1063","line":"      /*! Versioning implementation */"},
{"lineNum":" 1064","line":"      template <class T, PROCESS_IF(non_member_versioned_load)> inline"},
{"lineNum":" 1065","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":" 1066","line":"      {"},
{"lineNum":" 1067","line":"        const auto version = loadClassVersion<T>();"},
{"lineNum":" 1068","line":"        CEREAL_LOAD_FUNCTION_NAME(*self, t, version);"},
{"lineNum":" 1069","line":"        return *self;"},
{"lineNum":" 1070","line":"      }"},
{"lineNum":" 1071","line":""},
{"lineNum":" 1072","line":"      //! Member split (load_minimal)"},
{"lineNum":" 1073","line":"      /*! Versioning implementation */"},
{"lineNum":" 1074","line":"      template <class T, PROCESS_IF(member_versioned_load_minimal)> inline"},
{"lineNum":" 1075","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":" 1076","line":"      {"},
{"lineNum":" 1077","line":"        using OutArchiveType = typename traits::detail::get_output_from_input<ArchiveType>::type;"},
{"lineNum":" 1078","line":"        const auto version = loadClassVersion<T>();"},
{"lineNum":" 1079","line":"        typename traits::has_member_versioned_save_minimal<T, OutArchiveType>::type value;"},
{"lineNum":" 1080","line":"        self->process(value);"},
{"lineNum":" 1081","line":"        access::member_load_minimal(*self, t, value, version);"},
{"lineNum":" 1082","line":"        return *self;"},
{"lineNum":" 1083","line":"      }"},
{"lineNum":" 1084","line":""},
{"lineNum":" 1085","line":"      //! Non member split (load_minimal)"},
{"lineNum":" 1086","line":"      /*! Versioning implementation */"},
{"lineNum":" 1087","line":"      template <class T, PROCESS_IF(non_member_versioned_load_minimal)> inline"},
{"lineNum":" 1088","line":"      ArchiveType & processImpl(T & t)"},
{"lineNum":" 1089","line":"      {"},
{"lineNum":" 1090","line":"        using OutArchiveType = typename traits::detail::get_output_from_input<ArchiveType>::type;"},
{"lineNum":" 1091","line":"        const auto version = loadClassVersion<T>();"},
{"lineNum":" 1092","line":"        typename traits::has_non_member_versioned_save_minimal<T, OutArchiveType>::type value;"},
{"lineNum":" 1093","line":"        self->process(value);"},
{"lineNum":" 1094","line":"        CEREAL_LOAD_MINIMAL_FUNCTION_NAME(*self, t, value, version);"},
{"lineNum":" 1095","line":"        return *self;"},
{"lineNum":" 1096","line":"      }"},
{"lineNum":" 1097","line":""},
{"lineNum":" 1098","line":"      #undef PROCESS_IF"},
{"lineNum":" 1099","line":""},
{"lineNum":" 1100","line":"    private:"},
{"lineNum":" 1101","line":"      ArchiveType * const self;"},
{"lineNum":" 1102","line":""},
{"lineNum":" 1103","line":"      //! A set of all base classes that have been serialized"},
{"lineNum":" 1104","line":"      std::unordered_set<traits::detail::base_class_id, traits::detail::base_class_id_hash> itsBaseClassSet;"},
{"lineNum":" 1105","line":""},
{"lineNum":" 1106","line":"      //! Maps from pointer ids to metadata"},
{"lineNum":" 1107","line":"      std::unordered_map<std::uint32_t, std::shared_ptr<void>> itsSharedPointerMap;"},
{"lineNum":" 1108","line":""},
{"lineNum":" 1109","line":"      //! Maps from name ids to names"},
{"lineNum":" 1110","line":"      std::unordered_map<std::uint32_t, std::string> itsPolymorphicTypeMap;"},
{"lineNum":" 1111","line":""},
{"lineNum":" 1112","line":"      //! Maps from type hash codes to version numbers"},
{"lineNum":" 1113","line":"      std::unordered_map<std::size_t, std::uint32_t> itsVersionedTypes;"},
{"lineNum":" 1114","line":"  }; // class InputArchive"},
{"lineNum":" 1115","line":"} // namespace cereal"},
{"lineNum":" 1116","line":""},
{"lineNum":" 1117","line":"// This include needs to come after things such as binary_data, make_nvp, etc"},
{"lineNum":" 1118","line":"#include \"cereal/types/common.hpp\""},
{"lineNum":" 1119","line":""},
{"lineNum":" 1120","line":"#endif // CEREAL_CEREAL_HPP_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 82, "covered" : 0,};
var merged_data = [];
