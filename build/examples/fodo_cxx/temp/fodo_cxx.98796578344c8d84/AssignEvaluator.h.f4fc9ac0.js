var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2011 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2011-2014 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"// Copyright (C) 2011-2012 Jitse Niesen <jitse@maths.leeds.ac.uk>"},
{"lineNum":"    7","line":"//"},
{"lineNum":"    8","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    9","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"   10","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"#ifndef EIGEN_ASSIGN_EVALUATOR_H"},
{"lineNum":"   13","line":"#define EIGEN_ASSIGN_EVALUATOR_H"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace Eigen {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"// This implementation is based on Assign.h"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"namespace internal {"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"/***************************************************************************"},
{"lineNum":"   24","line":"* Part 1 : the logic deciding a strategy for traversal and unrolling       *"},
{"lineNum":"   25","line":"***************************************************************************/"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"// copy_using_evaluator_traits is based on assign_traits"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"template <typename DstEvaluator, typename SrcEvaluator, typename AssignFunc, int MaxPacketSize = -1>"},
{"lineNum":"   30","line":"struct copy_using_evaluator_traits"},
{"lineNum":"   31","line":"{"},
{"lineNum":"   32","line":"  typedef typename DstEvaluator::XprType Dst;"},
{"lineNum":"   33","line":"  typedef typename Dst::Scalar DstScalar;"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"  enum {"},
{"lineNum":"   36","line":"    DstFlags = DstEvaluator::Flags,"},
{"lineNum":"   37","line":"    SrcFlags = SrcEvaluator::Flags"},
{"lineNum":"   38","line":"  };"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"public:"},
{"lineNum":"   41","line":"  enum {"},
{"lineNum":"   42","line":"    DstAlignment = DstEvaluator::Alignment,"},
{"lineNum":"   43","line":"    SrcAlignment = SrcEvaluator::Alignment,"},
{"lineNum":"   44","line":"    DstHasDirectAccess = (DstFlags & DirectAccessBit) == DirectAccessBit,"},
{"lineNum":"   45","line":"    JointAlignment = EIGEN_PLAIN_ENUM_MIN(DstAlignment,SrcAlignment)"},
{"lineNum":"   46","line":"  };"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"private:"},
{"lineNum":"   49","line":"  enum {"},
{"lineNum":"   50","line":"    InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)"},
{"lineNum":"   51","line":"              : int(DstFlags)&RowMajorBit ? int(Dst::ColsAtCompileTime)"},
{"lineNum":"   52","line":"              : int(Dst::RowsAtCompileTime),"},
{"lineNum":"   53","line":"    InnerMaxSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)"},
{"lineNum":"   54","line":"              : int(DstFlags)&RowMajorBit ? int(Dst::MaxColsAtCompileTime)"},
{"lineNum":"   55","line":"              : int(Dst::MaxRowsAtCompileTime),"},
{"lineNum":"   56","line":"    RestrictedInnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(InnerSize,MaxPacketSize),"},
{"lineNum":"   57","line":"    RestrictedLinearSize = EIGEN_SIZE_MIN_PREFER_FIXED(Dst::SizeAtCompileTime,MaxPacketSize),"},
{"lineNum":"   58","line":"    OuterStride = int(outer_stride_at_compile_time<Dst>::ret),"},
{"lineNum":"   59","line":"    MaxSizeAtCompileTime = Dst::SizeAtCompileTime"},
{"lineNum":"   60","line":"  };"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"  // TODO distinguish between linear traversal and inner-traversals"},
{"lineNum":"   63","line":"  typedef typename find_best_packet<DstScalar,RestrictedLinearSize>::type LinearPacketType;"},
{"lineNum":"   64","line":"  typedef typename find_best_packet<DstScalar,RestrictedInnerSize>::type InnerPacketType;"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"  enum {"},
{"lineNum":"   67","line":"    LinearPacketSize = unpacket_traits<LinearPacketType>::size,"},
{"lineNum":"   68","line":"    InnerPacketSize = unpacket_traits<InnerPacketType>::size"},
{"lineNum":"   69","line":"  };"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"public:"},
{"lineNum":"   72","line":"  enum {"},
{"lineNum":"   73","line":"    LinearRequiredAlignment = unpacket_traits<LinearPacketType>::alignment,"},
{"lineNum":"   74","line":"    InnerRequiredAlignment = unpacket_traits<InnerPacketType>::alignment"},
{"lineNum":"   75","line":"  };"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"private:"},
{"lineNum":"   78","line":"  enum {"},
{"lineNum":"   79","line":"    DstIsRowMajor = DstFlags&RowMajorBit,"},
{"lineNum":"   80","line":"    SrcIsRowMajor = SrcFlags&RowMajorBit,"},
{"lineNum":"   81","line":"    StorageOrdersAgree = (int(DstIsRowMajor) == int(SrcIsRowMajor)),"},
{"lineNum":"   82","line":"    MightVectorize = bool(StorageOrdersAgree)"},
{"lineNum":"   83","line":"                  && (int(DstFlags) & int(SrcFlags) & ActualPacketAccessBit)"},
{"lineNum":"   84","line":"                  && bool(functor_traits<AssignFunc>::PacketAccess),"},
{"lineNum":"   85","line":"    MayInnerVectorize  = MightVectorize"},
{"lineNum":"   86","line":"                       && int(InnerSize)!=Dynamic && int(InnerSize)%int(InnerPacketSize)==0"},
{"lineNum":"   87","line":"                       && int(OuterStride)!=Dynamic && int(OuterStride)%int(InnerPacketSize)==0"},
{"lineNum":"   88","line":"                       && (EIGEN_UNALIGNED_VECTORIZE  || int(JointAlignment)>=int(InnerRequiredAlignment)),"},
{"lineNum":"   89","line":"    MayLinearize = bool(StorageOrdersAgree) && (int(DstFlags) & int(SrcFlags) & LinearAccessBit),"},
{"lineNum":"   90","line":"    MayLinearVectorize = bool(MightVectorize) && bool(MayLinearize) && bool(DstHasDirectAccess)"},
{"lineNum":"   91","line":"                       && (EIGEN_UNALIGNED_VECTORIZE || (int(DstAlignment)>=int(LinearRequiredAlignment)) || MaxSizeAtCompileTime == Dynamic),"},
{"lineNum":"   92","line":"      /* If the destination isn\'t aligned, we have to do runtime checks and we don\'t unroll,"},
{"lineNum":"   93","line":"         so it\'s only good for large enough sizes. */"},
{"lineNum":"   94","line":"    MaySliceVectorize  = bool(MightVectorize) && bool(DstHasDirectAccess)"},
{"lineNum":"   95","line":"                       && (int(InnerMaxSize)==Dynamic || int(InnerMaxSize)>=(EIGEN_UNALIGNED_VECTORIZE?InnerPacketSize:(3*InnerPacketSize)))"},
{"lineNum":"   96","line":"      /* slice vectorization can be slow, so we only want it if the slices are big, which is"},
{"lineNum":"   97","line":"         indicated by InnerMaxSize rather than InnerSize, think of the case of a dynamic block"},
{"lineNum":"   98","line":"         in a fixed-size matrix"},
{"lineNum":"   99","line":"         However, with EIGEN_UNALIGNED_VECTORIZE and unrolling, slice vectorization is still worth it */"},
{"lineNum":"  100","line":"  };"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"public:"},
{"lineNum":"  103","line":"  enum {"},
{"lineNum":"  104","line":"    Traversal =  int(Dst::SizeAtCompileTime) == 0 ? int(AllAtOnceTraversal) // If compile-size is zero, traversing will fail at compile-time."},
{"lineNum":"  105","line":"              : (int(MayLinearVectorize) && (LinearPacketSize>InnerPacketSize)) ? int(LinearVectorizedTraversal)"},
{"lineNum":"  106","line":"              : int(MayInnerVectorize)   ? int(InnerVectorizedTraversal)"},
{"lineNum":"  107","line":"              : int(MayLinearVectorize)  ? int(LinearVectorizedTraversal)"},
{"lineNum":"  108","line":"              : int(MaySliceVectorize)   ? int(SliceVectorizedTraversal)"},
{"lineNum":"  109","line":"              : int(MayLinearize)        ? int(LinearTraversal)"},
{"lineNum":"  110","line":"                                         : int(DefaultTraversal),"},
{"lineNum":"  111","line":"    Vectorized = int(Traversal) == InnerVectorizedTraversal"},
{"lineNum":"  112","line":"              || int(Traversal) == LinearVectorizedTraversal"},
{"lineNum":"  113","line":"              || int(Traversal) == SliceVectorizedTraversal"},
{"lineNum":"  114","line":"  };"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"  typedef typename conditional<int(Traversal)==LinearVectorizedTraversal, LinearPacketType, InnerPacketType>::type PacketType;"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"private:"},
{"lineNum":"  119","line":"  enum {"},
{"lineNum":"  120","line":"    ActualPacketSize    = int(Traversal)==LinearVectorizedTraversal ? LinearPacketSize"},
{"lineNum":"  121","line":"                        : Vectorized ? InnerPacketSize"},
{"lineNum":"  122","line":"                        : 1,"},
{"lineNum":"  123","line":"    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * ActualPacketSize,"},
{"lineNum":"  124","line":"    MayUnrollCompletely = int(Dst::SizeAtCompileTime) != Dynamic"},
{"lineNum":"  125","line":"                       && int(Dst::SizeAtCompileTime) * (int(DstEvaluator::CoeffReadCost)+int(SrcEvaluator::CoeffReadCost)) <= int(UnrollingLimit),"},
{"lineNum":"  126","line":"    MayUnrollInner      = int(InnerSize) != Dynamic"},
{"lineNum":"  127","line":"                       && int(InnerSize) * (int(DstEvaluator::CoeffReadCost)+int(SrcEvaluator::CoeffReadCost)) <= int(UnrollingLimit)"},
{"lineNum":"  128","line":"  };"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"public:"},
{"lineNum":"  131","line":"  enum {"},
{"lineNum":"  132","line":"    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))"},
{"lineNum":"  133","line":"                ? ("},
{"lineNum":"  134","line":"                    int(MayUnrollCompletely) ? int(CompleteUnrolling)"},
{"lineNum":"  135","line":"                  : int(MayUnrollInner)      ? int(InnerUnrolling)"},
{"lineNum":"  136","line":"                                             : int(NoUnrolling)"},
{"lineNum":"  137","line":"                  )"},
{"lineNum":"  138","line":"              : int(Traversal) == int(LinearVectorizedTraversal)"},
{"lineNum":"  139","line":"                ? ( bool(MayUnrollCompletely) && ( EIGEN_UNALIGNED_VECTORIZE || (int(DstAlignment)>=int(LinearRequiredAlignment)))"},
{"lineNum":"  140","line":"                          ? int(CompleteUnrolling)"},
{"lineNum":"  141","line":"                          : int(NoUnrolling) )"},
{"lineNum":"  142","line":"              : int(Traversal) == int(LinearTraversal)"},
{"lineNum":"  143","line":"                ? ( bool(MayUnrollCompletely) ? int(CompleteUnrolling)"},
{"lineNum":"  144","line":"                                              : int(NoUnrolling) )"},
{"lineNum":"  145","line":"#if EIGEN_UNALIGNED_VECTORIZE"},
{"lineNum":"  146","line":"              : int(Traversal) == int(SliceVectorizedTraversal)"},
{"lineNum":"  147","line":"                ? ( bool(MayUnrollInner) ? int(InnerUnrolling)"},
{"lineNum":"  148","line":"                                         : int(NoUnrolling) )"},
{"lineNum":"  149","line":"#endif"},
{"lineNum":"  150","line":"              : int(NoUnrolling)"},
{"lineNum":"  151","line":"  };"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"#ifdef EIGEN_DEBUG_ASSIGN"},
{"lineNum":"  154","line":"  static void debug()"},
{"lineNum":"  155","line":"  {"},
{"lineNum":"  156","line":"    std::cerr << \"DstXpr: \" << typeid(typename DstEvaluator::XprType).name() << std::endl;"},
{"lineNum":"  157","line":"    std::cerr << \"SrcXpr: \" << typeid(typename SrcEvaluator::XprType).name() << std::endl;"},
{"lineNum":"  158","line":"    std::cerr.setf(std::ios::hex, std::ios::basefield);"},
{"lineNum":"  159","line":"    std::cerr << \"DstFlags\" << \" = \" << DstFlags << \" (\" << demangle_flags(DstFlags) << \" )\" << std::endl;"},
{"lineNum":"  160","line":"    std::cerr << \"SrcFlags\" << \" = \" << SrcFlags << \" (\" << demangle_flags(SrcFlags) << \" )\" << std::endl;"},
{"lineNum":"  161","line":"    std::cerr.unsetf(std::ios::hex);"},
{"lineNum":"  162","line":"    EIGEN_DEBUG_VAR(DstAlignment)"},
{"lineNum":"  163","line":"    EIGEN_DEBUG_VAR(SrcAlignment)"},
{"lineNum":"  164","line":"    EIGEN_DEBUG_VAR(LinearRequiredAlignment)"},
{"lineNum":"  165","line":"    EIGEN_DEBUG_VAR(InnerRequiredAlignment)"},
{"lineNum":"  166","line":"    EIGEN_DEBUG_VAR(JointAlignment)"},
{"lineNum":"  167","line":"    EIGEN_DEBUG_VAR(InnerSize)"},
{"lineNum":"  168","line":"    EIGEN_DEBUG_VAR(InnerMaxSize)"},
{"lineNum":"  169","line":"    EIGEN_DEBUG_VAR(LinearPacketSize)"},
{"lineNum":"  170","line":"    EIGEN_DEBUG_VAR(InnerPacketSize)"},
{"lineNum":"  171","line":"    EIGEN_DEBUG_VAR(ActualPacketSize)"},
{"lineNum":"  172","line":"    EIGEN_DEBUG_VAR(StorageOrdersAgree)"},
{"lineNum":"  173","line":"    EIGEN_DEBUG_VAR(MightVectorize)"},
{"lineNum":"  174","line":"    EIGEN_DEBUG_VAR(MayLinearize)"},
{"lineNum":"  175","line":"    EIGEN_DEBUG_VAR(MayInnerVectorize)"},
{"lineNum":"  176","line":"    EIGEN_DEBUG_VAR(MayLinearVectorize)"},
{"lineNum":"  177","line":"    EIGEN_DEBUG_VAR(MaySliceVectorize)"},
{"lineNum":"  178","line":"    std::cerr << \"Traversal\" << \" = \" << Traversal << \" (\" << demangle_traversal(Traversal) << \")\" << std::endl;"},
{"lineNum":"  179","line":"    EIGEN_DEBUG_VAR(SrcEvaluator::CoeffReadCost)"},
{"lineNum":"  180","line":"    EIGEN_DEBUG_VAR(DstEvaluator::CoeffReadCost)"},
{"lineNum":"  181","line":"    EIGEN_DEBUG_VAR(Dst::SizeAtCompileTime)"},
{"lineNum":"  182","line":"    EIGEN_DEBUG_VAR(UnrollingLimit)"},
{"lineNum":"  183","line":"    EIGEN_DEBUG_VAR(MayUnrollCompletely)"},
{"lineNum":"  184","line":"    EIGEN_DEBUG_VAR(MayUnrollInner)"},
{"lineNum":"  185","line":"    std::cerr << \"Unrolling\" << \" = \" << Unrolling << \" (\" << demangle_unrolling(Unrolling) << \")\" << std::endl;"},
{"lineNum":"  186","line":"    std::cerr << std::endl;"},
{"lineNum":"  187","line":"  }"},
{"lineNum":"  188","line":"#endif"},
{"lineNum":"  189","line":"};"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"/***************************************************************************"},
{"lineNum":"  192","line":"* Part 2 : meta-unrollers"},
{"lineNum":"  193","line":"***************************************************************************/"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"/************************"},
{"lineNum":"  196","line":"*** Default traversal ***"},
{"lineNum":"  197","line":"************************/"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"template<typename Kernel, int Index, int Stop>"},
{"lineNum":"  200","line":"struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling"},
{"lineNum":"  201","line":"{"},
{"lineNum":"  202","line":"  // FIXME: this is not very clean, perhaps this information should be provided by the kernel?"},
{"lineNum":"  203","line":"  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;"},
{"lineNum":"  204","line":"  typedef typename DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"  enum {"},
{"lineNum":"  207","line":"    outer = Index / DstXprType::InnerSizeAtCompileTime,"},
{"lineNum":"  208","line":"    inner = Index % DstXprType::InnerSizeAtCompileTime"},
{"lineNum":"  209","line":"  };"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  212","line":"  {"},
{"lineNum":"  213","line":"    kernel.assignCoeffByOuterInner(outer, inner);"},
{"lineNum":"  214","line":"    copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);"},
{"lineNum":"  215","line":"  }"},
{"lineNum":"  216","line":"};"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"template<typename Kernel, int Stop>"},
{"lineNum":"  219","line":"struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, Stop, Stop>"},
{"lineNum":"  220","line":"{"},
{"lineNum":"  221","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }"},
{"lineNum":"  222","line":"};"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"template<typename Kernel, int Index_, int Stop>"},
{"lineNum":"  225","line":"struct copy_using_evaluator_DefaultTraversal_InnerUnrolling"},
{"lineNum":"  226","line":"{"},
{"lineNum":"  227","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel, Index outer)"},
{"lineNum":"  228","line":"  {"},
{"lineNum":"  229","line":"    kernel.assignCoeffByOuterInner(outer, Index_);"},
{"lineNum":"  230","line":"    copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, Index_+1, Stop>::run(kernel, outer);"},
{"lineNum":"  231","line":"  }"},
{"lineNum":"  232","line":"};"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"template<typename Kernel, int Stop>"},
{"lineNum":"  235","line":"struct copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, Stop, Stop>"},
{"lineNum":"  236","line":"{"},
{"lineNum":"  237","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index) { }"},
{"lineNum":"  238","line":"};"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"/***********************"},
{"lineNum":"  241","line":"*** Linear traversal ***"},
{"lineNum":"  242","line":"***********************/"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"template<typename Kernel, int Index, int Stop>"},
{"lineNum":"  245","line":"struct copy_using_evaluator_LinearTraversal_CompleteUnrolling"},
{"lineNum":"  246","line":"{"},
{"lineNum":"  247","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel& kernel)"},
{"lineNum":"  248","line":"  {"},
{"lineNum":"  249","line":"    kernel.assignCoeff(Index);"},
{"lineNum":"  250","line":"    copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Index+1, Stop>::run(kernel);"},
{"lineNum":"  251","line":"  }"},
{"lineNum":"  252","line":"};"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"template<typename Kernel, int Stop>"},
{"lineNum":"  255","line":"struct copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, Stop, Stop>"},
{"lineNum":"  256","line":"{"},
{"lineNum":"  257","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }"},
{"lineNum":"  258","line":"};"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"/**************************"},
{"lineNum":"  261","line":"*** Inner vectorization ***"},
{"lineNum":"  262","line":"**************************/"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"template<typename Kernel, int Index, int Stop>"},
{"lineNum":"  265","line":"struct copy_using_evaluator_innervec_CompleteUnrolling"},
{"lineNum":"  266","line":"{"},
{"lineNum":"  267","line":"  // FIXME: this is not very clean, perhaps this information should be provided by the kernel?"},
{"lineNum":"  268","line":"  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;"},
{"lineNum":"  269","line":"  typedef typename DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  270","line":"  typedef typename Kernel::PacketType PacketType;"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"  enum {"},
{"lineNum":"  273","line":"    outer = Index / DstXprType::InnerSizeAtCompileTime,"},
{"lineNum":"  274","line":"    inner = Index % DstXprType::InnerSizeAtCompileTime,"},
{"lineNum":"  275","line":"    SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,"},
{"lineNum":"  276","line":"    DstAlignment = Kernel::AssignmentTraits::DstAlignment"},
{"lineNum":"  277","line":"  };"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  280","line":"  {"},
{"lineNum":"  281","line":"    kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, inner);"},
{"lineNum":"  282","line":"    enum { NextIndex = Index + unpacket_traits<PacketType>::size };"},
{"lineNum":"  283","line":"    copy_using_evaluator_innervec_CompleteUnrolling<Kernel, NextIndex, Stop>::run(kernel);"},
{"lineNum":"  284","line":"  }"},
{"lineNum":"  285","line":"};"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"template<typename Kernel, int Stop>"},
{"lineNum":"  288","line":"struct copy_using_evaluator_innervec_CompleteUnrolling<Kernel, Stop, Stop>"},
{"lineNum":"  289","line":"{"},
{"lineNum":"  290","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&) { }"},
{"lineNum":"  291","line":"};"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"template<typename Kernel, int Index_, int Stop, int SrcAlignment, int DstAlignment>"},
{"lineNum":"  294","line":"struct copy_using_evaluator_innervec_InnerUnrolling"},
{"lineNum":"  295","line":"{"},
{"lineNum":"  296","line":"  typedef typename Kernel::PacketType PacketType;"},
{"lineNum":"  297","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel, Index outer)"},
{"lineNum":"  298","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  299","line":"    kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, Index_);"},
{"lineNum":"  300","line":"    enum { NextIndex = Index_ + unpacket_traits<PacketType>::size };"},
{"lineNum":"  301","line":"    copy_using_evaluator_innervec_InnerUnrolling<Kernel, NextIndex, Stop, SrcAlignment, DstAlignment>::run(kernel, outer);"},
{"lineNum":"  302","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  303","line":"};"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"template<typename Kernel, int Stop, int SrcAlignment, int DstAlignment>"},
{"lineNum":"  306","line":"struct copy_using_evaluator_innervec_InnerUnrolling<Kernel, Stop, Stop, SrcAlignment, DstAlignment>"},
{"lineNum":"  307","line":"{"},
{"lineNum":"  308","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &, Index) { }"},
{"lineNum":"  309","line":"};"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"/***************************************************************************"},
{"lineNum":"  312","line":"* Part 3 : implementation of all cases"},
{"lineNum":"  313","line":"***************************************************************************/"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"// dense_assignment_loop is based on assign_impl"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"template<typename Kernel,"},
{"lineNum":"  318","line":"         int Traversal = Kernel::AssignmentTraits::Traversal,"},
{"lineNum":"  319","line":"         int Unrolling = Kernel::AssignmentTraits::Unrolling>"},
{"lineNum":"  320","line":"struct dense_assignment_loop;"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"/************************"},
{"lineNum":"  323","line":"***** Special Cases *****"},
{"lineNum":"  324","line":"************************/"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"// Zero-sized assignment is a no-op."},
{"lineNum":"  327","line":"template<typename Kernel, int Unrolling>"},
{"lineNum":"  328","line":"struct dense_assignment_loop<Kernel, AllAtOnceTraversal, Unrolling>"},
{"lineNum":"  329","line":"{"},
{"lineNum":"  330","line":"  EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel& /*kernel*/)"},
{"lineNum":"  331","line":"  {"},
{"lineNum":"  332","line":"    EIGEN_STATIC_ASSERT(int(Kernel::DstEvaluatorType::XprType::SizeAtCompileTime) == 0,"},
{"lineNum":"  333","line":"      EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT)"},
{"lineNum":"  334","line":"  }"},
{"lineNum":"  335","line":"};"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"/************************"},
{"lineNum":"  338","line":"*** Default traversal ***"},
{"lineNum":"  339","line":"************************/"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"template<typename Kernel>"},
{"lineNum":"  342","line":"struct dense_assignment_loop<Kernel, DefaultTraversal, NoUnrolling>"},
{"lineNum":"  343","line":"{"},
{"lineNum":"  344","line":"  EIGEN_DEVICE_FUNC static void EIGEN_STRONG_INLINE run(Kernel &kernel)"},
{"lineNum":"  345","line":"  {"},
{"lineNum":"  346","line":"    for(Index outer = 0; outer < kernel.outerSize(); ++outer) {","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  347","line":"      for(Index inner = 0; inner < kernel.innerSize(); ++inner) {","class":"lineNoCov","hits":"0","possible_hits":"105",},
{"lineNum":"  348","line":"        kernel.assignCoeffByOuterInner(outer, inner);"},
{"lineNum":"  349","line":"      }"},
{"lineNum":"  350","line":"    }"},
{"lineNum":"  351","line":"  }"},
{"lineNum":"  352","line":"};"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"template<typename Kernel>"},
{"lineNum":"  355","line":"struct dense_assignment_loop<Kernel, DefaultTraversal, CompleteUnrolling>"},
{"lineNum":"  356","line":"{"},
{"lineNum":"  357","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  358","line":"  {"},
{"lineNum":"  359","line":"    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  360","line":"    copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTime>::run(kernel);"},
{"lineNum":"  361","line":"  }"},
{"lineNum":"  362","line":"};"},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"template<typename Kernel>"},
{"lineNum":"  365","line":"struct dense_assignment_loop<Kernel, DefaultTraversal, InnerUnrolling>"},
{"lineNum":"  366","line":"{"},
{"lineNum":"  367","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  368","line":"  {"},
{"lineNum":"  369","line":"    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"    const Index outerSize = kernel.outerSize();"},
{"lineNum":"  372","line":"    for(Index outer = 0; outer < outerSize; ++outer)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  373","line":"      copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, 0, DstXprType::InnerSizeAtCompileTime>::run(kernel, outer);"},
{"lineNum":"  374","line":"  }"},
{"lineNum":"  375","line":"};"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"/***************************"},
{"lineNum":"  378","line":"*** Linear vectorization ***"},
{"lineNum":"  379","line":"***************************/"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"// The goal of unaligned_dense_assignment_loop is simply to factorize the handling"},
{"lineNum":"  383","line":"// of the non vectorizable beginning and ending parts"},
{"lineNum":"  384","line":""},
{"lineNum":"  385","line":"template <bool IsAligned = false>"},
{"lineNum":"  386","line":"struct unaligned_dense_assignment_loop"},
{"lineNum":"  387","line":"{"},
{"lineNum":"  388","line":"  // if IsAligned = true, then do nothing"},
{"lineNum":"  389","line":"  template <typename Kernel>"},
{"lineNum":"  390","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel&, Index, Index) {}"},
{"lineNum":"  391","line":"};"},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"template <>"},
{"lineNum":"  394","line":"struct unaligned_dense_assignment_loop<false>"},
{"lineNum":"  395","line":"{"},
{"lineNum":"  396","line":"  // MSVC must not inline this functions. If it does, it fails to optimize the"},
{"lineNum":"  397","line":"  // packet access path."},
{"lineNum":"  398","line":"  // FIXME check which version exhibits this issue"},
{"lineNum":"  399","line":"#if EIGEN_COMP_MSVC"},
{"lineNum":"  400","line":"  template <typename Kernel>"},
{"lineNum":"  401","line":"  static EIGEN_DONT_INLINE void run(Kernel &kernel,"},
{"lineNum":"  402","line":"                                    Index start,"},
{"lineNum":"  403","line":"                                    Index end)"},
{"lineNum":"  404","line":"#else"},
{"lineNum":"  405","line":"  template <typename Kernel>"},
{"lineNum":"  406","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel,"},
{"lineNum":"  407","line":"                                      Index start,"},
{"lineNum":"  408","line":"                                      Index end)"},
{"lineNum":"  409","line":"#endif"},
{"lineNum":"  410","line":"  {"},
{"lineNum":"  411","line":"    for (Index index = start; index < end; ++index)","class":"lineNoCov","hits":"0","possible_hits":"564",},
{"lineNum":"  412","line":"      kernel.assignCoeff(index);"},
{"lineNum":"  413","line":"  }"},
{"lineNum":"  414","line":"};"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"template<typename Kernel>"},
{"lineNum":"  417","line":"struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, NoUnrolling>"},
{"lineNum":"  418","line":"{"},
{"lineNum":"  419","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  420","line":"  {"},
{"lineNum":"  421","line":"    const Index size = kernel.size();"},
{"lineNum":"  422","line":"    typedef typename Kernel::Scalar Scalar;"},
{"lineNum":"  423","line":"    typedef typename Kernel::PacketType PacketType;"},
{"lineNum":"  424","line":"    enum {"},
{"lineNum":"  425","line":"      requestedAlignment = Kernel::AssignmentTraits::LinearRequiredAlignment,"},
{"lineNum":"  426","line":"      packetSize = unpacket_traits<PacketType>::size,"},
{"lineNum":"  427","line":"      dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),"},
{"lineNum":"  428","line":"      dstAlignment = packet_traits<Scalar>::AlignedOnScalar ? int(requestedAlignment)"},
{"lineNum":"  429","line":"                                                            : int(Kernel::AssignmentTraits::DstAlignment),"},
{"lineNum":"  430","line":"      srcAlignment = Kernel::AssignmentTraits::JointAlignment"},
{"lineNum":"  431","line":"    };"},
{"lineNum":"  432","line":"    const Index alignedStart = dstIsAligned ? 0 : internal::first_aligned<requestedAlignment>(kernel.dstDataPtr(), size);"},
{"lineNum":"  433","line":"    const Index alignedEnd = alignedStart + ((size-alignedStart)/packetSize)*packetSize;","class":"lineNoCov","hits":"0","possible_hits":"77",},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"    unaligned_dense_assignment_loop<dstIsAligned!=0>::run(kernel, 0, alignedStart);"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"    for(Index index = alignedStart; index < alignedEnd; index += packetSize)","class":"lineNoCov","hits":"0","possible_hits":"173",},
{"lineNum":"  438","line":"      kernel.template assignPacket<dstAlignment, srcAlignment, PacketType>(index);"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"    unaligned_dense_assignment_loop<>::run(kernel, alignedEnd, size);"},
{"lineNum":"  441","line":"  }"},
{"lineNum":"  442","line":"};"},
{"lineNum":"  443","line":""},
{"lineNum":"  444","line":"template<typename Kernel>"},
{"lineNum":"  445","line":"struct dense_assignment_loop<Kernel, LinearVectorizedTraversal, CompleteUnrolling>"},
{"lineNum":"  446","line":"{"},
{"lineNum":"  447","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  448","line":"  {"},
{"lineNum":"  449","line":"    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  450","line":"    typedef typename Kernel::PacketType PacketType;"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"    enum { size = DstXprType::SizeAtCompileTime,"},
{"lineNum":"  453","line":"           packetSize =unpacket_traits<PacketType>::size,"},
{"lineNum":"  454","line":"           alignedSize = (int(size)/packetSize)*packetSize };"},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"    copy_using_evaluator_innervec_CompleteUnrolling<Kernel, 0, alignedSize>::run(kernel);"},
{"lineNum":"  457","line":"    copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, alignedSize, size>::run(kernel);"},
{"lineNum":"  458","line":"  }"},
{"lineNum":"  459","line":"};"},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":"/**************************"},
{"lineNum":"  462","line":"*** Inner vectorization ***"},
{"lineNum":"  463","line":"**************************/"},
{"lineNum":"  464","line":""},
{"lineNum":"  465","line":"template<typename Kernel>"},
{"lineNum":"  466","line":"struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, NoUnrolling>"},
{"lineNum":"  467","line":"{"},
{"lineNum":"  468","line":"  typedef typename Kernel::PacketType PacketType;"},
{"lineNum":"  469","line":"  enum {"},
{"lineNum":"  470","line":"    SrcAlignment = Kernel::AssignmentTraits::SrcAlignment,"},
{"lineNum":"  471","line":"    DstAlignment = Kernel::AssignmentTraits::DstAlignment"},
{"lineNum":"  472","line":"  };"},
{"lineNum":"  473","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  474","line":"  {"},
{"lineNum":"  475","line":"    const Index innerSize = kernel.innerSize();"},
{"lineNum":"  476","line":"    const Index outerSize = kernel.outerSize();"},
{"lineNum":"  477","line":"    const Index packetSize = unpacket_traits<PacketType>::size;"},
{"lineNum":"  478","line":"    for(Index outer = 0; outer < outerSize; ++outer)"},
{"lineNum":"  479","line":"      for(Index inner = 0; inner < innerSize; inner+=packetSize)"},
{"lineNum":"  480","line":"        kernel.template assignPacketByOuterInner<DstAlignment, SrcAlignment, PacketType>(outer, inner);"},
{"lineNum":"  481","line":"  }"},
{"lineNum":"  482","line":"};"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"template<typename Kernel>"},
{"lineNum":"  485","line":"struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, CompleteUnrolling>"},
{"lineNum":"  486","line":"{"},
{"lineNum":"  487","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  488","line":"  {"},
{"lineNum":"  489","line":"    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  490","line":"    copy_using_evaluator_innervec_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTime>::run(kernel);"},
{"lineNum":"  491","line":"  }"},
{"lineNum":"  492","line":"};"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"template<typename Kernel>"},
{"lineNum":"  495","line":"struct dense_assignment_loop<Kernel, InnerVectorizedTraversal, InnerUnrolling>"},
{"lineNum":"  496","line":"{"},
{"lineNum":"  497","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  498","line":"  {"},
{"lineNum":"  499","line":"    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  500","line":"    typedef typename Kernel::AssignmentTraits Traits;"},
{"lineNum":"  501","line":"    const Index outerSize = kernel.outerSize();"},
{"lineNum":"  502","line":"    for(Index outer = 0; outer < outerSize; ++outer)"},
{"lineNum":"  503","line":"      copy_using_evaluator_innervec_InnerUnrolling<Kernel, 0, DstXprType::InnerSizeAtCompileTime,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  504","line":"                                                   Traits::SrcAlignment, Traits::DstAlignment>::run(kernel, outer);"},
{"lineNum":"  505","line":"  }"},
{"lineNum":"  506","line":"};"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"/***********************"},
{"lineNum":"  509","line":"*** Linear traversal ***"},
{"lineNum":"  510","line":"***********************/"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"template<typename Kernel>"},
{"lineNum":"  513","line":"struct dense_assignment_loop<Kernel, LinearTraversal, NoUnrolling>"},
{"lineNum":"  514","line":"{"},
{"lineNum":"  515","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  516","line":"  {"},
{"lineNum":"  517","line":"    const Index size = kernel.size();"},
{"lineNum":"  518","line":"    for(Index i = 0; i < size; ++i)","class":"lineNoCov","hits":"0","possible_hits":"327",},
{"lineNum":"  519","line":"      kernel.assignCoeff(i);"},
{"lineNum":"  520","line":"  }"},
{"lineNum":"  521","line":"};"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"template<typename Kernel>"},
{"lineNum":"  524","line":"struct dense_assignment_loop<Kernel, LinearTraversal, CompleteUnrolling>"},
{"lineNum":"  525","line":"{"},
{"lineNum":"  526","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  527","line":"  {"},
{"lineNum":"  528","line":"    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  529","line":"    copy_using_evaluator_LinearTraversal_CompleteUnrolling<Kernel, 0, DstXprType::SizeAtCompileTime>::run(kernel);"},
{"lineNum":"  530","line":"  }"},
{"lineNum":"  531","line":"};"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"/**************************"},
{"lineNum":"  534","line":"*** Slice vectorization ***"},
{"lineNum":"  535","line":"***************************/"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"template<typename Kernel>"},
{"lineNum":"  538","line":"struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, NoUnrolling>"},
{"lineNum":"  539","line":"{"},
{"lineNum":"  540","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  541","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  542","line":"    typedef typename Kernel::Scalar Scalar;"},
{"lineNum":"  543","line":"    typedef typename Kernel::PacketType PacketType;"},
{"lineNum":"  544","line":"    enum {"},
{"lineNum":"  545","line":"      packetSize = unpacket_traits<PacketType>::size,"},
{"lineNum":"  546","line":"      requestedAlignment = int(Kernel::AssignmentTraits::InnerRequiredAlignment),"},
{"lineNum":"  547","line":"      alignable = packet_traits<Scalar>::AlignedOnScalar || int(Kernel::AssignmentTraits::DstAlignment)>=sizeof(Scalar),"},
{"lineNum":"  548","line":"      dstIsAligned = int(Kernel::AssignmentTraits::DstAlignment)>=int(requestedAlignment),"},
{"lineNum":"  549","line":"      dstAlignment = alignable ? int(requestedAlignment)"},
{"lineNum":"  550","line":"                               : int(Kernel::AssignmentTraits::DstAlignment)"},
{"lineNum":"  551","line":"    };"},
{"lineNum":"  552","line":"    const Scalar *dst_ptr = kernel.dstDataPtr();"},
{"lineNum":"  553","line":"    if((!bool(dstIsAligned)) && (UIntPtr(dst_ptr) % sizeof(Scalar))>0)","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  554","line":"    {"},
{"lineNum":"  555","line":"      // the pointer is not aligned-on scalar, so alignment is not possible"},
{"lineNum":"  556","line":"      return dense_assignment_loop<Kernel,DefaultTraversal,NoUnrolling>::run(kernel);"},
{"lineNum":"  557","line":"    }"},
{"lineNum":"  558","line":"    const Index packetAlignedMask = packetSize - 1;"},
{"lineNum":"  559","line":"    const Index innerSize = kernel.innerSize();"},
{"lineNum":"  560","line":"    const Index outerSize = kernel.outerSize();"},
{"lineNum":"  561","line":"    const Index alignedStep = alignable ? (packetSize - kernel.outerStride() % packetSize) & packetAlignedMask : 0;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  562","line":"    Index alignedStart = ((!alignable) || bool(dstIsAligned)) ? 0 : internal::first_aligned<requestedAlignment>(dst_ptr, innerSize);"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"    for(Index outer = 0; outer < outerSize; ++outer)","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  565","line":"    {"},
{"lineNum":"  566","line":"      const Index alignedEnd = alignedStart + ((innerSize-alignedStart) & ~packetAlignedMask);","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  567","line":"      // do the non-vectorizable part of the assignment"},
{"lineNum":"  568","line":"      for(Index inner = 0; inner<alignedStart ; ++inner)","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  569","line":"        kernel.assignCoeffByOuterInner(outer, inner);"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"      // do the vectorizable part of the assignment"},
{"lineNum":"  572","line":"      for(Index inner = alignedStart; inner<alignedEnd; inner+=packetSize)","class":"lineNoCov","hits":"0","possible_hits":"28",},
{"lineNum":"  573","line":"        kernel.template assignPacketByOuterInner<dstAlignment, Unaligned, PacketType>(outer, inner);"},
{"lineNum":"  574","line":""},
{"lineNum":"  575","line":"      // do the non-vectorizable part of the assignment"},
{"lineNum":"  576","line":"      for(Index inner = alignedEnd; inner<innerSize ; ++inner)","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  577","line":"        kernel.assignCoeffByOuterInner(outer, inner);"},
{"lineNum":"  578","line":""},
{"lineNum":"  579","line":"      alignedStart = numext::mini((alignedStart+alignedStep)%packetSize, innerSize);","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  580","line":"    }"},
{"lineNum":"  581","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"28",},
{"lineNum":"  582","line":"};"},
{"lineNum":"  583","line":""},
{"lineNum":"  584","line":"#if EIGEN_UNALIGNED_VECTORIZE"},
{"lineNum":"  585","line":"template<typename Kernel>"},
{"lineNum":"  586","line":"struct dense_assignment_loop<Kernel, SliceVectorizedTraversal, InnerUnrolling>"},
{"lineNum":"  587","line":"{"},
{"lineNum":"  588","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE void run(Kernel &kernel)"},
{"lineNum":"  589","line":"  {"},
{"lineNum":"  590","line":"    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  591","line":"    typedef typename Kernel::PacketType PacketType;"},
{"lineNum":"  592","line":""},
{"lineNum":"  593","line":"    enum { innerSize = DstXprType::InnerSizeAtCompileTime,"},
{"lineNum":"  594","line":"           packetSize =unpacket_traits<PacketType>::size,"},
{"lineNum":"  595","line":"           vectorizableSize = (int(innerSize) / int(packetSize)) * int(packetSize),"},
{"lineNum":"  596","line":"           size = DstXprType::SizeAtCompileTime };"},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"    for(Index outer = 0; outer < kernel.outerSize(); ++outer)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  599","line":"    {"},
{"lineNum":"  600","line":"      copy_using_evaluator_innervec_InnerUnrolling<Kernel, 0, vectorizableSize, 0, 0>::run(kernel, outer);"},
{"lineNum":"  601","line":"      copy_using_evaluator_DefaultTraversal_InnerUnrolling<Kernel, vectorizableSize, innerSize>::run(kernel, outer);"},
{"lineNum":"  602","line":"    }"},
{"lineNum":"  603","line":"  }"},
{"lineNum":"  604","line":"};"},
{"lineNum":"  605","line":"#endif"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":""},
{"lineNum":"  608","line":"/***************************************************************************"},
{"lineNum":"  609","line":"* Part 4 : Generic dense assignment kernel"},
{"lineNum":"  610","line":"***************************************************************************/"},
{"lineNum":"  611","line":""},
{"lineNum":"  612","line":"// This class generalize the assignment of a coefficient (or packet) from one dense evaluator"},
{"lineNum":"  613","line":"// to another dense writable evaluator."},
{"lineNum":"  614","line":"// It is parametrized by the two evaluators, and the actual assignment functor."},
{"lineNum":"  615","line":"// This abstraction level permits to keep the evaluation loops as simple and as generic as possible."},
{"lineNum":"  616","line":"// One can customize the assignment using this generic dense_assignment_kernel with different"},
{"lineNum":"  617","line":"// functors, or by completely overloading it, by-passing a functor."},
{"lineNum":"  618","line":"template<typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT, typename Functor, int Version = Specialized>"},
{"lineNum":"  619","line":"class generic_dense_assignment_kernel"},
{"lineNum":"  620","line":"{"},
{"lineNum":"  621","line":"protected:"},
{"lineNum":"  622","line":"  typedef typename DstEvaluatorTypeT::XprType DstXprType;"},
{"lineNum":"  623","line":"  typedef typename SrcEvaluatorTypeT::XprType SrcXprType;"},
{"lineNum":"  624","line":"public:"},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"  typedef DstEvaluatorTypeT DstEvaluatorType;"},
{"lineNum":"  627","line":"  typedef SrcEvaluatorTypeT SrcEvaluatorType;"},
{"lineNum":"  628","line":"  typedef typename DstEvaluatorType::Scalar Scalar;"},
{"lineNum":"  629","line":"  typedef copy_using_evaluator_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor> AssignmentTraits;"},
{"lineNum":"  630","line":"  typedef typename AssignmentTraits::PacketType PacketType;"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  634","line":"  generic_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)"},
{"lineNum":"  635","line":"    : m_dst(dst), m_src(src), m_functor(func), m_dstExpr(dstExpr)","class":"lineNoCov","hits":"0","possible_hits":"28",},
{"lineNum":"  636","line":"  {"},
{"lineNum":"  637","line":"    #ifdef EIGEN_DEBUG_ASSIGN"},
{"lineNum":"  638","line":"    AssignmentTraits::debug();"},
{"lineNum":"  639","line":"    #endif"},
{"lineNum":"  640","line":"  }"},
{"lineNum":"  641","line":""},
{"lineNum":"  642","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index size() const EIGEN_NOEXCEPT { return m_dstExpr.size(); }"},
{"lineNum":"  643","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index innerSize() const EIGEN_NOEXCEPT { return m_dstExpr.innerSize(); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  644","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index outerSize() const EIGEN_NOEXCEPT { return m_dstExpr.outerSize(); }"},
{"lineNum":"  645","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_dstExpr.rows(); }"},
{"lineNum":"  646","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_dstExpr.cols(); }"},
{"lineNum":"  647","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index outerStride() const EIGEN_NOEXCEPT { return m_dstExpr.outerStride(); }"},
{"lineNum":"  648","line":""},
{"lineNum":"  649","line":"  EIGEN_DEVICE_FUNC DstEvaluatorType& dstEvaluator() EIGEN_NOEXCEPT { return m_dst; }"},
{"lineNum":"  650","line":"  EIGEN_DEVICE_FUNC const SrcEvaluatorType& srcEvaluator() const EIGEN_NOEXCEPT { return m_src; }"},
{"lineNum":"  651","line":""},
{"lineNum":"  652","line":"  /// Assign src(row,col) to dst(row,col) through the assignment functor."},
{"lineNum":"  653","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index row, Index col)"},
{"lineNum":"  654","line":"  {"},
{"lineNum":"  655","line":"    m_functor.assignCoeff(m_dst.coeffRef(row,col), m_src.coeff(row,col));"},
{"lineNum":"  656","line":"  }"},
{"lineNum":"  657","line":""},
{"lineNum":"  658","line":"  /// \\sa assignCoeff(Index,Index)"},
{"lineNum":"  659","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Index index)"},
{"lineNum":"  660","line":"  {"},
{"lineNum":"  661","line":"    m_functor.assignCoeff(m_dst.coeffRef(index), m_src.coeff(index));"},
{"lineNum":"  662","line":"  }"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"  /// \\sa assignCoeff(Index,Index)"},
{"lineNum":"  665","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeffByOuterInner(Index outer, Index inner)"},
{"lineNum":"  666","line":"  {"},
{"lineNum":"  667","line":"    Index row = rowIndexByOuterInner(outer, inner);"},
{"lineNum":"  668","line":"    Index col = colIndexByOuterInner(outer, inner);"},
{"lineNum":"  669","line":"    assignCoeff(row, col);"},
{"lineNum":"  670","line":"  }"},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"  template<int StoreMode, int LoadMode, typename PacketType>"},
{"lineNum":"  674","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index row, Index col)"},
{"lineNum":"  675","line":"  {"},
{"lineNum":"  676","line":"    m_functor.template assignPacket<StoreMode>(&m_dst.coeffRef(row,col), m_src.template packet<LoadMode,PacketType>(row,col));","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  677","line":"  }"},
{"lineNum":"  678","line":""},
{"lineNum":"  679","line":"  template<int StoreMode, int LoadMode, typename PacketType>"},
{"lineNum":"  680","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacket(Index index)"},
{"lineNum":"  681","line":"  {"},
{"lineNum":"  682","line":"    m_functor.template assignPacket<StoreMode>(&m_dst.coeffRef(index), m_src.template packet<LoadMode,PacketType>(index));"},
{"lineNum":"  683","line":"  }"},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"  template<int StoreMode, int LoadMode, typename PacketType>"},
{"lineNum":"  686","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignPacketByOuterInner(Index outer, Index inner)"},
{"lineNum":"  687","line":"  {"},
{"lineNum":"  688","line":"    Index row = rowIndexByOuterInner(outer, inner);"},
{"lineNum":"  689","line":"    Index col = colIndexByOuterInner(outer, inner);"},
{"lineNum":"  690","line":"    assignPacket<StoreMode,LoadMode,PacketType>(row, col);"},
{"lineNum":"  691","line":"  }"},
{"lineNum":"  692","line":""},
{"lineNum":"  693","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner)"},
{"lineNum":"  694","line":"  {"},
{"lineNum":"  695","line":"    typedef typename DstEvaluatorType::ExpressionTraits Traits;"},
{"lineNum":"  696","line":"    return int(Traits::RowsAtCompileTime) == 1 ? 0"},
{"lineNum":"  697","line":"      : int(Traits::ColsAtCompileTime) == 1 ? inner"},
{"lineNum":"  698","line":"      : int(DstEvaluatorType::Flags)&RowMajorBit ? outer"},
{"lineNum":"  699","line":"      : inner;"},
{"lineNum":"  700","line":"  }"},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner)"},
{"lineNum":"  703","line":"  {"},
{"lineNum":"  704","line":"    typedef typename DstEvaluatorType::ExpressionTraits Traits;"},
{"lineNum":"  705","line":"    return int(Traits::ColsAtCompileTime) == 1 ? 0"},
{"lineNum":"  706","line":"      : int(Traits::RowsAtCompileTime) == 1 ? inner"},
{"lineNum":"  707","line":"      : int(DstEvaluatorType::Flags)&RowMajorBit ? inner"},
{"lineNum":"  708","line":"      : outer;"},
{"lineNum":"  709","line":"  }"},
{"lineNum":"  710","line":""},
{"lineNum":"  711","line":"  EIGEN_DEVICE_FUNC const Scalar* dstDataPtr() const"},
{"lineNum":"  712","line":"  {"},
{"lineNum":"  713","line":"    return m_dstExpr.data();","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  714","line":"  }"},
{"lineNum":"  715","line":""},
{"lineNum":"  716","line":"protected:"},
{"lineNum":"  717","line":"  DstEvaluatorType& m_dst;"},
{"lineNum":"  718","line":"  const SrcEvaluatorType& m_src;"},
{"lineNum":"  719","line":"  const Functor &m_functor;"},
{"lineNum":"  720","line":"  // TODO find a way to avoid the needs of the original expression"},
{"lineNum":"  721","line":"  DstXprType& m_dstExpr;"},
{"lineNum":"  722","line":"};"},
{"lineNum":"  723","line":""},
{"lineNum":"  724","line":"// Special kernel used when computing small products whose operands have dynamic dimensions.  It ensures that the"},
{"lineNum":"  725","line":"// PacketSize used is no larger than 4, thereby increasing the chance that vectorized instructions will be used"},
{"lineNum":"  726","line":"// when computing the product."},
{"lineNum":"  727","line":""},
{"lineNum":"  728","line":"template<typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT, typename Functor>"},
{"lineNum":"  729","line":"class restricted_packet_dense_assignment_kernel : public generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, BuiltIn>"},
{"lineNum":"  730","line":"{"},
{"lineNum":"  731","line":"protected:"},
{"lineNum":"  732","line":"  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, BuiltIn> Base;"},
{"lineNum":"  733","line":" public:"},
{"lineNum":"  734","line":"    typedef typename Base::Scalar Scalar;"},
{"lineNum":"  735","line":"    typedef typename Base::DstXprType DstXprType;"},
{"lineNum":"  736","line":"    typedef copy_using_evaluator_traits<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, 4> AssignmentTraits;"},
{"lineNum":"  737","line":"    typedef typename AssignmentTraits::PacketType PacketType;"},
{"lineNum":"  738","line":""},
{"lineNum":"  739","line":"    EIGEN_DEVICE_FUNC restricted_packet_dense_assignment_kernel(DstEvaluatorTypeT &dst, const SrcEvaluatorTypeT &src, const Functor &func, DstXprType& dstExpr)"},
{"lineNum":"  740","line":"    : Base(dst, src, func, dstExpr)"},
{"lineNum":"  741","line":"  {"},
{"lineNum":"  742","line":"  }"},
{"lineNum":"  743","line":" };"},
{"lineNum":"  744","line":""},
{"lineNum":"  745","line":"/***************************************************************************"},
{"lineNum":"  746","line":"* Part 5 : Entry point for dense rectangular assignment"},
{"lineNum":"  747","line":"***************************************************************************/"},
{"lineNum":"  748","line":""},
{"lineNum":"  749","line":"template<typename DstXprType,typename SrcXprType, typename Functor>"},
{"lineNum":"  750","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  751","line":"void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const Functor &/*func*/)"},
{"lineNum":"  752","line":"{"},
{"lineNum":"  753","line":"  EIGEN_ONLY_USED_FOR_DEBUG(dst);"},
{"lineNum":"  754","line":"  EIGEN_ONLY_USED_FOR_DEBUG(src);"},
{"lineNum":"  755","line":"  eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());"},
{"lineNum":"  756","line":"}"},
{"lineNum":"  757","line":""},
{"lineNum":"  758","line":"template<typename DstXprType,typename SrcXprType, typename T1, typename T2>"},
{"lineNum":"  759","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  760","line":"void resize_if_allowed(DstXprType &dst, const SrcXprType& src, const internal::assign_op<T1,T2> &/*func*/)"},
{"lineNum":"  761","line":"{"},
{"lineNum":"  762","line":"  Index dstRows = src.rows();"},
{"lineNum":"  763","line":"  Index dstCols = src.cols();"},
{"lineNum":"  764","line":"  if(((dst.rows()!=dstRows) || (dst.cols()!=dstCols)))","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  765","line":"    dst.resize(dstRows, dstCols);","class":"lineNoCov","hits":"0","possible_hits":"32",},
{"lineNum":"  766","line":"  eigen_assert(dst.rows() == dstRows && dst.cols() == dstCols);"},
{"lineNum":"  767","line":"}"},
{"lineNum":"  768","line":""},
{"lineNum":"  769","line":"template<typename DstXprType, typename SrcXprType, typename Functor>"},
{"lineNum":"  770","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src, const Functor &func)"},
{"lineNum":"  771","line":"{","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  772","line":"  typedef evaluator<DstXprType> DstEvaluatorType;"},
{"lineNum":"  773","line":"  typedef evaluator<SrcXprType> SrcEvaluatorType;"},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":"  SrcEvaluatorType srcEvaluator(src);"},
{"lineNum":"  776","line":""},
{"lineNum":"  777","line":"  // NOTE To properly handle A = (A*A.transpose())/s with A rectangular,"},
{"lineNum":"  778","line":"  // we need to resize the destination after the source evaluator has been created."},
{"lineNum":"  779","line":"  resize_if_allowed(dst, src, func);"},
{"lineNum":"  780","line":""},
{"lineNum":"  781","line":"  DstEvaluatorType dstEvaluator(dst);"},
{"lineNum":"  782","line":""},
{"lineNum":"  783","line":"  typedef generic_dense_assignment_kernel<DstEvaluatorType,SrcEvaluatorType,Functor> Kernel;"},
{"lineNum":"  784","line":"  Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());"},
{"lineNum":"  785","line":""},
{"lineNum":"  786","line":"  dense_assignment_loop<Kernel>::run(kernel);","class":"lineNoCov","hits":"0","possible_hits":"22",},
{"lineNum":"  787","line":"}","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  788","line":""},
{"lineNum":"  789","line":"// Specialization for filling the destination with a constant value."},
{"lineNum":"  790","line":"#ifndef EIGEN_GPU_COMPILE_PHASE"},
{"lineNum":"  791","line":"template<typename DstXprType>"},
{"lineNum":"  792","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const Eigen::CwiseNullaryOp<Eigen::internal::scalar_constant_op<typename DstXprType::Scalar>, DstXprType>& src, const internal::assign_op<typename DstXprType::Scalar,typename DstXprType::Scalar>& func)"},
{"lineNum":"  793","line":"{"},
{"lineNum":"  794","line":"  resize_if_allowed(dst, src, func);"},
{"lineNum":"  795","line":"  std::fill_n(dst.data(), dst.size(), src.functor()());"},
{"lineNum":"  796","line":"}"},
{"lineNum":"  797","line":"#endif"},
{"lineNum":"  798","line":""},
{"lineNum":"  799","line":"template<typename DstXprType, typename SrcXprType>"},
{"lineNum":"  800","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void call_dense_assignment_loop(DstXprType& dst, const SrcXprType& src)"},
{"lineNum":"  801","line":"{"},
{"lineNum":"  802","line":"  call_dense_assignment_loop(dst, src, internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>());"},
{"lineNum":"  803","line":"}"},
{"lineNum":"  804","line":""},
{"lineNum":"  805","line":"/***************************************************************************"},
{"lineNum":"  806","line":"* Part 6 : Generic assignment"},
{"lineNum":"  807","line":"***************************************************************************/"},
{"lineNum":"  808","line":""},
{"lineNum":"  809","line":"// Based on the respective shapes of the destination and source,"},
{"lineNum":"  810","line":"// the class AssignmentKind determine the kind of assignment mechanism."},
{"lineNum":"  811","line":"// AssignmentKind must define a Kind typedef."},
{"lineNum":"  812","line":"template<typename DstShape, typename SrcShape> struct AssignmentKind;"},
{"lineNum":"  813","line":""},
{"lineNum":"  814","line":"// Assignment kind defined in this file:"},
{"lineNum":"  815","line":"struct Dense2Dense {};"},
{"lineNum":"  816","line":"struct EigenBase2EigenBase {};"},
{"lineNum":"  817","line":""},
{"lineNum":"  818","line":"template<typename,typename> struct AssignmentKind { typedef EigenBase2EigenBase Kind; };"},
{"lineNum":"  819","line":"template<> struct AssignmentKind<DenseShape,DenseShape> { typedef Dense2Dense Kind; };"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"// This is the main assignment class"},
{"lineNum":"  822","line":"template< typename DstXprType, typename SrcXprType, typename Functor,"},
{"lineNum":"  823","line":"          typename Kind = typename AssignmentKind< typename evaluator_traits<DstXprType>::Shape , typename evaluator_traits<SrcXprType>::Shape >::Kind,"},
{"lineNum":"  824","line":"          typename EnableIf = void>"},
{"lineNum":"  825","line":"struct Assignment;"},
{"lineNum":"  826","line":""},
{"lineNum":"  827","line":""},
{"lineNum":"  828","line":"// The only purpose of this call_assignment() function is to deal with noalias() / \"assume-aliasing\" and automatic transposition."},
{"lineNum":"  829","line":"// Indeed, I (Gael) think that this concept of \"assume-aliasing\" was a mistake, and it makes thing quite complicated."},
{"lineNum":"  830","line":"// So this intermediate function removes everything related to \"assume-aliasing\" such that Assignment"},
{"lineNum":"  831","line":"// does not has to bother about these annoying details."},
{"lineNum":"  832","line":""},
{"lineNum":"  833","line":"template<typename Dst, typename Src>"},
{"lineNum":"  834","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  835","line":"void call_assignment(Dst& dst, const Src& src)"},
{"lineNum":"  836","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  837","line":"  call_assignment(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  838","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  839","line":"template<typename Dst, typename Src>"},
{"lineNum":"  840","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  841","line":"void call_assignment(const Dst& dst, const Src& src)"},
{"lineNum":"  842","line":"{"},
{"lineNum":"  843","line":"  call_assignment(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());"},
{"lineNum":"  844","line":"}"},
{"lineNum":"  845","line":""},
{"lineNum":"  846","line":"// Deal with \"assume-aliasing\""},
{"lineNum":"  847","line":"template<typename Dst, typename Src, typename Func>"},
{"lineNum":"  848","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  849","line":"void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if< evaluator_assume_aliasing<Src>::value, void*>::type = 0)"},
{"lineNum":"  850","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  851","line":"  typename plain_matrix_type<Src>::type tmp(src);"},
{"lineNum":"  852","line":"  call_assignment_no_alias(dst, tmp, func);"},
{"lineNum":"  853","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  854","line":""},
{"lineNum":"  855","line":"template<typename Dst, typename Src, typename Func>"},
{"lineNum":"  856","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  857","line":"void call_assignment(Dst& dst, const Src& src, const Func& func, typename enable_if<!evaluator_assume_aliasing<Src>::value, void*>::type = 0)"},
{"lineNum":"  858","line":"{"},
{"lineNum":"  859","line":"  call_assignment_no_alias(dst, src, func);"},
{"lineNum":"  860","line":"}"},
{"lineNum":"  861","line":""},
{"lineNum":"  862","line":"// by-pass \"assume-aliasing\""},
{"lineNum":"  863","line":"// When there is no aliasing, we require that \'dst\' has been properly resized"},
{"lineNum":"  864","line":"template<typename Dst, template <typename> class StorageBase, typename Src, typename Func>"},
{"lineNum":"  865","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  866","line":"void call_assignment(NoAlias<Dst,StorageBase>& dst, const Src& src, const Func& func)"},
{"lineNum":"  867","line":"{"},
{"lineNum":"  868","line":"  call_assignment_no_alias(dst.expression(), src, func);"},
{"lineNum":"  869","line":"}"},
{"lineNum":"  870","line":""},
{"lineNum":"  871","line":""},
{"lineNum":"  872","line":"template<typename Dst, typename Src, typename Func>"},
{"lineNum":"  873","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  874","line":"void call_assignment_no_alias(Dst& dst, const Src& src, const Func& func)"},
{"lineNum":"  875","line":"{"},
{"lineNum":"  876","line":"  enum {"},
{"lineNum":"  877","line":"    NeedToTranspose = (    (int(Dst::RowsAtCompileTime) == 1 && int(Src::ColsAtCompileTime) == 1)"},
{"lineNum":"  878","line":"                        || (int(Dst::ColsAtCompileTime) == 1 && int(Src::RowsAtCompileTime) == 1)"},
{"lineNum":"  879","line":"                      ) && int(Dst::SizeAtCompileTime) != 1"},
{"lineNum":"  880","line":"  };"},
{"lineNum":"  881","line":""},
{"lineNum":"  882","line":"  typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst>::type ActualDstTypeCleaned;"},
{"lineNum":"  883","line":"  typedef typename internal::conditional<NeedToTranspose, Transpose<Dst>, Dst&>::type ActualDstType;"},
{"lineNum":"  884","line":"  ActualDstType actualDst(dst);"},
{"lineNum":"  885","line":""},
{"lineNum":"  886","line":"  // TODO check whether this is the right place to perform these checks:"},
{"lineNum":"  887","line":"  EIGEN_STATIC_ASSERT_LVALUE(Dst)"},
{"lineNum":"  888","line":"  EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(ActualDstTypeCleaned,Src)"},
{"lineNum":"  889","line":"  EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename ActualDstTypeCleaned::Scalar,typename Src::Scalar);"},
{"lineNum":"  890","line":""},
{"lineNum":"  891","line":"  Assignment<ActualDstTypeCleaned,Src,Func>::run(actualDst, src, func);","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  892","line":"}"},
{"lineNum":"  893","line":""},
{"lineNum":"  894","line":"template<typename Dst, typename Src, typename Func>"},
{"lineNum":"  895","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  896","line":"void call_restricted_packet_assignment_no_alias(Dst& dst, const Src& src, const Func& func)"},
{"lineNum":"  897","line":"{","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  898","line":"    typedef evaluator<Dst> DstEvaluatorType;"},
{"lineNum":"  899","line":"    typedef evaluator<Src> SrcEvaluatorType;"},
{"lineNum":"  900","line":"    typedef restricted_packet_dense_assignment_kernel<DstEvaluatorType,SrcEvaluatorType,Func> Kernel;"},
{"lineNum":"  901","line":""},
{"lineNum":"  902","line":"    EIGEN_STATIC_ASSERT_LVALUE(Dst)"},
{"lineNum":"  903","line":"    EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename Dst::Scalar,typename Src::Scalar);"},
{"lineNum":"  904","line":""},
{"lineNum":"  905","line":"    SrcEvaluatorType srcEvaluator(src);"},
{"lineNum":"  906","line":"    resize_if_allowed(dst, src, func);"},
{"lineNum":"  907","line":""},
{"lineNum":"  908","line":"    DstEvaluatorType dstEvaluator(dst);"},
{"lineNum":"  909","line":"    Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());"},
{"lineNum":"  910","line":""},
{"lineNum":"  911","line":"    dense_assignment_loop<Kernel>::run(kernel);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  912","line":"}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  913","line":""},
{"lineNum":"  914","line":"template<typename Dst, typename Src>"},
{"lineNum":"  915","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  916","line":"void call_assignment_no_alias(Dst& dst, const Src& src)"},
{"lineNum":"  917","line":"{"},
{"lineNum":"  918","line":"  call_assignment_no_alias(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());"},
{"lineNum":"  919","line":"}"},
{"lineNum":"  920","line":""},
{"lineNum":"  921","line":"template<typename Dst, typename Src, typename Func>"},
{"lineNum":"  922","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  923","line":"void call_assignment_no_alias_no_transpose(Dst& dst, const Src& src, const Func& func)"},
{"lineNum":"  924","line":"{"},
{"lineNum":"  925","line":"  // TODO check whether this is the right place to perform these checks:"},
{"lineNum":"  926","line":"  EIGEN_STATIC_ASSERT_LVALUE(Dst)"},
{"lineNum":"  927","line":"  EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(Dst,Src)"},
{"lineNum":"  928","line":"  EIGEN_CHECK_BINARY_COMPATIBILIY(Func,typename Dst::Scalar,typename Src::Scalar);"},
{"lineNum":"  929","line":""},
{"lineNum":"  930","line":"  Assignment<Dst,Src,Func>::run(dst, src, func);"},
{"lineNum":"  931","line":"}"},
{"lineNum":"  932","line":"template<typename Dst, typename Src>"},
{"lineNum":"  933","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  934","line":"void call_assignment_no_alias_no_transpose(Dst& dst, const Src& src)"},
{"lineNum":"  935","line":"{"},
{"lineNum":"  936","line":"  call_assignment_no_alias_no_transpose(dst, src, internal::assign_op<typename Dst::Scalar,typename Src::Scalar>());"},
{"lineNum":"  937","line":"}"},
{"lineNum":"  938","line":""},
{"lineNum":"  939","line":"// forward declaration"},
{"lineNum":"  940","line":"template<typename Dst, typename Src> void check_for_aliasing(const Dst &dst, const Src &src);"},
{"lineNum":"  941","line":""},
{"lineNum":"  942","line":"// Generic Dense to Dense assignment"},
{"lineNum":"  943","line":"// Note that the last template argument \"Weak\" is needed to make it possible to perform"},
{"lineNum":"  944","line":"// both partial specialization+SFINAE without ambiguous specialization"},
{"lineNum":"  945","line":"template< typename DstXprType, typename SrcXprType, typename Functor, typename Weak>"},
{"lineNum":"  946","line":"struct Assignment<DstXprType, SrcXprType, Functor, Dense2Dense, Weak>"},
{"lineNum":"  947","line":"{"},
{"lineNum":"  948","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  949","line":"  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const Functor &func)"},
{"lineNum":"  950","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  951","line":"#ifndef EIGEN_NO_DEBUG"},
{"lineNum":"  952","line":"    internal::check_for_aliasing(dst, src);"},
{"lineNum":"  953","line":"#endif"},
{"lineNum":"  954","line":""},
{"lineNum":"  955","line":"    call_dense_assignment_loop(dst, src, func);","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  956","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  957","line":"};"},
{"lineNum":"  958","line":""},
{"lineNum":"  959","line":"// Generic assignment through evalTo."},
{"lineNum":"  960","line":"// TODO: not sure we have to keep that one, but it helps porting current code to new evaluator mechanism."},
{"lineNum":"  961","line":"// Note that the last template argument \"Weak\" is needed to make it possible to perform"},
{"lineNum":"  962","line":"// both partial specialization+SFINAE without ambiguous specialization"},
{"lineNum":"  963","line":"template< typename DstXprType, typename SrcXprType, typename Functor, typename Weak>"},
{"lineNum":"  964","line":"struct Assignment<DstXprType, SrcXprType, Functor, EigenBase2EigenBase, Weak>"},
{"lineNum":"  965","line":"{"},
{"lineNum":"  966","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  967","line":"  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar> &/*func*/)"},
{"lineNum":"  968","line":"  {"},
{"lineNum":"  969","line":"    Index dstRows = src.rows();"},
{"lineNum":"  970","line":"    Index dstCols = src.cols();"},
{"lineNum":"  971","line":"    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))"},
{"lineNum":"  972","line":"      dst.resize(dstRows, dstCols);"},
{"lineNum":"  973","line":""},
{"lineNum":"  974","line":"    eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());"},
{"lineNum":"  975","line":"    src.evalTo(dst);"},
{"lineNum":"  976","line":"  }"},
{"lineNum":"  977","line":""},
{"lineNum":"  978","line":"  // NOTE The following two functions are templated to avoid their instantiation if not needed"},
{"lineNum":"  979","line":"  //      This is needed because some expressions supports evalTo only and/or have \'void\' as scalar type."},
{"lineNum":"  980","line":"  template<typename SrcScalarType>"},
{"lineNum":"  981","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  982","line":"  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<typename DstXprType::Scalar,SrcScalarType> &/*func*/)"},
{"lineNum":"  983","line":"  {"},
{"lineNum":"  984","line":"    Index dstRows = src.rows();"},
{"lineNum":"  985","line":"    Index dstCols = src.cols();"},
{"lineNum":"  986","line":"    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))"},
{"lineNum":"  987","line":"      dst.resize(dstRows, dstCols);"},
{"lineNum":"  988","line":""},
{"lineNum":"  989","line":"    eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());"},
{"lineNum":"  990","line":"    src.addTo(dst);"},
{"lineNum":"  991","line":"  }"},
{"lineNum":"  992","line":""},
{"lineNum":"  993","line":"  template<typename SrcScalarType>"},
{"lineNum":"  994","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  995","line":"  static EIGEN_STRONG_INLINE void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<typename DstXprType::Scalar,SrcScalarType> &/*func*/)"},
{"lineNum":"  996","line":"  {"},
{"lineNum":"  997","line":"    Index dstRows = src.rows();"},
{"lineNum":"  998","line":"    Index dstCols = src.cols();"},
{"lineNum":"  999","line":"    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))"},
{"lineNum":" 1000","line":"      dst.resize(dstRows, dstCols);"},
{"lineNum":" 1001","line":""},
{"lineNum":" 1002","line":"    eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());"},
{"lineNum":" 1003","line":"    src.subTo(dst);"},
{"lineNum":" 1004","line":"  }"},
{"lineNum":" 1005","line":"};"},
{"lineNum":" 1006","line":""},
{"lineNum":" 1007","line":"} // namespace internal"},
{"lineNum":" 1008","line":""},
{"lineNum":" 1009","line":"} // end namespace Eigen"},
{"lineNum":" 1010","line":""},
{"lineNum":" 1011","line":"#endif // EIGEN_ASSIGN_EVALUATOR_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 42, "covered" : 0,};
var merged_data = [];
