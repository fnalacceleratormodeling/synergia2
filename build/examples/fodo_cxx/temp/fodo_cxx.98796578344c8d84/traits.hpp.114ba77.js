var data = {lines:[
{"lineNum":"    1","line":"/*! \\file traits.hpp"},
{"lineNum":"    2","line":"    \\brief Internal type trait support"},
{"lineNum":"    3","line":"    \\ingroup Internal */"},
{"lineNum":"    4","line":"/*"},
{"lineNum":"    5","line":"  Copyright (c) 2014, Randolph Voorhies, Shane Grant"},
{"lineNum":"    6","line":"  All rights reserved."},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"  Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    9","line":"  modification, are permitted provided that the following conditions are met:"},
{"lineNum":"   10","line":"      * Redistributions of source code must retain the above copyright"},
{"lineNum":"   11","line":"        notice, this list of conditions and the following disclaimer."},
{"lineNum":"   12","line":"      * Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   13","line":"        notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   14","line":"        documentation and/or other materials provided with the distribution."},
{"lineNum":"   15","line":"      * Neither the name of cereal nor the"},
{"lineNum":"   16","line":"        names of its contributors may be used to endorse or promote products"},
{"lineNum":"   17","line":"        derived from this software without specific prior written permission."},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"},
{"lineNum":"   20","line":"  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"},
{"lineNum":"   21","line":"  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"},
{"lineNum":"   22","line":"  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES OR SHANE GRANT BE LIABLE FOR ANY"},
{"lineNum":"   23","line":"  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"},
{"lineNum":"   24","line":"  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"},
{"lineNum":"   25","line":"  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"},
{"lineNum":"   26","line":"  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   27","line":"  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   28","line":"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   29","line":"*/"},
{"lineNum":"   30","line":"#ifndef CEREAL_DETAILS_TRAITS_HPP_"},
{"lineNum":"   31","line":"#define CEREAL_DETAILS_TRAITS_HPP_"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"#ifndef __clang__"},
{"lineNum":"   34","line":"#if (__GNUC__ == 4 && __GNUC_MINOR__ <= 7)"},
{"lineNum":"   35","line":"#define CEREAL_OLDER_GCC"},
{"lineNum":"   36","line":"#endif // gcc 4.7 or earlier"},
{"lineNum":"   37","line":"#endif // __clang__"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"#include <type_traits>"},
{"lineNum":"   40","line":"#include <typeindex>"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"#include \"cereal/macros.hpp\""},
{"lineNum":"   43","line":"#include \"cereal/access.hpp\""},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"namespace cereal"},
{"lineNum":"   46","line":"{"},
{"lineNum":"   47","line":"  namespace traits"},
{"lineNum":"   48","line":"  {"},
{"lineNum":"   49","line":"    using yes = std::true_type;"},
{"lineNum":"   50","line":"    using no  = std::false_type;"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"    namespace detail"},
{"lineNum":"   53","line":"    {"},
{"lineNum":"   54","line":"      // ######################################################################"},
{"lineNum":"   55","line":"      //! Used to delay a static_assert until template instantiation"},
{"lineNum":"   56","line":"      template <class T>"},
{"lineNum":"   57","line":"      struct delay_static_assert : std::false_type {};"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"      // ######################################################################"},
{"lineNum":"   60","line":"      // SFINAE Helpers"},
{"lineNum":"   61","line":"      #ifdef CEREAL_OLDER_GCC // when VS supports better SFINAE, we can use this as the default"},
{"lineNum":"   62","line":"      template<typename> struct Void { typedef void type; };"},
{"lineNum":"   63","line":"      #endif // CEREAL_OLDER_GCC"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"      //! Return type for SFINAE Enablers"},
{"lineNum":"   66","line":"      enum class sfinae {};"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"      // ######################################################################"},
{"lineNum":"   69","line":"      // Helper functionality for boolean integral constants and Enable/DisableIf"},
{"lineNum":"   70","line":"      template <bool H, bool ... T> struct meta_bool_and : std::integral_constant<bool, H && meta_bool_and<T...>::value> {};"},
{"lineNum":"   71","line":"      template <bool B> struct meta_bool_and<B> : std::integral_constant<bool, B> {};"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"      template <bool H, bool ... T> struct meta_bool_or : std::integral_constant<bool, H || meta_bool_or<T...>::value> {};"},
{"lineNum":"   74","line":"      template <bool B> struct meta_bool_or<B> : std::integral_constant<bool, B> {};"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"      // workaround needed due to bug in MSVC 2013, see"},
{"lineNum":"   77","line":"      // http://connect.microsoft.com/VisualStudio/feedback/details/800231/c-11-alias-template-issue"},
{"lineNum":"   78","line":"      template <bool ... Conditions>"},
{"lineNum":"   79","line":"      struct EnableIfHelper : std::enable_if<meta_bool_and<Conditions...>::value, sfinae> {};"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"      template <bool ... Conditions>"},
{"lineNum":"   82","line":"      struct DisableIfHelper : std::enable_if<!meta_bool_or<Conditions...>::value, sfinae> {};"},
{"lineNum":"   83","line":"    } // namespace detail"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"    //! Used as the default value for EnableIf and DisableIf template parameters"},
{"lineNum":"   86","line":"    /*! @relates EnableIf"},
{"lineNum":"   87","line":"        @relates DisableIf */"},
{"lineNum":"   88","line":"    static const detail::sfinae sfinae = {};"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"    // ######################################################################"},
{"lineNum":"   91","line":"    //! Provides a way to enable a function if conditions are met"},
{"lineNum":"   92","line":"    /*! This is intended to be used in a near identical fashion to std::enable_if"},
{"lineNum":"   93","line":"        while being significantly easier to read at the cost of not allowing for as"},
{"lineNum":"   94","line":"        complicated of a condition."},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"        This will compile (allow the function) if every condition evaluates to true."},
{"lineNum":"   97","line":"        at compile time.  This should be used with SFINAE to ensure that at least"},
{"lineNum":"   98","line":"        one other candidate function works when one fails due to an EnableIf."},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"        This should be used as the las template parameter to a function as"},
{"lineNum":"  101","line":"        an unnamed parameter with a default value of cereal::traits::sfinae:"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"        @code{cpp}"},
{"lineNum":"  104","line":"        // using by making the last template argument variadic"},
{"lineNum":"  105","line":"        template <class T, EnableIf<std::is_same<T, bool>::value> = sfinae>"},
{"lineNum":"  106","line":"        void func(T t );"},
{"lineNum":"  107","line":"        @endcode"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"        Note that this performs a logical AND of all conditions, so you will need"},
{"lineNum":"  110","line":"        to construct more complicated requirements with this fact in mind."},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"        @relates DisableIf"},
{"lineNum":"  113","line":"        @relates sfinae"},
{"lineNum":"  114","line":"        @tparam Conditions The conditions which will be logically ANDed to enable the function. */"},
{"lineNum":"  115","line":"    template <bool ... Conditions>"},
{"lineNum":"  116","line":"    using EnableIf = typename detail::EnableIfHelper<Conditions...>::type;"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"    // ######################################################################"},
{"lineNum":"  119","line":"    //! Provides a way to disable a function if conditions are met"},
{"lineNum":"  120","line":"    /*! This is intended to be used in a near identical fashion to std::enable_if"},
{"lineNum":"  121","line":"        while being significantly easier to read at the cost of not allowing for as"},
{"lineNum":"  122","line":"        complicated of a condition."},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"        This will compile (allow the function) if every condition evaluates to false."},
{"lineNum":"  125","line":"        This should be used with SFINAE to ensure that at least one other candidate"},
{"lineNum":"  126","line":"        function works when one fails due to a DisableIf."},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"        This should be used as the las template parameter to a function as"},
{"lineNum":"  129","line":"        an unnamed parameter with a default value of cereal::traits::sfinae:"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"        @code{cpp}"},
{"lineNum":"  132","line":"        // using by making the last template argument variadic"},
{"lineNum":"  133","line":"        template <class T, DisableIf<std::is_same<T, bool>::value> = sfinae>"},
{"lineNum":"  134","line":"        void func(T t );"},
{"lineNum":"  135","line":"        @endcode"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"        This is often used in conjunction with EnableIf to form an enable/disable pair of"},
{"lineNum":"  138","line":"        overloads."},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"        Note that this performs a logical AND of all conditions, so you will need"},
{"lineNum":"  141","line":"        to construct more complicated requirements with this fact in mind.  If all conditions"},
{"lineNum":"  142","line":"        hold, the function will be disabled."},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"        @relates EnableIf"},
{"lineNum":"  145","line":"        @relates sfinae"},
{"lineNum":"  146","line":"        @tparam Conditions The conditions which will be logically ANDed to disable the function. */"},
{"lineNum":"  147","line":"    template <bool ... Conditions>"},
{"lineNum":"  148","line":"    using DisableIf = typename detail::DisableIfHelper<Conditions...>::type;"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"    // ######################################################################"},
{"lineNum":"  151","line":"    namespace detail"},
{"lineNum":"  152","line":"    {"},
{"lineNum":"  153","line":"      template <class InputArchive>"},
{"lineNum":"  154","line":"      struct get_output_from_input : no"},
{"lineNum":"  155","line":"      {"},
{"lineNum":"  156","line":"        static_assert( detail::delay_static_assert<InputArchive>::value,"},
{"lineNum":"  157","line":"            \"Could not find an associated output archive for input archive.\" );"},
{"lineNum":"  158","line":"      };"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"      template <class OutputArchive>"},
{"lineNum":"  161","line":"      struct get_input_from_output : no"},
{"lineNum":"  162","line":"      {"},
{"lineNum":"  163","line":"        static_assert( detail::delay_static_assert<OutputArchive>::value,"},
{"lineNum":"  164","line":"            \"Could not find an associated input archive for output archive.\" );"},
{"lineNum":"  165","line":"      };"},
{"lineNum":"  166","line":"    }"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"    //! Sets up traits that relate an input archive to an output archive"},
{"lineNum":"  169","line":"    #define CEREAL_SETUP_ARCHIVE_TRAITS(InputArchive, OutputArchive)  \\"},
{"lineNum":"  170","line":"    namespace cereal { namespace traits { namespace detail {          \\"},
{"lineNum":"  171","line":"      template <> struct get_output_from_input<InputArchive>          \\"},
{"lineNum":"  172","line":"      { using type = OutputArchive; };                                \\"},
{"lineNum":"  173","line":"      template <> struct get_input_from_output<OutputArchive>         \\"},
{"lineNum":"  174","line":"      { using type = InputArchive; }; } } } /* end namespaces */"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    // ######################################################################"},
{"lineNum":"  177","line":"    //! Used to convert a MAKE_HAS_XXX macro into a versioned variant"},
{"lineNum":"  178","line":"    #define CEREAL_MAKE_VERSIONED_TEST ,0"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"    // ######################################################################"},
{"lineNum":"  181","line":"    //! Creates a test for whether a non const member function exists"},
{"lineNum":"  182","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  183","line":"        the type has the proper member function for the given archive."},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"        @param name The name of the function to test for (e.g. serialize, load, save)"},
{"lineNum":"  186","line":"        @param test_name The name to give the test for the function being tested for (e.g. serialize, versioned_serialize)"},
{"lineNum":"  187","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  188","line":"    #ifdef CEREAL_OLDER_GCC"},
{"lineNum":"  189","line":"    #define CEREAL_MAKE_HAS_MEMBER_TEST(name, test_name, versioned)                                                                         \\"},
{"lineNum":"  190","line":"    template <class T, class A, class SFINAE = void>                                                                                        \\"},
{"lineNum":"  191","line":"    struct has_member_##test_name : no {};                                                                                                  \\"},
{"lineNum":"  192","line":"    template <class T, class A>                                                                                                             \\"},
{"lineNum":"  193","line":"    struct has_member_##test_name<T, A,                                                                                                     \\"},
{"lineNum":"  194","line":"      typename detail::Void< decltype( cereal::access::member_##name( std::declval<A&>(), std::declval<T&>() versioned ) ) >::type> : yes {}"},
{"lineNum":"  195","line":"    #else // NOT CEREAL_OLDER_GCC"},
{"lineNum":"  196","line":"    #define CEREAL_MAKE_HAS_MEMBER_TEST(name, test_name, versioned)                                                                     \\"},
{"lineNum":"  197","line":"    namespace detail                                                                                                                    \\"},
{"lineNum":"  198","line":"    {                                                                                                                                   \\"},
{"lineNum":"  199","line":"      template <class T, class A>                                                                                                       \\"},
{"lineNum":"  200","line":"      struct has_member_##name##_##versioned##_impl                                                                                     \\"},
{"lineNum":"  201","line":"      {                                                                                                                                 \\"},
{"lineNum":"  202","line":"        template <class TT, class AA>                                                                                                   \\"},
{"lineNum":"  203","line":"        static auto test(int) -> decltype( cereal::access::member_##name( std::declval<AA&>(), std::declval<TT&>() versioned ), yes()); \\"},
{"lineNum":"  204","line":"        template <class, class>                                                                                                         \\"},
{"lineNum":"  205","line":"        static no test(...);                                                                                                            \\"},
{"lineNum":"  206","line":"        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;                                                    \\"},
{"lineNum":"  207","line":"      };                                                                                                                                \\"},
{"lineNum":"  208","line":"    } /* end namespace detail */                                                                                                        \\"},
{"lineNum":"  209","line":"    template <class T, class A>                                                                                                         \\"},
{"lineNum":"  210","line":"    struct has_member_##test_name : std::integral_constant<bool, detail::has_member_##name##_##versioned##_impl<T, A>::value> {}"},
{"lineNum":"  211","line":"    #endif // NOT CEREAL_OLDER_GCC"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    // ######################################################################"},
{"lineNum":"  214","line":"    //! Creates a test for whether a non const non-member function exists"},
{"lineNum":"  215","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  216","line":"        the type has the proper non-member function for the given archive. */"},
{"lineNum":"  217","line":"    #define CEREAL_MAKE_HAS_NON_MEMBER_TEST(test_name, func, versioned)                                                         \\"},
{"lineNum":"  218","line":"    namespace detail                                                                                                            \\"},
{"lineNum":"  219","line":"    {                                                                                                                           \\"},
{"lineNum":"  220","line":"      template <class T, class A>                                                                                               \\"},
{"lineNum":"  221","line":"      struct has_non_member_##test_name##_impl                                                                                  \\"},
{"lineNum":"  222","line":"      {                                                                                                                         \\"},
{"lineNum":"  223","line":"        template <class TT, class AA>                                                                                           \\"},
{"lineNum":"  224","line":"        static auto test(int) -> decltype( func( std::declval<AA&>(), std::declval<TT&>() versioned ), yes());                  \\"},
{"lineNum":"  225","line":"        template <class, class>                                                                                                 \\"},
{"lineNum":"  226","line":"        static no test( ... );                                                                                                  \\"},
{"lineNum":"  227","line":"        static const bool value = std::is_same<decltype( test<T, A>( 0 ) ), yes>::value;                                        \\"},
{"lineNum":"  228","line":"      };                                                                                                                        \\"},
{"lineNum":"  229","line":"    } /* end namespace detail */                                                                                                \\"},
{"lineNum":"  230","line":"    template <class T, class A>                                                                                                 \\"},
{"lineNum":"  231","line":"    struct has_non_member_##test_name : std::integral_constant<bool, detail::has_non_member_##test_name##_impl<T, A>::value> {}"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"    // ######################################################################"},
{"lineNum":"  234","line":"    // Member Serialize"},
{"lineNum":"  235","line":"    CEREAL_MAKE_HAS_MEMBER_TEST(serialize, serialize,);"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"    // ######################################################################"},
{"lineNum":"  238","line":"    // Member Serialize (versioned)"},
{"lineNum":"  239","line":"    CEREAL_MAKE_HAS_MEMBER_TEST(serialize, versioned_serialize, CEREAL_MAKE_VERSIONED_TEST);"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"    // ######################################################################"},
{"lineNum":"  242","line":"    // Non Member Serialize"},
{"lineNum":"  243","line":"    CEREAL_MAKE_HAS_NON_MEMBER_TEST(serialize, CEREAL_SERIALIZE_FUNCTION_NAME,);"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"    // ######################################################################"},
{"lineNum":"  246","line":"    // Non Member Serialize (versioned)"},
{"lineNum":"  247","line":"    CEREAL_MAKE_HAS_NON_MEMBER_TEST(versioned_serialize, CEREAL_SERIALIZE_FUNCTION_NAME, CEREAL_MAKE_VERSIONED_TEST);"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"    // ######################################################################"},
{"lineNum":"  250","line":"    // Member Load"},
{"lineNum":"  251","line":"    CEREAL_MAKE_HAS_MEMBER_TEST(load, load,);"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"    // ######################################################################"},
{"lineNum":"  254","line":"    // Member Load (versioned)"},
{"lineNum":"  255","line":"    CEREAL_MAKE_HAS_MEMBER_TEST(load, versioned_load, CEREAL_MAKE_VERSIONED_TEST);"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"    // ######################################################################"},
{"lineNum":"  258","line":"    // Non Member Load"},
{"lineNum":"  259","line":"    CEREAL_MAKE_HAS_NON_MEMBER_TEST(load, CEREAL_LOAD_FUNCTION_NAME,);"},
{"lineNum":"  260","line":""},
{"lineNum":"  261","line":"    // ######################################################################"},
{"lineNum":"  262","line":"    // Non Member Load (versioned)"},
{"lineNum":"  263","line":"    CEREAL_MAKE_HAS_NON_MEMBER_TEST(versioned_load, CEREAL_LOAD_FUNCTION_NAME, CEREAL_MAKE_VERSIONED_TEST);"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"    // ######################################################################"},
{"lineNum":"  266","line":"    #undef CEREAL_MAKE_HAS_NON_MEMBER_TEST"},
{"lineNum":"  267","line":"    #undef CEREAL_MAKE_HAS_MEMBER_TEST"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"    // ######################################################################"},
{"lineNum":"  270","line":"    //! Creates a test for whether a member save function exists"},
{"lineNum":"  271","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  272","line":"        the type has the proper member function for the given archive."},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"        @param test_name The name to give the test (e.g. save or versioned_save)"},
{"lineNum":"  275","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  276","line":"    #ifdef CEREAL_OLDER_GCC"},
{"lineNum":"  277","line":"    #define CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL(test_name, versioned)                                                                  \\"},
{"lineNum":"  278","line":"    namespace detail                                                                                                                \\"},
{"lineNum":"  279","line":"    {                                                                                                                               \\"},
{"lineNum":"  280","line":"    template <class T, class A>                                                                                                     \\"},
{"lineNum":"  281","line":"    struct has_member_##test_name##_impl                                                                                            \\"},
{"lineNum":"  282","line":"      {                                                                                                                             \\"},
{"lineNum":"  283","line":"        template <class TT, class AA, class SFINAE = void> struct test : no {};                                                     \\"},
{"lineNum":"  284","line":"        template <class TT, class AA>                                                                                               \\"},
{"lineNum":"  285","line":"        struct test<TT, AA,                                                                                                         \\"},
{"lineNum":"  286","line":"          typename detail::Void< decltype( cereal::access::member_save( std::declval<AA&>(),                                        \\"},
{"lineNum":"  287","line":"                                                                        std::declval<TT const &>() versioned ) ) >::type> : yes {}; \\"},
{"lineNum":"  288","line":"        static const bool value = test<T, A>();                                                                                     \\"},
{"lineNum":"  289","line":"                                                                                                                                    \\"},
{"lineNum":"  290","line":"        template <class TT, class AA, class SFINAE = void> struct test2 : no {};                                                    \\"},
{"lineNum":"  291","line":"        template <class TT, class AA>                                                                                               \\"},
{"lineNum":"  292","line":"        struct test2<TT, AA,                                                                                                        \\"},
{"lineNum":"  293","line":"          typename detail::Void< decltype( cereal::access::member_save_non_const(                                                   \\"},
{"lineNum":"  294","line":"                                            std::declval<AA&>(),                                                                    \\"},
{"lineNum":"  295","line":"                                            std::declval<typename std::remove_const<TT>::type&>() versioned ) ) >::type> : yes {};  \\"},
{"lineNum":"  296","line":"        static const bool not_const_type = test2<T, A>();                                                                           \\"},
{"lineNum":"  297","line":"      };                                                                                                                            \\"},
{"lineNum":"  298","line":"    } /* end namespace detail */"},
{"lineNum":"  299","line":"    #else /* NOT CEREAL_OLDER_GCC =================================== */"},
{"lineNum":"  300","line":"    #define CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL(test_name, versioned)                                                                  \\"},
{"lineNum":"  301","line":"    namespace detail                                                                                                                \\"},
{"lineNum":"  302","line":"    {                                                                                                                               \\"},
{"lineNum":"  303","line":"    template <class T, class A>                                                                                                     \\"},
{"lineNum":"  304","line":"    struct has_member_##test_name##_impl                                                                                            \\"},
{"lineNum":"  305","line":"      {                                                                                                                             \\"},
{"lineNum":"  306","line":"        template <class TT, class AA>                                                                                               \\"},
{"lineNum":"  307","line":"        static auto test(int) -> decltype( cereal::access::member_save( std::declval<AA&>(),                                        \\"},
{"lineNum":"  308","line":"                                                                        std::declval<TT const &>() versioned ), yes());             \\"},
{"lineNum":"  309","line":"        template <class, class> static no test(...);                                                                                \\"},
{"lineNum":"  310","line":"        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;                                                \\"},
{"lineNum":"  311","line":"                                                                                                                                    \\"},
{"lineNum":"  312","line":"        template <class TT, class AA>                                                                                               \\"},
{"lineNum":"  313","line":"        static auto test2(int) -> decltype( cereal::access::member_save_non_const(                                                  \\"},
{"lineNum":"  314","line":"                                              std::declval<AA &>(),                                                                 \\"},
{"lineNum":"  315","line":"                                              std::declval<typename std::remove_const<TT>::type&>() versioned ), yes());            \\"},
{"lineNum":"  316","line":"        template <class, class> static no test2(...);                                                                               \\"},
{"lineNum":"  317","line":"        static const bool not_const_type = std::is_same<decltype(test2<T, A>(0)), yes>::value;                                      \\"},
{"lineNum":"  318","line":"      };                                                                                                                            \\"},
{"lineNum":"  319","line":"    } /* end namespace detail */"},
{"lineNum":"  320","line":"    #endif /* NOT CEREAL_OLDER_GCC */"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"    // ######################################################################"},
{"lineNum":"  323","line":"    // Member Save"},
{"lineNum":"  324","line":"    CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL(save, )"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"    template <class T, class A>"},
{"lineNum":"  327","line":"    struct has_member_save : std::integral_constant<bool, detail::has_member_save_impl<T, A>::value>"},
{"lineNum":"  328","line":"    {"},
{"lineNum":"  329","line":"      typedef typename detail::has_member_save_impl<T, A> check;"},
{"lineNum":"  330","line":"      static_assert( check::value || !check::not_const_type,"},
{"lineNum":"  331","line":"        \"cereal detected a non-const save. \\n \""},
{"lineNum":"  332","line":"        \"save member functions must always be const\" );"},
{"lineNum":"  333","line":"    };"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"    // ######################################################################"},
{"lineNum":"  336","line":"    // Member Save (versioned)"},
{"lineNum":"  337","line":"    CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL(versioned_save, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"    template <class T, class A>"},
{"lineNum":"  340","line":"    struct has_member_versioned_save : std::integral_constant<bool, detail::has_member_versioned_save_impl<T, A>::value>"},
{"lineNum":"  341","line":"    {"},
{"lineNum":"  342","line":"      typedef typename detail::has_member_versioned_save_impl<T, A> check;"},
{"lineNum":"  343","line":"      static_assert( check::value || !check::not_const_type,"},
{"lineNum":"  344","line":"        \"cereal detected a versioned non-const save. \\n \""},
{"lineNum":"  345","line":"        \"save member functions must always be const\" );"},
{"lineNum":"  346","line":"    };"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"    // ######################################################################"},
{"lineNum":"  349","line":"    #undef CEREAL_MAKE_HAS_MEMBER_SAVE_IMPL"},
{"lineNum":"  350","line":""},
{"lineNum":"  351","line":"    // ######################################################################"},
{"lineNum":"  352","line":"    //! Creates a test for whether a non-member save function exists"},
{"lineNum":"  353","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  354","line":"        the type has the proper non-member function for the given archive."},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"        @param test_name The name to give the test (e.g. save or versioned_save)"},
{"lineNum":"  357","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  358","line":"    #define CEREAL_MAKE_HAS_NON_MEMBER_SAVE_TEST(test_name, versioned)                                                       \\"},
{"lineNum":"  359","line":"    namespace detail                                                                                                         \\"},
{"lineNum":"  360","line":"    {                                                                                                                        \\"},
{"lineNum":"  361","line":"      template <class T, class A>                                                                                            \\"},
{"lineNum":"  362","line":"      struct has_non_member_##test_name##_impl                                                                               \\"},
{"lineNum":"  363","line":"      {                                                                                                                      \\"},
{"lineNum":"  364","line":"        template <class TT, class AA>                                                                                        \\"},
{"lineNum":"  365","line":"        static auto test(int) -> decltype( CEREAL_SAVE_FUNCTION_NAME(                                                        \\"},
{"lineNum":"  366","line":"                                              std::declval<AA&>(),                                                           \\"},
{"lineNum":"  367","line":"                                              std::declval<TT const &>() versioned ), yes());                                \\"},
{"lineNum":"  368","line":"        template <class, class> static no test(...);                                                                         \\"},
{"lineNum":"  369","line":"        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;                                         \\"},
{"lineNum":"  370","line":"                                                                                                                             \\"},
{"lineNum":"  371","line":"        template <class TT, class AA>                                                                                        \\"},
{"lineNum":"  372","line":"        static auto test2(int) -> decltype( CEREAL_SAVE_FUNCTION_NAME(                                                       \\"},
{"lineNum":"  373","line":"                                              std::declval<AA &>(),                                                          \\"},
{"lineNum":"  374","line":"                                              std::declval<typename std::remove_const<TT>::type&>() versioned ), yes());     \\"},
{"lineNum":"  375","line":"        template <class, class> static no test2(...);                                                                        \\"},
{"lineNum":"  376","line":"        static const bool not_const_type = std::is_same<decltype(test2<T, A>(0)), yes>::value;                               \\"},
{"lineNum":"  377","line":"      };                                                                                                                     \\"},
{"lineNum":"  378","line":"    } /* end namespace detail */                                                                                             \\"},
{"lineNum":"  379","line":"                                                                                                                             \\"},
{"lineNum":"  380","line":"    template <class T, class A>                                                                                              \\"},
{"lineNum":"  381","line":"    struct has_non_member_##test_name : std::integral_constant<bool, detail::has_non_member_##test_name##_impl<T, A>::value> \\"},
{"lineNum":"  382","line":"    {                                                                                                                        \\"},
{"lineNum":"  383","line":"      using check = typename detail::has_non_member_##test_name##_impl<T, A>;                                                \\"},
{"lineNum":"  384","line":"      static_assert( check::value || !check::not_const_type,                                                                 \\"},
{"lineNum":"  385","line":"        \"cereal detected a non-const type parameter in non-member \" #test_name \". \\n \"                                       \\"},
{"lineNum":"  386","line":"        #test_name \" non-member functions must always pass their types as const\" );                                          \\"},
{"lineNum":"  387","line":"    };"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"    // ######################################################################"},
{"lineNum":"  390","line":"    // Non Member Save"},
{"lineNum":"  391","line":"    CEREAL_MAKE_HAS_NON_MEMBER_SAVE_TEST(save, )"},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"    // ######################################################################"},
{"lineNum":"  394","line":"    // Non Member Save (versioned)"},
{"lineNum":"  395","line":"    CEREAL_MAKE_HAS_NON_MEMBER_SAVE_TEST(versioned_save, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"    // ######################################################################"},
{"lineNum":"  398","line":"    #undef CEREAL_MAKE_HAS_NON_MEMBER_SAVE_TEST"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"    // ######################################################################"},
{"lineNum":"  401","line":"    // Minimal Utilities"},
{"lineNum":"  402","line":"    namespace detail"},
{"lineNum":"  403","line":"    {"},
{"lineNum":"  404","line":"      // Determines if the provided type is an std::string"},
{"lineNum":"  405","line":"      template <class> struct is_string : std::false_type {};"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"      template <class CharT, class Traits, class Alloc>"},
{"lineNum":"  408","line":"      struct is_string<std::basic_string<CharT, Traits, Alloc>> : std::true_type {};"},
{"lineNum":"  409","line":"    }"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"    // Determines if the type is valid for use with a minimal serialize function"},
{"lineNum":"  412","line":"    template <class T>"},
{"lineNum":"  413","line":"    struct is_minimal_type : std::integral_constant<bool,"},
{"lineNum":"  414","line":"      detail::is_string<T>::value || std::is_arithmetic<T>::value> {};"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"    // ######################################################################"},
{"lineNum":"  417","line":"    //! Creates implementation details for whether a member save_minimal function exists"},
{"lineNum":"  418","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  419","line":"        the type has the proper member function for the given archive."},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"        @param test_name The name to give the test (e.g. save_minimal or versioned_save_minimal)"},
{"lineNum":"  422","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  423","line":"    #ifdef CEREAL_OLDER_GCC"},
{"lineNum":"  424","line":"    #define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL(test_name, versioned)                                                                        \\"},
{"lineNum":"  425","line":"    namespace detail                                                                                                                              \\"},
{"lineNum":"  426","line":"    {                                                                                                                                             \\"},
{"lineNum":"  427","line":"      template <class T, class A>                                                                                                                 \\"},
{"lineNum":"  428","line":"      struct has_member_##test_name##_impl                                                                                                        \\"},
{"lineNum":"  429","line":"      {                                                                                                                                           \\"},
{"lineNum":"  430","line":"        template <class TT, class AA, class SFINAE = void> struct test : no {};                                                                   \\"},
{"lineNum":"  431","line":"        template <class TT, class AA>                                                                                                             \\"},
{"lineNum":"  432","line":"        struct test<TT, AA, typename detail::Void< decltype(                                                                                      \\"},
{"lineNum":"  433","line":"            cereal::access::member_save_minimal( std::declval<AA const &>(),                                                                      \\"},
{"lineNum":"  434","line":"                                                 std::declval<TT const &>() versioned ) ) >::type> : yes {};                                      \\"},
{"lineNum":"  435","line":"                                                                                                                                                  \\"},
{"lineNum":"  436","line":"        static const bool value = test<T, A>();                                                                                                   \\"},
{"lineNum":"  437","line":"                                                                                                                                                  \\"},
{"lineNum":"  438","line":"        template <class TT, class AA, class SFINAE = void> struct test2 : no {};                                                                  \\"},
{"lineNum":"  439","line":"        template <class TT, class AA>                                                                                                             \\"},
{"lineNum":"  440","line":"        struct test2<TT, AA, typename detail::Void< decltype(                                                                                     \\"},
{"lineNum":"  441","line":"            cereal::access::member_save_minimal_non_const( std::declval<AA const &>(),                                                            \\"},
{"lineNum":"  442","line":"                                                           std::declval<typename std::remove_const<TT>::type&>() versioned ) ) >::type> : yes {}; \\"},
{"lineNum":"  443","line":"        static const bool not_const_type = test2<T, A>();                                                                                         \\"},
{"lineNum":"  444","line":"                                                                                                                                                  \\"},
{"lineNum":"  445","line":"        static const bool valid = value || !not_const_type;                                                                                       \\"},
{"lineNum":"  446","line":"      };                                                                                                                                          \\"},
{"lineNum":"  447","line":"    } /* end namespace detail */"},
{"lineNum":"  448","line":"    #else /* NOT CEREAL_OLDER_GCC =================================== */"},
{"lineNum":"  449","line":"    #define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL(test_name, versioned)                     \\"},
{"lineNum":"  450","line":"    namespace detail                                                                           \\"},
{"lineNum":"  451","line":"    {                                                                                          \\"},
{"lineNum":"  452","line":"      template <class T, class A>                                                              \\"},
{"lineNum":"  453","line":"      struct has_member_##test_name##_impl                                                     \\"},
{"lineNum":"  454","line":"      {                                                                                        \\"},
{"lineNum":"  455","line":"        template <class TT, class AA>                                                          \\"},
{"lineNum":"  456","line":"        static auto test(int) -> decltype( cereal::access::member_save_minimal(                \\"},
{"lineNum":"  457","line":"              std::declval<AA const &>(),                                                      \\"},
{"lineNum":"  458","line":"              std::declval<TT const &>() versioned ), yes());                                  \\"},
{"lineNum":"  459","line":"        template <class, class> static no test(...);                                           \\"},
{"lineNum":"  460","line":"        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;           \\"},
{"lineNum":"  461","line":"                                                                                               \\"},
{"lineNum":"  462","line":"        template <class TT, class AA>                                                          \\"},
{"lineNum":"  463","line":"        static auto test2(int) -> decltype( cereal::access::member_save_minimal_non_const(     \\"},
{"lineNum":"  464","line":"              std::declval<AA const &>(),                                                      \\"},
{"lineNum":"  465","line":"              std::declval<typename std::remove_const<TT>::type&>() versioned ), yes());       \\"},
{"lineNum":"  466","line":"        template <class, class> static no test2(...);                                          \\"},
{"lineNum":"  467","line":"        static const bool not_const_type = std::is_same<decltype(test2<T, A>(0)), yes>::value; \\"},
{"lineNum":"  468","line":"                                                                                               \\"},
{"lineNum":"  469","line":"        static const bool valid = value || !not_const_type;                                    \\"},
{"lineNum":"  470","line":"      };                                                                                       \\"},
{"lineNum":"  471","line":"    } /* end namespace detail */"},
{"lineNum":"  472","line":"    #endif // NOT CEREAL_OLDER_GCC"},
{"lineNum":"  473","line":""},
{"lineNum":"  474","line":"    // ######################################################################"},
{"lineNum":"  475","line":"    //! Creates helpers for minimal save functions"},
{"lineNum":"  476","line":"    /*! The get_member_*_type structs allow access to the return type of a save_minimal,"},
{"lineNum":"  477","line":"        assuming that the function actually exists.  If the function does not"},
{"lineNum":"  478","line":"        exist, the type will be void."},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"        @param test_name The name to give the test (e.g. save_minimal or versioned_save_minimal)"},
{"lineNum":"  481","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  482","line":"    #define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_HELPERS_IMPL(test_name, versioned)                           \\"},
{"lineNum":"  483","line":"    namespace detail                                                                                         \\"},
{"lineNum":"  484","line":"    {                                                                                                        \\"},
{"lineNum":"  485","line":"      template <class T, class A, bool Valid>                                                                \\"},
{"lineNum":"  486","line":"      struct get_member_##test_name##_type { using type = void; };                                           \\"},
{"lineNum":"  487","line":"                                                                                                             \\"},
{"lineNum":"  488","line":"      template <class T, class A>                                                                            \\"},
{"lineNum":"  489","line":"      struct get_member_##test_name##_type<T, A, true>                                                       \\"},
{"lineNum":"  490","line":"      {                                                                                                      \\"},
{"lineNum":"  491","line":"        using type = decltype( cereal::access::member_save_minimal( std::declval<A const &>(),               \\"},
{"lineNum":"  492","line":"                                                                    std::declval<T const &>() versioned ) ); \\"},
{"lineNum":"  493","line":"      };                                                                                                     \\"},
{"lineNum":"  494","line":"    } /* end namespace detail */"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"    // ######################################################################"},
{"lineNum":"  497","line":"    //! Creates a test for whether a member save_minimal function exists"},
{"lineNum":"  498","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  499","line":"        the type has the proper member function for the given archive."},
{"lineNum":"  500","line":""},
{"lineNum":"  501","line":"        @param test_name The name to give the test (e.g. save_minimal or versioned_save_minimal) */"},
{"lineNum":"  502","line":"    #define CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_TEST(test_name)                                                      \\"},
{"lineNum":"  503","line":"    template <class T, class A>                                                                                      \\"},
{"lineNum":"  504","line":"    struct has_member_##test_name : std::integral_constant<bool, detail::has_member_##test_name##_impl<T, A>::value> \\"},
{"lineNum":"  505","line":"    {                                                                                                                \\"},
{"lineNum":"  506","line":"      using check = typename detail::has_member_##test_name##_impl<T, A>;                                            \\"},
{"lineNum":"  507","line":"      static_assert( check::valid,                                                                                   \\"},
{"lineNum":"  508","line":"        \"cereal detected a non-const member \" #test_name \". \\n \"                                                     \\"},
{"lineNum":"  509","line":"        #test_name \" member functions must always be const\" );                                                       \\"},
{"lineNum":"  510","line":"                                                                                                                     \\"},
{"lineNum":"  511","line":"      using type = typename detail::get_member_##test_name##_type<T, A, check::value>::type;                         \\"},
{"lineNum":"  512","line":"      static_assert( (check::value && is_minimal_type<type>::value) || !check::value,                                \\"},
{"lineNum":"  513","line":"        \"cereal detected a member \" #test_name \" with an invalid return type. \\n \"                                   \\"},
{"lineNum":"  514","line":"        \"return type must be arithmetic or string\" );                                                                \\"},
{"lineNum":"  515","line":"    };"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"    // ######################################################################"},
{"lineNum":"  518","line":"    // Member Save Minimal"},
{"lineNum":"  519","line":"    CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL(save_minimal, )"},
{"lineNum":"  520","line":"    CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_HELPERS_IMPL(save_minimal, )"},
{"lineNum":"  521","line":"    CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_TEST(save_minimal)"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"    // ######################################################################"},
{"lineNum":"  524","line":"    // Member Save Minimal (versioned)"},
{"lineNum":"  525","line":"    CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL(versioned_save_minimal, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  526","line":"    CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_HELPERS_IMPL(versioned_save_minimal, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  527","line":"    CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_TEST(versioned_save_minimal)"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"    // ######################################################################"},
{"lineNum":"  530","line":"    #undef CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_IMPL"},
{"lineNum":"  531","line":"    #undef CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_HELPERS_IMPL"},
{"lineNum":"  532","line":"    #undef CEREAL_MAKE_HAS_MEMBER_SAVE_MINIMAL_TEST"},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":"    // ######################################################################"},
{"lineNum":"  535","line":"    //! Creates a test for whether a non-member save_minimal function exists"},
{"lineNum":"  536","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  537","line":"        the type has the proper member function for the given archive."},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"        @param test_name The name to give the test (e.g. save_minimal or versioned_save_minimal)"},
{"lineNum":"  540","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  541","line":"    #define CEREAL_MAKE_HAS_NON_MEMBER_SAVE_MINIMAL_TEST(test_name, versioned)                                               \\"},
{"lineNum":"  542","line":"    namespace detail                                                                                                         \\"},
{"lineNum":"  543","line":"    {                                                                                                                        \\"},
{"lineNum":"  544","line":"      template <class T, class A>                                                                                            \\"},
{"lineNum":"  545","line":"      struct has_non_member_##test_name##_impl                                                                               \\"},
{"lineNum":"  546","line":"      {                                                                                                                      \\"},
{"lineNum":"  547","line":"        template <class TT, class AA>                                                                                        \\"},
{"lineNum":"  548","line":"        static auto test(int) -> decltype( CEREAL_SAVE_MINIMAL_FUNCTION_NAME(                                                \\"},
{"lineNum":"  549","line":"              std::declval<AA const &>(),                                                                                    \\"},
{"lineNum":"  550","line":"              std::declval<TT const &>() versioned ), yes());                                                                \\"},
{"lineNum":"  551","line":"        template <class, class> static no test(...);                                                                         \\"},
{"lineNum":"  552","line":"        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;                                         \\"},
{"lineNum":"  553","line":"                                                                                                                             \\"},
{"lineNum":"  554","line":"        template <class TT, class AA>                                                                                        \\"},
{"lineNum":"  555","line":"        static auto test2(int) -> decltype( CEREAL_SAVE_MINIMAL_FUNCTION_NAME(                                               \\"},
{"lineNum":"  556","line":"              std::declval<AA const &>(),                                                                                    \\"},
{"lineNum":"  557","line":"              std::declval<typename std::remove_const<TT>::type&>() versioned ), yes());                                     \\"},
{"lineNum":"  558","line":"        template <class, class> static no test2(...);                                                                        \\"},
{"lineNum":"  559","line":"        static const bool not_const_type = std::is_same<decltype(test2<T, A>(0)), yes>::value;                               \\"},
{"lineNum":"  560","line":"                                                                                                                             \\"},
{"lineNum":"  561","line":"        static const bool valid = value || !not_const_type;                                                                  \\"},
{"lineNum":"  562","line":"      };                                                                                                                     \\"},
{"lineNum":"  563","line":"                                                                                                                             \\"},
{"lineNum":"  564","line":"      template <class T, class A, bool Valid>                                                                                \\"},
{"lineNum":"  565","line":"      struct get_non_member_##test_name##_type { using type = void; };                                                       \\"},
{"lineNum":"  566","line":"                                                                                                                             \\"},
{"lineNum":"  567","line":"      template <class T, class A>                                                                                            \\"},
{"lineNum":"  568","line":"      struct get_non_member_##test_name##_type <T, A, true>                                                                  \\"},
{"lineNum":"  569","line":"      {                                                                                                                      \\"},
{"lineNum":"  570","line":"        using type = decltype( CEREAL_SAVE_MINIMAL_FUNCTION_NAME( std::declval<A const &>(),                                 \\"},
{"lineNum":"  571","line":"                                                                  std::declval<T const &>() versioned ) );                   \\"},
{"lineNum":"  572","line":"      };                                                                                                                     \\"},
{"lineNum":"  573","line":"    } /* end namespace detail */                                                                                             \\"},
{"lineNum":"  574","line":"                                                                                                                             \\"},
{"lineNum":"  575","line":"    template <class T, class A>                                                                                              \\"},
{"lineNum":"  576","line":"    struct has_non_member_##test_name : std::integral_constant<bool, detail::has_non_member_##test_name##_impl<T, A>::value> \\"},
{"lineNum":"  577","line":"    {                                                                                                                        \\"},
{"lineNum":"  578","line":"      using check = typename detail::has_non_member_##test_name##_impl<T, A>;                                                \\"},
{"lineNum":"  579","line":"      static_assert( check::valid,                                                                                           \\"},
{"lineNum":"  580","line":"        \"cereal detected a non-const type parameter in non-member \" #test_name \". \\n \"                                       \\"},
{"lineNum":"  581","line":"        #test_name \" non-member functions must always pass their types as const\" );                                          \\"},
{"lineNum":"  582","line":"                                                                                                                             \\"},
{"lineNum":"  583","line":"      using type = typename detail::get_non_member_##test_name##_type<T, A, check::value>::type;                             \\"},
{"lineNum":"  584","line":"      static_assert( (check::value && is_minimal_type<type>::value) || !check::value,                                        \\"},
{"lineNum":"  585","line":"        \"cereal detected a non-member \" #test_name \" with an invalid return type. \\n \"                                       \\"},
{"lineNum":"  586","line":"        \"return type must be arithmetic or string\" );                                                                        \\"},
{"lineNum":"  587","line":"    };"},
{"lineNum":"  588","line":""},
{"lineNum":"  589","line":"    // ######################################################################"},
{"lineNum":"  590","line":"    // Non-Member Save Minimal"},
{"lineNum":"  591","line":"    CEREAL_MAKE_HAS_NON_MEMBER_SAVE_MINIMAL_TEST(save_minimal, )"},
{"lineNum":"  592","line":""},
{"lineNum":"  593","line":"    // ######################################################################"},
{"lineNum":"  594","line":"    // Non-Member Save Minimal (versioned)"},
{"lineNum":"  595","line":"    CEREAL_MAKE_HAS_NON_MEMBER_SAVE_MINIMAL_TEST(versioned_save_minimal, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  596","line":""},
{"lineNum":"  597","line":"    // ######################################################################"},
{"lineNum":"  598","line":"    #undef CEREAL_MAKE_HAS_NON_MEMBER_SAVE_MINIMAL_TEST"},
{"lineNum":"  599","line":""},
{"lineNum":"  600","line":"    // ######################################################################"},
{"lineNum":"  601","line":"    // Load Minimal Utilities"},
{"lineNum":"  602","line":"    namespace detail"},
{"lineNum":"  603","line":"    {"},
{"lineNum":"  604","line":"      //! Used to help strip away conversion wrappers"},
{"lineNum":"  605","line":"      /*! If someone writes a non-member load/save minimal function that accepts its"},
{"lineNum":"  606","line":"          parameter as some generic template type and needs to perform trait checks"},
{"lineNum":"  607","line":"          on that type, our NoConvert wrappers will interfere with this.  Using"},
{"lineNum":"  608","line":"          the struct strip_minmal, users can strip away our wrappers to get to"},
{"lineNum":"  609","line":"          the underlying type, allowing traits to work properly */"},
{"lineNum":"  610","line":"      struct NoConvertBase {};"},
{"lineNum":"  611","line":""},
{"lineNum":"  612","line":"      //! A struct that prevents implicit conversion"},
{"lineNum":"  613","line":"      /*! Any type instantiated with this struct will be unable to implicitly convert"},
{"lineNum":"  614","line":"          to another type.  Is designed to only allow conversion to Source const &."},
{"lineNum":"  615","line":""},
{"lineNum":"  616","line":"          @tparam Source the type of the original source */"},
{"lineNum":"  617","line":"      template <class Source>"},
{"lineNum":"  618","line":"      struct NoConvertConstRef : NoConvertBase"},
{"lineNum":"  619","line":"      {"},
{"lineNum":"  620","line":"        using type = Source; //!< Used to get underlying type easily"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>"},
{"lineNum":"  623","line":"        operator Dest () = delete;"},
{"lineNum":"  624","line":""},
{"lineNum":"  625","line":"        //! only allow conversion if the types are the same and we are converting into a const reference"},
{"lineNum":"  626","line":"        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>"},
{"lineNum":"  627","line":"        operator Dest const & ();"},
{"lineNum":"  628","line":"      };"},
{"lineNum":"  629","line":""},
{"lineNum":"  630","line":"      //! A struct that prevents implicit conversion"},
{"lineNum":"  631","line":"      /*! Any type instantiated with this struct will be unable to implicitly convert"},
{"lineNum":"  632","line":"          to another type.  Is designed to only allow conversion to Source &."},
{"lineNum":"  633","line":""},
{"lineNum":"  634","line":"          @tparam Source the type of the original source */"},
{"lineNum":"  635","line":"      template <class Source>"},
{"lineNum":"  636","line":"      struct NoConvertRef : NoConvertBase"},
{"lineNum":"  637","line":"      {"},
{"lineNum":"  638","line":"        using type = Source; //!< Used to get underlying type easily"},
{"lineNum":"  639","line":""},
{"lineNum":"  640","line":"        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>"},
{"lineNum":"  641","line":"        operator Dest () = delete;"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"        #ifdef __clang__"},
{"lineNum":"  644","line":"        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>"},
{"lineNum":"  645","line":"        operator Dest const & () = delete;"},
{"lineNum":"  646","line":"        #endif // __clang__"},
{"lineNum":"  647","line":""},
{"lineNum":"  648","line":"        //! only allow conversion if the types are the same and we are converting into a const reference"},
{"lineNum":"  649","line":"        template <class Dest, class = typename std::enable_if<std::is_same<Source, Dest>::value>::type>"},
{"lineNum":"  650","line":"        operator Dest & ();"},
{"lineNum":"  651","line":"      };"},
{"lineNum":"  652","line":""},
{"lineNum":"  653","line":"      //! A type that can implicitly convert to anything else"},
{"lineNum":"  654","line":"      struct AnyConvert"},
{"lineNum":"  655","line":"      {"},
{"lineNum":"  656","line":"        template <class Dest>"},
{"lineNum":"  657","line":"        operator Dest & ();"},
{"lineNum":"  658","line":""},
{"lineNum":"  659","line":"        template <class Dest>"},
{"lineNum":"  660","line":"        operator Dest const & () const;"},
{"lineNum":"  661","line":"      };"},
{"lineNum":"  662","line":"    } // namespace detail"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"    // ######################################################################"},
{"lineNum":"  665","line":"    //! Creates a test for whether a member load_minimal function exists"},
{"lineNum":"  666","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  667","line":"        the type has the proper member function for the given archive."},
{"lineNum":"  668","line":""},
{"lineNum":"  669","line":"        Our strategy here is to first check if a function matching the signature more or less exists"},
{"lineNum":"  670","line":"        (allow anything like load_minimal(xxx) using AnyConvert, and then secondly enforce"},
{"lineNum":"  671","line":"        that it has the correct signature using NoConvertConstRef"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"        @param test_name The name to give the test (e.g. load_minimal or versioned_load_minimal)"},
{"lineNum":"  674","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  675","line":"    #ifdef CEREAL_OLDER_GCC"},
{"lineNum":"  676","line":"    #define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL(test_name, versioned)                                                    \\"},
{"lineNum":"  677","line":"    namespace detail                                                                                                          \\"},
{"lineNum":"  678","line":"    {                                                                                                                         \\"},
{"lineNum":"  679","line":"      template <class T, class A, class SFINAE = void> struct has_member_##test_name##_impl : no {};                          \\"},
{"lineNum":"  680","line":"      template <class T, class A>                                                                                             \\"},
{"lineNum":"  681","line":"      struct has_member_##test_name##_impl<T, A, typename detail::Void< decltype(                                             \\"},
{"lineNum":"  682","line":"          cereal::access::member_load_minimal( std::declval<A const &>(),                                                     \\"},
{"lineNum":"  683","line":"                                               std::declval<T &>(), AnyConvert() versioned ) ) >::type> : yes {};             \\"},
{"lineNum":"  684","line":"                                                                                                                              \\"},
{"lineNum":"  685","line":"        template <class T, class A, class U, class SFINAE = void> struct has_member_##test_name##_type_impl : no {};          \\"},
{"lineNum":"  686","line":"        template <class T, class A, class U>                                                                                  \\"},
{"lineNum":"  687","line":"        struct has_member_##test_name##_type_impl<T, A, U, typename detail::Void< decltype(                                   \\"},
{"lineNum":"  688","line":"            cereal::access::member_load_minimal( std::declval<A const &>(),                                                   \\"},
{"lineNum":"  689","line":"                                                 std::declval<T &>(), NoConvertConstRef<U>() versioned ) ) >::type> : yes {}; \\"},
{"lineNum":"  690","line":"    } /* end namespace detail */"},
{"lineNum":"  691","line":"    #else /* NOT CEREAL_OLDER_GCC =================================== */"},
{"lineNum":"  692","line":"    #define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL(test_name, versioned)              \\"},
{"lineNum":"  693","line":"    namespace detail                                                                    \\"},
{"lineNum":"  694","line":"    {                                                                                   \\"},
{"lineNum":"  695","line":"      template <class T, class A>                                                       \\"},
{"lineNum":"  696","line":"      struct has_member_##test_name##_impl                                              \\"},
{"lineNum":"  697","line":"      {                                                                                 \\"},
{"lineNum":"  698","line":"        template <class TT, class AA>                                                   \\"},
{"lineNum":"  699","line":"        static auto test(int) -> decltype( cereal::access::member_load_minimal(         \\"},
{"lineNum":"  700","line":"              std::declval<AA const &>(),                                               \\"},
{"lineNum":"  701","line":"              std::declval<TT &>(), AnyConvert() versioned ), yes());                   \\"},
{"lineNum":"  702","line":"        template <class, class> static no test(...);                                    \\"},
{"lineNum":"  703","line":"        static const bool value = std::is_same<decltype(test<T, A>(0)), yes>::value;    \\"},
{"lineNum":"  704","line":"      };                                                                                \\"},
{"lineNum":"  705","line":"      template <class T, class A, class U>                                              \\"},
{"lineNum":"  706","line":"      struct has_member_##test_name##_type_impl                                         \\"},
{"lineNum":"  707","line":"      {                                                                                 \\"},
{"lineNum":"  708","line":"        template <class TT, class AA, class UU>                                         \\"},
{"lineNum":"  709","line":"        static auto test(int) -> decltype( cereal::access::member_load_minimal(         \\"},
{"lineNum":"  710","line":"              std::declval<AA const &>(),                                               \\"},
{"lineNum":"  711","line":"              std::declval<TT &>(), NoConvertConstRef<UU>() versioned ), yes());        \\"},
{"lineNum":"  712","line":"        template <class, class, class> static no test(...);                             \\"},
{"lineNum":"  713","line":"        static const bool value = std::is_same<decltype(test<T, A, U>(0)), yes>::value; \\"},
{"lineNum":"  714","line":"                                                                                        \\"},
{"lineNum":"  715","line":"      };                                                                                \\"},
{"lineNum":"  716","line":"    } /* end namespace detail */"},
{"lineNum":"  717","line":"    #endif // NOT CEREAL_OLDER_GCC"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"    // ######################################################################"},
{"lineNum":"  720","line":"    //! Creates helpers for minimal load functions"},
{"lineNum":"  721","line":"    /*! The has_member_*_wrapper structs ensure that the load and save types for the"},
{"lineNum":"  722","line":"        requested function type match appropriately."},
{"lineNum":"  723","line":""},
{"lineNum":"  724","line":"        @param load_test_name The name to give the test (e.g. load_minimal or versioned_load_minimal)"},
{"lineNum":"  725","line":"        @param save_test_name The name to give the test (e.g. save_minimal or versioned_save_minimal,"},
{"lineNum":"  726","line":"                              should match the load name."},
{"lineNum":"  727","line":"        @param save_test_prefix The name to give the test (e.g. save_minimal or versioned_save_minimal,"},
{"lineNum":"  728","line":"                              should match the load name, without the trailing \"_minimal\" (e.g."},
{"lineNum":"  729","line":"                              save or versioned_save).  Needed because the preprocessor is an abomination."},
{"lineNum":"  730","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  731","line":"    #define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_HELPERS_IMPL(load_test_name, save_test_name, save_test_prefix, versioned) \\"},
{"lineNum":"  732","line":"    namespace detail                                                                                                      \\"},
{"lineNum":"  733","line":"    {                                                                                                                     \\"},
{"lineNum":"  734","line":"      template <class T, class A, bool Valid>                                                                             \\"},
{"lineNum":"  735","line":"      struct has_member_##load_test_name##_wrapper : std::false_type {};                                                  \\"},
{"lineNum":"  736","line":"                                                                                                                          \\"},
{"lineNum":"  737","line":"      template <class T, class A>                                                                                         \\"},
{"lineNum":"  738","line":"      struct has_member_##load_test_name##_wrapper<T, A, true>                                                            \\"},
{"lineNum":"  739","line":"      {                                                                                                                   \\"},
{"lineNum":"  740","line":"        using AOut = typename detail::get_output_from_input<A>::type;                                                     \\"},
{"lineNum":"  741","line":"                                                                                                                          \\"},
{"lineNum":"  742","line":"        static_assert( has_member_##save_test_prefix##_minimal<T, AOut>::value,                                           \\"},
{"lineNum":"  743","line":"          \"cereal detected member \" #load_test_name \" but no valid member \" #save_test_name \". \\n \"                       \\"},
{"lineNum":"  744","line":"          \"cannot evaluate correctness of \" #load_test_name \" without valid \" #save_test_name \".\" );                      \\"},
{"lineNum":"  745","line":"                                                                                                                          \\"},
{"lineNum":"  746","line":"        using SaveType = typename detail::get_member_##save_test_prefix##_minimal_type<T, AOut, true>::type;              \\"},
{"lineNum":"  747","line":"        const static bool value = has_member_##load_test_name##_impl<T, A>::value;                                        \\"},
{"lineNum":"  748","line":"        const static bool valid = has_member_##load_test_name##_type_impl<T, A, SaveType>::value;                         \\"},
{"lineNum":"  749","line":"                                                                                                                          \\"},
{"lineNum":"  750","line":"        static_assert( valid || !value, \"cereal detected different or invalid types in corresponding member \"             \\"},
{"lineNum":"  751","line":"            #load_test_name \" and \" #save_test_name \" functions. \\n \"                                                     \\"},
{"lineNum":"  752","line":"            \"the paramater to \" #load_test_name \" must be a constant reference to the type that \"                         \\"},
{"lineNum":"  753","line":"            #save_test_name \" returns.\" );                                                                                \\"},
{"lineNum":"  754","line":"      };                                                                                                                  \\"},
{"lineNum":"  755","line":"    } /* end namespace detail */"},
{"lineNum":"  756","line":""},
{"lineNum":"  757","line":"    // ######################################################################"},
{"lineNum":"  758","line":"    //! Creates a test for whether a member load_minimal function exists"},
{"lineNum":"  759","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  760","line":"        the type has the proper member function for the given archive."},
{"lineNum":"  761","line":""},
{"lineNum":"  762","line":"        @param load_test_name The name to give the test (e.g. load_minimal or versioned_load_minimal)"},
{"lineNum":"  763","line":"        @param load_test_prefix The above parameter minus the trailing \"_minimal\" */"},
{"lineNum":"  764","line":"    #define CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_TEST(load_test_name, load_test_prefix)                                         \\"},
{"lineNum":"  765","line":"    template <class T, class A>                                                                                                \\"},
{"lineNum":"  766","line":"    struct has_member_##load_test_prefix##_minimal : std::integral_constant<bool,                                              \\"},
{"lineNum":"  767","line":"      detail::has_member_##load_test_name##_wrapper<T, A, detail::has_member_##load_test_name##_impl<T, A>::value>::value> {};"},
{"lineNum":"  768","line":""},
{"lineNum":"  769","line":"    // ######################################################################"},
{"lineNum":"  770","line":"    // Member Load Minimal"},
{"lineNum":"  771","line":"    CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL(load_minimal, )"},
{"lineNum":"  772","line":"    CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_HELPERS_IMPL(load_minimal, save_minimal, save, )"},
{"lineNum":"  773","line":"    CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_TEST(load_minimal, load)"},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":"    // ######################################################################"},
{"lineNum":"  776","line":"    // Member Load Minimal (versioned)"},
{"lineNum":"  777","line":"    CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL(versioned_load_minimal, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  778","line":"    CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_HELPERS_IMPL(versioned_load_minimal, versioned_save_minimal, versioned_save, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  779","line":"    CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_TEST(versioned_load_minimal, versioned_load)"},
{"lineNum":"  780","line":""},
{"lineNum":"  781","line":"    // ######################################################################"},
{"lineNum":"  782","line":"    #undef CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_IMPL"},
{"lineNum":"  783","line":"    #undef CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_HELPERS_IMPL"},
{"lineNum":"  784","line":"    #undef CEREAL_MAKE_HAS_MEMBER_LOAD_MINIMAL_TEST"},
{"lineNum":"  785","line":""},
{"lineNum":"  786","line":"    // ######################################################################"},
{"lineNum":"  787","line":"    // Non-Member Load Minimal"},
{"lineNum":"  788","line":"    namespace detail"},
{"lineNum":"  789","line":"    {"},
{"lineNum":"  790","line":"      #ifdef CEREAL_OLDER_GCC"},
{"lineNum":"  791","line":"      void CEREAL_LOAD_MINIMAL_FUNCTION_NAME(); // prevents nonsense complaining about not finding this"},
{"lineNum":"  792","line":"      void CEREAL_SAVE_MINIMAL_FUNCTION_NAME();"},
{"lineNum":"  793","line":"      #endif // CEREAL_OLDER_GCC"},
{"lineNum":"  794","line":"    } // namespace detail"},
{"lineNum":"  795","line":""},
{"lineNum":"  796","line":"    // ######################################################################"},
{"lineNum":"  797","line":"    //! Creates a test for whether a non-member load_minimal function exists"},
{"lineNum":"  798","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  799","line":"        the type has the proper member function for the given archive."},
{"lineNum":"  800","line":""},
{"lineNum":"  801","line":"        See notes from member load_minimal implementation."},
{"lineNum":"  802","line":""},
{"lineNum":"  803","line":"        Note that there should be an additional const check on load_minimal after the valid check,"},
{"lineNum":"  804","line":"        but this currently interferes with many valid uses of minimal serialization.  It has been"},
{"lineNum":"  805","line":"        removed (see #565 on github) and previously was:"},
{"lineNum":"  806","line":""},
{"lineNum":"  807","line":"        @code"},
{"lineNum":"  808","line":"        static_assert( check::const_valid || !check::exists,"},
{"lineNum":"  809","line":"            \"cereal detected an invalid serialization type parameter in non-member \" #test_name \".  \""},
{"lineNum":"  810","line":"            #test_name \" non-member functions must accept their serialization type by non-const reference\" );"},
{"lineNum":"  811","line":"        @endcode"},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"        See #132, #436, #263, and #565 on https://github.com/USCiLab/cereal for more details."},
{"lineNum":"  814","line":""},
{"lineNum":"  815","line":"        @param test_name The name to give the test (e.g. load_minimal or versioned_load_minimal)"},
{"lineNum":"  816","line":"        @param save_name The corresponding name the save test would have (e.g. save_minimal or versioned_save_minimal)"},
{"lineNum":"  817","line":"        @param versioned Either blank or the macro CEREAL_MAKE_VERSIONED_TEST */"},
{"lineNum":"  818","line":"    #define CEREAL_MAKE_HAS_NON_MEMBER_LOAD_MINIMAL_TEST(test_name, save_name, versioned)                                    \\"},
{"lineNum":"  819","line":"    namespace detail                                                                                                         \\"},
{"lineNum":"  820","line":"    {                                                                                                                        \\"},
{"lineNum":"  821","line":"      template <class T, class A, class U = void>                                                                            \\"},
{"lineNum":"  822","line":"      struct has_non_member_##test_name##_impl                                                                               \\"},
{"lineNum":"  823","line":"      {                                                                                                                      \\"},
{"lineNum":"  824","line":"        template <class TT, class AA>                                                                                        \\"},
{"lineNum":"  825","line":"        static auto test(int) -> decltype( CEREAL_LOAD_MINIMAL_FUNCTION_NAME(                                                \\"},
{"lineNum":"  826","line":"              std::declval<AA const &>(), std::declval<TT&>(), AnyConvert() versioned ), yes() );                            \\"},
{"lineNum":"  827","line":"        template <class, class> static no test( ... );                                                                       \\"},
{"lineNum":"  828","line":"        static const bool exists = std::is_same<decltype( test<T, A>( 0 ) ), yes>::value;                                    \\"},
{"lineNum":"  829","line":"                                                                                                                             \\"},
{"lineNum":"  830","line":"        template <class TT, class AA, class UU>                                                                              \\"},
{"lineNum":"  831","line":"        static auto test2(int) -> decltype( CEREAL_LOAD_MINIMAL_FUNCTION_NAME(                                               \\"},
{"lineNum":"  832","line":"              std::declval<AA const &>(), std::declval<TT&>(), NoConvertConstRef<UU>() versioned ), yes() );                 \\"},
{"lineNum":"  833","line":"        template <class, class, class> static no test2( ... );                                                               \\"},
{"lineNum":"  834","line":"        static const bool valid = std::is_same<decltype( test2<T, A, U>( 0 ) ), yes>::value;                                 \\"},
{"lineNum":"  835","line":"                                                                                                                             \\"},
{"lineNum":"  836","line":"        template <class TT, class AA>                                                                                        \\"},
{"lineNum":"  837","line":"        static auto test3(int) -> decltype( CEREAL_LOAD_MINIMAL_FUNCTION_NAME(                                               \\"},
{"lineNum":"  838","line":"              std::declval<AA const &>(), NoConvertRef<TT>(), AnyConvert() versioned ), yes() );                             \\"},
{"lineNum":"  839","line":"        template <class, class> static no test3( ... );                                                                      \\"},
{"lineNum":"  840","line":"        static const bool const_valid = std::is_same<decltype( test3<T, A>( 0 ) ), yes>::value;                              \\"},
{"lineNum":"  841","line":"      };                                                                                                                     \\"},
{"lineNum":"  842","line":"                                                                                                                             \\"},
{"lineNum":"  843","line":"      template <class T, class A, bool Valid>                                                                                \\"},
{"lineNum":"  844","line":"      struct has_non_member_##test_name##_wrapper : std::false_type {};                                                      \\"},
{"lineNum":"  845","line":"                                                                                                                             \\"},
{"lineNum":"  846","line":"      template <class T, class A>                                                                                            \\"},
{"lineNum":"  847","line":"      struct has_non_member_##test_name##_wrapper<T, A, true>                                                                \\"},
{"lineNum":"  848","line":"      {                                                                                                                      \\"},
{"lineNum":"  849","line":"        using AOut = typename detail::get_output_from_input<A>::type;                                                        \\"},
{"lineNum":"  850","line":"                                                                                                                             \\"},
{"lineNum":"  851","line":"        static_assert( detail::has_non_member_##save_name##_impl<T, AOut>::valid,                                            \\"},
{"lineNum":"  852","line":"          \"cereal detected non-member \" #test_name \" but no valid non-member \" #save_name \". \\n \"                            \\"},
{"lineNum":"  853","line":"          \"cannot evaluate correctness of \" #test_name \" without valid \" #save_name \".\" );                                   \\"},
{"lineNum":"  854","line":"                                                                                                                             \\"},
{"lineNum":"  855","line":"        using SaveType = typename detail::get_non_member_##save_name##_type<T, AOut, true>::type;                            \\"},
{"lineNum":"  856","line":"        using check = has_non_member_##test_name##_impl<T, A, SaveType>;                                                     \\"},
{"lineNum":"  857","line":"        static const bool value = check::exists;                                                                             \\"},
{"lineNum":"  858","line":"                                                                                                                             \\"},
{"lineNum":"  859","line":"        static_assert( check::valid || !check::exists, \"cereal detected different types in corresponding non-member \"        \\"},
{"lineNum":"  860","line":"            #test_name \" and \" #save_name \" functions. \\n \"                                                                  \\"},
{"lineNum":"  861","line":"            \"the paramater to \" #test_name \" must be a constant reference to the type that \" #save_name \" returns.\" );       \\"},
{"lineNum":"  862","line":"      };                                                                                                                     \\"},
{"lineNum":"  863","line":"    } /* namespace detail */                                                                                                 \\"},
{"lineNum":"  864","line":"                                                                                                                             \\"},
{"lineNum":"  865","line":"    template <class T, class A>                                                                                              \\"},
{"lineNum":"  866","line":"    struct has_non_member_##test_name : std::integral_constant<bool,                                                         \\"},
{"lineNum":"  867","line":"      detail::has_non_member_##test_name##_wrapper<T, A, detail::has_non_member_##test_name##_impl<T, A>::exists>::value> {};"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"    // ######################################################################"},
{"lineNum":"  870","line":"    // Non-Member Load Minimal"},
{"lineNum":"  871","line":"    CEREAL_MAKE_HAS_NON_MEMBER_LOAD_MINIMAL_TEST(load_minimal, save_minimal, )"},
{"lineNum":"  872","line":""},
{"lineNum":"  873","line":"    // ######################################################################"},
{"lineNum":"  874","line":"    // Non-Member Load Minimal (versioned)"},
{"lineNum":"  875","line":"    CEREAL_MAKE_HAS_NON_MEMBER_LOAD_MINIMAL_TEST(versioned_load_minimal, versioned_save_minimal, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  876","line":""},
{"lineNum":"  877","line":"    // ######################################################################"},
{"lineNum":"  878","line":"    #undef CEREAL_MAKE_HAS_NON_MEMBER_LOAD_MINIMAL_TEST"},
{"lineNum":"  879","line":""},
{"lineNum":"  880","line":"    // ######################################################################"},
{"lineNum":"  881","line":"    namespace detail"},
{"lineNum":"  882","line":"    {"},
{"lineNum":"  883","line":"      // const stripped away before reaching here, prevents errors on conversion from"},
{"lineNum":"  884","line":"      // construct<const T> to construct<T>"},
{"lineNum":"  885","line":"      template<typename T, typename A>"},
{"lineNum":"  886","line":"      struct has_member_load_and_construct_impl : std::integral_constant<bool,"},
{"lineNum":"  887","line":"        std::is_same<decltype( access::load_and_construct<T>( std::declval<A&>(), std::declval< ::cereal::construct<T>&>() ) ), void>::value>"},
{"lineNum":"  888","line":"      { };"},
{"lineNum":"  889","line":""},
{"lineNum":"  890","line":"      template<typename T, typename A>"},
{"lineNum":"  891","line":"      struct has_member_versioned_load_and_construct_impl : std::integral_constant<bool,"},
{"lineNum":"  892","line":"        std::is_same<decltype( access::load_and_construct<T>( std::declval<A&>(), std::declval< ::cereal::construct<T>&>(), 0 ) ), void>::value>"},
{"lineNum":"  893","line":"      { };"},
{"lineNum":"  894","line":"    } // namespace detail"},
{"lineNum":"  895","line":""},
{"lineNum":"  896","line":"    //! Member load and construct check"},
{"lineNum":"  897","line":"    template<typename T, typename A>"},
{"lineNum":"  898","line":"    struct has_member_load_and_construct : detail::has_member_load_and_construct_impl<typename std::remove_const<T>::type, A>"},
{"lineNum":"  899","line":"    { };"},
{"lineNum":"  900","line":""},
{"lineNum":"  901","line":"    //! Member load and construct check (versioned)"},
{"lineNum":"  902","line":"    template<typename T, typename A>"},
{"lineNum":"  903","line":"    struct has_member_versioned_load_and_construct : detail::has_member_versioned_load_and_construct_impl<typename std::remove_const<T>::type, A>"},
{"lineNum":"  904","line":"    { };"},
{"lineNum":"  905","line":""},
{"lineNum":"  906","line":"    // ######################################################################"},
{"lineNum":"  907","line":"    //! Creates a test for whether a non-member load_and_construct specialization exists"},
{"lineNum":"  908","line":"    /*! This creates a class derived from std::integral_constant that will be true if"},
{"lineNum":"  909","line":"        the type has the proper non-member function for the given archive. */"},
{"lineNum":"  910","line":"    #define CEREAL_MAKE_HAS_NON_MEMBER_LOAD_AND_CONSTRUCT_TEST(test_name, versioned)                                            \\"},
{"lineNum":"  911","line":"    namespace detail                                                                                                            \\"},
{"lineNum":"  912","line":"    {                                                                                                                           \\"},
{"lineNum":"  913","line":"      template <class T, class A>                                                                                               \\"},
{"lineNum":"  914","line":"      struct has_non_member_##test_name##_impl                                                                                  \\"},
{"lineNum":"  915","line":"      {                                                                                                                         \\"},
{"lineNum":"  916","line":"        template <class TT, class AA>                                                                                           \\"},
{"lineNum":"  917","line":"        static auto test(int) -> decltype( LoadAndConstruct<TT>::load_and_construct(                                            \\"},
{"lineNum":"  918","line":"                                           std::declval<AA&>(), std::declval< ::cereal::construct<TT>&>() versioned ), yes());  \\"},
{"lineNum":"  919","line":"        template <class, class>                                                                                                 \\"},
{"lineNum":"  920","line":"        static no test( ... );                                                                                                  \\"},
{"lineNum":"  921","line":"        static const bool value = std::is_same<decltype( test<T, A>( 0 ) ), yes>::value;                                        \\"},
{"lineNum":"  922","line":"      };                                                                                                                        \\"},
{"lineNum":"  923","line":"    } /* end namespace detail */                                                                                                \\"},
{"lineNum":"  924","line":"    template <class T, class A>                                                                                                 \\"},
{"lineNum":"  925","line":"    struct has_non_member_##test_name :                                                                                         \\"},
{"lineNum":"  926","line":"      std::integral_constant<bool, detail::has_non_member_##test_name##_impl<typename std::remove_const<T>::type, A>::value> {};"},
{"lineNum":"  927","line":""},
{"lineNum":"  928","line":"    // ######################################################################"},
{"lineNum":"  929","line":"    //! Non member load and construct check"},
{"lineNum":"  930","line":"    CEREAL_MAKE_HAS_NON_MEMBER_LOAD_AND_CONSTRUCT_TEST(load_and_construct, )"},
{"lineNum":"  931","line":""},
{"lineNum":"  932","line":"    // ######################################################################"},
{"lineNum":"  933","line":"    //! Non member load and construct check (versioned)"},
{"lineNum":"  934","line":"    CEREAL_MAKE_HAS_NON_MEMBER_LOAD_AND_CONSTRUCT_TEST(versioned_load_and_construct, CEREAL_MAKE_VERSIONED_TEST)"},
{"lineNum":"  935","line":""},
{"lineNum":"  936","line":"    // ######################################################################"},
{"lineNum":"  937","line":"    //! Has either a member or non member load and construct"},
{"lineNum":"  938","line":"    template<typename T, typename A>"},
{"lineNum":"  939","line":"    struct has_load_and_construct : std::integral_constant<bool,"},
{"lineNum":"  940","line":"      has_member_load_and_construct<T, A>::value || has_non_member_load_and_construct<T, A>::value ||"},
{"lineNum":"  941","line":"      has_member_versioned_load_and_construct<T, A>::value || has_non_member_versioned_load_and_construct<T, A>::value>"},
{"lineNum":"  942","line":"    { };"},
{"lineNum":"  943","line":""},
{"lineNum":"  944","line":"    // ######################################################################"},
{"lineNum":"  945","line":"    #undef CEREAL_MAKE_HAS_NON_MEMBER_LOAD_AND_CONSTRUCT_TEST"},
{"lineNum":"  946","line":""},
{"lineNum":"  947","line":"    // ######################################################################"},
{"lineNum":"  948","line":"    // End of serialization existence tests"},
{"lineNum":"  949","line":"    #undef CEREAL_MAKE_VERSIONED_TEST"},
{"lineNum":"  950","line":""},
{"lineNum":"  951","line":"    // ######################################################################"},
{"lineNum":"  952","line":"    template <class T, class InputArchive, class OutputArchive>"},
{"lineNum":"  953","line":"    struct has_member_split : std::integral_constant<bool,"},
{"lineNum":"  954","line":"      (has_member_load<T, InputArchive>::value && has_member_save<T, OutputArchive>::value) ||"},
{"lineNum":"  955","line":"      (has_member_versioned_load<T, InputArchive>::value && has_member_versioned_save<T, OutputArchive>::value)> {};"},
{"lineNum":"  956","line":""},
{"lineNum":"  957","line":"    // ######################################################################"},
{"lineNum":"  958","line":"    template <class T, class InputArchive, class OutputArchive>"},
{"lineNum":"  959","line":"    struct has_non_member_split : std::integral_constant<bool,"},
{"lineNum":"  960","line":"      (has_non_member_load<T, InputArchive>::value && has_non_member_save<T, OutputArchive>::value) ||"},
{"lineNum":"  961","line":"      (has_non_member_versioned_load<T, InputArchive>::value && has_non_member_versioned_save<T, OutputArchive>::value)> {};"},
{"lineNum":"  962","line":""},
{"lineNum":"  963","line":"    // ######################################################################"},
{"lineNum":"  964","line":"    template <class T, class OutputArchive>"},
{"lineNum":"  965","line":"    struct has_invalid_output_versioning : std::integral_constant<bool,"},
{"lineNum":"  966","line":"      (has_member_versioned_save<T, OutputArchive>::value && has_member_save<T, OutputArchive>::value) ||"},
{"lineNum":"  967","line":"      (has_non_member_versioned_save<T, OutputArchive>::value && has_non_member_save<T, OutputArchive>::value) ||"},
{"lineNum":"  968","line":"      (has_member_versioned_serialize<T, OutputArchive>::value && has_member_serialize<T, OutputArchive>::value) ||"},
{"lineNum":"  969","line":"      (has_non_member_versioned_serialize<T, OutputArchive>::value && has_non_member_serialize<T, OutputArchive>::value) ||"},
{"lineNum":"  970","line":"      (has_member_versioned_save_minimal<T, OutputArchive>::value && has_member_save_minimal<T, OutputArchive>::value) ||"},
{"lineNum":"  971","line":"      (has_non_member_versioned_save_minimal<T, OutputArchive>::value &&  has_non_member_save_minimal<T, OutputArchive>::value)> {};"},
{"lineNum":"  972","line":""},
{"lineNum":"  973","line":"    // ######################################################################"},
{"lineNum":"  974","line":"    template <class T, class InputArchive>"},
{"lineNum":"  975","line":"    struct has_invalid_input_versioning : std::integral_constant<bool,"},
{"lineNum":"  976","line":"      (has_member_versioned_load<T, InputArchive>::value && has_member_load<T, InputArchive>::value) ||"},
{"lineNum":"  977","line":"      (has_non_member_versioned_load<T, InputArchive>::value && has_non_member_load<T, InputArchive>::value) ||"},
{"lineNum":"  978","line":"      (has_member_versioned_serialize<T, InputArchive>::value && has_member_serialize<T, InputArchive>::value) ||"},
{"lineNum":"  979","line":"      (has_non_member_versioned_serialize<T, InputArchive>::value && has_non_member_serialize<T, InputArchive>::value) ||"},
{"lineNum":"  980","line":"      (has_member_versioned_load_minimal<T, InputArchive>::value && has_member_load_minimal<T, InputArchive>::value) ||"},
{"lineNum":"  981","line":"      (has_non_member_versioned_load_minimal<T, InputArchive>::value &&  has_non_member_load_minimal<T, InputArchive>::value)> {};"},
{"lineNum":"  982","line":""},
{"lineNum":"  983","line":"    // ######################################################################"},
{"lineNum":"  984","line":"    namespace detail"},
{"lineNum":"  985","line":"    {"},
{"lineNum":"  986","line":"      //! Create a test for a cereal::specialization entry"},
{"lineNum":"  987","line":"      #define CEREAL_MAKE_IS_SPECIALIZED_IMPL(name)                                          \\"},
{"lineNum":"  988","line":"      template <class T, class A>                                                            \\"},
{"lineNum":"  989","line":"      struct is_specialized_##name : std::integral_constant<bool,                            \\"},
{"lineNum":"  990","line":"        !std::is_base_of<std::false_type, specialize<A, T, specialization::name>>::value> {}"},
{"lineNum":"  991","line":""},
{"lineNum":"  992","line":"      CEREAL_MAKE_IS_SPECIALIZED_IMPL(member_serialize);"},
{"lineNum":"  993","line":"      CEREAL_MAKE_IS_SPECIALIZED_IMPL(member_load_save);"},
{"lineNum":"  994","line":"      CEREAL_MAKE_IS_SPECIALIZED_IMPL(member_load_save_minimal);"},
{"lineNum":"  995","line":"      CEREAL_MAKE_IS_SPECIALIZED_IMPL(non_member_serialize);"},
{"lineNum":"  996","line":"      CEREAL_MAKE_IS_SPECIALIZED_IMPL(non_member_load_save);"},
{"lineNum":"  997","line":"      CEREAL_MAKE_IS_SPECIALIZED_IMPL(non_member_load_save_minimal);"},
{"lineNum":"  998","line":""},
{"lineNum":"  999","line":"      #undef CEREAL_MAKE_IS_SPECIALIZED_IMPL"},
{"lineNum":" 1000","line":""},
{"lineNum":" 1001","line":"      //! Number of specializations detected"},
{"lineNum":" 1002","line":"      template <class T, class A>"},
{"lineNum":" 1003","line":"      struct count_specializations : std::integral_constant<int,"},
{"lineNum":" 1004","line":"        is_specialized_member_serialize<T, A>::value +"},
{"lineNum":" 1005","line":"        is_specialized_member_load_save<T, A>::value +"},
{"lineNum":" 1006","line":"        is_specialized_member_load_save_minimal<T, A>::value +"},
{"lineNum":" 1007","line":"        is_specialized_non_member_serialize<T, A>::value +"},
{"lineNum":" 1008","line":"        is_specialized_non_member_load_save<T, A>::value +"},
{"lineNum":" 1009","line":"        is_specialized_non_member_load_save_minimal<T, A>::value> {};"},
{"lineNum":" 1010","line":"    } // namespace detail"},
{"lineNum":" 1011","line":""},
{"lineNum":" 1012","line":"    //! Check if any specialization exists for a type"},
{"lineNum":" 1013","line":"    template <class T, class A>"},
{"lineNum":" 1014","line":"    struct is_specialized : std::integral_constant<bool,"},
{"lineNum":" 1015","line":"      detail::is_specialized_member_serialize<T, A>::value ||"},
{"lineNum":" 1016","line":"      detail::is_specialized_member_load_save<T, A>::value ||"},
{"lineNum":" 1017","line":"      detail::is_specialized_member_load_save_minimal<T, A>::value ||"},
{"lineNum":" 1018","line":"      detail::is_specialized_non_member_serialize<T, A>::value ||"},
{"lineNum":" 1019","line":"      detail::is_specialized_non_member_load_save<T, A>::value ||"},
{"lineNum":" 1020","line":"      detail::is_specialized_non_member_load_save_minimal<T, A>::value>"},
{"lineNum":" 1021","line":"    {"},
{"lineNum":" 1022","line":"      static_assert(detail::count_specializations<T, A>::value <= 1, \"More than one explicit specialization detected for type.\");"},
{"lineNum":" 1023","line":"    };"},
{"lineNum":" 1024","line":""},
{"lineNum":" 1025","line":"    //! Create the static assertion for some specialization"},
{"lineNum":" 1026","line":"    /*! This assertion will fail if the type is indeed specialized and does not have the appropriate"},
{"lineNum":" 1027","line":"        type of serialization functions */"},
{"lineNum":" 1028","line":"    #define CEREAL_MAKE_IS_SPECIALIZED_ASSERT(name, versioned_name, print_name, spec_name)                      \\"},
{"lineNum":" 1029","line":"    static_assert( (is_specialized<T, A>::value && detail::is_specialized_##spec_name<T, A>::value &&           \\"},
{"lineNum":" 1030","line":"                   (has_##name<T, A>::value || has_##versioned_name<T, A>::value))                              \\"},
{"lineNum":" 1031","line":"                   || !(is_specialized<T, A>::value && detail::is_specialized_##spec_name<T, A>::value),        \\"},
{"lineNum":" 1032","line":"                   \"cereal detected \" #print_name \" specialization but no \" #print_name \" serialize function\" )"},
{"lineNum":" 1033","line":""},
{"lineNum":" 1034","line":"    //! Generates a test for specialization for versioned and unversioned functions"},
{"lineNum":" 1035","line":"    /*! This creates checks that can be queried to see if a given type of serialization function"},
{"lineNum":" 1036","line":"        has been specialized for this type */"},
{"lineNum":" 1037","line":"    #define CEREAL_MAKE_IS_SPECIALIZED(name, versioned_name, spec_name)                     \\"},
{"lineNum":" 1038","line":"    template <class T, class A>                                                             \\"},
{"lineNum":" 1039","line":"    struct is_specialized_##name : std::integral_constant<bool,                             \\"},
{"lineNum":" 1040","line":"      is_specialized<T, A>::value && detail::is_specialized_##spec_name<T, A>::value>       \\"},
{"lineNum":" 1041","line":"    { CEREAL_MAKE_IS_SPECIALIZED_ASSERT(name, versioned_name, name, spec_name); };          \\"},
{"lineNum":" 1042","line":"    template <class T, class A>                                                             \\"},
{"lineNum":" 1043","line":"    struct is_specialized_##versioned_name : std::integral_constant<bool,                   \\"},
{"lineNum":" 1044","line":"      is_specialized<T, A>::value && detail::is_specialized_##spec_name<T, A>::value>       \\"},
{"lineNum":" 1045","line":"    { CEREAL_MAKE_IS_SPECIALIZED_ASSERT(name, versioned_name, versioned_name, spec_name); }"},
{"lineNum":" 1046","line":""},
{"lineNum":" 1047","line":"    CEREAL_MAKE_IS_SPECIALIZED(member_serialize, member_versioned_serialize, member_serialize);"},
{"lineNum":" 1048","line":"    CEREAL_MAKE_IS_SPECIALIZED(non_member_serialize, non_member_versioned_serialize, non_member_serialize);"},
{"lineNum":" 1049","line":""},
{"lineNum":" 1050","line":"    CEREAL_MAKE_IS_SPECIALIZED(member_save, member_versioned_save, member_load_save);"},
{"lineNum":" 1051","line":"    CEREAL_MAKE_IS_SPECIALIZED(non_member_save, non_member_versioned_save, non_member_load_save);"},
{"lineNum":" 1052","line":"    CEREAL_MAKE_IS_SPECIALIZED(member_load, member_versioned_load, member_load_save);"},
{"lineNum":" 1053","line":"    CEREAL_MAKE_IS_SPECIALIZED(non_member_load, non_member_versioned_load, non_member_load_save);"},
{"lineNum":" 1054","line":""},
{"lineNum":" 1055","line":"    CEREAL_MAKE_IS_SPECIALIZED(member_save_minimal, member_versioned_save_minimal, member_load_save_minimal);"},
{"lineNum":" 1056","line":"    CEREAL_MAKE_IS_SPECIALIZED(non_member_save_minimal, non_member_versioned_save_minimal, non_member_load_save_minimal);"},
{"lineNum":" 1057","line":"    CEREAL_MAKE_IS_SPECIALIZED(member_load_minimal, member_versioned_load_minimal, member_load_save_minimal);"},
{"lineNum":" 1058","line":"    CEREAL_MAKE_IS_SPECIALIZED(non_member_load_minimal, non_member_versioned_load_minimal, non_member_load_save_minimal);"},
{"lineNum":" 1059","line":""},
{"lineNum":" 1060","line":"    #undef CEREAL_MAKE_IS_SPECIALIZED_ASSERT"},
{"lineNum":" 1061","line":"    #undef CEREAL_MAKE_IS_SPECIALIZED"},
{"lineNum":" 1062","line":""},
{"lineNum":" 1063","line":"    // ######################################################################"},
{"lineNum":" 1064","line":"    // detects if a type has any active minimal output serialization"},
{"lineNum":" 1065","line":"    template <class T, class OutputArchive>"},
{"lineNum":" 1066","line":"    struct has_minimal_output_serialization : std::integral_constant<bool,"},
{"lineNum":" 1067","line":"      is_specialized_member_save_minimal<T, OutputArchive>::value ||"},
{"lineNum":" 1068","line":"      ((has_member_save_minimal<T, OutputArchive>::value ||"},
{"lineNum":" 1069","line":"        has_non_member_save_minimal<T, OutputArchive>::value ||"},
{"lineNum":" 1070","line":"        has_member_versioned_save_minimal<T, OutputArchive>::value ||"},
{"lineNum":" 1071","line":"        has_non_member_versioned_save_minimal<T, OutputArchive>::value) &&"},
{"lineNum":" 1072","line":"       !(is_specialized_member_serialize<T, OutputArchive>::value ||"},
{"lineNum":" 1073","line":"         is_specialized_member_save<T, OutputArchive>::value))> {};"},
{"lineNum":" 1074","line":""},
{"lineNum":" 1075","line":"    // ######################################################################"},
{"lineNum":" 1076","line":"    // detects if a type has any active minimal input serialization"},
{"lineNum":" 1077","line":"    template <class T, class InputArchive>"},
{"lineNum":" 1078","line":"    struct has_minimal_input_serialization : std::integral_constant<bool,"},
{"lineNum":" 1079","line":"      is_specialized_member_load_minimal<T, InputArchive>::value ||"},
{"lineNum":" 1080","line":"      ((has_member_load_minimal<T, InputArchive>::value ||"},
{"lineNum":" 1081","line":"        has_non_member_load_minimal<T, InputArchive>::value ||"},
{"lineNum":" 1082","line":"        has_member_versioned_load_minimal<T, InputArchive>::value ||"},
{"lineNum":" 1083","line":"        has_non_member_versioned_load_minimal<T, InputArchive>::value) &&"},
{"lineNum":" 1084","line":"       !(is_specialized_member_serialize<T, InputArchive>::value ||"},
{"lineNum":" 1085","line":"         is_specialized_member_load<T, InputArchive>::value))> {};"},
{"lineNum":" 1086","line":""},
{"lineNum":" 1087","line":"    // ######################################################################"},
{"lineNum":" 1088","line":"    namespace detail"},
{"lineNum":" 1089","line":"    {"},
{"lineNum":" 1090","line":"      //! The number of output serialization functions available"},
{"lineNum":" 1091","line":"      /*! If specialization is being used, we\'ll count only those; otherwise we\'ll count everything */"},
{"lineNum":" 1092","line":"      template <class T, class OutputArchive>"},
{"lineNum":" 1093","line":"      struct count_output_serializers : std::integral_constant<int,"},
{"lineNum":" 1094","line":"        count_specializations<T, OutputArchive>::value ? count_specializations<T, OutputArchive>::value :"},
{"lineNum":" 1095","line":"        has_member_save<T, OutputArchive>::value +"},
{"lineNum":" 1096","line":"        has_non_member_save<T, OutputArchive>::value +"},
{"lineNum":" 1097","line":"        has_member_serialize<T, OutputArchive>::value +"},
{"lineNum":" 1098","line":"        has_non_member_serialize<T, OutputArchive>::value +"},
{"lineNum":" 1099","line":"        has_member_save_minimal<T, OutputArchive>::value +"},
{"lineNum":" 1100","line":"        has_non_member_save_minimal<T, OutputArchive>::value +"},
{"lineNum":" 1101","line":"        /*-versioned---------------------------------------------------------*/"},
{"lineNum":" 1102","line":"        has_member_versioned_save<T, OutputArchive>::value +"},
{"lineNum":" 1103","line":"        has_non_member_versioned_save<T, OutputArchive>::value +"},
{"lineNum":" 1104","line":"        has_member_versioned_serialize<T, OutputArchive>::value +"},
{"lineNum":" 1105","line":"        has_non_member_versioned_serialize<T, OutputArchive>::value +"},
{"lineNum":" 1106","line":"        has_member_versioned_save_minimal<T, OutputArchive>::value +"},
{"lineNum":" 1107","line":"        has_non_member_versioned_save_minimal<T, OutputArchive>::value> {};"},
{"lineNum":" 1108","line":"    }"},
{"lineNum":" 1109","line":""},
{"lineNum":" 1110","line":"    template <class T, class OutputArchive>"},
{"lineNum":" 1111","line":"    struct is_output_serializable : std::integral_constant<bool,"},
{"lineNum":" 1112","line":"      detail::count_output_serializers<T, OutputArchive>::value == 1> {};"},
{"lineNum":" 1113","line":""},
{"lineNum":" 1114","line":"    // ######################################################################"},
{"lineNum":" 1115","line":"    namespace detail"},
{"lineNum":" 1116","line":"    {"},
{"lineNum":" 1117","line":"      //! The number of input serialization functions available"},
{"lineNum":" 1118","line":"      /*! If specialization is being used, we\'ll count only those; otherwise we\'ll count everything */"},
{"lineNum":" 1119","line":"      template <class T, class InputArchive>"},
{"lineNum":" 1120","line":"      struct count_input_serializers : std::integral_constant<int,"},
{"lineNum":" 1121","line":"        count_specializations<T, InputArchive>::value ? count_specializations<T, InputArchive>::value :"},
{"lineNum":" 1122","line":"        has_member_load<T, InputArchive>::value +"},
{"lineNum":" 1123","line":"        has_non_member_load<T, InputArchive>::value +"},
{"lineNum":" 1124","line":"        has_member_serialize<T, InputArchive>::value +"},
{"lineNum":" 1125","line":"        has_non_member_serialize<T, InputArchive>::value +"},
{"lineNum":" 1126","line":"        has_member_load_minimal<T, InputArchive>::value +"},
{"lineNum":" 1127","line":"        has_non_member_load_minimal<T, InputArchive>::value +"},
{"lineNum":" 1128","line":"        /*-versioned---------------------------------------------------------*/"},
{"lineNum":" 1129","line":"        has_member_versioned_load<T, InputArchive>::value +"},
{"lineNum":" 1130","line":"        has_non_member_versioned_load<T, InputArchive>::value +"},
{"lineNum":" 1131","line":"        has_member_versioned_serialize<T, InputArchive>::value +"},
{"lineNum":" 1132","line":"        has_non_member_versioned_serialize<T, InputArchive>::value +"},
{"lineNum":" 1133","line":"        has_member_versioned_load_minimal<T, InputArchive>::value +"},
{"lineNum":" 1134","line":"        has_non_member_versioned_load_minimal<T, InputArchive>::value> {};"},
{"lineNum":" 1135","line":"    }"},
{"lineNum":" 1136","line":""},
{"lineNum":" 1137","line":"    template <class T, class InputArchive>"},
{"lineNum":" 1138","line":"    struct is_input_serializable : std::integral_constant<bool,"},
{"lineNum":" 1139","line":"      detail::count_input_serializers<T, InputArchive>::value == 1> {};"},
{"lineNum":" 1140","line":""},
{"lineNum":" 1141","line":"    // ######################################################################"},
{"lineNum":" 1142","line":"    // Base Class Support"},
{"lineNum":" 1143","line":"    namespace detail"},
{"lineNum":" 1144","line":"    {"},
{"lineNum":" 1145","line":"      struct base_class_id"},
{"lineNum":" 1146","line":"      {"},
{"lineNum":" 1147","line":"        template<class T>"},
{"lineNum":" 1148","line":"          base_class_id(T const * const t) :"},
{"lineNum":" 1149","line":"          type(typeid(T)),"},
{"lineNum":" 1150","line":"          ptr(t),","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1151","line":"          hash(std::hash<std::type_index>()(typeid(T)) ^ (std::hash<void const *>()(t) << 1))","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1152","line":"          { }"},
{"lineNum":" 1153","line":""},
{"lineNum":" 1154","line":"          bool operator==(base_class_id const & other) const"},
{"lineNum":" 1155","line":"          { return (type == other.type) && (ptr == other.ptr); }"},
{"lineNum":" 1156","line":""},
{"lineNum":" 1157","line":"          std::type_index type;"},
{"lineNum":" 1158","line":"          void const * ptr;"},
{"lineNum":" 1159","line":"          size_t hash;"},
{"lineNum":" 1160","line":"      };"},
{"lineNum":" 1161","line":"      struct base_class_id_hash { size_t operator()(base_class_id const & id) const { return id.hash; }  };","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1162","line":"    } // namespace detail"},
{"lineNum":" 1163","line":""},
{"lineNum":" 1164","line":"    namespace detail"},
{"lineNum":" 1165","line":"    {"},
{"lineNum":" 1166","line":"      //! Common base type for base class casting"},
{"lineNum":" 1167","line":"      struct BaseCastBase {};"},
{"lineNum":" 1168","line":""},
{"lineNum":" 1169","line":"      template <class>"},
{"lineNum":" 1170","line":"      struct get_base_class;"},
{"lineNum":" 1171","line":""},
{"lineNum":" 1172","line":"      template <template<typename> class Cast, class Base>"},
{"lineNum":" 1173","line":"      struct get_base_class<Cast<Base>>"},
{"lineNum":" 1174","line":"      {"},
{"lineNum":" 1175","line":"        using type = Base;"},
{"lineNum":" 1176","line":"      };"},
{"lineNum":" 1177","line":""},
{"lineNum":" 1178","line":"      //! Base class cast, behave as the test"},
{"lineNum":" 1179","line":"      template <class Cast, template<class, class> class Test, class Archive,"},
{"lineNum":" 1180","line":"                bool IsBaseCast = std::is_base_of<BaseCastBase, Cast>::value>"},
{"lineNum":" 1181","line":"      struct has_minimal_base_class_serialization_impl : Test<typename get_base_class<Cast>::type, Archive>"},
{"lineNum":" 1182","line":"      { };"},
{"lineNum":" 1183","line":""},
{"lineNum":" 1184","line":"      //! Not a base class cast"},
{"lineNum":" 1185","line":"      template <class Cast, template<class, class> class Test, class Archive>"},
{"lineNum":" 1186","line":"      struct has_minimal_base_class_serialization_impl<Cast,Test, Archive, false> : std::false_type"},
{"lineNum":" 1187","line":"      { };"},
{"lineNum":" 1188","line":"    }"},
{"lineNum":" 1189","line":""},
{"lineNum":" 1190","line":"    //! Checks to see if the base class used in a cast has a minimal serialization"},
{"lineNum":" 1191","line":"    /*! @tparam Cast Either base_class or virtual_base_class wrapped type"},
{"lineNum":" 1192","line":"        @tparam Test A has_minimal test (for either input or output)"},
{"lineNum":" 1193","line":"        @tparam Archive The archive to use with the test */"},
{"lineNum":" 1194","line":"    template <class Cast, template<class, class> class Test, class Archive>"},
{"lineNum":" 1195","line":"    struct has_minimal_base_class_serialization : detail::has_minimal_base_class_serialization_impl<Cast, Test, Archive>"},
{"lineNum":" 1196","line":"    { };"},
{"lineNum":" 1197","line":""},
{"lineNum":" 1198","line":""},
{"lineNum":" 1199","line":"    // ######################################################################"},
{"lineNum":" 1200","line":"    namespace detail"},
{"lineNum":" 1201","line":"    {"},
{"lineNum":" 1202","line":"      struct shared_from_this_wrapper"},
{"lineNum":" 1203","line":"      {"},
{"lineNum":" 1204","line":"        template <class U>"},
{"lineNum":" 1205","line":"        static auto (check)( U const & t ) -> decltype( ::cereal::access::shared_from_this(t), std::true_type() );"},
{"lineNum":" 1206","line":""},
{"lineNum":" 1207","line":"        static auto (check)( ... ) -> decltype( std::false_type() );"},
{"lineNum":" 1208","line":""},
{"lineNum":" 1209","line":"        template <class U>"},
{"lineNum":" 1210","line":"        static auto get( U const & t ) -> decltype( t.shared_from_this() );"},
{"lineNum":" 1211","line":"      };"},
{"lineNum":" 1212","line":"    }"},
{"lineNum":" 1213","line":""},
{"lineNum":" 1214","line":"    //! Determine if T or any base class of T has inherited from std::enable_shared_from_this"},
{"lineNum":" 1215","line":"    template<class T>"},
{"lineNum":" 1216","line":"    struct has_shared_from_this : decltype((detail::shared_from_this_wrapper::check)(std::declval<T>()))"},
{"lineNum":" 1217","line":"    { };"},
{"lineNum":" 1218","line":""},
{"lineNum":" 1219","line":"    //! Get the type of the base class of T which inherited from std::enable_shared_from_this"},
{"lineNum":" 1220","line":"    template <class T>"},
{"lineNum":" 1221","line":"    struct get_shared_from_this_base"},
{"lineNum":" 1222","line":"    {"},
{"lineNum":" 1223","line":"      private:"},
{"lineNum":" 1224","line":"        using PtrType = decltype(detail::shared_from_this_wrapper::get(std::declval<T>()));"},
{"lineNum":" 1225","line":"      public:"},
{"lineNum":" 1226","line":"        //! The type of the base of T that inherited from std::enable_shared_from_this"},
{"lineNum":" 1227","line":"        using type = typename std::decay<typename PtrType::element_type>::type;"},
{"lineNum":" 1228","line":"    };"},
{"lineNum":" 1229","line":""},
{"lineNum":" 1230","line":"    // ######################################################################"},
{"lineNum":" 1231","line":"    //! Extracts the true type from something possibly wrapped in a cereal NoConvert"},
{"lineNum":" 1232","line":"    /*! Internally cereal uses some wrapper classes to test the validity of non-member"},
{"lineNum":" 1233","line":"        minimal load and save functions.  This can interfere with user type traits on"},
{"lineNum":" 1234","line":"        templated load and save minimal functions.  To get to the correct underlying type,"},
{"lineNum":" 1235","line":"        users should use strip_minimal when performing any enable_if type type trait checks."},
{"lineNum":" 1236","line":""},
{"lineNum":" 1237","line":"        See the enum serialization in types/common.hpp for an example of using this */"},
{"lineNum":" 1238","line":"    template <class T, bool IsCerealMinimalTrait = std::is_base_of<detail::NoConvertBase, T>::value>"},
{"lineNum":" 1239","line":"    struct strip_minimal"},
{"lineNum":" 1240","line":"    {"},
{"lineNum":" 1241","line":"      using type = T;"},
{"lineNum":" 1242","line":"    };"},
{"lineNum":" 1243","line":""},
{"lineNum":" 1244","line":"    //! Specialization for types wrapped in a NoConvert"},
{"lineNum":" 1245","line":"    template <class T>"},
{"lineNum":" 1246","line":"    struct strip_minimal<T, true>"},
{"lineNum":" 1247","line":"    {"},
{"lineNum":" 1248","line":"      using type = typename T::type;"},
{"lineNum":" 1249","line":"    };"},
{"lineNum":" 1250","line":""},
{"lineNum":" 1251","line":"    // ######################################################################"},
{"lineNum":" 1252","line":"    //! Determines whether the class T can be default constructed by cereal::access"},
{"lineNum":" 1253","line":"    template <class T>"},
{"lineNum":" 1254","line":"    struct is_default_constructible"},
{"lineNum":" 1255","line":"    {"},
{"lineNum":" 1256","line":"      #ifdef CEREAL_OLDER_GCC"},
{"lineNum":" 1257","line":"      template <class TT, class SFINAE = void>"},
{"lineNum":" 1258","line":"      struct test : no {};"},
{"lineNum":" 1259","line":"      template <class TT>"},
{"lineNum":" 1260","line":"      struct test<TT, typename detail::Void< decltype( cereal::access::construct<TT>() ) >::type> : yes {};"},
{"lineNum":" 1261","line":"      static const bool value = test<T>();"},
{"lineNum":" 1262","line":"      #else // NOT CEREAL_OLDER_GCC ========================================="},
{"lineNum":" 1263","line":"      template <class TT>"},
{"lineNum":" 1264","line":"      static auto test(int) -> decltype( cereal::access::construct<TT>(), yes());"},
{"lineNum":" 1265","line":"      template <class>"},
{"lineNum":" 1266","line":"      static no test(...);"},
{"lineNum":" 1267","line":"      static const bool value = std::is_same<decltype(test<T>(0)), yes>::value;"},
{"lineNum":" 1268","line":"      #endif // NOT CEREAL_OLDER_GCC"},
{"lineNum":" 1269","line":"    };"},
{"lineNum":" 1270","line":""},
{"lineNum":" 1271","line":"    // ######################################################################"},
{"lineNum":" 1272","line":"    namespace detail"},
{"lineNum":" 1273","line":"    {"},
{"lineNum":" 1274","line":"      //! Removes all qualifiers and minimal wrappers from an archive"},
{"lineNum":" 1275","line":"      template <class A>"},
{"lineNum":" 1276","line":"      using decay_archive = typename std::decay<typename strip_minimal<A>::type>::type;"},
{"lineNum":" 1277","line":"    }"},
{"lineNum":" 1278","line":""},
{"lineNum":" 1279","line":"    //! Checks if the provided archive type is equal to some cereal archive type"},
{"lineNum":" 1280","line":"    /*! This automatically does things such as std::decay and removing any other wrappers that may be"},
{"lineNum":" 1281","line":"        on the Archive template parameter."},
{"lineNum":" 1282","line":""},
{"lineNum":" 1283","line":"        Example use:"},
{"lineNum":" 1284","line":"        @code{cpp}"},
{"lineNum":" 1285","line":"        // example use to disable a serialization function"},
{"lineNum":" 1286","line":"        template <class Archive, EnableIf<cereal::traits::is_same_archive<Archive, cereal::BinaryOutputArchive>::value> = sfinae>"},
{"lineNum":" 1287","line":"        void save( Archive & ar, MyType const & mt );"},
{"lineNum":" 1288","line":"        @endcode */"},
{"lineNum":" 1289","line":"    template <class ArchiveT, class CerealArchiveT>"},
{"lineNum":" 1290","line":"    struct is_same_archive : std::integral_constant<bool,"},
{"lineNum":" 1291","line":"      std::is_same<detail::decay_archive<ArchiveT>, CerealArchiveT>::value>"},
{"lineNum":" 1292","line":"    { };"},
{"lineNum":" 1293","line":""},
{"lineNum":" 1294","line":"    // ######################################################################"},
{"lineNum":" 1295","line":"    //! A macro to use to restrict which types of archives your function will work for."},
{"lineNum":" 1296","line":"    /*! This requires you to have a template class parameter named Archive and replaces the void return"},
{"lineNum":" 1297","line":"        type for your function."},
{"lineNum":" 1298","line":""},
{"lineNum":" 1299","line":"        INTYPE refers to the input archive type you wish to restrict on."},
{"lineNum":" 1300","line":"        OUTTYPE refers to the output archive type you wish to restrict on."},
{"lineNum":" 1301","line":""},
{"lineNum":" 1302","line":"        For example, if we want to limit a serialize to only work with binary serialization:"},
{"lineNum":" 1303","line":""},
{"lineNum":" 1304","line":"        @code{.cpp}"},
{"lineNum":" 1305","line":"        template <class Archive>"},
{"lineNum":" 1306","line":"        CEREAL_ARCHIVE_RESTRICT(BinaryInputArchive, BinaryOutputArchive)"},
{"lineNum":" 1307","line":"        serialize( Archive & ar, MyCoolType & m )"},
{"lineNum":" 1308","line":"        {"},
{"lineNum":" 1309","line":"          ar & m;"},
{"lineNum":" 1310","line":"        }"},
{"lineNum":" 1311","line":"        @endcode"},
{"lineNum":" 1312","line":""},
{"lineNum":" 1313","line":"        If you need to do more restrictions in your enable_if, you will need to do this by hand."},
{"lineNum":" 1314","line":"     */"},
{"lineNum":" 1315","line":"    #define CEREAL_ARCHIVE_RESTRICT(INTYPE, OUTTYPE) \\"},
{"lineNum":" 1316","line":"    typename std::enable_if<cereal::traits::is_same_archive<Archive, INTYPE>::value || cereal::traits::is_same_archive<Archive, OUTTYPE>::value, void>::type"},
{"lineNum":" 1317","line":""},
{"lineNum":" 1318","line":"    //! Type traits only struct used to mark an archive as human readable (text based)"},
{"lineNum":" 1319","line":"    /*! Archives that wish to identify as text based/human readable should inherit from"},
{"lineNum":" 1320","line":"        this struct */"},
{"lineNum":" 1321","line":"    struct TextArchive {};"},
{"lineNum":" 1322","line":""},
{"lineNum":" 1323","line":"    //! Checks if an archive is a text archive (human readable)"},
{"lineNum":" 1324","line":"    template <class A>"},
{"lineNum":" 1325","line":"    struct is_text_archive : std::integral_constant<bool,"},
{"lineNum":" 1326","line":"      std::is_base_of<TextArchive, detail::decay_archive<A>>::value>"},
{"lineNum":" 1327","line":"    { };"},
{"lineNum":" 1328","line":"  } // namespace traits"},
{"lineNum":" 1329","line":""},
{"lineNum":" 1330","line":"  // ######################################################################"},
{"lineNum":" 1331","line":"  namespace detail"},
{"lineNum":" 1332","line":"  {"},
{"lineNum":" 1333","line":"    template <class T, class A,"},
{"lineNum":" 1334","line":"              bool Member = traits::has_member_load_and_construct<T, A>::value,"},
{"lineNum":" 1335","line":"              bool MemberVersioned = traits::has_member_versioned_load_and_construct<T, A>::value,"},
{"lineNum":" 1336","line":"              bool NonMember = traits::has_non_member_load_and_construct<T, A>::value,"},
{"lineNum":" 1337","line":"              bool NonMemberVersioned = traits::has_non_member_versioned_load_and_construct<T, A>::value>"},
{"lineNum":" 1338","line":"    struct Construct"},
{"lineNum":" 1339","line":"    {"},
{"lineNum":" 1340","line":"      static_assert( cereal::traits::detail::delay_static_assert<T>::value,"},
{"lineNum":" 1341","line":"        \"cereal found more than one compatible load_and_construct function for the provided type and archive combination. \\n\\n \""},
{"lineNum":" 1342","line":"        \"Types must either have a member load_and_construct function or a non-member specialization of LoadAndConstruct (you may not mix these). \\n \""},
{"lineNum":" 1343","line":"        \"In addition, you may not mix versioned with non-versioned load_and_construct functions. \\n\\n \" );"},
{"lineNum":" 1344","line":"      static T * load_andor_construct( A & /*ar*/, construct<T> & /*construct*/ )"},
{"lineNum":" 1345","line":"      { return nullptr; }"},
{"lineNum":" 1346","line":"    };"},
{"lineNum":" 1347","line":""},
{"lineNum":" 1348","line":"    // no load and construct case"},
{"lineNum":" 1349","line":"    template <class T, class A>"},
{"lineNum":" 1350","line":"    struct Construct<T, A, false, false, false, false>"},
{"lineNum":" 1351","line":"    {"},
{"lineNum":" 1352","line":"      static_assert( ::cereal::traits::is_default_constructible<T>::value,"},
{"lineNum":" 1353","line":"                     \"Trying to serialize a an object with no default constructor. \\n\\n \""},
{"lineNum":" 1354","line":"                     \"Types must either be default constructible or define either a member or non member Construct function. \\n \""},
{"lineNum":" 1355","line":"                     \"Construct functions generally have the signature: \\n\\n \""},
{"lineNum":" 1356","line":"                     \"template <class Archive> \\n \""},
{"lineNum":" 1357","line":"                     \"static void load_and_construct(Archive & ar, cereal::construct<T> & construct) \\n \""},
{"lineNum":" 1358","line":"                     \"{ \\n \""},
{"lineNum":" 1359","line":"                     \"  var a; \\n \""},
{"lineNum":" 1360","line":"                     \"  ar( a ) \\n \""},
{"lineNum":" 1361","line":"                     \"  construct( a ); \\n \""},
{"lineNum":" 1362","line":"                     \"} \\n\\n\" );"},
{"lineNum":" 1363","line":"      static T * load_andor_construct()"},
{"lineNum":" 1364","line":"      { return ::cereal::access::construct<T>(); }","class":"lineNoCov","hits":"0","possible_hits":"99",},
{"lineNum":" 1365","line":"    };"},
{"lineNum":" 1366","line":""},
{"lineNum":" 1367","line":"    // member non-versioned"},
{"lineNum":" 1368","line":"    template <class T, class A>"},
{"lineNum":" 1369","line":"    struct Construct<T, A, true, false, false, false>"},
{"lineNum":" 1370","line":"    {"},
{"lineNum":" 1371","line":"      static void load_andor_construct( A & ar, construct<T> & construct )"},
{"lineNum":" 1372","line":"      {"},
{"lineNum":" 1373","line":"        access::load_and_construct<T>( ar, construct );"},
{"lineNum":" 1374","line":"      }"},
{"lineNum":" 1375","line":"    };"},
{"lineNum":" 1376","line":""},
{"lineNum":" 1377","line":"    // member versioned"},
{"lineNum":" 1378","line":"    template <class T, class A>"},
{"lineNum":" 1379","line":"    struct Construct<T, A, false, true, false, false>"},
{"lineNum":" 1380","line":"    {"},
{"lineNum":" 1381","line":"      static void load_andor_construct( A & ar, construct<T> & construct )"},
{"lineNum":" 1382","line":"      {"},
{"lineNum":" 1383","line":"        const auto version = ar.template loadClassVersion<T>();"},
{"lineNum":" 1384","line":"        access::load_and_construct<T>( ar, construct, version );"},
{"lineNum":" 1385","line":"      }"},
{"lineNum":" 1386","line":"    };"},
{"lineNum":" 1387","line":""},
{"lineNum":" 1388","line":"    // non-member non-versioned"},
{"lineNum":" 1389","line":"    template <class T, class A>"},
{"lineNum":" 1390","line":"    struct Construct<T, A, false, false, true, false>"},
{"lineNum":" 1391","line":"    {"},
{"lineNum":" 1392","line":"      static void load_andor_construct( A & ar, construct<T> & construct )"},
{"lineNum":" 1393","line":"      {"},
{"lineNum":" 1394","line":"        LoadAndConstruct<T>::load_and_construct( ar, construct );"},
{"lineNum":" 1395","line":"      }"},
{"lineNum":" 1396","line":"    };"},
{"lineNum":" 1397","line":""},
{"lineNum":" 1398","line":"    // non-member versioned"},
{"lineNum":" 1399","line":"    template <class T, class A>"},
{"lineNum":" 1400","line":"    struct Construct<T, A, false, false, false, true>"},
{"lineNum":" 1401","line":"    {"},
{"lineNum":" 1402","line":"      static void load_andor_construct( A & ar, construct<T> & construct )"},
{"lineNum":" 1403","line":"      {"},
{"lineNum":" 1404","line":"        const auto version = ar.template loadClassVersion<T>();"},
{"lineNum":" 1405","line":"        LoadAndConstruct<T>::load_and_construct( ar, construct, version );"},
{"lineNum":" 1406","line":"      }"},
{"lineNum":" 1407","line":"    };"},
{"lineNum":" 1408","line":"  } // namespace detail"},
{"lineNum":" 1409","line":"} // namespace cereal"},
{"lineNum":" 1410","line":""},
{"lineNum":" 1411","line":"#endif // CEREAL_DETAILS_TRAITS_HPP_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
