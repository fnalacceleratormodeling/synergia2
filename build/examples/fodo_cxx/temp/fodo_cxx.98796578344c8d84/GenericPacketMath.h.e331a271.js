var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_GENERIC_PACKET_MATH_H"},
{"lineNum":"   12","line":"#define EIGEN_GENERIC_PACKET_MATH_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"/** \\internal"},
{"lineNum":"   21","line":"  * \\file GenericPacketMath.h"},
{"lineNum":"   22","line":"  *"},
{"lineNum":"   23","line":"  * Default implementation for types not supported by the vectorization."},
{"lineNum":"   24","line":"  * In practice these functions are provided to make easier the writing"},
{"lineNum":"   25","line":"  * of generic vectorized code."},
{"lineNum":"   26","line":"  */"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"#ifndef EIGEN_DEBUG_ALIGNED_LOAD"},
{"lineNum":"   29","line":"#define EIGEN_DEBUG_ALIGNED_LOAD"},
{"lineNum":"   30","line":"#endif"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"#ifndef EIGEN_DEBUG_UNALIGNED_LOAD"},
{"lineNum":"   33","line":"#define EIGEN_DEBUG_UNALIGNED_LOAD"},
{"lineNum":"   34","line":"#endif"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"#ifndef EIGEN_DEBUG_ALIGNED_STORE"},
{"lineNum":"   37","line":"#define EIGEN_DEBUG_ALIGNED_STORE"},
{"lineNum":"   38","line":"#endif"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"#ifndef EIGEN_DEBUG_UNALIGNED_STORE"},
{"lineNum":"   41","line":"#define EIGEN_DEBUG_UNALIGNED_STORE"},
{"lineNum":"   42","line":"#endif"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"struct default_packet_traits"},
{"lineNum":"   45","line":"{"},
{"lineNum":"   46","line":"  enum {"},
{"lineNum":"   47","line":"    HasHalfPacket = 0,"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"    HasAdd       = 1,"},
{"lineNum":"   50","line":"    HasSub       = 1,"},
{"lineNum":"   51","line":"    HasShift     = 1,"},
{"lineNum":"   52","line":"    HasMul       = 1,"},
{"lineNum":"   53","line":"    HasNegate    = 1,"},
{"lineNum":"   54","line":"    HasAbs       = 1,"},
{"lineNum":"   55","line":"    HasArg       = 0,"},
{"lineNum":"   56","line":"    HasAbs2      = 1,"},
{"lineNum":"   57","line":"    HasAbsDiff   = 0,"},
{"lineNum":"   58","line":"    HasMin       = 1,"},
{"lineNum":"   59","line":"    HasMax       = 1,"},
{"lineNum":"   60","line":"    HasConj      = 1,"},
{"lineNum":"   61","line":"    HasSetLinear = 1,"},
{"lineNum":"   62","line":"    HasBlend     = 0,"},
{"lineNum":"   63","line":"    // This flag is used to indicate whether packet comparison is supported."},
{"lineNum":"   64","line":"    // pcmp_eq, pcmp_lt and pcmp_le should be defined for it to be true."},
{"lineNum":"   65","line":"    HasCmp       = 0,"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"    HasDiv    = 0,"},
{"lineNum":"   68","line":"    HasSqrt   = 0,"},
{"lineNum":"   69","line":"    HasRsqrt  = 0,"},
{"lineNum":"   70","line":"    HasExp    = 0,"},
{"lineNum":"   71","line":"    HasExpm1  = 0,"},
{"lineNum":"   72","line":"    HasLog    = 0,"},
{"lineNum":"   73","line":"    HasLog1p  = 0,"},
{"lineNum":"   74","line":"    HasLog10  = 0,"},
{"lineNum":"   75","line":"    HasPow    = 0,"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"    HasSin    = 0,"},
{"lineNum":"   78","line":"    HasCos    = 0,"},
{"lineNum":"   79","line":"    HasTan    = 0,"},
{"lineNum":"   80","line":"    HasASin   = 0,"},
{"lineNum":"   81","line":"    HasACos   = 0,"},
{"lineNum":"   82","line":"    HasATan   = 0,"},
{"lineNum":"   83","line":"    HasSinh   = 0,"},
{"lineNum":"   84","line":"    HasCosh   = 0,"},
{"lineNum":"   85","line":"    HasTanh   = 0,"},
{"lineNum":"   86","line":"    HasLGamma = 0,"},
{"lineNum":"   87","line":"    HasDiGamma = 0,"},
{"lineNum":"   88","line":"    HasZeta = 0,"},
{"lineNum":"   89","line":"    HasPolygamma = 0,"},
{"lineNum":"   90","line":"    HasErf = 0,"},
{"lineNum":"   91","line":"    HasErfc = 0,"},
{"lineNum":"   92","line":"    HasNdtri = 0,"},
{"lineNum":"   93","line":"    HasBessel = 0,"},
{"lineNum":"   94","line":"    HasIGamma = 0,"},
{"lineNum":"   95","line":"    HasIGammaDerA = 0,"},
{"lineNum":"   96","line":"    HasGammaSampleDerAlpha = 0,"},
{"lineNum":"   97","line":"    HasIGammac = 0,"},
{"lineNum":"   98","line":"    HasBetaInc = 0,"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"    HasRound  = 0,"},
{"lineNum":"  101","line":"    HasRint   = 0,"},
{"lineNum":"  102","line":"    HasFloor  = 0,"},
{"lineNum":"  103","line":"    HasCeil   = 0,"},
{"lineNum":"  104","line":"    HasSign   = 0"},
{"lineNum":"  105","line":"  };"},
{"lineNum":"  106","line":"};"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"template<typename T> struct packet_traits : default_packet_traits"},
{"lineNum":"  109","line":"{"},
{"lineNum":"  110","line":"  typedef T type;"},
{"lineNum":"  111","line":"  typedef T half;"},
{"lineNum":"  112","line":"  enum {"},
{"lineNum":"  113","line":"    Vectorizable = 0,"},
{"lineNum":"  114","line":"    size = 1,"},
{"lineNum":"  115","line":"    AlignedOnScalar = 0,"},
{"lineNum":"  116","line":"    HasHalfPacket = 0"},
{"lineNum":"  117","line":"  };"},
{"lineNum":"  118","line":"  enum {"},
{"lineNum":"  119","line":"    HasAdd    = 0,"},
{"lineNum":"  120","line":"    HasSub    = 0,"},
{"lineNum":"  121","line":"    HasMul    = 0,"},
{"lineNum":"  122","line":"    HasNegate = 0,"},
{"lineNum":"  123","line":"    HasAbs    = 0,"},
{"lineNum":"  124","line":"    HasAbs2   = 0,"},
{"lineNum":"  125","line":"    HasMin    = 0,"},
{"lineNum":"  126","line":"    HasMax    = 0,"},
{"lineNum":"  127","line":"    HasConj   = 0,"},
{"lineNum":"  128","line":"    HasSetLinear = 0"},
{"lineNum":"  129","line":"  };"},
{"lineNum":"  130","line":"};"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"template<typename T> struct packet_traits<const T> : packet_traits<T> { };"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"template<typename T> struct unpacket_traits"},
{"lineNum":"  135","line":"{"},
{"lineNum":"  136","line":"  typedef T type;"},
{"lineNum":"  137","line":"  typedef T half;"},
{"lineNum":"  138","line":"  enum"},
{"lineNum":"  139","line":"  {"},
{"lineNum":"  140","line":"    size = 1,"},
{"lineNum":"  141","line":"    alignment = 1,"},
{"lineNum":"  142","line":"    vectorizable = false,"},
{"lineNum":"  143","line":"    masked_load_available=false,"},
{"lineNum":"  144","line":"    masked_store_available=false"},
{"lineNum":"  145","line":"  };"},
{"lineNum":"  146","line":"};"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"template<typename T> struct unpacket_traits<const T> : unpacket_traits<T> { };"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"template <typename Src, typename Tgt> struct type_casting_traits {"},
{"lineNum":"  151","line":"  enum {"},
{"lineNum":"  152","line":"    VectorizedCast = 0,"},
{"lineNum":"  153","line":"    SrcCoeffRatio = 1,"},
{"lineNum":"  154","line":"    TgtCoeffRatio = 1"},
{"lineNum":"  155","line":"  };"},
{"lineNum":"  156","line":"};"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"/** \\internal Wrapper to ensure that multiple packet types can map to the same"},
{"lineNum":"  159","line":"    same underlying vector type. */"},
{"lineNum":"  160","line":"template<typename T, int unique_id = 0>"},
{"lineNum":"  161","line":"struct eigen_packet_wrapper"},
{"lineNum":"  162","line":"{"},
{"lineNum":"  163","line":"  EIGEN_ALWAYS_INLINE operator T&() { return m_val; }"},
{"lineNum":"  164","line":"  EIGEN_ALWAYS_INLINE operator const T&() const { return m_val; }"},
{"lineNum":"  165","line":"  EIGEN_ALWAYS_INLINE eigen_packet_wrapper() = default;"},
{"lineNum":"  166","line":"  EIGEN_ALWAYS_INLINE eigen_packet_wrapper(const T &v) : m_val(v) {}"},
{"lineNum":"  167","line":"  EIGEN_ALWAYS_INLINE eigen_packet_wrapper& operator=(const T &v) {"},
{"lineNum":"  168","line":"    m_val = v;"},
{"lineNum":"  169","line":"    return *this;"},
{"lineNum":"  170","line":"  }"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  T m_val;"},
{"lineNum":"  173","line":"};"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"/** \\internal A convenience utility for determining if the type is a scalar."},
{"lineNum":"  177","line":" * This is used to enable some generic packet implementations."},
{"lineNum":"  178","line":" */"},
{"lineNum":"  179","line":"template<typename Packet>"},
{"lineNum":"  180","line":"struct is_scalar {"},
{"lineNum":"  181","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  182","line":"  enum {"},
{"lineNum":"  183","line":"    value = internal::is_same<Packet, Scalar>::value"},
{"lineNum":"  184","line":"  };"},
{"lineNum":"  185","line":"};"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"/** \\internal \\returns static_cast<TgtType>(a) (coeff-wise) */"},
{"lineNum":"  188","line":"template <typename SrcPacket, typename TgtPacket>"},
{"lineNum":"  189","line":"EIGEN_DEVICE_FUNC inline TgtPacket"},
{"lineNum":"  190","line":"pcast(const SrcPacket& a) {"},
{"lineNum":"  191","line":"  return static_cast<TgtPacket>(a);"},
{"lineNum":"  192","line":"}"},
{"lineNum":"  193","line":"template <typename SrcPacket, typename TgtPacket>"},
{"lineNum":"  194","line":"EIGEN_DEVICE_FUNC inline TgtPacket"},
{"lineNum":"  195","line":"pcast(const SrcPacket& a, const SrcPacket& /*b*/) {"},
{"lineNum":"  196","line":"  return static_cast<TgtPacket>(a);"},
{"lineNum":"  197","line":"}"},
{"lineNum":"  198","line":"template <typename SrcPacket, typename TgtPacket>"},
{"lineNum":"  199","line":"EIGEN_DEVICE_FUNC inline TgtPacket"},
{"lineNum":"  200","line":"pcast(const SrcPacket& a, const SrcPacket& /*b*/, const SrcPacket& /*c*/, const SrcPacket& /*d*/) {"},
{"lineNum":"  201","line":"  return static_cast<TgtPacket>(a);"},
{"lineNum":"  202","line":"}"},
{"lineNum":"  203","line":"template <typename SrcPacket, typename TgtPacket>"},
{"lineNum":"  204","line":"EIGEN_DEVICE_FUNC inline TgtPacket"},
{"lineNum":"  205","line":"pcast(const SrcPacket& a, const SrcPacket& /*b*/, const SrcPacket& /*c*/, const SrcPacket& /*d*/,"},
{"lineNum":"  206","line":"      const SrcPacket& /*e*/, const SrcPacket& /*f*/, const SrcPacket& /*g*/, const SrcPacket& /*h*/) {"},
{"lineNum":"  207","line":"  return static_cast<TgtPacket>(a);"},
{"lineNum":"  208","line":"}"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"/** \\internal \\returns reinterpret_cast<Target>(a) */"},
{"lineNum":"  211","line":"template <typename Target, typename Packet>"},
{"lineNum":"  212","line":"EIGEN_DEVICE_FUNC inline Target"},
{"lineNum":"  213","line":"preinterpret(const Packet& a); /* { return reinterpret_cast<const Target&>(a); } */"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"/** \\internal \\returns a + b (coeff-wise) */"},
{"lineNum":"  216","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  217","line":"padd(const Packet& a, const Packet& b) { return a+b; }","class":"lineNoCov","hits":"0","possible_hits":"33",},
{"lineNum":"  218","line":"// Avoid compiler warning for boolean algebra."},
{"lineNum":"  219","line":"template<> EIGEN_DEVICE_FUNC inline bool"},
{"lineNum":"  220","line":"padd(const bool& a, const bool& b) { return a || b; }"},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"/** \\internal \\returns a - b (coeff-wise) */"},
{"lineNum":"  223","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  224","line":"psub(const Packet& a, const Packet& b) { return a-b; }"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"/** \\internal \\returns -a (coeff-wise) */"},
{"lineNum":"  227","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  228","line":"pnegate(const Packet& a) { return -a; }"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"template<> EIGEN_DEVICE_FUNC inline bool"},
{"lineNum":"  231","line":"pnegate(const bool& a) { return !a; }"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"/** \\internal \\returns conj(a) (coeff-wise) */"},
{"lineNum":"  234","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  235","line":"pconj(const Packet& a) { return numext::conj(a); }"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"/** \\internal \\returns a * b (coeff-wise) */"},
{"lineNum":"  238","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  239","line":"pmul(const Packet& a, const Packet& b) { return a*b; }","class":"lineNoCov","hits":"0","possible_hits":"282",},
{"lineNum":"  240","line":"// Avoid compiler warning for boolean algebra."},
{"lineNum":"  241","line":"template<> EIGEN_DEVICE_FUNC inline bool"},
{"lineNum":"  242","line":"pmul(const bool& a, const bool& b) { return a && b; }"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"/** \\internal \\returns a / b (coeff-wise) */"},
{"lineNum":"  245","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  246","line":"pdiv(const Packet& a, const Packet& b) { return a/b; }"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"// In the generic case, memset to all one bits."},
{"lineNum":"  249","line":"template<typename Packet, typename EnableIf = void>"},
{"lineNum":"  250","line":"struct ptrue_impl {"},
{"lineNum":"  251","line":"  static EIGEN_DEVICE_FUNC inline Packet run(const Packet& /*a*/){"},
{"lineNum":"  252","line":"    Packet b;"},
{"lineNum":"  253","line":"    memset(static_cast<void*>(&b), 0xff, sizeof(Packet));"},
{"lineNum":"  254","line":"    return b;"},
{"lineNum":"  255","line":"  }"},
{"lineNum":"  256","line":"};"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"// For non-trivial scalars, set to Scalar(1) (i.e. a non-zero value)."},
{"lineNum":"  259","line":"// Although this is technically not a valid bitmask, the scalar path for pselect"},
{"lineNum":"  260","line":"// uses a comparison to zero, so this should still work in most cases. We don\'t"},
{"lineNum":"  261","line":"// have another option, since the scalar type requires initialization."},
{"lineNum":"  262","line":"template<typename T>"},
{"lineNum":"  263","line":"struct ptrue_impl<T,"},
{"lineNum":"  264","line":"    typename internal::enable_if<is_scalar<T>::value && NumTraits<T>::RequireInitialization>::type > {"},
{"lineNum":"  265","line":"  static EIGEN_DEVICE_FUNC inline T run(const T& /*a*/){"},
{"lineNum":"  266","line":"    return T(1);"},
{"lineNum":"  267","line":"  }"},
{"lineNum":"  268","line":"};"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"/** \\internal \\returns one bits. */"},
{"lineNum":"  271","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  272","line":"ptrue(const Packet& a) {"},
{"lineNum":"  273","line":"  return ptrue_impl<Packet>::run(a);"},
{"lineNum":"  274","line":"}"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"// In the general case, memset to zero."},
{"lineNum":"  277","line":"template<typename Packet, typename EnableIf = void>"},
{"lineNum":"  278","line":"struct pzero_impl {"},
{"lineNum":"  279","line":"  static EIGEN_DEVICE_FUNC inline Packet run(const Packet& /*a*/) {"},
{"lineNum":"  280","line":"    Packet b;"},
{"lineNum":"  281","line":"    memset(static_cast<void*>(&b), 0x00, sizeof(Packet));"},
{"lineNum":"  282","line":"    return b;"},
{"lineNum":"  283","line":"  }"},
{"lineNum":"  284","line":"};"},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"// For scalars, explicitly set to Scalar(0), since the underlying representation"},
{"lineNum":"  287","line":"// for zero may not consist of all-zero bits."},
{"lineNum":"  288","line":"template<typename T>"},
{"lineNum":"  289","line":"struct pzero_impl<T,"},
{"lineNum":"  290","line":"    typename internal::enable_if<is_scalar<T>::value>::type> {"},
{"lineNum":"  291","line":"  static EIGEN_DEVICE_FUNC inline T run(const T& /*a*/) {"},
{"lineNum":"  292","line":"    return T(0);"},
{"lineNum":"  293","line":"  }"},
{"lineNum":"  294","line":"};"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"/** \\internal \\returns packet of zeros */"},
{"lineNum":"  297","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  298","line":"pzero(const Packet& a) {"},
{"lineNum":"  299","line":"  return pzero_impl<Packet>::run(a);"},
{"lineNum":"  300","line":"}"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"/** \\internal \\returns a <= b as a bit mask */"},
{"lineNum":"  303","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  304","line":"pcmp_le(const Packet& a, const Packet& b)  { return a<=b ? ptrue(a) : pzero(a); }"},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"/** \\internal \\returns a < b as a bit mask */"},
{"lineNum":"  307","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  308","line":"pcmp_lt(const Packet& a, const Packet& b)  { return a<b ? ptrue(a) : pzero(a); }"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"/** \\internal \\returns a == b as a bit mask */"},
{"lineNum":"  311","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  312","line":"pcmp_eq(const Packet& a, const Packet& b) { return a==b ? ptrue(a) : pzero(a); }"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"/** \\internal \\returns a < b or a==NaN or b==NaN as a bit mask */"},
{"lineNum":"  315","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  316","line":"pcmp_lt_or_nan(const Packet& a, const Packet& b) { return a>=b ? pzero(a) : ptrue(a); }"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"template<typename T>"},
{"lineNum":"  319","line":"struct bit_and {"},
{"lineNum":"  320","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR EIGEN_ALWAYS_INLINE T operator()(const T& a, const T& b) const {"},
{"lineNum":"  321","line":"    return a & b;"},
{"lineNum":"  322","line":"  }"},
{"lineNum":"  323","line":"};"},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"template<typename T>"},
{"lineNum":"  326","line":"struct bit_or {"},
{"lineNum":"  327","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR EIGEN_ALWAYS_INLINE T operator()(const T& a, const T& b) const {"},
{"lineNum":"  328","line":"    return a | b;"},
{"lineNum":"  329","line":"  }"},
{"lineNum":"  330","line":"};"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"template<typename T>"},
{"lineNum":"  333","line":"struct bit_xor {"},
{"lineNum":"  334","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR EIGEN_ALWAYS_INLINE T operator()(const T& a, const T& b) const {"},
{"lineNum":"  335","line":"    return a ^ b;"},
{"lineNum":"  336","line":"  }"},
{"lineNum":"  337","line":"};"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"template<typename T>"},
{"lineNum":"  340","line":"struct bit_not {"},
{"lineNum":"  341","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR EIGEN_ALWAYS_INLINE T operator()(const T& a) const {"},
{"lineNum":"  342","line":"    return ~a;"},
{"lineNum":"  343","line":"  }"},
{"lineNum":"  344","line":"};"},
{"lineNum":"  345","line":""},
{"lineNum":"  346","line":"// Use operators &, |, ^, ~."},
{"lineNum":"  347","line":"template<typename T>"},
{"lineNum":"  348","line":"struct operator_bitwise_helper {"},
{"lineNum":"  349","line":"  EIGEN_DEVICE_FUNC static inline T bitwise_and(const T& a, const T& b) { return bit_and<T>()(a, b); }"},
{"lineNum":"  350","line":"  EIGEN_DEVICE_FUNC static inline T bitwise_or(const T& a, const T& b) { return bit_or<T>()(a, b); }"},
{"lineNum":"  351","line":"  EIGEN_DEVICE_FUNC static inline T bitwise_xor(const T& a, const T& b) { return bit_xor<T>()(a, b); }"},
{"lineNum":"  352","line":"  EIGEN_DEVICE_FUNC static inline T bitwise_not(const T& a) { return bit_not<T>()(a); }"},
{"lineNum":"  353","line":"};"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"// Apply binary operations byte-by-byte"},
{"lineNum":"  356","line":"template<typename T>"},
{"lineNum":"  357","line":"struct bytewise_bitwise_helper {"},
{"lineNum":"  358","line":"  EIGEN_DEVICE_FUNC static inline T bitwise_and(const T& a, const T& b) {"},
{"lineNum":"  359","line":"    return binary(a, b, bit_and<unsigned char>());"},
{"lineNum":"  360","line":"  }"},
{"lineNum":"  361","line":"  EIGEN_DEVICE_FUNC static inline T bitwise_or(const T& a, const T& b) {"},
{"lineNum":"  362","line":"    return binary(a, b, bit_or<unsigned char>());"},
{"lineNum":"  363","line":"   }"},
{"lineNum":"  364","line":"  EIGEN_DEVICE_FUNC static inline T bitwise_xor(const T& a, const T& b) {"},
{"lineNum":"  365","line":"    return binary(a, b, bit_xor<unsigned char>());"},
{"lineNum":"  366","line":"  }"},
{"lineNum":"  367","line":"  EIGEN_DEVICE_FUNC static inline T bitwise_not(const T& a) {"},
{"lineNum":"  368","line":"    return unary(a,bit_not<unsigned char>());"},
{"lineNum":"  369","line":"   }"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":" private:"},
{"lineNum":"  372","line":"  template<typename Op>"},
{"lineNum":"  373","line":"  EIGEN_DEVICE_FUNC static inline T unary(const T& a, Op op) {"},
{"lineNum":"  374","line":"    const unsigned char* a_ptr = reinterpret_cast<const unsigned char*>(&a);"},
{"lineNum":"  375","line":"    T c;"},
{"lineNum":"  376","line":"    unsigned char* c_ptr = reinterpret_cast<unsigned char*>(&c);"},
{"lineNum":"  377","line":"    for (size_t i = 0; i < sizeof(T); ++i) {"},
{"lineNum":"  378","line":"      *c_ptr++ = op(*a_ptr++);"},
{"lineNum":"  379","line":"    }"},
{"lineNum":"  380","line":"    return c;"},
{"lineNum":"  381","line":"  }"},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"  template<typename Op>"},
{"lineNum":"  384","line":"  EIGEN_DEVICE_FUNC static inline T binary(const T& a, const T& b, Op op) {"},
{"lineNum":"  385","line":"    const unsigned char* a_ptr = reinterpret_cast<const unsigned char*>(&a);"},
{"lineNum":"  386","line":"    const unsigned char* b_ptr = reinterpret_cast<const unsigned char*>(&b);"},
{"lineNum":"  387","line":"    T c;"},
{"lineNum":"  388","line":"    unsigned char* c_ptr = reinterpret_cast<unsigned char*>(&c);"},
{"lineNum":"  389","line":"    for (size_t i = 0; i < sizeof(T); ++i) {"},
{"lineNum":"  390","line":"      *c_ptr++ = op(*a_ptr++, *b_ptr++);"},
{"lineNum":"  391","line":"    }"},
{"lineNum":"  392","line":"    return c;"},
{"lineNum":"  393","line":"  }"},
{"lineNum":"  394","line":"};"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"// In the general case, use byte-by-byte manipulation."},
{"lineNum":"  397","line":"template<typename T, typename EnableIf = void>"},
{"lineNum":"  398","line":"struct bitwise_helper : public bytewise_bitwise_helper<T> {};"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"// For integers or non-trivial scalars, use binary operators."},
{"lineNum":"  401","line":"template<typename T>"},
{"lineNum":"  402","line":"struct bitwise_helper<T,"},
{"lineNum":"  403","line":"  typename internal::enable_if<"},
{"lineNum":"  404","line":"    is_scalar<T>::value && (NumTraits<T>::IsInteger || NumTraits<T>::RequireInitialization)>::type"},
{"lineNum":"  405","line":"  > : public operator_bitwise_helper<T> {};"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"/** \\internal \\returns the bitwise and of \\a a and \\a b */"},
{"lineNum":"  408","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  409","line":"pand(const Packet& a, const Packet& b) {"},
{"lineNum":"  410","line":"  return bitwise_helper<Packet>::bitwise_and(a, b);"},
{"lineNum":"  411","line":"}"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"/** \\internal \\returns the bitwise or of \\a a and \\a b */"},
{"lineNum":"  414","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  415","line":"por(const Packet& a, const Packet& b) {"},
{"lineNum":"  416","line":"  return bitwise_helper<Packet>::bitwise_or(a, b);"},
{"lineNum":"  417","line":"}"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"/** \\internal \\returns the bitwise xor of \\a a and \\a b */"},
{"lineNum":"  420","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  421","line":"pxor(const Packet& a, const Packet& b) {"},
{"lineNum":"  422","line":"  return bitwise_helper<Packet>::bitwise_xor(a, b);"},
{"lineNum":"  423","line":"}"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"/** \\internal \\returns the bitwise not of \\a a */"},
{"lineNum":"  426","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  427","line":"pnot(const Packet& a) {"},
{"lineNum":"  428","line":"  return bitwise_helper<Packet>::bitwise_not(a);"},
{"lineNum":"  429","line":"}"},
{"lineNum":"  430","line":""},
{"lineNum":"  431","line":"/** \\internal \\returns the bitwise and of \\a a and not \\a b */"},
{"lineNum":"  432","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  433","line":"pandnot(const Packet& a, const Packet& b) { return pand(a, pnot(b)); }"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"// In the general case, use bitwise select."},
{"lineNum":"  436","line":"template<typename Packet, typename EnableIf = void>"},
{"lineNum":"  437","line":"struct pselect_impl {"},
{"lineNum":"  438","line":"  static EIGEN_DEVICE_FUNC inline Packet run(const Packet& mask, const Packet& a, const Packet& b) {"},
{"lineNum":"  439","line":"    return por(pand(a,mask),pandnot(b,mask));"},
{"lineNum":"  440","line":"  }"},
{"lineNum":"  441","line":"};"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"// For scalars, use ternary select."},
{"lineNum":"  444","line":"template<typename Packet>"},
{"lineNum":"  445","line":"struct pselect_impl<Packet,"},
{"lineNum":"  446","line":"    typename internal::enable_if<is_scalar<Packet>::value>::type > {"},
{"lineNum":"  447","line":"  static EIGEN_DEVICE_FUNC inline Packet run(const Packet& mask, const Packet& a, const Packet& b) {"},
{"lineNum":"  448","line":"    return numext::equal_strict(mask, Packet(0)) ? b : a;"},
{"lineNum":"  449","line":"  }"},
{"lineNum":"  450","line":"};"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"/** \\internal \\returns \\a or \\b for each field in packet according to \\mask */"},
{"lineNum":"  453","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  454","line":"pselect(const Packet& mask, const Packet& a, const Packet& b) {"},
{"lineNum":"  455","line":"  return pselect_impl<Packet>::run(mask, a, b);"},
{"lineNum":"  456","line":"}"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"template<> EIGEN_DEVICE_FUNC inline bool pselect<bool>("},
{"lineNum":"  459","line":"    const bool& cond, const bool& a, const bool& b) {"},
{"lineNum":"  460","line":"  return cond ? a : b;"},
{"lineNum":"  461","line":"}"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"/** \\internal \\returns the min or of \\a a and \\a b (coeff-wise)"},
{"lineNum":"  464","line":"    If either \\a a or \\a b are NaN, the result is implementation defined. */"},
{"lineNum":"  465","line":"template<int NaNPropagation>"},
{"lineNum":"  466","line":"struct pminmax_impl {"},
{"lineNum":"  467","line":"  template <typename Packet, typename Op>"},
{"lineNum":"  468","line":"  static EIGEN_DEVICE_FUNC inline Packet run(const Packet& a, const Packet& b, Op op) {"},
{"lineNum":"  469","line":"    return op(a,b);"},
{"lineNum":"  470","line":"  }"},
{"lineNum":"  471","line":"};"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"/** \\internal \\returns the min or max of \\a a and \\a b (coeff-wise)"},
{"lineNum":"  474","line":"    If either \\a a or \\a b are NaN, NaN is returned. */"},
{"lineNum":"  475","line":"template<>"},
{"lineNum":"  476","line":"struct pminmax_impl<PropagateNaN> {"},
{"lineNum":"  477","line":"  template <typename Packet, typename Op>"},
{"lineNum":"  478","line":"  static EIGEN_DEVICE_FUNC inline Packet run(const Packet& a, const Packet& b, Op op) {"},
{"lineNum":"  479","line":"  Packet not_nan_mask_a = pcmp_eq(a, a);"},
{"lineNum":"  480","line":"  Packet not_nan_mask_b = pcmp_eq(b, b);"},
{"lineNum":"  481","line":"  return pselect(not_nan_mask_a,"},
{"lineNum":"  482","line":"                 pselect(not_nan_mask_b, op(a, b), b),"},
{"lineNum":"  483","line":"                 a);"},
{"lineNum":"  484","line":"  }"},
{"lineNum":"  485","line":"};"},
{"lineNum":"  486","line":""},
{"lineNum":"  487","line":"/** \\internal \\returns the min or max of \\a a and \\a b (coeff-wise)"},
{"lineNum":"  488","line":"    If both \\a a and \\a b are NaN, NaN is returned."},
{"lineNum":"  489","line":"    Equivalent to std::fmin(a, b).  */"},
{"lineNum":"  490","line":"template<>"},
{"lineNum":"  491","line":"struct pminmax_impl<PropagateNumbers> {"},
{"lineNum":"  492","line":"  template <typename Packet, typename Op>"},
{"lineNum":"  493","line":"  static EIGEN_DEVICE_FUNC inline Packet run(const Packet& a, const Packet& b, Op op) {"},
{"lineNum":"  494","line":"  Packet not_nan_mask_a = pcmp_eq(a, a);"},
{"lineNum":"  495","line":"  Packet not_nan_mask_b = pcmp_eq(b, b);"},
{"lineNum":"  496","line":"  return pselect(not_nan_mask_a,"},
{"lineNum":"  497","line":"                 pselect(not_nan_mask_b, op(a, b), a),"},
{"lineNum":"  498","line":"                 b);"},
{"lineNum":"  499","line":"  }"},
{"lineNum":"  500","line":"};"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"#ifndef SYCL_DEVICE_ONLY"},
{"lineNum":"  504","line":"#define EIGEN_BINARY_OP_NAN_PROPAGATION(Type, Func) Func"},
{"lineNum":"  505","line":"#else"},
{"lineNum":"  506","line":"#define EIGEN_BINARY_OP_NAN_PROPAGATION(Type, Func) \\"},
{"lineNum":"  507","line":"[](const Type& a, const Type& b) { \\"},
{"lineNum":"  508","line":"        return Func(a, b);}"},
{"lineNum":"  509","line":"#endif"},
{"lineNum":"  510","line":""},
{"lineNum":"  511","line":"/** \\internal \\returns the min of \\a a and \\a b  (coeff-wise)."},
{"lineNum":"  512","line":"    If \\a a or \\b b is NaN, the return value is implementation defined. */"},
{"lineNum":"  513","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  514","line":"pmin(const Packet& a, const Packet& b) { return numext::mini(a,b); }"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"/** \\internal \\returns the min of \\a a and \\a b  (coeff-wise)."},
{"lineNum":"  517","line":"    NaNPropagation determines the NaN propagation semantics. */"},
{"lineNum":"  518","line":"template <int NaNPropagation, typename Packet>"},
{"lineNum":"  519","line":"EIGEN_DEVICE_FUNC inline Packet pmin(const Packet& a, const Packet& b) {"},
{"lineNum":"  520","line":"  return pminmax_impl<NaNPropagation>::run(a, b, EIGEN_BINARY_OP_NAN_PROPAGATION(Packet, (pmin<Packet>)));"},
{"lineNum":"  521","line":"}"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"/** \\internal \\returns the max of \\a a and \\a b  (coeff-wise)"},
{"lineNum":"  524","line":"    If \\a a or \\b b is NaN, the return value is implementation defined. */"},
{"lineNum":"  525","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  526","line":"pmax(const Packet& a, const Packet& b) { return numext::maxi(a, b); }"},
{"lineNum":"  527","line":""},
{"lineNum":"  528","line":"/** \\internal \\returns the max of \\a a and \\a b  (coeff-wise)."},
{"lineNum":"  529","line":"    NaNPropagation determines the NaN propagation semantics. */"},
{"lineNum":"  530","line":"template <int NaNPropagation, typename Packet>"},
{"lineNum":"  531","line":"EIGEN_DEVICE_FUNC inline Packet pmax(const Packet& a, const Packet& b) {"},
{"lineNum":"  532","line":"  return pminmax_impl<NaNPropagation>::run(a, b, EIGEN_BINARY_OP_NAN_PROPAGATION(Packet,(pmax<Packet>)));"},
{"lineNum":"  533","line":"}"},
{"lineNum":"  534","line":""},
{"lineNum":"  535","line":"/** \\internal \\returns the absolute value of \\a a */"},
{"lineNum":"  536","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  537","line":"pabs(const Packet& a) { return numext::abs(a); }"},
{"lineNum":"  538","line":"template<> EIGEN_DEVICE_FUNC inline unsigned int"},
{"lineNum":"  539","line":"pabs(const unsigned int& a) { return a; }"},
{"lineNum":"  540","line":"template<> EIGEN_DEVICE_FUNC inline unsigned long"},
{"lineNum":"  541","line":"pabs(const unsigned long& a) { return a; }"},
{"lineNum":"  542","line":"template<> EIGEN_DEVICE_FUNC inline unsigned long long"},
{"lineNum":"  543","line":"pabs(const unsigned long long& a) { return a; }"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"/** \\internal \\returns the addsub value of \\a a,b */"},
{"lineNum":"  546","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  547","line":"paddsub(const Packet& a, const Packet& b) {"},
{"lineNum":"  548","line":"  return pselect(peven_mask(a), padd(a, b), psub(a, b));"},
{"lineNum":"  549","line":" }"},
{"lineNum":"  550","line":""},
{"lineNum":"  551","line":"/** \\internal \\returns the phase angle of \\a a */"},
{"lineNum":"  552","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  553","line":"parg(const Packet& a) { using numext::arg; return arg(a); }"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"/** \\internal \\returns \\a a logically shifted by N bits to the right */"},
{"lineNum":"  557","line":"template<int N> EIGEN_DEVICE_FUNC inline int"},
{"lineNum":"  558","line":"parithmetic_shift_right(const int& a) { return a >> N; }"},
{"lineNum":"  559","line":"template<int N> EIGEN_DEVICE_FUNC inline long int"},
{"lineNum":"  560","line":"parithmetic_shift_right(const long int& a) { return a >> N; }"},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"/** \\internal \\returns \\a a arithmetically shifted by N bits to the right */"},
{"lineNum":"  563","line":"template<int N> EIGEN_DEVICE_FUNC inline int"},
{"lineNum":"  564","line":"plogical_shift_right(const int& a) { return static_cast<int>(static_cast<unsigned int>(a) >> N); }"},
{"lineNum":"  565","line":"template<int N> EIGEN_DEVICE_FUNC inline long int"},
{"lineNum":"  566","line":"plogical_shift_right(const long int& a) { return static_cast<long>(static_cast<unsigned long>(a) >> N); }"},
{"lineNum":"  567","line":""},
{"lineNum":"  568","line":"/** \\internal \\returns \\a a shifted by N bits to the left */"},
{"lineNum":"  569","line":"template<int N> EIGEN_DEVICE_FUNC inline int"},
{"lineNum":"  570","line":"plogical_shift_left(const int& a) { return a << N; }"},
{"lineNum":"  571","line":"template<int N> EIGEN_DEVICE_FUNC inline long int"},
{"lineNum":"  572","line":"plogical_shift_left(const long int& a) { return a << N; }"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"/** \\internal \\returns the significant and exponent of the underlying floating point numbers"},
{"lineNum":"  575","line":"  * See https://en.cppreference.com/w/cpp/numeric/math/frexp"},
{"lineNum":"  576","line":"  */"},
{"lineNum":"  577","line":"template <typename Packet>"},
{"lineNum":"  578","line":"EIGEN_DEVICE_FUNC inline Packet pfrexp(const Packet& a, Packet& exponent) {"},
{"lineNum":"  579","line":"  int exp;"},
{"lineNum":"  580","line":"  EIGEN_USING_STD(frexp);"},
{"lineNum":"  581","line":"  Packet result = static_cast<Packet>(frexp(a, &exp));"},
{"lineNum":"  582","line":"  exponent = static_cast<Packet>(exp);"},
{"lineNum":"  583","line":"  return result;"},
{"lineNum":"  584","line":"}"},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"/** \\internal \\returns a * 2^((int)exponent)"},
{"lineNum":"  587","line":"  * See https://en.cppreference.com/w/cpp/numeric/math/ldexp"},
{"lineNum":"  588","line":"  */"},
{"lineNum":"  589","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  590","line":"pldexp(const Packet &a, const Packet &exponent) {"},
{"lineNum":"  591","line":"  EIGEN_USING_STD(ldexp)"},
{"lineNum":"  592","line":"  return static_cast<Packet>(ldexp(a, static_cast<int>(exponent)));"},
{"lineNum":"  593","line":"}"},
{"lineNum":"  594","line":""},
{"lineNum":"  595","line":"/** \\internal \\returns the min of \\a a and \\a b  (coeff-wise) */"},
{"lineNum":"  596","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  597","line":"pabsdiff(const Packet& a, const Packet& b) { return pselect(pcmp_lt(a, b), psub(b, a), psub(a, b)); }"},
{"lineNum":"  598","line":""},
{"lineNum":"  599","line":"/** \\internal \\returns a packet version of \\a *from, from must be 16 bytes aligned */"},
{"lineNum":"  600","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  601","line":"pload(const typename unpacket_traits<Packet>::type* from) { return *from; }"},
{"lineNum":"  602","line":""},
{"lineNum":"  603","line":"/** \\internal \\returns a packet version of \\a *from, (un-aligned load) */"},
{"lineNum":"  604","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  605","line":"ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"/** \\internal \\returns a packet version of \\a *from, (un-aligned masked load)"},
{"lineNum":"  608","line":" * There is no generic implementation. We only have implementations for specialized"},
{"lineNum":"  609","line":" * cases. Generic case should not be called."},
{"lineNum":"  610","line":" */"},
{"lineNum":"  611","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline"},
{"lineNum":"  612","line":"typename enable_if<unpacket_traits<Packet>::masked_load_available, Packet>::type"},
{"lineNum":"  613","line":"ploadu(const typename unpacket_traits<Packet>::type* from, typename unpacket_traits<Packet>::mask_t umask);"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"/** \\internal \\returns a packet with constant coefficients \\a a, e.g.: (a,a,a,a) */"},
{"lineNum":"  616","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  617","line":"pset1(const typename unpacket_traits<Packet>::type& a) { return a; }"},
{"lineNum":"  618","line":""},
{"lineNum":"  619","line":"/** \\internal \\returns a packet with constant coefficients set from bits */"},
{"lineNum":"  620","line":"template<typename Packet,typename BitsType> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  621","line":"pset1frombits(BitsType a);"},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"/** \\internal \\returns a packet with constant coefficients \\a a[0], e.g.: (a[0],a[0],a[0],a[0]) */"},
{"lineNum":"  624","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  625","line":"pload1(const typename unpacket_traits<Packet>::type  *a) { return pset1<Packet>(*a); }"},
{"lineNum":"  626","line":""},
{"lineNum":"  627","line":"/** \\internal \\returns a packet with elements of \\a *from duplicated."},
{"lineNum":"  628","line":"  * For instance, for a packet of 8 elements, 4 scalars will be read from \\a *from and"},
{"lineNum":"  629","line":"  * duplicated to form: {from[0],from[0],from[1],from[1],from[2],from[2],from[3],from[3]}"},
{"lineNum":"  630","line":"  * Currently, this function is only used for scalar * complex products."},
{"lineNum":"  631","line":"  */"},
{"lineNum":"  632","line":"template<typename Packet> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet"},
{"lineNum":"  633","line":"ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"/** \\internal \\returns a packet with elements of \\a *from quadrupled."},
{"lineNum":"  636","line":"  * For instance, for a packet of 8 elements, 2 scalars will be read from \\a *from and"},
{"lineNum":"  637","line":"  * replicated to form: {from[0],from[0],from[0],from[0],from[1],from[1],from[1],from[1]}"},
{"lineNum":"  638","line":"  * Currently, this function is only used in matrix products."},
{"lineNum":"  639","line":"  * For packet-size smaller or equal to 4, this function is equivalent to pload1"},
{"lineNum":"  640","line":"  */"},
{"lineNum":"  641","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  642","line":"ploadquad(const typename unpacket_traits<Packet>::type* from)"},
{"lineNum":"  643","line":"{ return pload1<Packet>(from); }"},
{"lineNum":"  644","line":""},
{"lineNum":"  645","line":"/** \\internal equivalent to"},
{"lineNum":"  646","line":"  * \\code"},
{"lineNum":"  647","line":"  * a0 = pload1(a+0);"},
{"lineNum":"  648","line":"  * a1 = pload1(a+1);"},
{"lineNum":"  649","line":"  * a2 = pload1(a+2);"},
{"lineNum":"  650","line":"  * a3 = pload1(a+3);"},
{"lineNum":"  651","line":"  * \\endcode"},
{"lineNum":"  652","line":"  * \\sa pset1, pload1, ploaddup, pbroadcast2"},
{"lineNum":"  653","line":"  */"},
{"lineNum":"  654","line":"template<typename Packet> EIGEN_DEVICE_FUNC"},
{"lineNum":"  655","line":"inline void pbroadcast4(const typename unpacket_traits<Packet>::type *a,"},
{"lineNum":"  656","line":"                        Packet& a0, Packet& a1, Packet& a2, Packet& a3)"},
{"lineNum":"  657","line":"{"},
{"lineNum":"  658","line":"  a0 = pload1<Packet>(a+0);"},
{"lineNum":"  659","line":"  a1 = pload1<Packet>(a+1);"},
{"lineNum":"  660","line":"  a2 = pload1<Packet>(a+2);"},
{"lineNum":"  661","line":"  a3 = pload1<Packet>(a+3);"},
{"lineNum":"  662","line":"}"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"/** \\internal equivalent to"},
{"lineNum":"  665","line":"  * \\code"},
{"lineNum":"  666","line":"  * a0 = pload1(a+0);"},
{"lineNum":"  667","line":"  * a1 = pload1(a+1);"},
{"lineNum":"  668","line":"  * \\endcode"},
{"lineNum":"  669","line":"  * \\sa pset1, pload1, ploaddup, pbroadcast4"},
{"lineNum":"  670","line":"  */"},
{"lineNum":"  671","line":"template<typename Packet> EIGEN_DEVICE_FUNC"},
{"lineNum":"  672","line":"inline void pbroadcast2(const typename unpacket_traits<Packet>::type *a,"},
{"lineNum":"  673","line":"                        Packet& a0, Packet& a1)"},
{"lineNum":"  674","line":"{"},
{"lineNum":"  675","line":"  a0 = pload1<Packet>(a+0);"},
{"lineNum":"  676","line":"  a1 = pload1<Packet>(a+1);"},
{"lineNum":"  677","line":"}"},
{"lineNum":"  678","line":""},
{"lineNum":"  679","line":"/** \\internal \\brief Returns a packet with coefficients (a,a+1,...,a+packet_size-1). */"},
{"lineNum":"  680","line":"template<typename Packet> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Packet"},
{"lineNum":"  681","line":"plset(const typename unpacket_traits<Packet>::type& a) { return a; }"},
{"lineNum":"  682","line":""},
{"lineNum":"  683","line":"/** \\internal \\returns a packet with constant coefficients \\a a, e.g.: (x, 0, x, 0),"},
{"lineNum":"  684","line":"     where x is the value of all 1-bits. */"},
{"lineNum":"  685","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  686","line":"peven_mask(const Packet& /*a*/) {"},
{"lineNum":"  687","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  688","line":"  const size_t n = unpacket_traits<Packet>::size;"},
{"lineNum":"  689","line":"  EIGEN_ALIGN_TO_BOUNDARY(sizeof(Packet)) Scalar elements[n];"},
{"lineNum":"  690","line":"  for(size_t i = 0; i < n; ++i) {"},
{"lineNum":"  691","line":"    memset(elements+i, ((i & 1) == 0 ? 0xff : 0), sizeof(Scalar));"},
{"lineNum":"  692","line":"  }"},
{"lineNum":"  693","line":"  return ploadu<Packet>(elements);"},
{"lineNum":"  694","line":"}"},
{"lineNum":"  695","line":""},
{"lineNum":"  696","line":""},
{"lineNum":"  697","line":"/** \\internal copy the packet \\a from to \\a *to, \\a to must be 16 bytes aligned */"},
{"lineNum":"  698","line":"template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pstore(Scalar* to, const Packet& from)"},
{"lineNum":"  699","line":"{ (*to) = from; }"},
{"lineNum":"  700","line":""},
{"lineNum":"  701","line":"/** \\internal copy the packet \\a from to \\a *to, (un-aligned store) */"},
{"lineNum":"  702","line":"template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pstoreu(Scalar* to, const Packet& from)"},
{"lineNum":"  703","line":"{  (*to) = from; }"},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"/** \\internal copy the packet \\a from to \\a *to, (un-aligned store with a mask)"},
{"lineNum":"  706","line":" * There is no generic implementation. We only have implementations for specialized"},
{"lineNum":"  707","line":" * cases. Generic case should not be called."},
{"lineNum":"  708","line":" */"},
{"lineNum":"  709","line":"template<typename Scalar, typename Packet>"},
{"lineNum":"  710","line":"EIGEN_DEVICE_FUNC inline"},
{"lineNum":"  711","line":"typename enable_if<unpacket_traits<Packet>::masked_store_available, void>::type"},
{"lineNum":"  712","line":"pstoreu(Scalar* to, const Packet& from, typename unpacket_traits<Packet>::mask_t umask);"},
{"lineNum":"  713","line":""},
{"lineNum":"  714","line":" template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline Packet pgather(const Scalar* from, Index /*stride*/)"},
{"lineNum":"  715","line":" { return ploadu<Packet>(from); }"},
{"lineNum":"  716","line":""},
{"lineNum":"  717","line":" template<typename Scalar, typename Packet> EIGEN_DEVICE_FUNC inline void pscatter(Scalar* to, const Packet& from, Index /*stride*/)"},
{"lineNum":"  718","line":" { pstore(to, from); }"},
{"lineNum":"  719","line":""},
{"lineNum":"  720","line":"/** \\internal tries to do cache prefetching of \\a addr */"},
{"lineNum":"  721","line":"template<typename Scalar> EIGEN_DEVICE_FUNC inline void prefetch(const Scalar* addr)"},
{"lineNum":"  722","line":"{"},
{"lineNum":"  723","line":"#if defined(EIGEN_HIP_DEVICE_COMPILE)"},
{"lineNum":"  724","line":"  // do nothing"},
{"lineNum":"  725","line":"#elif defined(EIGEN_CUDA_ARCH)"},
{"lineNum":"  726","line":"#if defined(__LP64__) || EIGEN_OS_WIN64"},
{"lineNum":"  727","line":"  // 64-bit pointer operand constraint for inlined asm"},
{"lineNum":"  728","line":"  asm(\" prefetch.L1 [ %1 ];\" : \"=l\"(addr) : \"l\"(addr));"},
{"lineNum":"  729","line":"#else"},
{"lineNum":"  730","line":"  // 32-bit pointer operand constraint for inlined asm"},
{"lineNum":"  731","line":"  asm(\" prefetch.L1 [ %1 ];\" : \"=r\"(addr) : \"r\"(addr));"},
{"lineNum":"  732","line":"#endif"},
{"lineNum":"  733","line":"#elif (!EIGEN_COMP_MSVC) && (EIGEN_COMP_GNUC || EIGEN_COMP_CLANG || EIGEN_COMP_ICC)"},
{"lineNum":"  734","line":"  __builtin_prefetch(addr);"},
{"lineNum":"  735","line":"#endif"},
{"lineNum":"  736","line":"}"},
{"lineNum":"  737","line":""},
{"lineNum":"  738","line":"/** \\internal \\returns the reversed elements of \\a a*/"},
{"lineNum":"  739","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet preverse(const Packet& a)"},
{"lineNum":"  740","line":"{ return a; }"},
{"lineNum":"  741","line":""},
{"lineNum":"  742","line":"/** \\internal \\returns \\a a with real and imaginary part flipped (for complex type only) */"},
{"lineNum":"  743","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet pcplxflip(const Packet& a)"},
{"lineNum":"  744","line":"{"},
{"lineNum":"  745","line":"  return Packet(numext::imag(a),numext::real(a));"},
{"lineNum":"  746","line":"}"},
{"lineNum":"  747","line":""},
{"lineNum":"  748","line":"/**************************"},
{"lineNum":"  749","line":"* Special math functions"},
{"lineNum":"  750","line":"***************************/"},
{"lineNum":"  751","line":""},
{"lineNum":"  752","line":"/** \\internal \\returns the sine of \\a a (coeff-wise) */"},
{"lineNum":"  753","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  754","line":"Packet psin(const Packet& a) { EIGEN_USING_STD(sin); return sin(a); }"},
{"lineNum":"  755","line":""},
{"lineNum":"  756","line":"/** \\internal \\returns the cosine of \\a a (coeff-wise) */"},
{"lineNum":"  757","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  758","line":"Packet pcos(const Packet& a) { EIGEN_USING_STD(cos); return cos(a); }"},
{"lineNum":"  759","line":""},
{"lineNum":"  760","line":"/** \\internal \\returns the tan of \\a a (coeff-wise) */"},
{"lineNum":"  761","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  762","line":"Packet ptan(const Packet& a) { EIGEN_USING_STD(tan); return tan(a); }"},
{"lineNum":"  763","line":""},
{"lineNum":"  764","line":"/** \\internal \\returns the arc sine of \\a a (coeff-wise) */"},
{"lineNum":"  765","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  766","line":"Packet pasin(const Packet& a) { EIGEN_USING_STD(asin); return asin(a); }"},
{"lineNum":"  767","line":""},
{"lineNum":"  768","line":"/** \\internal \\returns the arc cosine of \\a a (coeff-wise) */"},
{"lineNum":"  769","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  770","line":"Packet pacos(const Packet& a) { EIGEN_USING_STD(acos); return acos(a); }"},
{"lineNum":"  771","line":""},
{"lineNum":"  772","line":"/** \\internal \\returns the arc tangent of \\a a (coeff-wise) */"},
{"lineNum":"  773","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  774","line":"Packet patan(const Packet& a) { EIGEN_USING_STD(atan); return atan(a); }"},
{"lineNum":"  775","line":""},
{"lineNum":"  776","line":"/** \\internal \\returns the hyperbolic sine of \\a a (coeff-wise) */"},
{"lineNum":"  777","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  778","line":"Packet psinh(const Packet& a) { EIGEN_USING_STD(sinh); return sinh(a); }"},
{"lineNum":"  779","line":""},
{"lineNum":"  780","line":"/** \\internal \\returns the hyperbolic cosine of \\a a (coeff-wise) */"},
{"lineNum":"  781","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  782","line":"Packet pcosh(const Packet& a) { EIGEN_USING_STD(cosh); return cosh(a); }"},
{"lineNum":"  783","line":""},
{"lineNum":"  784","line":"/** \\internal \\returns the hyperbolic tan of \\a a (coeff-wise) */"},
{"lineNum":"  785","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  786","line":"Packet ptanh(const Packet& a) { EIGEN_USING_STD(tanh); return tanh(a); }"},
{"lineNum":"  787","line":""},
{"lineNum":"  788","line":"/** \\internal \\returns the exp of \\a a (coeff-wise) */"},
{"lineNum":"  789","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  790","line":"Packet pexp(const Packet& a) { EIGEN_USING_STD(exp); return exp(a); }"},
{"lineNum":"  791","line":""},
{"lineNum":"  792","line":"/** \\internal \\returns the expm1 of \\a a (coeff-wise) */"},
{"lineNum":"  793","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  794","line":"Packet pexpm1(const Packet& a) { return numext::expm1(a); }"},
{"lineNum":"  795","line":""},
{"lineNum":"  796","line":"/** \\internal \\returns the log of \\a a (coeff-wise) */"},
{"lineNum":"  797","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  798","line":"Packet plog(const Packet& a) { EIGEN_USING_STD(log); return log(a); }"},
{"lineNum":"  799","line":""},
{"lineNum":"  800","line":"/** \\internal \\returns the log1p of \\a a (coeff-wise) */"},
{"lineNum":"  801","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  802","line":"Packet plog1p(const Packet& a) { return numext::log1p(a); }"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"/** \\internal \\returns the log10 of \\a a (coeff-wise) */"},
{"lineNum":"  805","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  806","line":"Packet plog10(const Packet& a) { EIGEN_USING_STD(log10); return log10(a); }"},
{"lineNum":"  807","line":""},
{"lineNum":"  808","line":"/** \\internal \\returns the log10 of \\a a (coeff-wise) */"},
{"lineNum":"  809","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  810","line":"Packet plog2(const Packet& a) {"},
{"lineNum":"  811","line":"  typedef typename internal::unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  812","line":"  return pmul(pset1<Packet>(Scalar(EIGEN_LOG2E)), plog(a));"},
{"lineNum":"  813","line":"}"},
{"lineNum":"  814","line":""},
{"lineNum":"  815","line":"/** \\internal \\returns the square-root of \\a a (coeff-wise) */"},
{"lineNum":"  816","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  817","line":"Packet psqrt(const Packet& a) { return numext::sqrt(a); }"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"/** \\internal \\returns the reciprocal square-root of \\a a (coeff-wise) */"},
{"lineNum":"  820","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  821","line":"Packet prsqrt(const Packet& a) {"},
{"lineNum":"  822","line":"  typedef typename internal::unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  823","line":"  return pdiv(pset1<Packet>(Scalar(1)), psqrt(a));"},
{"lineNum":"  824","line":"}"},
{"lineNum":"  825","line":""},
{"lineNum":"  826","line":"/** \\internal \\returns the rounded value of \\a a (coeff-wise) */"},
{"lineNum":"  827","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  828","line":"Packet pround(const Packet& a) { using numext::round; return round(a); }"},
{"lineNum":"  829","line":""},
{"lineNum":"  830","line":"/** \\internal \\returns the floor of \\a a (coeff-wise) */"},
{"lineNum":"  831","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  832","line":"Packet pfloor(const Packet& a) { using numext::floor; return floor(a); }"},
{"lineNum":"  833","line":""},
{"lineNum":"  834","line":"/** \\internal \\returns the rounded value of \\a a (coeff-wise) with current"},
{"lineNum":"  835","line":" * rounding mode */"},
{"lineNum":"  836","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  837","line":"Packet print(const Packet& a) { using numext::rint; return rint(a); }"},
{"lineNum":"  838","line":""},
{"lineNum":"  839","line":"/** \\internal \\returns the ceil of \\a a (coeff-wise) */"},
{"lineNum":"  840","line":"template<typename Packet> EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS"},
{"lineNum":"  841","line":"Packet pceil(const Packet& a) { using numext::ceil; return ceil(a); }"},
{"lineNum":"  842","line":""},
{"lineNum":"  843","line":"/** \\internal \\returns the first element of a packet */"},
{"lineNum":"  844","line":"template<typename Packet>"},
{"lineNum":"  845","line":"EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type"},
{"lineNum":"  846","line":"pfirst(const Packet& a)"},
{"lineNum":"  847","line":"{ return a; }"},
{"lineNum":"  848","line":""},
{"lineNum":"  849","line":"/** \\internal \\returns the sum of the elements of upper and lower half of \\a a if \\a a is larger than 4."},
{"lineNum":"  850","line":"  * For a packet {a0, a1, a2, a3, a4, a5, a6, a7}, it returns a half packet {a0+a4, a1+a5, a2+a6, a3+a7}"},
{"lineNum":"  851","line":"  * For packet-size smaller or equal to 4, this boils down to a noop."},
{"lineNum":"  852","line":"  */"},
{"lineNum":"  853","line":"template<typename Packet>"},
{"lineNum":"  854","line":"EIGEN_DEVICE_FUNC inline typename conditional<(unpacket_traits<Packet>::size%8)==0,typename unpacket_traits<Packet>::half,Packet>::type"},
{"lineNum":"  855","line":"predux_half_dowto4(const Packet& a)"},
{"lineNum":"  856","line":"{ return a; }"},
{"lineNum":"  857","line":""},
{"lineNum":"  858","line":"// Slow generic implementation of Packet reduction."},
{"lineNum":"  859","line":"template <typename Packet, typename Op>"},
{"lineNum":"  860","line":"EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type"},
{"lineNum":"  861","line":"predux_helper(const Packet& a, Op op) {"},
{"lineNum":"  862","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  863","line":"  const size_t n = unpacket_traits<Packet>::size;"},
{"lineNum":"  864","line":"  EIGEN_ALIGN_TO_BOUNDARY(sizeof(Packet)) Scalar elements[n];"},
{"lineNum":"  865","line":"  pstoreu<Scalar>(elements, a);"},
{"lineNum":"  866","line":"  for(size_t k = n / 2; k > 0; k /= 2)  {"},
{"lineNum":"  867","line":"    for(size_t i = 0; i < k; ++i) {"},
{"lineNum":"  868","line":"      elements[i] = op(elements[i], elements[i + k]);"},
{"lineNum":"  869","line":"    }"},
{"lineNum":"  870","line":"  }"},
{"lineNum":"  871","line":"  return elements[0];"},
{"lineNum":"  872","line":"}"},
{"lineNum":"  873","line":""},
{"lineNum":"  874","line":"/** \\internal \\returns the sum of the elements of \\a a*/"},
{"lineNum":"  875","line":"template<typename Packet>"},
{"lineNum":"  876","line":"EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type"},
{"lineNum":"  877","line":"predux(const Packet& a)"},
{"lineNum":"  878","line":"{"},
{"lineNum":"  879","line":"  return a;"},
{"lineNum":"  880","line":"}"},
{"lineNum":"  881","line":""},
{"lineNum":"  882","line":"/** \\internal \\returns the product of the elements of \\a a */"},
{"lineNum":"  883","line":"template <typename Packet>"},
{"lineNum":"  884","line":"EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_mul("},
{"lineNum":"  885","line":"    const Packet& a) {"},
{"lineNum":"  886","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  887","line":"  return predux_helper(a, EIGEN_BINARY_OP_NAN_PROPAGATION(Scalar, (pmul<Scalar>)));"},
{"lineNum":"  888","line":"}"},
{"lineNum":"  889","line":""},
{"lineNum":"  890","line":"/** \\internal \\returns the min of the elements of \\a a */"},
{"lineNum":"  891","line":"template <typename Packet>"},
{"lineNum":"  892","line":"EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_min("},
{"lineNum":"  893","line":"    const Packet &a) {"},
{"lineNum":"  894","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  895","line":"  return predux_helper(a, EIGEN_BINARY_OP_NAN_PROPAGATION(Scalar, (pmin<PropagateFast, Scalar>)));"},
{"lineNum":"  896","line":"}"},
{"lineNum":"  897","line":""},
{"lineNum":"  898","line":"template <int NaNPropagation, typename Packet>"},
{"lineNum":"  899","line":"EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_min("},
{"lineNum":"  900","line":"    const Packet& a) {"},
{"lineNum":"  901","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  902","line":"  return predux_helper(a, EIGEN_BINARY_OP_NAN_PROPAGATION(Scalar, (pmin<NaNPropagation, Scalar>)));"},
{"lineNum":"  903","line":"}"},
{"lineNum":"  904","line":""},
{"lineNum":"  905","line":"/** \\internal \\returns the min of the elements of \\a a */"},
{"lineNum":"  906","line":"template <typename Packet>"},
{"lineNum":"  907","line":"EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_max("},
{"lineNum":"  908","line":"    const Packet &a) {"},
{"lineNum":"  909","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  910","line":"  return predux_helper(a, EIGEN_BINARY_OP_NAN_PROPAGATION(Scalar, (pmax<PropagateFast, Scalar>)));"},
{"lineNum":"  911","line":"}"},
{"lineNum":"  912","line":""},
{"lineNum":"  913","line":"template <int NaNPropagation, typename Packet>"},
{"lineNum":"  914","line":"EIGEN_DEVICE_FUNC inline typename unpacket_traits<Packet>::type predux_max("},
{"lineNum":"  915","line":"    const Packet& a) {"},
{"lineNum":"  916","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  917","line":"  return predux_helper(a, EIGEN_BINARY_OP_NAN_PROPAGATION(Scalar, (pmax<NaNPropagation, Scalar>)));"},
{"lineNum":"  918","line":"}"},
{"lineNum":"  919","line":""},
{"lineNum":"  920","line":"#undef EIGEN_BINARY_OP_NAN_PROPAGATION"},
{"lineNum":"  921","line":""},
{"lineNum":"  922","line":"/** \\internal \\returns true if all coeffs of \\a a means \"true\""},
{"lineNum":"  923","line":"  * It is supposed to be called on values returned by pcmp_*."},
{"lineNum":"  924","line":"  */"},
{"lineNum":"  925","line":"// not needed yet"},
{"lineNum":"  926","line":"// template<typename Packet> EIGEN_DEVICE_FUNC inline bool predux_all(const Packet& a)"},
{"lineNum":"  927","line":"// { return bool(a); }"},
{"lineNum":"  928","line":""},
{"lineNum":"  929","line":"/** \\internal \\returns true if any coeffs of \\a a means \"true\""},
{"lineNum":"  930","line":"  * It is supposed to be called on values returned by pcmp_*."},
{"lineNum":"  931","line":"  */"},
{"lineNum":"  932","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline bool predux_any(const Packet& a)"},
{"lineNum":"  933","line":"{"},
{"lineNum":"  934","line":"  // Dirty but generic implementation where \"true\" is assumed to be non 0 and all the sames."},
{"lineNum":"  935","line":"  // It is expected that \"true\" is either:"},
{"lineNum":"  936","line":"  //  - Scalar(1)"},
{"lineNum":"  937","line":"  //  - bits full of ones (NaN for floats),"},
{"lineNum":"  938","line":"  //  - or first bit equals to 1 (1 for ints, smallest denormal for floats)."},
{"lineNum":"  939","line":"  // For all these cases, taking the sum is just fine, and this boils down to a no-op for scalars."},
{"lineNum":"  940","line":"  typedef typename unpacket_traits<Packet>::type Scalar;"},
{"lineNum":"  941","line":"  return numext::not_equal_strict(predux(a), Scalar(0));"},
{"lineNum":"  942","line":"}"},
{"lineNum":"  943","line":""},
{"lineNum":"  944","line":"/***************************************************************************"},
{"lineNum":"  945","line":"* The following functions might not have to be overwritten for vectorized types"},
{"lineNum":"  946","line":"***************************************************************************/"},
{"lineNum":"  947","line":""},
{"lineNum":"  948","line":"/** \\internal copy a packet with constant coefficient \\a a (e.g., [a,a,a,a]) to \\a *to. \\a to must be 16 bytes aligned */"},
{"lineNum":"  949","line":"// NOTE: this function must really be templated on the packet type (think about different packet types for the same scalar type)"},
{"lineNum":"  950","line":"template<typename Packet>"},
{"lineNum":"  951","line":"inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)"},
{"lineNum":"  952","line":"{"},
{"lineNum":"  953","line":"  pstore(to, pset1<Packet>(a));"},
{"lineNum":"  954","line":"}"},
{"lineNum":"  955","line":""},
{"lineNum":"  956","line":"/** \\internal \\returns a * b + c (coeff-wise) */"},
{"lineNum":"  957","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":"  958","line":"pmadd(const Packet&  a,"},
{"lineNum":"  959","line":"         const Packet&  b,"},
{"lineNum":"  960","line":"         const Packet&  c)"},
{"lineNum":"  961","line":"{ return padd(pmul(a, b),c); }"},
{"lineNum":"  962","line":""},
{"lineNum":"  963","line":"/** \\internal \\returns a packet version of \\a *from."},
{"lineNum":"  964","line":"  * The pointer \\a from must be aligned on a \\a Alignment bytes boundary. */"},
{"lineNum":"  965","line":"template<typename Packet, int Alignment>"},
{"lineNum":"  966","line":"EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet ploadt(const typename unpacket_traits<Packet>::type* from)"},
{"lineNum":"  967","line":"{"},
{"lineNum":"  968","line":"  if(Alignment >= unpacket_traits<Packet>::alignment)"},
{"lineNum":"  969","line":"    return pload<Packet>(from);"},
{"lineNum":"  970","line":"  else"},
{"lineNum":"  971","line":"    return ploadu<Packet>(from);"},
{"lineNum":"  972","line":"}"},
{"lineNum":"  973","line":""},
{"lineNum":"  974","line":"/** \\internal copy the packet \\a from to \\a *to."},
{"lineNum":"  975","line":"  * The pointer \\a from must be aligned on a \\a Alignment bytes boundary. */"},
{"lineNum":"  976","line":"template<typename Scalar, typename Packet, int Alignment>"},
{"lineNum":"  977","line":"EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void pstoret(Scalar* to, const Packet& from)"},
{"lineNum":"  978","line":"{"},
{"lineNum":"  979","line":"  if(Alignment >= unpacket_traits<Packet>::alignment)"},
{"lineNum":"  980","line":"    pstore(to, from);"},
{"lineNum":"  981","line":"  else"},
{"lineNum":"  982","line":"    pstoreu(to, from);"},
{"lineNum":"  983","line":"}"},
{"lineNum":"  984","line":""},
{"lineNum":"  985","line":"/** \\internal \\returns a packet version of \\a *from."},
{"lineNum":"  986","line":"  * Unlike ploadt, ploadt_ro takes advantage of the read-only memory path on the"},
{"lineNum":"  987","line":"  * hardware if available to speedup the loading of data that won\'t be modified"},
{"lineNum":"  988","line":"  * by the current computation."},
{"lineNum":"  989","line":"  */"},
{"lineNum":"  990","line":"template<typename Packet, int LoadMode>"},
{"lineNum":"  991","line":"EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet ploadt_ro(const typename unpacket_traits<Packet>::type* from)"},
{"lineNum":"  992","line":"{"},
{"lineNum":"  993","line":"  return ploadt<Packet, LoadMode>(from);"},
{"lineNum":"  994","line":"}"},
{"lineNum":"  995","line":""},
{"lineNum":"  996","line":"/***************************************************************************"},
{"lineNum":"  997","line":"* Fast complex products (GCC generates a function call which is very slow)"},
{"lineNum":"  998","line":"***************************************************************************/"},
{"lineNum":"  999","line":""},
{"lineNum":" 1000","line":"// Eigen+CUDA does not support complexes."},
{"lineNum":" 1001","line":"#if !defined(EIGEN_GPUCC)"},
{"lineNum":" 1002","line":""},
{"lineNum":" 1003","line":"template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)"},
{"lineNum":" 1004","line":"{ return std::complex<float>(a.real()*b.real() - a.imag()*b.imag(), a.imag()*b.real() + a.real()*b.imag()); }"},
{"lineNum":" 1005","line":""},
{"lineNum":" 1006","line":"template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)"},
{"lineNum":" 1007","line":"{ return std::complex<double>(a.real()*b.real() - a.imag()*b.imag(), a.imag()*b.real() + a.real()*b.imag()); }"},
{"lineNum":" 1008","line":""},
{"lineNum":" 1009","line":"#endif"},
{"lineNum":" 1010","line":""},
{"lineNum":" 1011","line":""},
{"lineNum":" 1012","line":"/***************************************************************************"},
{"lineNum":" 1013","line":" * PacketBlock, that is a collection of N packets where the number of words"},
{"lineNum":" 1014","line":" * in the packet is a multiple of N."},
{"lineNum":" 1015","line":"***************************************************************************/"},
{"lineNum":" 1016","line":"template <typename Packet,int N=unpacket_traits<Packet>::size> struct PacketBlock {"},
{"lineNum":" 1017","line":"  Packet packet[N];"},
{"lineNum":" 1018","line":"};"},
{"lineNum":" 1019","line":""},
{"lineNum":" 1020","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline void"},
{"lineNum":" 1021","line":"ptranspose(PacketBlock<Packet,1>& /*kernel*/) {"},
{"lineNum":" 1022","line":"  // Nothing to do in the scalar case, i.e. a 1x1 matrix."},
{"lineNum":" 1023","line":"}"},
{"lineNum":" 1024","line":""},
{"lineNum":" 1025","line":"/***************************************************************************"},
{"lineNum":" 1026","line":" * Selector, i.e. vector of N boolean values used to select (i.e. blend)"},
{"lineNum":" 1027","line":" * words from 2 packets."},
{"lineNum":" 1028","line":"***************************************************************************/"},
{"lineNum":" 1029","line":"template <size_t N> struct Selector {"},
{"lineNum":" 1030","line":"  bool select[N];"},
{"lineNum":" 1031","line":"};"},
{"lineNum":" 1032","line":""},
{"lineNum":" 1033","line":"template<typename Packet> EIGEN_DEVICE_FUNC inline Packet"},
{"lineNum":" 1034","line":"pblend(const Selector<unpacket_traits<Packet>::size>& ifPacket, const Packet& thenPacket, const Packet& elsePacket) {"},
{"lineNum":" 1035","line":"  return ifPacket.select[0] ? thenPacket : elsePacket;"},
{"lineNum":" 1036","line":"}"},
{"lineNum":" 1037","line":""},
{"lineNum":" 1038","line":"} // end namespace internal"},
{"lineNum":" 1039","line":""},
{"lineNum":" 1040","line":"} // end namespace Eigen"},
{"lineNum":" 1041","line":""},
{"lineNum":" 1042","line":"#endif // EIGEN_GENERIC_PACKET_MATH_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
