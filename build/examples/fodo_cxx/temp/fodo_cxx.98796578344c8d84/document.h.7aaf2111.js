var data = {lines:[
{"lineNum":"    1","line":"// Tencent is pleased to support the open source community by making RapidJSON available."},
{"lineNum":"    2","line":"//"},
{"lineNum":"    3","line":"// Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip. All rights reserved."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// Licensed under the MIT License (the \"License\"); you may not use this file except"},
{"lineNum":"    6","line":"// in compliance with the License. You may obtain a copy of the License at"},
{"lineNum":"    7","line":"//"},
{"lineNum":"    8","line":"// http://opensource.org/licenses/MIT"},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// Unless required by applicable law or agreed to in writing, software distributed"},
{"lineNum":"   11","line":"// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR"},
{"lineNum":"   12","line":"// CONDITIONS OF ANY KIND, either express or implied. See the License for the"},
{"lineNum":"   13","line":"// specific language governing permissions and limitations under the License."},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"#ifndef CEREAL_RAPIDJSON_DOCUMENT_H_"},
{"lineNum":"   16","line":"#define CEREAL_RAPIDJSON_DOCUMENT_H_"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"/*! \\file document.h */"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"#include \"reader.h\""},
{"lineNum":"   21","line":"#include \"internal/meta.h\""},
{"lineNum":"   22","line":"#include \"internal/strfunc.h\""},
{"lineNum":"   23","line":"#include \"memorystream.h\""},
{"lineNum":"   24","line":"#include \"encodedstream.h\""},
{"lineNum":"   25","line":"#include <new>      // placement new"},
{"lineNum":"   26","line":"#include <limits>"},
{"lineNum":"   27","line":"#ifdef __cpp_lib_three_way_comparison"},
{"lineNum":"   28","line":"#include <compare>"},
{"lineNum":"   29","line":"#endif"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"CEREAL_RAPIDJSON_DIAG_PUSH"},
{"lineNum":"   32","line":"#ifdef __clang__"},
{"lineNum":"   33","line":"CEREAL_RAPIDJSON_DIAG_OFF(padded)"},
{"lineNum":"   34","line":"CEREAL_RAPIDJSON_DIAG_OFF(switch-enum)"},
{"lineNum":"   35","line":"CEREAL_RAPIDJSON_DIAG_OFF(c++98-compat)"},
{"lineNum":"   36","line":"#elif defined(_MSC_VER)"},
{"lineNum":"   37","line":"CEREAL_RAPIDJSON_DIAG_OFF(4127) // conditional expression is constant"},
{"lineNum":"   38","line":"CEREAL_RAPIDJSON_DIAG_OFF(4244) // conversion from kXxxFlags to \'uint16_t\', possible loss of data"},
{"lineNum":"   39","line":"#endif"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"#ifdef __GNUC__"},
{"lineNum":"   42","line":"CEREAL_RAPIDJSON_DIAG_OFF(effc++)"},
{"lineNum":"   43","line":"#endif // __GNUC__"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef CEREAL_RAPIDJSON_NOMEMBERITERATORCLASS"},
{"lineNum":"   46","line":"#include <iterator> // std::random_access_iterator_tag"},
{"lineNum":"   47","line":"#endif"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":"   50","line":"#include <utility> // std::move"},
{"lineNum":"   51","line":"#endif"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"CEREAL_RAPIDJSON_NAMESPACE_BEGIN"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"// Forward declaration."},
{"lineNum":"   56","line":"template <typename Encoding, typename Allocator>"},
{"lineNum":"   57","line":"class GenericValue;"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"template <typename Encoding, typename Allocator, typename StackAllocator>"},
{"lineNum":"   60","line":"class GenericDocument;"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"//! Name-value pair in a JSON object value."},
{"lineNum":"   63","line":"/*!"},
{"lineNum":"   64","line":"    This class was internal to GenericValue. It used to be a inner struct."},
{"lineNum":"   65","line":"    But a compiler (IBM XL C/C++ for AIX) have reported to have problem with that so it moved as a namespace scope struct."},
{"lineNum":"   66","line":"    https://code.google.com/p/rapidjson/issues/detail?id=64"},
{"lineNum":"   67","line":"*/"},
{"lineNum":"   68","line":"template <typename Encoding, typename Allocator>"},
{"lineNum":"   69","line":"struct GenericMember {"},
{"lineNum":"   70","line":"    GenericValue<Encoding, Allocator> name;     //!< name of member (must be a string)"},
{"lineNum":"   71","line":"    GenericValue<Encoding, Allocator> value;    //!< value of member."},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    // swap() for std::sort() and other potential use in STL."},
{"lineNum":"   74","line":"    friend inline void swap(GenericMember& a, GenericMember& b) CEREAL_RAPIDJSON_NOEXCEPT {"},
{"lineNum":"   75","line":"        a.name.Swap(b.name);"},
{"lineNum":"   76","line":"        a.value.Swap(b.value);"},
{"lineNum":"   77","line":"    }"},
{"lineNum":"   78","line":"};"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"   81","line":"// GenericMemberIterator"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"#ifndef CEREAL_RAPIDJSON_NOMEMBERITERATORCLASS"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"//! (Constant) member iterator for a JSON object value"},
{"lineNum":"   86","line":"/*!"},
{"lineNum":"   87","line":"    \\tparam Const Is this a constant iterator?"},
{"lineNum":"   88","line":"    \\tparam Encoding    Encoding of the value. (Even non-string values need to have the same encoding in a document)"},
{"lineNum":"   89","line":"    \\tparam Allocator   Allocator type for allocating memory of object, array and string."},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"    This class implements a Random Access Iterator for GenericMember elements"},
{"lineNum":"   92","line":"    of a GenericValue, see ISO/IEC 14882:2003(E) C++ standard, 24.1 [lib.iterator.requirements]."},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"    \\note This iterator implementation is mainly intended to avoid implicit"},
{"lineNum":"   95","line":"        conversions from iterator values to \\c NULL,"},
{"lineNum":"   96","line":"        e.g. from GenericValue::FindMember."},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"    \\note Define \\c CEREAL_RAPIDJSON_NOMEMBERITERATORCLASS to fall back to a"},
{"lineNum":"   99","line":"        pointer-based implementation, if your platform doesn\'t provide"},
{"lineNum":"  100","line":"        the C++ <iterator> header."},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    \\see GenericMember, GenericValue::MemberIterator, GenericValue::ConstMemberIterator"},
{"lineNum":"  103","line":" */"},
{"lineNum":"  104","line":"template <bool Const, typename Encoding, typename Allocator>"},
{"lineNum":"  105","line":"class GenericMemberIterator {"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"    friend class GenericValue<Encoding,Allocator>;"},
{"lineNum":"  108","line":"    template <bool, typename, typename> friend class GenericMemberIterator;"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"    typedef GenericMember<Encoding,Allocator> PlainType;"},
{"lineNum":"  111","line":"    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"public:"},
{"lineNum":"  114","line":"    //! Iterator type itself"},
{"lineNum":"  115","line":"    typedef GenericMemberIterator Iterator;"},
{"lineNum":"  116","line":"    //! Constant iterator type"},
{"lineNum":"  117","line":"    typedef GenericMemberIterator<true,Encoding,Allocator>  ConstIterator;"},
{"lineNum":"  118","line":"    //! Non-constant iterator type"},
{"lineNum":"  119","line":"    typedef GenericMemberIterator<false,Encoding,Allocator> NonConstIterator;"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"    /** \\name std::iterator_traits support */"},
{"lineNum":"  122","line":"    //@{"},
{"lineNum":"  123","line":"    typedef ValueType      value_type;"},
{"lineNum":"  124","line":"    typedef ValueType *    pointer;"},
{"lineNum":"  125","line":"    typedef ValueType &    reference;"},
{"lineNum":"  126","line":"    typedef std::ptrdiff_t difference_type;"},
{"lineNum":"  127","line":"    typedef std::random_access_iterator_tag iterator_category;"},
{"lineNum":"  128","line":"    //@}"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"    //! Pointer to (const) GenericMember"},
{"lineNum":"  131","line":"    typedef pointer         Pointer;"},
{"lineNum":"  132","line":"    //! Reference to (const) GenericMember"},
{"lineNum":"  133","line":"    typedef reference       Reference;"},
{"lineNum":"  134","line":"    //! Signed integer type (e.g. \\c ptrdiff_t)"},
{"lineNum":"  135","line":"    typedef difference_type DifferenceType;"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"    //! Default constructor (singular value)"},
{"lineNum":"  138","line":"    /*! Creates an iterator pointing to no element."},
{"lineNum":"  139","line":"        \\note All operations, except for comparisons, are undefined on such values."},
{"lineNum":"  140","line":"     */"},
{"lineNum":"  141","line":"    GenericMemberIterator() : ptr_() {}","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"    //! Iterator conversions to more const"},
{"lineNum":"  144","line":"    /*!"},
{"lineNum":"  145","line":"        \\param it (Non-const) iterator to copy from"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"        Allows the creation of an iterator from another GenericMemberIterator"},
{"lineNum":"  148","line":"        that is \"less const\".  Especially, creating a non-constant iterator"},
{"lineNum":"  149","line":"        from a constant iterator are disabled:"},
{"lineNum":"  150","line":"        \\li const -> non-const (not ok)"},
{"lineNum":"  151","line":"        \\li const -> const (ok)"},
{"lineNum":"  152","line":"        \\li non-const -> const (ok)"},
{"lineNum":"  153","line":"        \\li non-const -> non-const (ok)"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"        \\note If the \\c Const template parameter is already \\c false, this"},
{"lineNum":"  156","line":"            constructor effectively defines a regular copy-constructor."},
{"lineNum":"  157","line":"            Otherwise, the copy constructor is implicitly defined."},
{"lineNum":"  158","line":"    */"},
{"lineNum":"  159","line":"    GenericMemberIterator(const NonConstIterator & it) : ptr_(it.ptr_) {}"},
{"lineNum":"  160","line":"    Iterator& operator=(const NonConstIterator & it) { ptr_ = it.ptr_; return *this; }"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"    //! @name stepping"},
{"lineNum":"  163","line":"    //@{"},
{"lineNum":"  164","line":"    Iterator& operator++(){ ++ptr_; return *this; }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  165","line":"    Iterator& operator--(){ --ptr_; return *this; }"},
{"lineNum":"  166","line":"    Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }"},
{"lineNum":"  167","line":"    Iterator  operator--(int){ Iterator old(*this); --ptr_; return old; }"},
{"lineNum":"  168","line":"    //@}"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"    //! @name increment/decrement"},
{"lineNum":"  171","line":"    //@{"},
{"lineNum":"  172","line":"    Iterator operator+(DifferenceType n) const { return Iterator(ptr_+n); }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  173","line":"    Iterator operator-(DifferenceType n) const { return Iterator(ptr_-n); }"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"    Iterator& operator+=(DifferenceType n) { ptr_+=n; return *this; }"},
{"lineNum":"  176","line":"    Iterator& operator-=(DifferenceType n) { ptr_-=n; return *this; }"},
{"lineNum":"  177","line":"    //@}"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"    //! @name relations"},
{"lineNum":"  180","line":"    //@{"},
{"lineNum":"  181","line":"    template <bool Const_> bool operator==(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ == that.ptr_; }"},
{"lineNum":"  182","line":"    template <bool Const_> bool operator!=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ != that.ptr_; }","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  183","line":"    template <bool Const_> bool operator<=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ <= that.ptr_; }"},
{"lineNum":"  184","line":"    template <bool Const_> bool operator>=(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ >= that.ptr_; }"},
{"lineNum":"  185","line":"    template <bool Const_> bool operator< (const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ < that.ptr_; }"},
{"lineNum":"  186","line":"    template <bool Const_> bool operator> (const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ > that.ptr_; }"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"#ifdef __cpp_lib_three_way_comparison"},
{"lineNum":"  189","line":"    template <bool Const_> std::strong_ordering operator<=>(const GenericMemberIterator<Const_, Encoding, Allocator>& that) const { return ptr_ <=> that.ptr_; }"},
{"lineNum":"  190","line":"#endif"},
{"lineNum":"  191","line":"    //@}"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"    //! @name dereference"},
{"lineNum":"  194","line":"    //@{"},
{"lineNum":"  195","line":"    Reference operator*() const { return *ptr_; }"},
{"lineNum":"  196","line":"    Pointer   operator->() const { return ptr_; }"},
{"lineNum":"  197","line":"    Reference operator[](DifferenceType n) const { return ptr_[n]; }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  198","line":"    //@}"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"    //! Distance"},
{"lineNum":"  201","line":"    DifferenceType operator-(ConstIterator that) const { return ptr_-that.ptr_; }","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"private:"},
{"lineNum":"  204","line":"    //! Internal constructor from plain pointer"},
{"lineNum":"  205","line":"    explicit GenericMemberIterator(Pointer p) : ptr_(p) {}"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"    Pointer ptr_; //!< raw pointer"},
{"lineNum":"  208","line":"};"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"#else // CEREAL_RAPIDJSON_NOMEMBERITERATORCLASS"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"// class-based member iterator implementation disabled, use plain pointers"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"template <bool Const, typename Encoding, typename Allocator>"},
{"lineNum":"  215","line":"class GenericMemberIterator;"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"//! non-const GenericMemberIterator"},
{"lineNum":"  218","line":"template <typename Encoding, typename Allocator>"},
{"lineNum":"  219","line":"class GenericMemberIterator<false,Encoding,Allocator> {"},
{"lineNum":"  220","line":"    //! use plain pointer as iterator type"},
{"lineNum":"  221","line":"    typedef GenericMember<Encoding,Allocator>* Iterator;"},
{"lineNum":"  222","line":"};"},
{"lineNum":"  223","line":"//! const GenericMemberIterator"},
{"lineNum":"  224","line":"template <typename Encoding, typename Allocator>"},
{"lineNum":"  225","line":"class GenericMemberIterator<true,Encoding,Allocator> {"},
{"lineNum":"  226","line":"    //! use plain const pointer as iterator type"},
{"lineNum":"  227","line":"    typedef const GenericMember<Encoding,Allocator>* Iterator;"},
{"lineNum":"  228","line":"};"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"#endif // CEREAL_RAPIDJSON_NOMEMBERITERATORCLASS"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  233","line":"// GenericStringRef"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"//! Reference to a constant string (not taking a copy)"},
{"lineNum":"  236","line":"/*!"},
{"lineNum":"  237","line":"    \\tparam CharType character type of the string"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"    This helper class is used to automatically infer constant string"},
{"lineNum":"  240","line":"    references for string literals, especially from \\c const \\b (!)"},
{"lineNum":"  241","line":"    character arrays."},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"    The main use is for creating JSON string values without copying the"},
{"lineNum":"  244","line":"    source string via an \\ref Allocator.  This requires that the referenced"},
{"lineNum":"  245","line":"    string pointers have a sufficient lifetime, which exceeds the lifetime"},
{"lineNum":"  246","line":"    of the associated GenericValue."},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"    \\b Example"},
{"lineNum":"  249","line":"    \\code"},
{"lineNum":"  250","line":"    Value v(\"foo\");   // ok, no need to copy & calculate length"},
{"lineNum":"  251","line":"    const char foo[] = \"foo\";"},
{"lineNum":"  252","line":"    v.SetString(foo); // ok"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"    const char* bar = foo;"},
{"lineNum":"  255","line":"    // Value x(bar); // not ok, can\'t rely on bar\'s lifetime"},
{"lineNum":"  256","line":"    Value x(StringRef(bar)); // lifetime explicitly guaranteed by user"},
{"lineNum":"  257","line":"    Value y(StringRef(bar, 3));  // ok, explicitly pass length"},
{"lineNum":"  258","line":"    \\endcode"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"    \\see StringRef, GenericValue::SetString"},
{"lineNum":"  261","line":"*/"},
{"lineNum":"  262","line":"template<typename CharType>"},
{"lineNum":"  263","line":"struct GenericStringRef {"},
{"lineNum":"  264","line":"    typedef CharType Ch; //!< character type of the string"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"    //! Create string reference from \\c const character array"},
{"lineNum":"  267","line":"#ifndef __clang__ // -Wdocumentation"},
{"lineNum":"  268","line":"    /*!"},
{"lineNum":"  269","line":"        This constructor implicitly creates a constant string reference from"},
{"lineNum":"  270","line":"        a \\c const character array.  It has better performance than"},
{"lineNum":"  271","line":"        \\ref StringRef(const CharType*) by inferring the string \\ref length"},
{"lineNum":"  272","line":"        from the array length, and also supports strings containing null"},
{"lineNum":"  273","line":"        characters."},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"        \\tparam N length of the string, automatically inferred"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"        \\param str Constant character array, lifetime assumed to be longer"},
{"lineNum":"  278","line":"            than the use of the string in e.g. a GenericValue"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"        \\post \\ref s == str"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"        \\note Constant complexity."},
{"lineNum":"  283","line":"        \\note There is a hidden, private overload to disallow references to"},
{"lineNum":"  284","line":"            non-const character arrays to be created via this constructor."},
{"lineNum":"  285","line":"            By this, e.g. function-scope arrays used to be filled via"},
{"lineNum":"  286","line":"            \\c snprintf are excluded from consideration."},
{"lineNum":"  287","line":"            In such cases, the referenced string should be \\b copied to the"},
{"lineNum":"  288","line":"            GenericValue instead."},
{"lineNum":"  289","line":"     */"},
{"lineNum":"  290","line":"#endif"},
{"lineNum":"  291","line":"    template<SizeType N>"},
{"lineNum":"  292","line":"    GenericStringRef(const CharType (&str)[N]) CEREAL_RAPIDJSON_NOEXCEPT"},
{"lineNum":"  293","line":"        : s(str), length(N-1) {}"},
{"lineNum":"  294","line":""},
{"lineNum":"  295","line":"    //! Explicitly create string reference from \\c const character pointer"},
{"lineNum":"  296","line":"#ifndef __clang__ // -Wdocumentation"},
{"lineNum":"  297","line":"    /*!"},
{"lineNum":"  298","line":"        This constructor can be used to \\b explicitly  create a reference to"},
{"lineNum":"  299","line":"        a constant string pointer."},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"        \\see StringRef(const CharType*)"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"        \\param str Constant character pointer, lifetime assumed to be longer"},
{"lineNum":"  304","line":"            than the use of the string in e.g. a GenericValue"},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"        \\post \\ref s == str"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"        \\note There is a hidden, private overload to disallow references to"},
{"lineNum":"  309","line":"            non-const character arrays to be created via this constructor."},
{"lineNum":"  310","line":"            By this, e.g. function-scope arrays used to be filled via"},
{"lineNum":"  311","line":"            \\c snprintf are excluded from consideration."},
{"lineNum":"  312","line":"            In such cases, the referenced string should be \\b copied to the"},
{"lineNum":"  313","line":"            GenericValue instead."},
{"lineNum":"  314","line":"     */"},
{"lineNum":"  315","line":"#endif"},
{"lineNum":"  316","line":"    explicit GenericStringRef(const CharType* str)"},
{"lineNum":"  317","line":"        : s(str), length(NotNullStrLen(str)) {}"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"    //! Create constant string reference from pointer and length"},
{"lineNum":"  320","line":"#ifndef __clang__ // -Wdocumentation"},
{"lineNum":"  321","line":"    /*! \\param str constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue"},
{"lineNum":"  322","line":"        \\param len length of the string, excluding the trailing NULL terminator"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"        \\post \\ref s == str && \\ref length == len"},
{"lineNum":"  325","line":"        \\note Constant complexity."},
{"lineNum":"  326","line":"     */"},
{"lineNum":"  327","line":"#endif"},
{"lineNum":"  328","line":"    GenericStringRef(const CharType* str, SizeType len)"},
{"lineNum":"  329","line":"        : s(CEREAL_RAPIDJSON_LIKELY(str) ? str : emptyString), length(len) { CEREAL_RAPIDJSON_ASSERT(str != 0 || len == 0u); }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"    GenericStringRef(const GenericStringRef& rhs) : s(rhs.s), length(rhs.length) {}"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"    //! implicit conversion to plain CharType pointer"},
{"lineNum":"  334","line":"    operator const Ch *() const { return s; }"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"    const Ch* const s; //!< plain CharType pointer"},
{"lineNum":"  337","line":"    const SizeType length; //!< length of the string (excluding the trailing NULL terminator)"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"private:"},
{"lineNum":"  340","line":"    SizeType NotNullStrLen(const CharType* str) {"},
{"lineNum":"  341","line":"        CEREAL_RAPIDJSON_ASSERT(str != 0);"},
{"lineNum":"  342","line":"        return internal::StrLen(str);"},
{"lineNum":"  343","line":"    }"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"    /// Empty string - used when passing in a NULL pointer"},
{"lineNum":"  346","line":"    static const Ch emptyString[];"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"    //! Disallow construction from non-const array"},
{"lineNum":"  349","line":"    template<SizeType N>"},
{"lineNum":"  350","line":"    GenericStringRef(CharType (&str)[N]) /* = delete */;"},
{"lineNum":"  351","line":"    //! Copy assignment operator not permitted - immutable type"},
{"lineNum":"  352","line":"    GenericStringRef& operator=(const GenericStringRef& rhs) /* = delete */;"},
{"lineNum":"  353","line":"};"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"template<typename CharType>"},
{"lineNum":"  356","line":"const CharType GenericStringRef<CharType>::emptyString[] = { CharType() };"},
{"lineNum":"  357","line":""},
{"lineNum":"  358","line":"//! Mark a character pointer as constant string"},
{"lineNum":"  359","line":"/*! Mark a plain character pointer as a \"string literal\".  This function"},
{"lineNum":"  360","line":"    can be used to avoid copying a character string to be referenced as a"},
{"lineNum":"  361","line":"    value in a JSON GenericValue object, if the string\'s lifetime is known"},
{"lineNum":"  362","line":"    to be valid long enough."},
{"lineNum":"  363","line":"    \\tparam CharType Character type of the string"},
{"lineNum":"  364","line":"    \\param str Constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue"},
{"lineNum":"  365","line":"    \\return GenericStringRef string reference object"},
{"lineNum":"  366","line":"    \\relatesalso GenericStringRef"},
{"lineNum":"  367","line":""},
{"lineNum":"  368","line":"    \\see GenericValue::GenericValue(StringRefType), GenericValue::operator=(StringRefType), GenericValue::SetString(StringRefType), GenericValue::PushBack(StringRefType, Allocator&), GenericValue::AddMember"},
{"lineNum":"  369","line":"*/"},
{"lineNum":"  370","line":"template<typename CharType>"},
{"lineNum":"  371","line":"inline GenericStringRef<CharType> StringRef(const CharType* str) {"},
{"lineNum":"  372","line":"    return GenericStringRef<CharType>(str);"},
{"lineNum":"  373","line":"}"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"//! Mark a character pointer as constant string"},
{"lineNum":"  376","line":"/*! Mark a plain character pointer as a \"string literal\".  This function"},
{"lineNum":"  377","line":"    can be used to avoid copying a character string to be referenced as a"},
{"lineNum":"  378","line":"    value in a JSON GenericValue object, if the string\'s lifetime is known"},
{"lineNum":"  379","line":"    to be valid long enough."},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"    This version has better performance with supplied length, and also"},
{"lineNum":"  382","line":"    supports string containing null characters."},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"    \\tparam CharType character type of the string"},
{"lineNum":"  385","line":"    \\param str Constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue"},
{"lineNum":"  386","line":"    \\param length The length of source string."},
{"lineNum":"  387","line":"    \\return GenericStringRef string reference object"},
{"lineNum":"  388","line":"    \\relatesalso GenericStringRef"},
{"lineNum":"  389","line":"*/"},
{"lineNum":"  390","line":"template<typename CharType>"},
{"lineNum":"  391","line":"inline GenericStringRef<CharType> StringRef(const CharType* str, size_t length) {"},
{"lineNum":"  392","line":"    return GenericStringRef<CharType>(str, SizeType(length));"},
{"lineNum":"  393","line":"}"},
{"lineNum":"  394","line":""},
{"lineNum":"  395","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":"  396","line":"//! Mark a string object as constant string"},
{"lineNum":"  397","line":"/*! Mark a string object (e.g. \\c std::string) as a \"string literal\"."},
{"lineNum":"  398","line":"    This function can be used to avoid copying a string to be referenced as a"},
{"lineNum":"  399","line":"    value in a JSON GenericValue object, if the string\'s lifetime is known"},
{"lineNum":"  400","line":"    to be valid long enough."},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"    \\tparam CharType character type of the string"},
{"lineNum":"  403","line":"    \\param str Constant string, lifetime assumed to be longer than the use of the string in e.g. a GenericValue"},
{"lineNum":"  404","line":"    \\return GenericStringRef string reference object"},
{"lineNum":"  405","line":"    \\relatesalso GenericStringRef"},
{"lineNum":"  406","line":"    \\note Requires the definition of the preprocessor symbol \\ref CEREAL_RAPIDJSON_HAS_STDSTRING."},
{"lineNum":"  407","line":"*/"},
{"lineNum":"  408","line":"template<typename CharType>"},
{"lineNum":"  409","line":"inline GenericStringRef<CharType> StringRef(const std::basic_string<CharType>& str) {"},
{"lineNum":"  410","line":"    return GenericStringRef<CharType>(str.data(), SizeType(str.size()));"},
{"lineNum":"  411","line":"}"},
{"lineNum":"  412","line":"#endif"},
{"lineNum":"  413","line":""},
{"lineNum":"  414","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  415","line":"// GenericValue type traits"},
{"lineNum":"  416","line":"namespace internal {"},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"template <typename T, typename Encoding = void, typename Allocator = void>"},
{"lineNum":"  419","line":"struct IsGenericValueImpl : FalseType {};"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"// select candidates according to nested encoding and allocator types"},
{"lineNum":"  422","line":"template <typename T> struct IsGenericValueImpl<T, typename Void<typename T::EncodingType>::Type, typename Void<typename T::AllocatorType>::Type>"},
{"lineNum":"  423","line":"    : IsBaseOf<GenericValue<typename T::EncodingType, typename T::AllocatorType>, T>::Type {};"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"// helper to match arbitrary GenericValue instantiations, including derived classes"},
{"lineNum":"  426","line":"template <typename T> struct IsGenericValue : IsGenericValueImpl<T>::Type {};"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"} // namespace internal"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  431","line":"// TypeHelper"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"namespace internal {"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"template <typename ValueType, typename T>"},
{"lineNum":"  436","line":"struct TypeHelper {};"},
{"lineNum":"  437","line":""},
{"lineNum":"  438","line":"template<typename ValueType>"},
{"lineNum":"  439","line":"struct TypeHelper<ValueType, bool> {"},
{"lineNum":"  440","line":"    static bool Is(const ValueType& v) { return v.IsBool(); }"},
{"lineNum":"  441","line":"    static bool Get(const ValueType& v) { return v.GetBool(); }"},
{"lineNum":"  442","line":"    static ValueType& Set(ValueType& v, bool data) { return v.SetBool(data); }"},
{"lineNum":"  443","line":"    static ValueType& Set(ValueType& v, bool data, typename ValueType::AllocatorType&) { return v.SetBool(data); }"},
{"lineNum":"  444","line":"};"},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":"template<typename ValueType>"},
{"lineNum":"  447","line":"struct TypeHelper<ValueType, int> {"},
{"lineNum":"  448","line":"    static bool Is(const ValueType& v) { return v.IsInt(); }"},
{"lineNum":"  449","line":"    static int Get(const ValueType& v) { return v.GetInt(); }"},
{"lineNum":"  450","line":"    static ValueType& Set(ValueType& v, int data) { return v.SetInt(data); }"},
{"lineNum":"  451","line":"    static ValueType& Set(ValueType& v, int data, typename ValueType::AllocatorType&) { return v.SetInt(data); }"},
{"lineNum":"  452","line":"};"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"template<typename ValueType>"},
{"lineNum":"  455","line":"struct TypeHelper<ValueType, unsigned> {"},
{"lineNum":"  456","line":"    static bool Is(const ValueType& v) { return v.IsUint(); }"},
{"lineNum":"  457","line":"    static unsigned Get(const ValueType& v) { return v.GetUint(); }"},
{"lineNum":"  458","line":"    static ValueType& Set(ValueType& v, unsigned data) { return v.SetUint(data); }"},
{"lineNum":"  459","line":"    static ValueType& Set(ValueType& v, unsigned data, typename ValueType::AllocatorType&) { return v.SetUint(data); }"},
{"lineNum":"  460","line":"};"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"#ifdef _MSC_VER"},
{"lineNum":"  463","line":"CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(long) == sizeof(int));"},
{"lineNum":"  464","line":"template<typename ValueType>"},
{"lineNum":"  465","line":"struct TypeHelper<ValueType, long> {"},
{"lineNum":"  466","line":"    static bool Is(const ValueType& v) { return v.IsInt(); }"},
{"lineNum":"  467","line":"    static long Get(const ValueType& v) { return v.GetInt(); }"},
{"lineNum":"  468","line":"    static ValueType& Set(ValueType& v, long data) { return v.SetInt(data); }"},
{"lineNum":"  469","line":"    static ValueType& Set(ValueType& v, long data, typename ValueType::AllocatorType&) { return v.SetInt(data); }"},
{"lineNum":"  470","line":"};"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"CEREAL_RAPIDJSON_STATIC_ASSERT(sizeof(unsigned long) == sizeof(unsigned));"},
{"lineNum":"  473","line":"template<typename ValueType>"},
{"lineNum":"  474","line":"struct TypeHelper<ValueType, unsigned long> {"},
{"lineNum":"  475","line":"    static bool Is(const ValueType& v) { return v.IsUint(); }"},
{"lineNum":"  476","line":"    static unsigned long Get(const ValueType& v) { return v.GetUint(); }"},
{"lineNum":"  477","line":"    static ValueType& Set(ValueType& v, unsigned long data) { return v.SetUint(data); }"},
{"lineNum":"  478","line":"    static ValueType& Set(ValueType& v, unsigned long data, typename ValueType::AllocatorType&) { return v.SetUint(data); }"},
{"lineNum":"  479","line":"};"},
{"lineNum":"  480","line":"#endif"},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"template<typename ValueType>"},
{"lineNum":"  483","line":"struct TypeHelper<ValueType, int64_t> {"},
{"lineNum":"  484","line":"    static bool Is(const ValueType& v) { return v.IsInt64(); }"},
{"lineNum":"  485","line":"    static int64_t Get(const ValueType& v) { return v.GetInt64(); }"},
{"lineNum":"  486","line":"    static ValueType& Set(ValueType& v, int64_t data) { return v.SetInt64(data); }"},
{"lineNum":"  487","line":"    static ValueType& Set(ValueType& v, int64_t data, typename ValueType::AllocatorType&) { return v.SetInt64(data); }"},
{"lineNum":"  488","line":"};"},
{"lineNum":"  489","line":""},
{"lineNum":"  490","line":"template<typename ValueType>"},
{"lineNum":"  491","line":"struct TypeHelper<ValueType, uint64_t> {"},
{"lineNum":"  492","line":"    static bool Is(const ValueType& v) { return v.IsUint64(); }"},
{"lineNum":"  493","line":"    static uint64_t Get(const ValueType& v) { return v.GetUint64(); }"},
{"lineNum":"  494","line":"    static ValueType& Set(ValueType& v, uint64_t data) { return v.SetUint64(data); }"},
{"lineNum":"  495","line":"    static ValueType& Set(ValueType& v, uint64_t data, typename ValueType::AllocatorType&) { return v.SetUint64(data); }"},
{"lineNum":"  496","line":"};"},
{"lineNum":"  497","line":""},
{"lineNum":"  498","line":"template<typename ValueType>"},
{"lineNum":"  499","line":"struct TypeHelper<ValueType, double> {"},
{"lineNum":"  500","line":"    static bool Is(const ValueType& v) { return v.IsDouble(); }"},
{"lineNum":"  501","line":"    static double Get(const ValueType& v) { return v.GetDouble(); }"},
{"lineNum":"  502","line":"    static ValueType& Set(ValueType& v, double data) { return v.SetDouble(data); }"},
{"lineNum":"  503","line":"    static ValueType& Set(ValueType& v, double data, typename ValueType::AllocatorType&) { return v.SetDouble(data); }"},
{"lineNum":"  504","line":"};"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"template<typename ValueType>"},
{"lineNum":"  507","line":"struct TypeHelper<ValueType, float> {"},
{"lineNum":"  508","line":"    static bool Is(const ValueType& v) { return v.IsFloat(); }"},
{"lineNum":"  509","line":"    static float Get(const ValueType& v) { return v.GetFloat(); }"},
{"lineNum":"  510","line":"    static ValueType& Set(ValueType& v, float data) { return v.SetFloat(data); }"},
{"lineNum":"  511","line":"    static ValueType& Set(ValueType& v, float data, typename ValueType::AllocatorType&) { return v.SetFloat(data); }"},
{"lineNum":"  512","line":"};"},
{"lineNum":"  513","line":""},
{"lineNum":"  514","line":"template<typename ValueType>"},
{"lineNum":"  515","line":"struct TypeHelper<ValueType, const typename ValueType::Ch*> {"},
{"lineNum":"  516","line":"    typedef const typename ValueType::Ch* StringType;"},
{"lineNum":"  517","line":"    static bool Is(const ValueType& v) { return v.IsString(); }"},
{"lineNum":"  518","line":"    static StringType Get(const ValueType& v) { return v.GetString(); }"},
{"lineNum":"  519","line":"    static ValueType& Set(ValueType& v, const StringType data) { return v.SetString(typename ValueType::StringRefType(data)); }"},
{"lineNum":"  520","line":"    static ValueType& Set(ValueType& v, const StringType data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }"},
{"lineNum":"  521","line":"};"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":"  524","line":"template<typename ValueType>"},
{"lineNum":"  525","line":"struct TypeHelper<ValueType, std::basic_string<typename ValueType::Ch> > {"},
{"lineNum":"  526","line":"    typedef std::basic_string<typename ValueType::Ch> StringType;"},
{"lineNum":"  527","line":"    static bool Is(const ValueType& v) { return v.IsString(); }"},
{"lineNum":"  528","line":"    static StringType Get(const ValueType& v) { return StringType(v.GetString(), v.GetStringLength()); }"},
{"lineNum":"  529","line":"    static ValueType& Set(ValueType& v, const StringType& data, typename ValueType::AllocatorType& a) { return v.SetString(data, a); }"},
{"lineNum":"  530","line":"};"},
{"lineNum":"  531","line":"#endif"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"template<typename ValueType>"},
{"lineNum":"  534","line":"struct TypeHelper<ValueType, typename ValueType::Array> {"},
{"lineNum":"  535","line":"    typedef typename ValueType::Array ArrayType;"},
{"lineNum":"  536","line":"    static bool Is(const ValueType& v) { return v.IsArray(); }"},
{"lineNum":"  537","line":"    static ArrayType Get(ValueType& v) { return v.GetArray(); }"},
{"lineNum":"  538","line":"    static ValueType& Set(ValueType& v, ArrayType data) { return v = data; }"},
{"lineNum":"  539","line":"    static ValueType& Set(ValueType& v, ArrayType data, typename ValueType::AllocatorType&) { return v = data; }"},
{"lineNum":"  540","line":"};"},
{"lineNum":"  541","line":""},
{"lineNum":"  542","line":"template<typename ValueType>"},
{"lineNum":"  543","line":"struct TypeHelper<ValueType, typename ValueType::ConstArray> {"},
{"lineNum":"  544","line":"    typedef typename ValueType::ConstArray ArrayType;"},
{"lineNum":"  545","line":"    static bool Is(const ValueType& v) { return v.IsArray(); }"},
{"lineNum":"  546","line":"    static ArrayType Get(const ValueType& v) { return v.GetArray(); }"},
{"lineNum":"  547","line":"};"},
{"lineNum":"  548","line":""},
{"lineNum":"  549","line":"template<typename ValueType>"},
{"lineNum":"  550","line":"struct TypeHelper<ValueType, typename ValueType::Object> {"},
{"lineNum":"  551","line":"    typedef typename ValueType::Object ObjectType;"},
{"lineNum":"  552","line":"    static bool Is(const ValueType& v) { return v.IsObject(); }"},
{"lineNum":"  553","line":"    static ObjectType Get(ValueType& v) { return v.GetObject(); }"},
{"lineNum":"  554","line":"    static ValueType& Set(ValueType& v, ObjectType data) { return v = data; }"},
{"lineNum":"  555","line":"    static ValueType& Set(ValueType& v, ObjectType data, typename ValueType::AllocatorType&) { return v = data; }"},
{"lineNum":"  556","line":"};"},
{"lineNum":"  557","line":""},
{"lineNum":"  558","line":"template<typename ValueType>"},
{"lineNum":"  559","line":"struct TypeHelper<ValueType, typename ValueType::ConstObject> {"},
{"lineNum":"  560","line":"    typedef typename ValueType::ConstObject ObjectType;"},
{"lineNum":"  561","line":"    static bool Is(const ValueType& v) { return v.IsObject(); }"},
{"lineNum":"  562","line":"    static ObjectType Get(const ValueType& v) { return v.GetObject(); }"},
{"lineNum":"  563","line":"};"},
{"lineNum":"  564","line":""},
{"lineNum":"  565","line":"} // namespace internal"},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"// Forward declarations"},
{"lineNum":"  568","line":"template <bool, typename> class GenericArray;"},
{"lineNum":"  569","line":"template <bool, typename> class GenericObject;"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  572","line":"// GenericValue"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"//! Represents a JSON value. Use Value for UTF8 encoding and default allocator."},
{"lineNum":"  575","line":"/*!"},
{"lineNum":"  576","line":"    A JSON value can be one of 7 types. This class is a variant type supporting"},
{"lineNum":"  577","line":"    these types."},
{"lineNum":"  578","line":""},
{"lineNum":"  579","line":"    Use the Value if UTF8 and default allocator"},
{"lineNum":"  580","line":""},
{"lineNum":"  581","line":"    \\tparam Encoding    Encoding of the value. (Even non-string values need to have the same encoding in a document)"},
{"lineNum":"  582","line":"    \\tparam Allocator   Allocator type for allocating memory of object, array and string."},
{"lineNum":"  583","line":"*/"},
{"lineNum":"  584","line":"template <typename Encoding, typename Allocator = MemoryPoolAllocator<> >"},
{"lineNum":"  585","line":"class GenericValue {"},
{"lineNum":"  586","line":"public:"},
{"lineNum":"  587","line":"    //! Name-value pair in an object."},
{"lineNum":"  588","line":"    typedef GenericMember<Encoding, Allocator> Member;"},
{"lineNum":"  589","line":"    typedef Encoding EncodingType;                  //!< Encoding type from template parameter."},
{"lineNum":"  590","line":"    typedef Allocator AllocatorType;                //!< Allocator type from template parameter."},
{"lineNum":"  591","line":"    typedef typename Encoding::Ch Ch;               //!< Character type derived from Encoding."},
{"lineNum":"  592","line":"    typedef GenericStringRef<Ch> StringRefType;     //!< Reference to a constant string"},
{"lineNum":"  593","line":"    typedef typename GenericMemberIterator<false,Encoding,Allocator>::Iterator MemberIterator;  //!< Member iterator for iterating in object."},
{"lineNum":"  594","line":"    typedef typename GenericMemberIterator<true,Encoding,Allocator>::Iterator ConstMemberIterator;  //!< Constant member iterator for iterating in object."},
{"lineNum":"  595","line":"    typedef GenericValue* ValueIterator;            //!< Value iterator for iterating in array."},
{"lineNum":"  596","line":"    typedef const GenericValue* ConstValueIterator; //!< Constant value iterator for iterating in array."},
{"lineNum":"  597","line":"    typedef GenericValue<Encoding, Allocator> ValueType;    //!< Value type of itself."},
{"lineNum":"  598","line":"    typedef GenericArray<false, ValueType> Array;"},
{"lineNum":"  599","line":"    typedef GenericArray<true, ValueType> ConstArray;"},
{"lineNum":"  600","line":"    typedef GenericObject<false, ValueType> Object;"},
{"lineNum":"  601","line":"    typedef GenericObject<true, ValueType> ConstObject;"},
{"lineNum":"  602","line":""},
{"lineNum":"  603","line":"    //!@name Constructors and destructor."},
{"lineNum":"  604","line":"    //@{"},
{"lineNum":"  605","line":""},
{"lineNum":"  606","line":"    //! Default constructor creates a null value."},
{"lineNum":"  607","line":"    GenericValue() CEREAL_RAPIDJSON_NOEXCEPT : data_() { data_.f.flags = kNullFlag; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  608","line":""},
{"lineNum":"  609","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":"  610","line":"    //! Move constructor in C++11"},
{"lineNum":"  611","line":"    GenericValue(GenericValue&& rhs) CEREAL_RAPIDJSON_NOEXCEPT : data_(rhs.data_) {"},
{"lineNum":"  612","line":"        rhs.data_.f.flags = kNullFlag; // give up contents"},
{"lineNum":"  613","line":"    }"},
{"lineNum":"  614","line":"#endif"},
{"lineNum":"  615","line":""},
{"lineNum":"  616","line":"private:"},
{"lineNum":"  617","line":"    //! Copy constructor is not permitted."},
{"lineNum":"  618","line":"    GenericValue(const GenericValue& rhs);"},
{"lineNum":"  619","line":""},
{"lineNum":"  620","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":"  621","line":"    //! Moving from a GenericDocument is not permitted."},
{"lineNum":"  622","line":"    template <typename StackAllocator>"},
{"lineNum":"  623","line":"    GenericValue(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);"},
{"lineNum":"  624","line":""},
{"lineNum":"  625","line":"    //! Move assignment from a GenericDocument is not permitted."},
{"lineNum":"  626","line":"    template <typename StackAllocator>"},
{"lineNum":"  627","line":"    GenericValue& operator=(GenericDocument<Encoding,Allocator,StackAllocator>&& rhs);"},
{"lineNum":"  628","line":"#endif"},
{"lineNum":"  629","line":""},
{"lineNum":"  630","line":"public:"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":"    //! Constructor with JSON value type."},
{"lineNum":"  633","line":"    /*! This creates a Value of specified type with default content."},
{"lineNum":"  634","line":"        \\param type Type of the value."},
{"lineNum":"  635","line":"        \\note Default content for number is zero."},
{"lineNum":"  636","line":"    */"},
{"lineNum":"  637","line":"    explicit GenericValue(Type type) CEREAL_RAPIDJSON_NOEXCEPT : data_() {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  638","line":"        static const uint16_t defaultFlags[] = {"},
{"lineNum":"  639","line":"            kNullFlag, kFalseFlag, kTrueFlag, kObjectFlag, kArrayFlag, kShortStringFlag,"},
{"lineNum":"  640","line":"            kNumberAnyFlag"},
{"lineNum":"  641","line":"        };"},
{"lineNum":"  642","line":"        CEREAL_RAPIDJSON_NOEXCEPT_ASSERT(type >= kNullType && type <= kNumberType);"},
{"lineNum":"  643","line":"        data_.f.flags = defaultFlags[type];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  644","line":""},
{"lineNum":"  645","line":"        // Use ShortString to store empty string."},
{"lineNum":"  646","line":"        if (type == kStringType)"},
{"lineNum":"  647","line":"            data_.ss.SetLength(0);"},
{"lineNum":"  648","line":"    }"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"    //! Explicit copy constructor (with allocator)"},
{"lineNum":"  651","line":"    /*! Creates a copy of a Value by using the given Allocator"},
{"lineNum":"  652","line":"        \\tparam SourceAllocator allocator of \\c rhs"},
{"lineNum":"  653","line":"        \\param rhs Value to copy from (read-only)"},
{"lineNum":"  654","line":"        \\param allocator Allocator for allocating copied elements and buffers. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":"  655","line":"        \\param copyConstStrings Force copying of constant strings (e.g. referencing an in-situ buffer)"},
{"lineNum":"  656","line":"        \\see CopyFrom()"},
{"lineNum":"  657","line":"    */"},
{"lineNum":"  658","line":"    template <typename SourceAllocator>"},
{"lineNum":"  659","line":"    GenericValue(const GenericValue<Encoding,SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings = false) {"},
{"lineNum":"  660","line":"        switch (rhs.GetType()) {"},
{"lineNum":"  661","line":"        case kObjectType: {"},
{"lineNum":"  662","line":"                SizeType count = rhs.data_.o.size;"},
{"lineNum":"  663","line":"                Member* lm = reinterpret_cast<Member*>(allocator.Malloc(count * sizeof(Member)));"},
{"lineNum":"  664","line":"                const typename GenericValue<Encoding,SourceAllocator>::Member* rm = rhs.GetMembersPointer();"},
{"lineNum":"  665","line":"                for (SizeType i = 0; i < count; i++) {"},
{"lineNum":"  666","line":"                    new (&lm[i].name) GenericValue(rm[i].name, allocator, copyConstStrings);"},
{"lineNum":"  667","line":"                    new (&lm[i].value) GenericValue(rm[i].value, allocator, copyConstStrings);"},
{"lineNum":"  668","line":"                }"},
{"lineNum":"  669","line":"                data_.f.flags = kObjectFlag;"},
{"lineNum":"  670","line":"                data_.o.size = data_.o.capacity = count;"},
{"lineNum":"  671","line":"                SetMembersPointer(lm);"},
{"lineNum":"  672","line":"            }"},
{"lineNum":"  673","line":"            break;"},
{"lineNum":"  674","line":"        case kArrayType: {"},
{"lineNum":"  675","line":"                SizeType count = rhs.data_.a.size;"},
{"lineNum":"  676","line":"                GenericValue* le = reinterpret_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));"},
{"lineNum":"  677","line":"                const GenericValue<Encoding,SourceAllocator>* re = rhs.GetElementsPointer();"},
{"lineNum":"  678","line":"                for (SizeType i = 0; i < count; i++)"},
{"lineNum":"  679","line":"                    new (&le[i]) GenericValue(re[i], allocator, copyConstStrings);"},
{"lineNum":"  680","line":"                data_.f.flags = kArrayFlag;"},
{"lineNum":"  681","line":"                data_.a.size = data_.a.capacity = count;"},
{"lineNum":"  682","line":"                SetElementsPointer(le);"},
{"lineNum":"  683","line":"            }"},
{"lineNum":"  684","line":"            break;"},
{"lineNum":"  685","line":"        case kStringType:"},
{"lineNum":"  686","line":"            if (rhs.data_.f.flags == kConstStringFlag && !copyConstStrings) {"},
{"lineNum":"  687","line":"                data_.f.flags = rhs.data_.f.flags;"},
{"lineNum":"  688","line":"                data_  = *reinterpret_cast<const Data*>(&rhs.data_);"},
{"lineNum":"  689","line":"            }"},
{"lineNum":"  690","line":"            else"},
{"lineNum":"  691","line":"                SetStringRaw(StringRef(rhs.GetString(), rhs.GetStringLength()), allocator);"},
{"lineNum":"  692","line":"            break;"},
{"lineNum":"  693","line":"        default:"},
{"lineNum":"  694","line":"            data_.f.flags = rhs.data_.f.flags;"},
{"lineNum":"  695","line":"            data_  = *reinterpret_cast<const Data*>(&rhs.data_);"},
{"lineNum":"  696","line":"            break;"},
{"lineNum":"  697","line":"        }"},
{"lineNum":"  698","line":"    }"},
{"lineNum":"  699","line":""},
{"lineNum":"  700","line":"    //! Constructor for boolean value."},
{"lineNum":"  701","line":"    /*! \\param b Boolean value"},
{"lineNum":"  702","line":"        \\note This constructor is limited to \\em real boolean values and rejects"},
{"lineNum":"  703","line":"            implicitly converted types like arbitrary pointers.  Use an explicit cast"},
{"lineNum":"  704","line":"            to \\c bool, if you want to construct a boolean JSON value in such cases."},
{"lineNum":"  705","line":"     */"},
{"lineNum":"  706","line":"#ifndef CEREAL_RAPIDJSON_DOXYGEN_RUNNING // hide SFINAE from Doxygen"},
{"lineNum":"  707","line":"    template <typename T>"},
{"lineNum":"  708","line":"    explicit GenericValue(T b, CEREAL_RAPIDJSON_ENABLEIF((internal::IsSame<bool, T>))) CEREAL_RAPIDJSON_NOEXCEPT  // See #472"},
{"lineNum":"  709","line":"#else"},
{"lineNum":"  710","line":"    explicit GenericValue(bool b) CEREAL_RAPIDJSON_NOEXCEPT"},
{"lineNum":"  711","line":"#endif"},
{"lineNum":"  712","line":"        : data_() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  713","line":"            // safe-guard against failing SFINAE"},
{"lineNum":"  714","line":"            CEREAL_RAPIDJSON_STATIC_ASSERT((internal::IsSame<bool,T>::Value));"},
{"lineNum":"  715","line":"            data_.f.flags = b ? kTrueFlag : kFalseFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  716","line":"    }"},
{"lineNum":"  717","line":""},
{"lineNum":"  718","line":"    //! Constructor for int value."},
{"lineNum":"  719","line":"    explicit GenericValue(int i) CEREAL_RAPIDJSON_NOEXCEPT : data_() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  720","line":"        data_.n.i64 = i;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  721","line":"        data_.f.flags = (i >= 0) ? (kNumberIntFlag | kUintFlag | kUint64Flag) : kNumberIntFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  722","line":"    }"},
{"lineNum":"  723","line":""},
{"lineNum":"  724","line":"    //! Constructor for unsigned value."},
{"lineNum":"  725","line":"    explicit GenericValue(unsigned u) CEREAL_RAPIDJSON_NOEXCEPT : data_() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  726","line":"        data_.n.u64 = u;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  727","line":"        data_.f.flags = (u & 0x80000000) ? kNumberUintFlag : (kNumberUintFlag | kIntFlag | kInt64Flag);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  728","line":"    }"},
{"lineNum":"  729","line":""},
{"lineNum":"  730","line":"    //! Constructor for int64_t value."},
{"lineNum":"  731","line":"    explicit GenericValue(int64_t i64) CEREAL_RAPIDJSON_NOEXCEPT : data_() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  732","line":"        data_.n.i64 = i64;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  733","line":"        data_.f.flags = kNumberInt64Flag;"},
{"lineNum":"  734","line":"        if (i64 >= 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  735","line":"            data_.f.flags |= kNumberUint64Flag;"},
{"lineNum":"  736","line":"            if (!(static_cast<uint64_t>(i64) & CEREAL_RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  737","line":"                data_.f.flags |= kUintFlag;"},
{"lineNum":"  738","line":"            if (!(static_cast<uint64_t>(i64) & CEREAL_RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  739","line":"                data_.f.flags |= kIntFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  740","line":"        }"},
{"lineNum":"  741","line":"        else if (i64 >= static_cast<int64_t>(CEREAL_RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  742","line":"            data_.f.flags |= kIntFlag;"},
{"lineNum":"  743","line":"    }"},
{"lineNum":"  744","line":""},
{"lineNum":"  745","line":"    //! Constructor for uint64_t value."},
{"lineNum":"  746","line":"    explicit GenericValue(uint64_t u64) CEREAL_RAPIDJSON_NOEXCEPT : data_() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  747","line":"        data_.n.u64 = u64;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  748","line":"        data_.f.flags = kNumberUint64Flag;"},
{"lineNum":"  749","line":"        if (!(u64 & CEREAL_RAPIDJSON_UINT64_C2(0x80000000, 0x00000000)))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  750","line":"            data_.f.flags |= kInt64Flag;"},
{"lineNum":"  751","line":"        if (!(u64 & CEREAL_RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x00000000)))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  752","line":"            data_.f.flags |= kUintFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  753","line":"        if (!(u64 & CEREAL_RAPIDJSON_UINT64_C2(0xFFFFFFFF, 0x80000000)))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  754","line":"            data_.f.flags |= kIntFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  755","line":"    }"},
{"lineNum":"  756","line":""},
{"lineNum":"  757","line":"    //! Constructor for double value."},
{"lineNum":"  758","line":"    explicit GenericValue(double d) CEREAL_RAPIDJSON_NOEXCEPT : data_() { data_.n.d = d; data_.f.flags = kNumberDoubleFlag; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  759","line":""},
{"lineNum":"  760","line":"    //! Constructor for float value."},
{"lineNum":"  761","line":"    explicit GenericValue(float f) CEREAL_RAPIDJSON_NOEXCEPT : data_() { data_.n.d = static_cast<double>(f); data_.f.flags = kNumberDoubleFlag; }"},
{"lineNum":"  762","line":""},
{"lineNum":"  763","line":"    //! Constructor for constant string (i.e. do not make a copy of string)"},
{"lineNum":"  764","line":"    GenericValue(const Ch* s, SizeType length) CEREAL_RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(StringRef(s, length)); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"    //! Constructor for constant string (i.e. do not make a copy of string)"},
{"lineNum":"  767","line":"    explicit GenericValue(StringRefType s) CEREAL_RAPIDJSON_NOEXCEPT : data_() { SetStringRaw(s); }"},
{"lineNum":"  768","line":""},
{"lineNum":"  769","line":"    //! Constructor for copy-string (i.e. do make a copy of string)"},
{"lineNum":"  770","line":"    GenericValue(const Ch* s, SizeType length, Allocator& allocator) : data_() { SetStringRaw(StringRef(s, length), allocator); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  771","line":""},
{"lineNum":"  772","line":"    //! Constructor for copy-string (i.e. do make a copy of string)"},
{"lineNum":"  773","line":"    GenericValue(const Ch*s, Allocator& allocator) : data_() { SetStringRaw(StringRef(s), allocator); }"},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":"  776","line":"    //! Constructor for copy-string from a string object (i.e. do make a copy of string)"},
{"lineNum":"  777","line":"    /*! \\note Requires the definition of the preprocessor symbol \\ref CEREAL_RAPIDJSON_HAS_STDSTRING."},
{"lineNum":"  778","line":"     */"},
{"lineNum":"  779","line":"    GenericValue(const std::basic_string<Ch>& s, Allocator& allocator) : data_() { SetStringRaw(StringRef(s), allocator); }"},
{"lineNum":"  780","line":"#endif"},
{"lineNum":"  781","line":""},
{"lineNum":"  782","line":"    //! Constructor for Array."},
{"lineNum":"  783","line":"    /*!"},
{"lineNum":"  784","line":"        \\param a An array obtained by \\c GetArray()."},
{"lineNum":"  785","line":"        \\note \\c Array is always pass-by-value."},
{"lineNum":"  786","line":"        \\note the source array is moved into this value and the sourec array becomes empty."},
{"lineNum":"  787","line":"    */"},
{"lineNum":"  788","line":"    GenericValue(Array a) CEREAL_RAPIDJSON_NOEXCEPT : data_(a.value_.data_) {"},
{"lineNum":"  789","line":"        a.value_.data_ = Data();"},
{"lineNum":"  790","line":"        a.value_.data_.f.flags = kArrayFlag;"},
{"lineNum":"  791","line":"    }"},
{"lineNum":"  792","line":""},
{"lineNum":"  793","line":"    //! Constructor for Object."},
{"lineNum":"  794","line":"    /*!"},
{"lineNum":"  795","line":"        \\param o An object obtained by \\c GetObject()."},
{"lineNum":"  796","line":"        \\note \\c Object is always pass-by-value."},
{"lineNum":"  797","line":"        \\note the source object is moved into this value and the sourec object becomes empty."},
{"lineNum":"  798","line":"    */"},
{"lineNum":"  799","line":"    GenericValue(Object o) CEREAL_RAPIDJSON_NOEXCEPT : data_(o.value_.data_) {"},
{"lineNum":"  800","line":"        o.value_.data_ = Data();"},
{"lineNum":"  801","line":"        o.value_.data_.f.flags = kObjectFlag;"},
{"lineNum":"  802","line":"    }"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"    //! Destructor."},
{"lineNum":"  805","line":"    /*! Need to destruct elements of array, members of object, or copy-string."},
{"lineNum":"  806","line":"    */"},
{"lineNum":"  807","line":"    ~GenericValue() {"},
{"lineNum":"  808","line":"        if (Allocator::kNeedFree) { // Shortcut by Allocator\'s trait"},
{"lineNum":"  809","line":"            switch(data_.f.flags) {"},
{"lineNum":"  810","line":"            case kArrayFlag:"},
{"lineNum":"  811","line":"                {"},
{"lineNum":"  812","line":"                    GenericValue* e = GetElementsPointer();"},
{"lineNum":"  813","line":"                    for (GenericValue* v = e; v != e + data_.a.size; ++v)"},
{"lineNum":"  814","line":"                        v->~GenericValue();"},
{"lineNum":"  815","line":"                    Allocator::Free(e);"},
{"lineNum":"  816","line":"                }"},
{"lineNum":"  817","line":"                break;"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"            case kObjectFlag:"},
{"lineNum":"  820","line":"                for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)"},
{"lineNum":"  821","line":"                    m->~Member();"},
{"lineNum":"  822","line":"                Allocator::Free(GetMembersPointer());"},
{"lineNum":"  823","line":"                break;"},
{"lineNum":"  824","line":""},
{"lineNum":"  825","line":"            case kCopyStringFlag:"},
{"lineNum":"  826","line":"                Allocator::Free(const_cast<Ch*>(GetStringPointer()));"},
{"lineNum":"  827","line":"                break;"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"            default:"},
{"lineNum":"  830","line":"                break;  // Do nothing for other types."},
{"lineNum":"  831","line":"            }"},
{"lineNum":"  832","line":"        }"},
{"lineNum":"  833","line":"    }"},
{"lineNum":"  834","line":""},
{"lineNum":"  835","line":"    //@}"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"    //!@name Assignment operators"},
{"lineNum":"  838","line":"    //@{"},
{"lineNum":"  839","line":""},
{"lineNum":"  840","line":"    //! Assignment with move semantics."},
{"lineNum":"  841","line":"    /*! \\param rhs Source of the assignment. It will become a null value after assignment."},
{"lineNum":"  842","line":"    */"},
{"lineNum":"  843","line":"    GenericValue& operator=(GenericValue& rhs) CEREAL_RAPIDJSON_NOEXCEPT {"},
{"lineNum":"  844","line":"        if (CEREAL_RAPIDJSON_LIKELY(this != &rhs)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  845","line":"            this->~GenericValue();"},
{"lineNum":"  846","line":"            RawAssign(rhs);"},
{"lineNum":"  847","line":"        }"},
{"lineNum":"  848","line":"        return *this;"},
{"lineNum":"  849","line":"    }"},
{"lineNum":"  850","line":""},
{"lineNum":"  851","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":"  852","line":"    //! Move assignment in C++11"},
{"lineNum":"  853","line":"    GenericValue& operator=(GenericValue&& rhs) CEREAL_RAPIDJSON_NOEXCEPT {"},
{"lineNum":"  854","line":"        return *this = rhs.Move();"},
{"lineNum":"  855","line":"    }"},
{"lineNum":"  856","line":"#endif"},
{"lineNum":"  857","line":""},
{"lineNum":"  858","line":"    //! Assignment of constant string reference (no copy)"},
{"lineNum":"  859","line":"    /*! \\param str Constant string reference to be assigned"},
{"lineNum":"  860","line":"        \\note This overload is needed to avoid clashes with the generic primitive type assignment overload below."},
{"lineNum":"  861","line":"        \\see GenericStringRef, operator=(T)"},
{"lineNum":"  862","line":"    */"},
{"lineNum":"  863","line":"    GenericValue& operator=(StringRefType str) CEREAL_RAPIDJSON_NOEXCEPT {"},
{"lineNum":"  864","line":"        GenericValue s(str);"},
{"lineNum":"  865","line":"        return *this = s;"},
{"lineNum":"  866","line":"    }"},
{"lineNum":"  867","line":""},
{"lineNum":"  868","line":"    //! Assignment with primitive types."},
{"lineNum":"  869","line":"    /*! \\tparam T Either \\ref Type, \\c int, \\c unsigned, \\c int64_t, \\c uint64_t"},
{"lineNum":"  870","line":"        \\param value The value to be assigned."},
{"lineNum":"  871","line":""},
{"lineNum":"  872","line":"        \\note The source type \\c T explicitly disallows all pointer types,"},
{"lineNum":"  873","line":"            especially (\\c const) \\ref Ch*.  This helps avoiding implicitly"},
{"lineNum":"  874","line":"            referencing character strings with insufficient lifetime, use"},
{"lineNum":"  875","line":"            \\ref SetString(const Ch*, Allocator&) (for copying) or"},
{"lineNum":"  876","line":"            \\ref StringRef() (to explicitly mark the pointer as constant) instead."},
{"lineNum":"  877","line":"            All other pointer types would implicitly convert to \\c bool,"},
{"lineNum":"  878","line":"            use \\ref SetBool() instead."},
{"lineNum":"  879","line":"    */"},
{"lineNum":"  880","line":"    template <typename T>"},
{"lineNum":"  881","line":"    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::IsPointer<T>), (GenericValue&))"},
{"lineNum":"  882","line":"    operator=(T value) {"},
{"lineNum":"  883","line":"        GenericValue v(value);"},
{"lineNum":"  884","line":"        return *this = v;"},
{"lineNum":"  885","line":"    }"},
{"lineNum":"  886","line":""},
{"lineNum":"  887","line":"    //! Deep-copy assignment from Value"},
{"lineNum":"  888","line":"    /*! Assigns a \\b copy of the Value to the current Value object"},
{"lineNum":"  889","line":"        \\tparam SourceAllocator Allocator type of \\c rhs"},
{"lineNum":"  890","line":"        \\param rhs Value to copy from (read-only)"},
{"lineNum":"  891","line":"        \\param allocator Allocator to use for copying"},
{"lineNum":"  892","line":"        \\param copyConstStrings Force copying of constant strings (e.g. referencing an in-situ buffer)"},
{"lineNum":"  893","line":"     */"},
{"lineNum":"  894","line":"    template <typename SourceAllocator>"},
{"lineNum":"  895","line":"    GenericValue& CopyFrom(const GenericValue<Encoding, SourceAllocator>& rhs, Allocator& allocator, bool copyConstStrings = false) {"},
{"lineNum":"  896","line":"        CEREAL_RAPIDJSON_ASSERT(static_cast<void*>(this) != static_cast<void const*>(&rhs));"},
{"lineNum":"  897","line":"        this->~GenericValue();"},
{"lineNum":"  898","line":"        new (this) GenericValue(rhs, allocator, copyConstStrings);"},
{"lineNum":"  899","line":"        return *this;"},
{"lineNum":"  900","line":"    }"},
{"lineNum":"  901","line":""},
{"lineNum":"  902","line":"    //! Exchange the contents of this value with those of other."},
{"lineNum":"  903","line":"    /*!"},
{"lineNum":"  904","line":"        \\param other Another value."},
{"lineNum":"  905","line":"        \\note Constant complexity."},
{"lineNum":"  906","line":"    */"},
{"lineNum":"  907","line":"    GenericValue& Swap(GenericValue& other) CEREAL_RAPIDJSON_NOEXCEPT {"},
{"lineNum":"  908","line":"        GenericValue temp;"},
{"lineNum":"  909","line":"        temp.RawAssign(*this);"},
{"lineNum":"  910","line":"        RawAssign(other);"},
{"lineNum":"  911","line":"        other.RawAssign(temp);"},
{"lineNum":"  912","line":"        return *this;"},
{"lineNum":"  913","line":"    }"},
{"lineNum":"  914","line":""},
{"lineNum":"  915","line":"    //! free-standing swap function helper"},
{"lineNum":"  916","line":"    /*!"},
{"lineNum":"  917","line":"        Helper function to enable support for common swap implementation pattern based on \\c std::swap:"},
{"lineNum":"  918","line":"        \\code"},
{"lineNum":"  919","line":"        void swap(MyClass& a, MyClass& b) {"},
{"lineNum":"  920","line":"            using std::swap;"},
{"lineNum":"  921","line":"            swap(a.value, b.value);"},
{"lineNum":"  922","line":"            // ..."},
{"lineNum":"  923","line":"        }"},
{"lineNum":"  924","line":"        \\endcode"},
{"lineNum":"  925","line":"        \\see Swap()"},
{"lineNum":"  926","line":"     */"},
{"lineNum":"  927","line":"    friend inline void swap(GenericValue& a, GenericValue& b) CEREAL_RAPIDJSON_NOEXCEPT { a.Swap(b); }"},
{"lineNum":"  928","line":""},
{"lineNum":"  929","line":"    //! Prepare Value for move semantics"},
{"lineNum":"  930","line":"    /*! \\return *this */"},
{"lineNum":"  931","line":"    GenericValue& Move() CEREAL_RAPIDJSON_NOEXCEPT { return *this; }"},
{"lineNum":"  932","line":"    //@}"},
{"lineNum":"  933","line":""},
{"lineNum":"  934","line":"    //!@name Equal-to and not-equal-to operators"},
{"lineNum":"  935","line":"    //@{"},
{"lineNum":"  936","line":"    //! Equal-to operator"},
{"lineNum":"  937","line":"    /*!"},
{"lineNum":"  938","line":"        \\note If an object contains duplicated named member, comparing equality with any object is always \\c false."},
{"lineNum":"  939","line":"        \\note Complexity is quadratic in Object\'s member number and linear for the rest (number of all values in the subtree and total lengths of all strings)."},
{"lineNum":"  940","line":"    */"},
{"lineNum":"  941","line":"    template <typename SourceAllocator>"},
{"lineNum":"  942","line":"    bool operator==(const GenericValue<Encoding, SourceAllocator>& rhs) const {"},
{"lineNum":"  943","line":"        typedef GenericValue<Encoding, SourceAllocator> RhsType;"},
{"lineNum":"  944","line":"        if (GetType() != rhs.GetType())"},
{"lineNum":"  945","line":"            return false;"},
{"lineNum":"  946","line":""},
{"lineNum":"  947","line":"        switch (GetType()) {"},
{"lineNum":"  948","line":"        case kObjectType: // Warning: O(n^2) inner-loop"},
{"lineNum":"  949","line":"            if (data_.o.size != rhs.data_.o.size)"},
{"lineNum":"  950","line":"                return false;"},
{"lineNum":"  951","line":"            for (ConstMemberIterator lhsMemberItr = MemberBegin(); lhsMemberItr != MemberEnd(); ++lhsMemberItr) {"},
{"lineNum":"  952","line":"                typename RhsType::ConstMemberIterator rhsMemberItr = rhs.FindMember(lhsMemberItr->name);"},
{"lineNum":"  953","line":"                if (rhsMemberItr == rhs.MemberEnd() || lhsMemberItr->value != rhsMemberItr->value)"},
{"lineNum":"  954","line":"                    return false;"},
{"lineNum":"  955","line":"            }"},
{"lineNum":"  956","line":"            return true;"},
{"lineNum":"  957","line":""},
{"lineNum":"  958","line":"        case kArrayType:"},
{"lineNum":"  959","line":"            if (data_.a.size != rhs.data_.a.size)"},
{"lineNum":"  960","line":"                return false;"},
{"lineNum":"  961","line":"            for (SizeType i = 0; i < data_.a.size; i++)"},
{"lineNum":"  962","line":"                if ((*this)[i] != rhs[i])"},
{"lineNum":"  963","line":"                    return false;"},
{"lineNum":"  964","line":"            return true;"},
{"lineNum":"  965","line":""},
{"lineNum":"  966","line":"        case kStringType:"},
{"lineNum":"  967","line":"            return StringEqual(rhs);"},
{"lineNum":"  968","line":""},
{"lineNum":"  969","line":"        case kNumberType:"},
{"lineNum":"  970","line":"            if (IsDouble() || rhs.IsDouble()) {"},
{"lineNum":"  971","line":"                double a = GetDouble();     // May convert from integer to double."},
{"lineNum":"  972","line":"                double b = rhs.GetDouble(); // Ditto"},
{"lineNum":"  973","line":"                return a >= b && a <= b;    // Prevent -Wfloat-equal"},
{"lineNum":"  974","line":"            }"},
{"lineNum":"  975","line":"            else"},
{"lineNum":"  976","line":"                return data_.n.u64 == rhs.data_.n.u64;"},
{"lineNum":"  977","line":""},
{"lineNum":"  978","line":"        default:"},
{"lineNum":"  979","line":"            return true;"},
{"lineNum":"  980","line":"        }"},
{"lineNum":"  981","line":"    }"},
{"lineNum":"  982","line":""},
{"lineNum":"  983","line":"    //! Equal-to operator with const C-string pointer"},
{"lineNum":"  984","line":"    bool operator==(const Ch* rhs) const { return *this == GenericValue(StringRef(rhs)); }"},
{"lineNum":"  985","line":""},
{"lineNum":"  986","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":"  987","line":"    //! Equal-to operator with string object"},
{"lineNum":"  988","line":"    /*! \\note Requires the definition of the preprocessor symbol \\ref CEREAL_RAPIDJSON_HAS_STDSTRING."},
{"lineNum":"  989","line":"     */"},
{"lineNum":"  990","line":"    bool operator==(const std::basic_string<Ch>& rhs) const { return *this == GenericValue(StringRef(rhs)); }"},
{"lineNum":"  991","line":"#endif"},
{"lineNum":"  992","line":""},
{"lineNum":"  993","line":"    //! Equal-to operator with primitive types"},
{"lineNum":"  994","line":"    /*! \\tparam T Either \\ref Type, \\c int, \\c unsigned, \\c int64_t, \\c uint64_t, \\c double, \\c true, \\c false"},
{"lineNum":"  995","line":"    */"},
{"lineNum":"  996","line":"    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>,internal::IsGenericValue<T> >), (bool)) operator==(const T& rhs) const { return *this == GenericValue(rhs); }"},
{"lineNum":"  997","line":""},
{"lineNum":"  998","line":"    //! Not-equal-to operator"},
{"lineNum":"  999","line":"    /*! \\return !(*this == rhs)"},
{"lineNum":" 1000","line":"     */"},
{"lineNum":" 1001","line":"    template <typename SourceAllocator>"},
{"lineNum":" 1002","line":"    bool operator!=(const GenericValue<Encoding, SourceAllocator>& rhs) const { return !(*this == rhs); }"},
{"lineNum":" 1003","line":""},
{"lineNum":" 1004","line":"    //! Not-equal-to operator with const C-string pointer"},
{"lineNum":" 1005","line":"    bool operator!=(const Ch* rhs) const { return !(*this == rhs); }"},
{"lineNum":" 1006","line":""},
{"lineNum":" 1007","line":"    //! Not-equal-to operator with arbitrary types"},
{"lineNum":" 1008","line":"    /*! \\return !(*this == rhs)"},
{"lineNum":" 1009","line":"     */"},
{"lineNum":" 1010","line":"    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator!=(const T& rhs) const { return !(*this == rhs); }"},
{"lineNum":" 1011","line":""},
{"lineNum":" 1012","line":"    //! Equal-to operator with arbitrary types (symmetric version)"},
{"lineNum":" 1013","line":"    /*! \\return (rhs == lhs)"},
{"lineNum":" 1014","line":"     */"},
{"lineNum":" 1015","line":"    template <typename T> friend CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator==(const T& lhs, const GenericValue& rhs) { return rhs == lhs; }"},
{"lineNum":" 1016","line":""},
{"lineNum":" 1017","line":"    //! Not-Equal-to operator with arbitrary types (symmetric version)"},
{"lineNum":" 1018","line":"    /*! \\return !(rhs == lhs)"},
{"lineNum":" 1019","line":"     */"},
{"lineNum":" 1020","line":"    template <typename T> friend CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::IsGenericValue<T>), (bool)) operator!=(const T& lhs, const GenericValue& rhs) { return !(rhs == lhs); }"},
{"lineNum":" 1021","line":"    //@}"},
{"lineNum":" 1022","line":""},
{"lineNum":" 1023","line":"    //!@name Type"},
{"lineNum":" 1024","line":"    //@{"},
{"lineNum":" 1025","line":""},
{"lineNum":" 1026","line":"    Type GetType()  const { return static_cast<Type>(data_.f.flags & kTypeMask); }"},
{"lineNum":" 1027","line":"    bool IsNull()   const { return data_.f.flags == kNullFlag; }"},
{"lineNum":" 1028","line":"    bool IsFalse()  const { return data_.f.flags == kFalseFlag; }"},
{"lineNum":" 1029","line":"    bool IsTrue()   const { return data_.f.flags == kTrueFlag; }"},
{"lineNum":" 1030","line":"    bool IsBool()   const { return (data_.f.flags & kBoolFlag) != 0; }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1031","line":"    bool IsObject() const { return data_.f.flags == kObjectFlag; }","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":" 1032","line":"    bool IsArray()  const { return data_.f.flags == kArrayFlag; }","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":" 1033","line":"    bool IsNumber() const { return (data_.f.flags & kNumberFlag) != 0; }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1034","line":"    bool IsInt()    const { return (data_.f.flags & kIntFlag) != 0; }"},
{"lineNum":" 1035","line":"    bool IsUint()   const { return (data_.f.flags & kUintFlag) != 0; }"},
{"lineNum":" 1036","line":"    bool IsInt64()  const { return (data_.f.flags & kInt64Flag) != 0; }"},
{"lineNum":" 1037","line":"    bool IsUint64() const { return (data_.f.flags & kUint64Flag) != 0; }"},
{"lineNum":" 1038","line":"    bool IsDouble() const { return (data_.f.flags & kDoubleFlag) != 0; }"},
{"lineNum":" 1039","line":"    bool IsString() const { return (data_.f.flags & kStringFlag) != 0; }","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":" 1040","line":""},
{"lineNum":" 1041","line":"    // Checks whether a number can be losslessly converted to a double."},
{"lineNum":" 1042","line":"    bool IsLosslessDouble() const {"},
{"lineNum":" 1043","line":"        if (!IsNumber()) return false;"},
{"lineNum":" 1044","line":"        if (IsUint64()) {"},
{"lineNum":" 1045","line":"            uint64_t u = GetUint64();"},
{"lineNum":" 1046","line":"            volatile double d = static_cast<double>(u);"},
{"lineNum":" 1047","line":"            return (d >= 0.0)"},
{"lineNum":" 1048","line":"                && (d < static_cast<double>((std::numeric_limits<uint64_t>::max)()))"},
{"lineNum":" 1049","line":"                && (u == static_cast<uint64_t>(d));"},
{"lineNum":" 1050","line":"        }"},
{"lineNum":" 1051","line":"        if (IsInt64()) {"},
{"lineNum":" 1052","line":"            int64_t i = GetInt64();"},
{"lineNum":" 1053","line":"            volatile double d = static_cast<double>(i);"},
{"lineNum":" 1054","line":"            return (d >= static_cast<double>((std::numeric_limits<int64_t>::min)()))"},
{"lineNum":" 1055","line":"                && (d < static_cast<double>((std::numeric_limits<int64_t>::max)()))"},
{"lineNum":" 1056","line":"                && (i == static_cast<int64_t>(d));"},
{"lineNum":" 1057","line":"        }"},
{"lineNum":" 1058","line":"        return true; // double, int, uint are always lossless"},
{"lineNum":" 1059","line":"    }"},
{"lineNum":" 1060","line":""},
{"lineNum":" 1061","line":"    // Checks whether a number is a float (possible lossy)."},
{"lineNum":" 1062","line":"    bool IsFloat() const  {"},
{"lineNum":" 1063","line":"        if ((data_.f.flags & kDoubleFlag) == 0)"},
{"lineNum":" 1064","line":"            return false;"},
{"lineNum":" 1065","line":"        double d = GetDouble();"},
{"lineNum":" 1066","line":"        return d >= -3.4028234e38 && d <= 3.4028234e38;"},
{"lineNum":" 1067","line":"    }"},
{"lineNum":" 1068","line":"    // Checks whether a number can be losslessly converted to a float."},
{"lineNum":" 1069","line":"    bool IsLosslessFloat() const {"},
{"lineNum":" 1070","line":"        if (!IsNumber()) return false;"},
{"lineNum":" 1071","line":"        double a = GetDouble();"},
{"lineNum":" 1072","line":"        if (a < static_cast<double>(-(std::numeric_limits<float>::max)())"},
{"lineNum":" 1073","line":"                || a > static_cast<double>((std::numeric_limits<float>::max)()))"},
{"lineNum":" 1074","line":"            return false;"},
{"lineNum":" 1075","line":"        double b = static_cast<double>(static_cast<float>(a));"},
{"lineNum":" 1076","line":"        return a >= b && a <= b;    // Prevent -Wfloat-equal"},
{"lineNum":" 1077","line":"    }"},
{"lineNum":" 1078","line":""},
{"lineNum":" 1079","line":"    //@}"},
{"lineNum":" 1080","line":""},
{"lineNum":" 1081","line":"    //!@name Null"},
{"lineNum":" 1082","line":"    //@{"},
{"lineNum":" 1083","line":""},
{"lineNum":" 1084","line":"    GenericValue& SetNull() { this->~GenericValue(); new (this) GenericValue(); return *this; }"},
{"lineNum":" 1085","line":""},
{"lineNum":" 1086","line":"    //@}"},
{"lineNum":" 1087","line":""},
{"lineNum":" 1088","line":"    //!@name Bool"},
{"lineNum":" 1089","line":"    //@{"},
{"lineNum":" 1090","line":""},
{"lineNum":" 1091","line":"    bool GetBool() const { CEREAL_RAPIDJSON_ASSERT(IsBool()); return data_.f.flags == kTrueFlag; }","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":" 1092","line":"    //!< Set boolean value"},
{"lineNum":" 1093","line":"    /*! \\post IsBool() == true */"},
{"lineNum":" 1094","line":"    GenericValue& SetBool(bool b) { this->~GenericValue(); new (this) GenericValue(b); return *this; }"},
{"lineNum":" 1095","line":""},
{"lineNum":" 1096","line":"    //@}"},
{"lineNum":" 1097","line":""},
{"lineNum":" 1098","line":"    //!@name Object"},
{"lineNum":" 1099","line":"    //@{"},
{"lineNum":" 1100","line":""},
{"lineNum":" 1101","line":"    //! Set this value as an empty object."},
{"lineNum":" 1102","line":"    /*! \\post IsObject() == true */"},
{"lineNum":" 1103","line":"    GenericValue& SetObject() { this->~GenericValue(); new (this) GenericValue(kObjectType); return *this; }"},
{"lineNum":" 1104","line":""},
{"lineNum":" 1105","line":"    //! Get the number of members in the object."},
{"lineNum":" 1106","line":"    SizeType MemberCount() const { CEREAL_RAPIDJSON_ASSERT(IsObject()); return data_.o.size; }"},
{"lineNum":" 1107","line":""},
{"lineNum":" 1108","line":"    //! Get the capacity of object."},
{"lineNum":" 1109","line":"    SizeType MemberCapacity() const { CEREAL_RAPIDJSON_ASSERT(IsObject()); return data_.o.capacity; }"},
{"lineNum":" 1110","line":""},
{"lineNum":" 1111","line":"    //! Check whether the object is empty."},
{"lineNum":" 1112","line":"    bool ObjectEmpty() const { CEREAL_RAPIDJSON_ASSERT(IsObject()); return data_.o.size == 0; }"},
{"lineNum":" 1113","line":""},
{"lineNum":" 1114","line":"    //! Get a value from an object associated with the name."},
{"lineNum":" 1115","line":"    /*! \\pre IsObject() == true"},
{"lineNum":" 1116","line":"        \\tparam T Either \\c Ch or \\c const \\c Ch (template used for disambiguation with \\ref operator[](SizeType))"},
{"lineNum":" 1117","line":"        \\note In version 0.1x, if the member is not found, this function returns a null value. This makes issue 7."},
{"lineNum":" 1118","line":"        Since 0.2, if the name is not correct, it will assert."},
{"lineNum":" 1119","line":"        If user is unsure whether a member exists, user should use HasMember() first."},
{"lineNum":" 1120","line":"        A better approach is to use FindMember()."},
{"lineNum":" 1121","line":"        \\note Linear time complexity."},
{"lineNum":" 1122","line":"    */"},
{"lineNum":" 1123","line":"    template <typename T>"},
{"lineNum":" 1124","line":"    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >),(GenericValue&)) operator[](T* name) {"},
{"lineNum":" 1125","line":"        GenericValue n(StringRef(name));"},
{"lineNum":" 1126","line":"        return (*this)[n];"},
{"lineNum":" 1127","line":"    }"},
{"lineNum":" 1128","line":"    template <typename T>"},
{"lineNum":" 1129","line":"    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::NotExpr<internal::IsSame<typename internal::RemoveConst<T>::Type, Ch> >),(const GenericValue&)) operator[](T* name) const { return const_cast<GenericValue&>(*this)[name]; }"},
{"lineNum":" 1130","line":""},
{"lineNum":" 1131","line":"    //! Get a value from an object associated with the name."},
{"lineNum":" 1132","line":"    /*! \\pre IsObject() == true"},
{"lineNum":" 1133","line":"        \\tparam SourceAllocator Allocator of the \\c name value"},
{"lineNum":" 1134","line":""},
{"lineNum":" 1135","line":"        \\note Compared to \\ref operator[](T*), this version is faster because it does not need a StrLen()."},
{"lineNum":" 1136","line":"        And it can also handle strings with embedded null characters."},
{"lineNum":" 1137","line":""},
{"lineNum":" 1138","line":"        \\note Linear time complexity."},
{"lineNum":" 1139","line":"    */"},
{"lineNum":" 1140","line":"    template <typename SourceAllocator>"},
{"lineNum":" 1141","line":"    GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) {"},
{"lineNum":" 1142","line":"        MemberIterator member = FindMember(name);"},
{"lineNum":" 1143","line":"        if (member != MemberEnd())"},
{"lineNum":" 1144","line":"            return member->value;"},
{"lineNum":" 1145","line":"        else {"},
{"lineNum":" 1146","line":"            CEREAL_RAPIDJSON_ASSERT(false);    // see above note"},
{"lineNum":" 1147","line":""},
{"lineNum":" 1148","line":"            // This will generate -Wexit-time-destructors in clang"},
{"lineNum":" 1149","line":"            // static GenericValue NullValue;"},
{"lineNum":" 1150","line":"            // return NullValue;"},
{"lineNum":" 1151","line":""},
{"lineNum":" 1152","line":"            // Use static buffer and placement-new to prevent destruction"},
{"lineNum":" 1153","line":"            static char buffer[sizeof(GenericValue)];"},
{"lineNum":" 1154","line":"            return *new (buffer) GenericValue();"},
{"lineNum":" 1155","line":"        }"},
{"lineNum":" 1156","line":"    }"},
{"lineNum":" 1157","line":"    template <typename SourceAllocator>"},
{"lineNum":" 1158","line":"    const GenericValue& operator[](const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this)[name]; }"},
{"lineNum":" 1159","line":""},
{"lineNum":" 1160","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 1161","line":"    //! Get a value from an object associated with name (string object)."},
{"lineNum":" 1162","line":"    GenericValue& operator[](const std::basic_string<Ch>& name) { return (*this)[GenericValue(StringRef(name))]; }"},
{"lineNum":" 1163","line":"    const GenericValue& operator[](const std::basic_string<Ch>& name) const { return (*this)[GenericValue(StringRef(name))]; }"},
{"lineNum":" 1164","line":"#endif"},
{"lineNum":" 1165","line":""},
{"lineNum":" 1166","line":"    //! Const member iterator"},
{"lineNum":" 1167","line":"    /*! \\pre IsObject() == true */"},
{"lineNum":" 1168","line":"    ConstMemberIterator MemberBegin() const { CEREAL_RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer()); }","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":" 1169","line":"    //! Const \\em past-the-end member iterator"},
{"lineNum":" 1170","line":"    /*! \\pre IsObject() == true */"},
{"lineNum":" 1171","line":"    ConstMemberIterator MemberEnd() const   { CEREAL_RAPIDJSON_ASSERT(IsObject()); return ConstMemberIterator(GetMembersPointer() + data_.o.size); }","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":" 1172","line":"    //! Member iterator"},
{"lineNum":" 1173","line":"    /*! \\pre IsObject() == true */"},
{"lineNum":" 1174","line":"    MemberIterator MemberBegin()            { CEREAL_RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer()); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1175","line":"    //! \\em Past-the-end member iterator"},
{"lineNum":" 1176","line":"    /*! \\pre IsObject() == true */"},
{"lineNum":" 1177","line":"    MemberIterator MemberEnd()              { CEREAL_RAPIDJSON_ASSERT(IsObject()); return MemberIterator(GetMembersPointer() + data_.o.size); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1178","line":""},
{"lineNum":" 1179","line":"    //! Request the object to have enough capacity to store members."},
{"lineNum":" 1180","line":"    /*! \\param newCapacity  The capacity that the object at least need to have."},
{"lineNum":" 1181","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1182","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1183","line":"        \\note Linear time complexity."},
{"lineNum":" 1184","line":"    */"},
{"lineNum":" 1185","line":"    GenericValue& MemberReserve(SizeType newCapacity, Allocator &allocator) {"},
{"lineNum":" 1186","line":"        CEREAL_RAPIDJSON_ASSERT(IsObject());"},
{"lineNum":" 1187","line":"        if (newCapacity > data_.o.capacity) {"},
{"lineNum":" 1188","line":"            SetMembersPointer(reinterpret_cast<Member*>(allocator.Realloc(GetMembersPointer(), data_.o.capacity * sizeof(Member), newCapacity * sizeof(Member))));"},
{"lineNum":" 1189","line":"            data_.o.capacity = newCapacity;"},
{"lineNum":" 1190","line":"        }"},
{"lineNum":" 1191","line":"        return *this;"},
{"lineNum":" 1192","line":"    }"},
{"lineNum":" 1193","line":""},
{"lineNum":" 1194","line":"    //! Check whether a member exists in the object."},
{"lineNum":" 1195","line":"    /*!"},
{"lineNum":" 1196","line":"        \\param name Member name to be searched."},
{"lineNum":" 1197","line":"        \\pre IsObject() == true"},
{"lineNum":" 1198","line":"        \\return Whether a member with that name exists."},
{"lineNum":" 1199","line":"        \\note It is better to use FindMember() directly if you need the obtain the value as well."},
{"lineNum":" 1200","line":"        \\note Linear time complexity."},
{"lineNum":" 1201","line":"    */"},
{"lineNum":" 1202","line":"    bool HasMember(const Ch* name) const { return FindMember(name) != MemberEnd(); }"},
{"lineNum":" 1203","line":""},
{"lineNum":" 1204","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 1205","line":"    //! Check whether a member exists in the object with string object."},
{"lineNum":" 1206","line":"    /*!"},
{"lineNum":" 1207","line":"        \\param name Member name to be searched."},
{"lineNum":" 1208","line":"        \\pre IsObject() == true"},
{"lineNum":" 1209","line":"        \\return Whether a member with that name exists."},
{"lineNum":" 1210","line":"        \\note It is better to use FindMember() directly if you need the obtain the value as well."},
{"lineNum":" 1211","line":"        \\note Linear time complexity."},
{"lineNum":" 1212","line":"    */"},
{"lineNum":" 1213","line":"    bool HasMember(const std::basic_string<Ch>& name) const { return FindMember(name) != MemberEnd(); }"},
{"lineNum":" 1214","line":"#endif"},
{"lineNum":" 1215","line":""},
{"lineNum":" 1216","line":"    //! Check whether a member exists in the object with GenericValue name."},
{"lineNum":" 1217","line":"    /*!"},
{"lineNum":" 1218","line":"        This version is faster because it does not need a StrLen(). It can also handle string with null character."},
{"lineNum":" 1219","line":"        \\param name Member name to be searched."},
{"lineNum":" 1220","line":"        \\pre IsObject() == true"},
{"lineNum":" 1221","line":"        \\return Whether a member with that name exists."},
{"lineNum":" 1222","line":"        \\note It is better to use FindMember() directly if you need the obtain the value as well."},
{"lineNum":" 1223","line":"        \\note Linear time complexity."},
{"lineNum":" 1224","line":"    */"},
{"lineNum":" 1225","line":"    template <typename SourceAllocator>"},
{"lineNum":" 1226","line":"    bool HasMember(const GenericValue<Encoding, SourceAllocator>& name) const { return FindMember(name) != MemberEnd(); }"},
{"lineNum":" 1227","line":""},
{"lineNum":" 1228","line":"    //! Find member by name."},
{"lineNum":" 1229","line":"    /*!"},
{"lineNum":" 1230","line":"        \\param name Member name to be searched."},
{"lineNum":" 1231","line":"        \\pre IsObject() == true"},
{"lineNum":" 1232","line":"        \\return Iterator to member, if it exists."},
{"lineNum":" 1233","line":"            Otherwise returns \\ref MemberEnd()."},
{"lineNum":" 1234","line":""},
{"lineNum":" 1235","line":"        \\note Earlier versions of Rapidjson returned a \\c NULL pointer, in case"},
{"lineNum":" 1236","line":"            the requested member doesn\'t exist. For consistency with e.g."},
{"lineNum":" 1237","line":"            \\c std::map, this has been changed to MemberEnd() now."},
{"lineNum":" 1238","line":"        \\note Linear time complexity."},
{"lineNum":" 1239","line":"    */"},
{"lineNum":" 1240","line":"    MemberIterator FindMember(const Ch* name) {"},
{"lineNum":" 1241","line":"        GenericValue n(StringRef(name));"},
{"lineNum":" 1242","line":"        return FindMember(n);"},
{"lineNum":" 1243","line":"    }"},
{"lineNum":" 1244","line":""},
{"lineNum":" 1245","line":"    ConstMemberIterator FindMember(const Ch* name) const { return const_cast<GenericValue&>(*this).FindMember(name); }"},
{"lineNum":" 1246","line":""},
{"lineNum":" 1247","line":"    //! Find member by name."},
{"lineNum":" 1248","line":"    /*!"},
{"lineNum":" 1249","line":"        This version is faster because it does not need a StrLen(). It can also handle string with null character."},
{"lineNum":" 1250","line":"        \\param name Member name to be searched."},
{"lineNum":" 1251","line":"        \\pre IsObject() == true"},
{"lineNum":" 1252","line":"        \\return Iterator to member, if it exists."},
{"lineNum":" 1253","line":"            Otherwise returns \\ref MemberEnd()."},
{"lineNum":" 1254","line":""},
{"lineNum":" 1255","line":"        \\note Earlier versions of Rapidjson returned a \\c NULL pointer, in case"},
{"lineNum":" 1256","line":"            the requested member doesn\'t exist. For consistency with e.g."},
{"lineNum":" 1257","line":"            \\c std::map, this has been changed to MemberEnd() now."},
{"lineNum":" 1258","line":"        \\note Linear time complexity."},
{"lineNum":" 1259","line":"    */"},
{"lineNum":" 1260","line":"    template <typename SourceAllocator>"},
{"lineNum":" 1261","line":"    MemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) {"},
{"lineNum":" 1262","line":"        CEREAL_RAPIDJSON_ASSERT(IsObject());"},
{"lineNum":" 1263","line":"        CEREAL_RAPIDJSON_ASSERT(name.IsString());"},
{"lineNum":" 1264","line":"        MemberIterator member = MemberBegin();"},
{"lineNum":" 1265","line":"        for ( ; member != MemberEnd(); ++member)"},
{"lineNum":" 1266","line":"            if (name.StringEqual(member->name))"},
{"lineNum":" 1267","line":"                break;"},
{"lineNum":" 1268","line":"        return member;"},
{"lineNum":" 1269","line":"    }"},
{"lineNum":" 1270","line":"    template <typename SourceAllocator> ConstMemberIterator FindMember(const GenericValue<Encoding, SourceAllocator>& name) const { return const_cast<GenericValue&>(*this).FindMember(name); }"},
{"lineNum":" 1271","line":""},
{"lineNum":" 1272","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 1273","line":"    //! Find member by string object name."},
{"lineNum":" 1274","line":"    /*!"},
{"lineNum":" 1275","line":"        \\param name Member name to be searched."},
{"lineNum":" 1276","line":"        \\pre IsObject() == true"},
{"lineNum":" 1277","line":"        \\return Iterator to member, if it exists."},
{"lineNum":" 1278","line":"            Otherwise returns \\ref MemberEnd()."},
{"lineNum":" 1279","line":"    */"},
{"lineNum":" 1280","line":"    MemberIterator FindMember(const std::basic_string<Ch>& name) { return FindMember(GenericValue(StringRef(name))); }"},
{"lineNum":" 1281","line":"    ConstMemberIterator FindMember(const std::basic_string<Ch>& name) const { return FindMember(GenericValue(StringRef(name))); }"},
{"lineNum":" 1282","line":"#endif"},
{"lineNum":" 1283","line":""},
{"lineNum":" 1284","line":"    //! Add a member (name-value pair) to the object."},
{"lineNum":" 1285","line":"    /*! \\param name A string value as name of member."},
{"lineNum":" 1286","line":"        \\param value Value of any type."},
{"lineNum":" 1287","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1288","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1289","line":"        \\note The ownership of \\c name and \\c value will be transferred to this object on success."},
{"lineNum":" 1290","line":"        \\pre  IsObject() && name.IsString()"},
{"lineNum":" 1291","line":"        \\post name.IsNull() && value.IsNull()"},
{"lineNum":" 1292","line":"        \\note Amortized Constant time complexity."},
{"lineNum":" 1293","line":"    */"},
{"lineNum":" 1294","line":"    GenericValue& AddMember(GenericValue& name, GenericValue& value, Allocator& allocator) {"},
{"lineNum":" 1295","line":"        CEREAL_RAPIDJSON_ASSERT(IsObject());"},
{"lineNum":" 1296","line":"        CEREAL_RAPIDJSON_ASSERT(name.IsString());"},
{"lineNum":" 1297","line":""},
{"lineNum":" 1298","line":"        ObjectData& o = data_.o;"},
{"lineNum":" 1299","line":"        if (o.size >= o.capacity)"},
{"lineNum":" 1300","line":"            MemberReserve(o.capacity == 0 ? kDefaultObjectCapacity : (o.capacity + (o.capacity + 1) / 2), allocator);"},
{"lineNum":" 1301","line":"        Member* members = GetMembersPointer();"},
{"lineNum":" 1302","line":"        members[o.size].name.RawAssign(name);"},
{"lineNum":" 1303","line":"        members[o.size].value.RawAssign(value);"},
{"lineNum":" 1304","line":"        o.size++;"},
{"lineNum":" 1305","line":"        return *this;"},
{"lineNum":" 1306","line":"    }"},
{"lineNum":" 1307","line":""},
{"lineNum":" 1308","line":"    //! Add a constant string value as member (name-value pair) to the object."},
{"lineNum":" 1309","line":"    /*! \\param name A string value as name of member."},
{"lineNum":" 1310","line":"        \\param value constant string reference as value of member."},
{"lineNum":" 1311","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1312","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1313","line":"        \\pre  IsObject()"},
{"lineNum":" 1314","line":"        \\note This overload is needed to avoid clashes with the generic primitive type AddMember(GenericValue&,T,Allocator&) overload below."},
{"lineNum":" 1315","line":"        \\note Amortized Constant time complexity."},
{"lineNum":" 1316","line":"    */"},
{"lineNum":" 1317","line":"    GenericValue& AddMember(GenericValue& name, StringRefType value, Allocator& allocator) {"},
{"lineNum":" 1318","line":"        GenericValue v(value);"},
{"lineNum":" 1319","line":"        return AddMember(name, v, allocator);"},
{"lineNum":" 1320","line":"    }"},
{"lineNum":" 1321","line":""},
{"lineNum":" 1322","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 1323","line":"    //! Add a string object as member (name-value pair) to the object."},
{"lineNum":" 1324","line":"    /*! \\param name A string value as name of member."},
{"lineNum":" 1325","line":"        \\param value constant string reference as value of member."},
{"lineNum":" 1326","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1327","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1328","line":"        \\pre  IsObject()"},
{"lineNum":" 1329","line":"        \\note This overload is needed to avoid clashes with the generic primitive type AddMember(GenericValue&,T,Allocator&) overload below."},
{"lineNum":" 1330","line":"        \\note Amortized Constant time complexity."},
{"lineNum":" 1331","line":"    */"},
{"lineNum":" 1332","line":"    GenericValue& AddMember(GenericValue& name, std::basic_string<Ch>& value, Allocator& allocator) {"},
{"lineNum":" 1333","line":"        GenericValue v(value, allocator);"},
{"lineNum":" 1334","line":"        return AddMember(name, v, allocator);"},
{"lineNum":" 1335","line":"    }"},
{"lineNum":" 1336","line":"#endif"},
{"lineNum":" 1337","line":""},
{"lineNum":" 1338","line":"    //! Add any primitive value as member (name-value pair) to the object."},
{"lineNum":" 1339","line":"    /*! \\tparam T Either \\ref Type, \\c int, \\c unsigned, \\c int64_t, \\c uint64_t"},
{"lineNum":" 1340","line":"        \\param name A string value as name of member."},
{"lineNum":" 1341","line":"        \\param value Value of primitive type \\c T as value of member"},
{"lineNum":" 1342","line":"        \\param allocator Allocator for reallocating memory. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1343","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1344","line":"        \\pre  IsObject()"},
{"lineNum":" 1345","line":""},
{"lineNum":" 1346","line":"        \\note The source type \\c T explicitly disallows all pointer types,"},
{"lineNum":" 1347","line":"            especially (\\c const) \\ref Ch*.  This helps avoiding implicitly"},
{"lineNum":" 1348","line":"            referencing character strings with insufficient lifetime, use"},
{"lineNum":" 1349","line":"            \\ref AddMember(StringRefType, GenericValue&, Allocator&) or \\ref"},
{"lineNum":" 1350","line":"            AddMember(StringRefType, StringRefType, Allocator&)."},
{"lineNum":" 1351","line":"            All other pointer types would implicitly convert to \\c bool,"},
{"lineNum":" 1352","line":"            use an explicit cast instead, if needed."},
{"lineNum":" 1353","line":"        \\note Amortized Constant time complexity."},
{"lineNum":" 1354","line":"    */"},
{"lineNum":" 1355","line":"    template <typename T>"},
{"lineNum":" 1356","line":"    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))"},
{"lineNum":" 1357","line":"    AddMember(GenericValue& name, T value, Allocator& allocator) {"},
{"lineNum":" 1358","line":"        GenericValue v(value);"},
{"lineNum":" 1359","line":"        return AddMember(name, v, allocator);"},
{"lineNum":" 1360","line":"    }"},
{"lineNum":" 1361","line":""},
{"lineNum":" 1362","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 1363","line":"    GenericValue& AddMember(GenericValue&& name, GenericValue&& value, Allocator& allocator) {"},
{"lineNum":" 1364","line":"        return AddMember(name, value, allocator);"},
{"lineNum":" 1365","line":"    }"},
{"lineNum":" 1366","line":"    GenericValue& AddMember(GenericValue&& name, GenericValue& value, Allocator& allocator) {"},
{"lineNum":" 1367","line":"        return AddMember(name, value, allocator);"},
{"lineNum":" 1368","line":"    }"},
{"lineNum":" 1369","line":"    GenericValue& AddMember(GenericValue& name, GenericValue&& value, Allocator& allocator) {"},
{"lineNum":" 1370","line":"        return AddMember(name, value, allocator);"},
{"lineNum":" 1371","line":"    }"},
{"lineNum":" 1372","line":"    GenericValue& AddMember(StringRefType name, GenericValue&& value, Allocator& allocator) {"},
{"lineNum":" 1373","line":"        GenericValue n(name);"},
{"lineNum":" 1374","line":"        return AddMember(n, value, allocator);"},
{"lineNum":" 1375","line":"    }"},
{"lineNum":" 1376","line":"#endif // CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 1377","line":""},
{"lineNum":" 1378","line":""},
{"lineNum":" 1379","line":"    //! Add a member (name-value pair) to the object."},
{"lineNum":" 1380","line":"    /*! \\param name A constant string reference as name of member."},
{"lineNum":" 1381","line":"        \\param value Value of any type."},
{"lineNum":" 1382","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1383","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1384","line":"        \\note The ownership of \\c value will be transferred to this object on success."},
{"lineNum":" 1385","line":"        \\pre  IsObject()"},
{"lineNum":" 1386","line":"        \\post value.IsNull()"},
{"lineNum":" 1387","line":"        \\note Amortized Constant time complexity."},
{"lineNum":" 1388","line":"    */"},
{"lineNum":" 1389","line":"    GenericValue& AddMember(StringRefType name, GenericValue& value, Allocator& allocator) {"},
{"lineNum":" 1390","line":"        GenericValue n(name);"},
{"lineNum":" 1391","line":"        return AddMember(n, value, allocator);"},
{"lineNum":" 1392","line":"    }"},
{"lineNum":" 1393","line":""},
{"lineNum":" 1394","line":"    //! Add a constant string value as member (name-value pair) to the object."},
{"lineNum":" 1395","line":"    /*! \\param name A constant string reference as name of member."},
{"lineNum":" 1396","line":"        \\param value constant string reference as value of member."},
{"lineNum":" 1397","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1398","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1399","line":"        \\pre  IsObject()"},
{"lineNum":" 1400","line":"        \\note This overload is needed to avoid clashes with the generic primitive type AddMember(StringRefType,T,Allocator&) overload below."},
{"lineNum":" 1401","line":"        \\note Amortized Constant time complexity."},
{"lineNum":" 1402","line":"    */"},
{"lineNum":" 1403","line":"    GenericValue& AddMember(StringRefType name, StringRefType value, Allocator& allocator) {"},
{"lineNum":" 1404","line":"        GenericValue v(value);"},
{"lineNum":" 1405","line":"        return AddMember(name, v, allocator);"},
{"lineNum":" 1406","line":"    }"},
{"lineNum":" 1407","line":""},
{"lineNum":" 1408","line":"    //! Add any primitive value as member (name-value pair) to the object."},
{"lineNum":" 1409","line":"    /*! \\tparam T Either \\ref Type, \\c int, \\c unsigned, \\c int64_t, \\c uint64_t"},
{"lineNum":" 1410","line":"        \\param name A constant string reference as name of member."},
{"lineNum":" 1411","line":"        \\param value Value of primitive type \\c T as value of member"},
{"lineNum":" 1412","line":"        \\param allocator Allocator for reallocating memory. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1413","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1414","line":"        \\pre  IsObject()"},
{"lineNum":" 1415","line":""},
{"lineNum":" 1416","line":"        \\note The source type \\c T explicitly disallows all pointer types,"},
{"lineNum":" 1417","line":"            especially (\\c const) \\ref Ch*.  This helps avoiding implicitly"},
{"lineNum":" 1418","line":"            referencing character strings with insufficient lifetime, use"},
{"lineNum":" 1419","line":"            \\ref AddMember(StringRefType, GenericValue&, Allocator&) or \\ref"},
{"lineNum":" 1420","line":"            AddMember(StringRefType, StringRefType, Allocator&)."},
{"lineNum":" 1421","line":"            All other pointer types would implicitly convert to \\c bool,"},
{"lineNum":" 1422","line":"            use an explicit cast instead, if needed."},
{"lineNum":" 1423","line":"        \\note Amortized Constant time complexity."},
{"lineNum":" 1424","line":"    */"},
{"lineNum":" 1425","line":"    template <typename T>"},
{"lineNum":" 1426","line":"    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))"},
{"lineNum":" 1427","line":"    AddMember(StringRefType name, T value, Allocator& allocator) {"},
{"lineNum":" 1428","line":"        GenericValue n(name);"},
{"lineNum":" 1429","line":"        return AddMember(n, value, allocator);"},
{"lineNum":" 1430","line":"    }"},
{"lineNum":" 1431","line":""},
{"lineNum":" 1432","line":"    //! Remove all members in the object."},
{"lineNum":" 1433","line":"    /*! This function do not deallocate memory in the object, i.e. the capacity is unchanged."},
{"lineNum":" 1434","line":"        \\note Linear time complexity."},
{"lineNum":" 1435","line":"    */"},
{"lineNum":" 1436","line":"    void RemoveAllMembers() {"},
{"lineNum":" 1437","line":"        CEREAL_RAPIDJSON_ASSERT(IsObject());"},
{"lineNum":" 1438","line":"        for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)"},
{"lineNum":" 1439","line":"            m->~Member();"},
{"lineNum":" 1440","line":"        data_.o.size = 0;"},
{"lineNum":" 1441","line":"    }"},
{"lineNum":" 1442","line":""},
{"lineNum":" 1443","line":"    //! Remove a member in object by its name."},
{"lineNum":" 1444","line":"    /*! \\param name Name of member to be removed."},
{"lineNum":" 1445","line":"        \\return Whether the member existed."},
{"lineNum":" 1446","line":"        \\note This function may reorder the object members. Use \\ref"},
{"lineNum":" 1447","line":"            EraseMember(ConstMemberIterator) if you need to preserve the"},
{"lineNum":" 1448","line":"            relative order of the remaining members."},
{"lineNum":" 1449","line":"        \\note Linear time complexity."},
{"lineNum":" 1450","line":"    */"},
{"lineNum":" 1451","line":"    bool RemoveMember(const Ch* name) {"},
{"lineNum":" 1452","line":"        GenericValue n(StringRef(name));"},
{"lineNum":" 1453","line":"        return RemoveMember(n);"},
{"lineNum":" 1454","line":"    }"},
{"lineNum":" 1455","line":""},
{"lineNum":" 1456","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 1457","line":"    bool RemoveMember(const std::basic_string<Ch>& name) { return RemoveMember(GenericValue(StringRef(name))); }"},
{"lineNum":" 1458","line":"#endif"},
{"lineNum":" 1459","line":""},
{"lineNum":" 1460","line":"    template <typename SourceAllocator>"},
{"lineNum":" 1461","line":"    bool RemoveMember(const GenericValue<Encoding, SourceAllocator>& name) {"},
{"lineNum":" 1462","line":"        MemberIterator m = FindMember(name);"},
{"lineNum":" 1463","line":"        if (m != MemberEnd()) {"},
{"lineNum":" 1464","line":"            RemoveMember(m);"},
{"lineNum":" 1465","line":"            return true;"},
{"lineNum":" 1466","line":"        }"},
{"lineNum":" 1467","line":"        else"},
{"lineNum":" 1468","line":"            return false;"},
{"lineNum":" 1469","line":"    }"},
{"lineNum":" 1470","line":""},
{"lineNum":" 1471","line":"    //! Remove a member in object by iterator."},
{"lineNum":" 1472","line":"    /*! \\param m member iterator (obtained by FindMember() or MemberBegin())."},
{"lineNum":" 1473","line":"        \\return the new iterator after removal."},
{"lineNum":" 1474","line":"        \\note This function may reorder the object members. Use \\ref"},
{"lineNum":" 1475","line":"            EraseMember(ConstMemberIterator) if you need to preserve the"},
{"lineNum":" 1476","line":"            relative order of the remaining members."},
{"lineNum":" 1477","line":"        \\note Constant time complexity."},
{"lineNum":" 1478","line":"    */"},
{"lineNum":" 1479","line":"    MemberIterator RemoveMember(MemberIterator m) {"},
{"lineNum":" 1480","line":"        CEREAL_RAPIDJSON_ASSERT(IsObject());"},
{"lineNum":" 1481","line":"        CEREAL_RAPIDJSON_ASSERT(data_.o.size > 0);"},
{"lineNum":" 1482","line":"        CEREAL_RAPIDJSON_ASSERT(GetMembersPointer() != 0);"},
{"lineNum":" 1483","line":"        CEREAL_RAPIDJSON_ASSERT(m >= MemberBegin() && m < MemberEnd());"},
{"lineNum":" 1484","line":""},
{"lineNum":" 1485","line":"        MemberIterator last(GetMembersPointer() + (data_.o.size - 1));"},
{"lineNum":" 1486","line":"        if (data_.o.size > 1 && m != last)"},
{"lineNum":" 1487","line":"            *m = *last; // Move the last one to this place"},
{"lineNum":" 1488","line":"        else"},
{"lineNum":" 1489","line":"            m->~Member(); // Only one left, just destroy"},
{"lineNum":" 1490","line":"        --data_.o.size;"},
{"lineNum":" 1491","line":"        return m;"},
{"lineNum":" 1492","line":"    }"},
{"lineNum":" 1493","line":""},
{"lineNum":" 1494","line":"    //! Remove a member from an object by iterator."},
{"lineNum":" 1495","line":"    /*! \\param pos iterator to the member to remove"},
{"lineNum":" 1496","line":"        \\pre IsObject() == true && \\ref MemberBegin() <= \\c pos < \\ref MemberEnd()"},
{"lineNum":" 1497","line":"        \\return Iterator following the removed element."},
{"lineNum":" 1498","line":"            If the iterator \\c pos refers to the last element, the \\ref MemberEnd() iterator is returned."},
{"lineNum":" 1499","line":"        \\note This function preserves the relative order of the remaining object"},
{"lineNum":" 1500","line":"            members. If you do not need this, use the more efficient \\ref RemoveMember(MemberIterator)."},
{"lineNum":" 1501","line":"        \\note Linear time complexity."},
{"lineNum":" 1502","line":"    */"},
{"lineNum":" 1503","line":"    MemberIterator EraseMember(ConstMemberIterator pos) {"},
{"lineNum":" 1504","line":"        return EraseMember(pos, pos +1);"},
{"lineNum":" 1505","line":"    }"},
{"lineNum":" 1506","line":""},
{"lineNum":" 1507","line":"    //! Remove members in the range [first, last) from an object."},
{"lineNum":" 1508","line":"    /*! \\param first iterator to the first member to remove"},
{"lineNum":" 1509","line":"        \\param last  iterator following the last member to remove"},
{"lineNum":" 1510","line":"        \\pre IsObject() == true && \\ref MemberBegin() <= \\c first <= \\c last <= \\ref MemberEnd()"},
{"lineNum":" 1511","line":"        \\return Iterator following the last removed element."},
{"lineNum":" 1512","line":"        \\note This function preserves the relative order of the remaining object"},
{"lineNum":" 1513","line":"            members."},
{"lineNum":" 1514","line":"        \\note Linear time complexity."},
{"lineNum":" 1515","line":"    */"},
{"lineNum":" 1516","line":"    MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) {"},
{"lineNum":" 1517","line":"        CEREAL_RAPIDJSON_ASSERT(IsObject());"},
{"lineNum":" 1518","line":"        CEREAL_RAPIDJSON_ASSERT(data_.o.size > 0);"},
{"lineNum":" 1519","line":"        CEREAL_RAPIDJSON_ASSERT(GetMembersPointer() != 0);"},
{"lineNum":" 1520","line":"        CEREAL_RAPIDJSON_ASSERT(first >= MemberBegin());"},
{"lineNum":" 1521","line":"        CEREAL_RAPIDJSON_ASSERT(first <= last);"},
{"lineNum":" 1522","line":"        CEREAL_RAPIDJSON_ASSERT(last <= MemberEnd());"},
{"lineNum":" 1523","line":""},
{"lineNum":" 1524","line":"        MemberIterator pos = MemberBegin() + (first - MemberBegin());"},
{"lineNum":" 1525","line":"        for (MemberIterator itr = pos; itr != last; ++itr)"},
{"lineNum":" 1526","line":"            itr->~Member();"},
{"lineNum":" 1527","line":"        std::memmove(static_cast<void*>(&*pos), &*last, static_cast<size_t>(MemberEnd() - last) * sizeof(Member));"},
{"lineNum":" 1528","line":"        data_.o.size -= static_cast<SizeType>(last - first);"},
{"lineNum":" 1529","line":"        return pos;"},
{"lineNum":" 1530","line":"    }"},
{"lineNum":" 1531","line":""},
{"lineNum":" 1532","line":"    //! Erase a member in object by its name."},
{"lineNum":" 1533","line":"    /*! \\param name Name of member to be removed."},
{"lineNum":" 1534","line":"        \\return Whether the member existed."},
{"lineNum":" 1535","line":"        \\note Linear time complexity."},
{"lineNum":" 1536","line":"    */"},
{"lineNum":" 1537","line":"    bool EraseMember(const Ch* name) {"},
{"lineNum":" 1538","line":"        GenericValue n(StringRef(name));"},
{"lineNum":" 1539","line":"        return EraseMember(n);"},
{"lineNum":" 1540","line":"    }"},
{"lineNum":" 1541","line":""},
{"lineNum":" 1542","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 1543","line":"    bool EraseMember(const std::basic_string<Ch>& name) { return EraseMember(GenericValue(StringRef(name))); }"},
{"lineNum":" 1544","line":"#endif"},
{"lineNum":" 1545","line":""},
{"lineNum":" 1546","line":"    template <typename SourceAllocator>"},
{"lineNum":" 1547","line":"    bool EraseMember(const GenericValue<Encoding, SourceAllocator>& name) {"},
{"lineNum":" 1548","line":"        MemberIterator m = FindMember(name);"},
{"lineNum":" 1549","line":"        if (m != MemberEnd()) {"},
{"lineNum":" 1550","line":"            EraseMember(m);"},
{"lineNum":" 1551","line":"            return true;"},
{"lineNum":" 1552","line":"        }"},
{"lineNum":" 1553","line":"        else"},
{"lineNum":" 1554","line":"            return false;"},
{"lineNum":" 1555","line":"    }"},
{"lineNum":" 1556","line":""},
{"lineNum":" 1557","line":"    Object GetObject() { CEREAL_RAPIDJSON_ASSERT(IsObject()); return Object(*this); }"},
{"lineNum":" 1558","line":"    ConstObject GetObject() const { CEREAL_RAPIDJSON_ASSERT(IsObject()); return ConstObject(*this); }"},
{"lineNum":" 1559","line":""},
{"lineNum":" 1560","line":"    //@}"},
{"lineNum":" 1561","line":""},
{"lineNum":" 1562","line":"    //!@name Array"},
{"lineNum":" 1563","line":"    //@{"},
{"lineNum":" 1564","line":""},
{"lineNum":" 1565","line":"    //! Set this value as an empty array."},
{"lineNum":" 1566","line":"    /*! \\post IsArray == true */"},
{"lineNum":" 1567","line":"    GenericValue& SetArray() { this->~GenericValue(); new (this) GenericValue(kArrayType); return *this; }"},
{"lineNum":" 1568","line":""},
{"lineNum":" 1569","line":"    //! Get the number of elements in array."},
{"lineNum":" 1570","line":"    SizeType Size() const { CEREAL_RAPIDJSON_ASSERT(IsArray()); return data_.a.size; }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1571","line":""},
{"lineNum":" 1572","line":"    //! Get the capacity of array."},
{"lineNum":" 1573","line":"    SizeType Capacity() const { CEREAL_RAPIDJSON_ASSERT(IsArray()); return data_.a.capacity; }"},
{"lineNum":" 1574","line":""},
{"lineNum":" 1575","line":"    //! Check whether the array is empty."},
{"lineNum":" 1576","line":"    bool Empty() const { CEREAL_RAPIDJSON_ASSERT(IsArray()); return data_.a.size == 0; }"},
{"lineNum":" 1577","line":""},
{"lineNum":" 1578","line":"    //! Remove all elements in the array."},
{"lineNum":" 1579","line":"    /*! This function do not deallocate memory in the array, i.e. the capacity is unchanged."},
{"lineNum":" 1580","line":"        \\note Linear time complexity."},
{"lineNum":" 1581","line":"    */"},
{"lineNum":" 1582","line":"    void Clear() {"},
{"lineNum":" 1583","line":"        CEREAL_RAPIDJSON_ASSERT(IsArray());"},
{"lineNum":" 1584","line":"        GenericValue* e = GetElementsPointer();"},
{"lineNum":" 1585","line":"        for (GenericValue* v = e; v != e + data_.a.size; ++v)"},
{"lineNum":" 1586","line":"            v->~GenericValue();"},
{"lineNum":" 1587","line":"        data_.a.size = 0;"},
{"lineNum":" 1588","line":"    }"},
{"lineNum":" 1589","line":""},
{"lineNum":" 1590","line":"    //! Get an element from array by index."},
{"lineNum":" 1591","line":"    /*! \\pre IsArray() == true"},
{"lineNum":" 1592","line":"        \\param index Zero-based index of element."},
{"lineNum":" 1593","line":"        \\see operator[](T*)"},
{"lineNum":" 1594","line":"    */"},
{"lineNum":" 1595","line":"    GenericValue& operator[](SizeType index) {"},
{"lineNum":" 1596","line":"        CEREAL_RAPIDJSON_ASSERT(IsArray());"},
{"lineNum":" 1597","line":"        CEREAL_RAPIDJSON_ASSERT(index < data_.a.size);"},
{"lineNum":" 1598","line":"        return GetElementsPointer()[index];"},
{"lineNum":" 1599","line":"    }"},
{"lineNum":" 1600","line":"    const GenericValue& operator[](SizeType index) const { return const_cast<GenericValue&>(*this)[index]; }"},
{"lineNum":" 1601","line":""},
{"lineNum":" 1602","line":"    //! Element iterator"},
{"lineNum":" 1603","line":"    /*! \\pre IsArray() == true */"},
{"lineNum":" 1604","line":"    ValueIterator Begin() { CEREAL_RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer(); }","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":" 1605","line":"    //! \\em Past-the-end element iterator"},
{"lineNum":" 1606","line":"    /*! \\pre IsArray() == true */"},
{"lineNum":" 1607","line":"    ValueIterator End() { CEREAL_RAPIDJSON_ASSERT(IsArray()); return GetElementsPointer() + data_.a.size; }","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":" 1608","line":"    //! Constant element iterator"},
{"lineNum":" 1609","line":"    /*! \\pre IsArray() == true */"},
{"lineNum":" 1610","line":"    ConstValueIterator Begin() const { return const_cast<GenericValue&>(*this).Begin(); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1611","line":"    //! Constant \\em past-the-end element iterator"},
{"lineNum":" 1612","line":"    /*! \\pre IsArray() == true */"},
{"lineNum":" 1613","line":"    ConstValueIterator End() const { return const_cast<GenericValue&>(*this).End(); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1614","line":""},
{"lineNum":" 1615","line":"    //! Request the array to have enough capacity to store elements."},
{"lineNum":" 1616","line":"    /*! \\param newCapacity  The capacity that the array at least need to have."},
{"lineNum":" 1617","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1618","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1619","line":"        \\note Linear time complexity."},
{"lineNum":" 1620","line":"    */"},
{"lineNum":" 1621","line":"    GenericValue& Reserve(SizeType newCapacity, Allocator &allocator) {"},
{"lineNum":" 1622","line":"        CEREAL_RAPIDJSON_ASSERT(IsArray());"},
{"lineNum":" 1623","line":"        if (newCapacity > data_.a.capacity) {"},
{"lineNum":" 1624","line":"            SetElementsPointer(reinterpret_cast<GenericValue*>(allocator.Realloc(GetElementsPointer(), data_.a.capacity * sizeof(GenericValue), newCapacity * sizeof(GenericValue))));"},
{"lineNum":" 1625","line":"            data_.a.capacity = newCapacity;"},
{"lineNum":" 1626","line":"        }"},
{"lineNum":" 1627","line":"        return *this;"},
{"lineNum":" 1628","line":"    }"},
{"lineNum":" 1629","line":""},
{"lineNum":" 1630","line":"    //! Append a GenericValue at the end of the array."},
{"lineNum":" 1631","line":"    /*! \\param value        Value to be appended."},
{"lineNum":" 1632","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1633","line":"        \\pre IsArray() == true"},
{"lineNum":" 1634","line":"        \\post value.IsNull() == true"},
{"lineNum":" 1635","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1636","line":"        \\note The ownership of \\c value will be transferred to this array on success."},
{"lineNum":" 1637","line":"        \\note If the number of elements to be appended is known, calls Reserve() once first may be more efficient."},
{"lineNum":" 1638","line":"        \\note Amortized constant time complexity."},
{"lineNum":" 1639","line":"    */"},
{"lineNum":" 1640","line":"    GenericValue& PushBack(GenericValue& value, Allocator& allocator) {"},
{"lineNum":" 1641","line":"        CEREAL_RAPIDJSON_ASSERT(IsArray());"},
{"lineNum":" 1642","line":"        if (data_.a.size >= data_.a.capacity)"},
{"lineNum":" 1643","line":"            Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : (data_.a.capacity + (data_.a.capacity + 1) / 2), allocator);"},
{"lineNum":" 1644","line":"        GetElementsPointer()[data_.a.size++].RawAssign(value);"},
{"lineNum":" 1645","line":"        return *this;"},
{"lineNum":" 1646","line":"    }"},
{"lineNum":" 1647","line":""},
{"lineNum":" 1648","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 1649","line":"    GenericValue& PushBack(GenericValue&& value, Allocator& allocator) {"},
{"lineNum":" 1650","line":"        return PushBack(value, allocator);"},
{"lineNum":" 1651","line":"    }"},
{"lineNum":" 1652","line":"#endif // CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 1653","line":""},
{"lineNum":" 1654","line":"    //! Append a constant string reference at the end of the array."},
{"lineNum":" 1655","line":"    /*! \\param value        Constant string reference to be appended."},
{"lineNum":" 1656","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one used previously. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1657","line":"        \\pre IsArray() == true"},
{"lineNum":" 1658","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1659","line":"        \\note If the number of elements to be appended is known, calls Reserve() once first may be more efficient."},
{"lineNum":" 1660","line":"        \\note Amortized constant time complexity."},
{"lineNum":" 1661","line":"        \\see GenericStringRef"},
{"lineNum":" 1662","line":"    */"},
{"lineNum":" 1663","line":"    GenericValue& PushBack(StringRefType value, Allocator& allocator) {"},
{"lineNum":" 1664","line":"        return (*this).template PushBack<StringRefType>(value, allocator);"},
{"lineNum":" 1665","line":"    }"},
{"lineNum":" 1666","line":""},
{"lineNum":" 1667","line":"    //! Append a primitive value at the end of the array."},
{"lineNum":" 1668","line":"    /*! \\tparam T Either \\ref Type, \\c int, \\c unsigned, \\c int64_t, \\c uint64_t"},
{"lineNum":" 1669","line":"        \\param value Value of primitive type T to be appended."},
{"lineNum":" 1670","line":"        \\param allocator    Allocator for reallocating memory. It must be the same one as used before. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1671","line":"        \\pre IsArray() == true"},
{"lineNum":" 1672","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1673","line":"        \\note If the number of elements to be appended is known, calls Reserve() once first may be more efficient."},
{"lineNum":" 1674","line":""},
{"lineNum":" 1675","line":"        \\note The source type \\c T explicitly disallows all pointer types,"},
{"lineNum":" 1676","line":"            especially (\\c const) \\ref Ch*.  This helps avoiding implicitly"},
{"lineNum":" 1677","line":"            referencing character strings with insufficient lifetime, use"},
{"lineNum":" 1678","line":"            \\ref PushBack(GenericValue&, Allocator&) or \\ref"},
{"lineNum":" 1679","line":"            PushBack(StringRefType, Allocator&)."},
{"lineNum":" 1680","line":"            All other pointer types would implicitly convert to \\c bool,"},
{"lineNum":" 1681","line":"            use an explicit cast instead, if needed."},
{"lineNum":" 1682","line":"        \\note Amortized constant time complexity."},
{"lineNum":" 1683","line":"    */"},
{"lineNum":" 1684","line":"    template <typename T>"},
{"lineNum":" 1685","line":"    CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericValue&))"},
{"lineNum":" 1686","line":"    PushBack(T value, Allocator& allocator) {"},
{"lineNum":" 1687","line":"        GenericValue v(value);"},
{"lineNum":" 1688","line":"        return PushBack(v, allocator);"},
{"lineNum":" 1689","line":"    }"},
{"lineNum":" 1690","line":""},
{"lineNum":" 1691","line":"    //! Remove the last element in the array."},
{"lineNum":" 1692","line":"    /*!"},
{"lineNum":" 1693","line":"        \\note Constant time complexity."},
{"lineNum":" 1694","line":"    */"},
{"lineNum":" 1695","line":"    GenericValue& PopBack() {"},
{"lineNum":" 1696","line":"        CEREAL_RAPIDJSON_ASSERT(IsArray());"},
{"lineNum":" 1697","line":"        CEREAL_RAPIDJSON_ASSERT(!Empty());"},
{"lineNum":" 1698","line":"        GetElementsPointer()[--data_.a.size].~GenericValue();"},
{"lineNum":" 1699","line":"        return *this;"},
{"lineNum":" 1700","line":"    }"},
{"lineNum":" 1701","line":""},
{"lineNum":" 1702","line":"    //! Remove an element of array by iterator."},
{"lineNum":" 1703","line":"    /*!"},
{"lineNum":" 1704","line":"        \\param pos iterator to the element to remove"},
{"lineNum":" 1705","line":"        \\pre IsArray() == true && \\ref Begin() <= \\c pos < \\ref End()"},
{"lineNum":" 1706","line":"        \\return Iterator following the removed element. If the iterator pos refers to the last element, the End() iterator is returned."},
{"lineNum":" 1707","line":"        \\note Linear time complexity."},
{"lineNum":" 1708","line":"    */"},
{"lineNum":" 1709","line":"    ValueIterator Erase(ConstValueIterator pos) {"},
{"lineNum":" 1710","line":"        return Erase(pos, pos + 1);"},
{"lineNum":" 1711","line":"    }"},
{"lineNum":" 1712","line":""},
{"lineNum":" 1713","line":"    //! Remove elements in the range [first, last) of the array."},
{"lineNum":" 1714","line":"    /*!"},
{"lineNum":" 1715","line":"        \\param first iterator to the first element to remove"},
{"lineNum":" 1716","line":"        \\param last  iterator following the last element to remove"},
{"lineNum":" 1717","line":"        \\pre IsArray() == true && \\ref Begin() <= \\c first <= \\c last <= \\ref End()"},
{"lineNum":" 1718","line":"        \\return Iterator following the last removed element."},
{"lineNum":" 1719","line":"        \\note Linear time complexity."},
{"lineNum":" 1720","line":"    */"},
{"lineNum":" 1721","line":"    ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) {"},
{"lineNum":" 1722","line":"        CEREAL_RAPIDJSON_ASSERT(IsArray());"},
{"lineNum":" 1723","line":"        CEREAL_RAPIDJSON_ASSERT(data_.a.size > 0);"},
{"lineNum":" 1724","line":"        CEREAL_RAPIDJSON_ASSERT(GetElementsPointer() != 0);"},
{"lineNum":" 1725","line":"        CEREAL_RAPIDJSON_ASSERT(first >= Begin());"},
{"lineNum":" 1726","line":"        CEREAL_RAPIDJSON_ASSERT(first <= last);"},
{"lineNum":" 1727","line":"        CEREAL_RAPIDJSON_ASSERT(last <= End());"},
{"lineNum":" 1728","line":"        ValueIterator pos = Begin() + (first - Begin());"},
{"lineNum":" 1729","line":"        for (ValueIterator itr = pos; itr != last; ++itr)"},
{"lineNum":" 1730","line":"            itr->~GenericValue();"},
{"lineNum":" 1731","line":"        std::memmove(static_cast<void*>(pos), last, static_cast<size_t>(End() - last) * sizeof(GenericValue));"},
{"lineNum":" 1732","line":"        data_.a.size -= static_cast<SizeType>(last - first);"},
{"lineNum":" 1733","line":"        return pos;"},
{"lineNum":" 1734","line":"    }"},
{"lineNum":" 1735","line":""},
{"lineNum":" 1736","line":"    Array GetArray() { CEREAL_RAPIDJSON_ASSERT(IsArray()); return Array(*this); }"},
{"lineNum":" 1737","line":"    ConstArray GetArray() const { CEREAL_RAPIDJSON_ASSERT(IsArray()); return ConstArray(*this); }"},
{"lineNum":" 1738","line":""},
{"lineNum":" 1739","line":"    //@}"},
{"lineNum":" 1740","line":""},
{"lineNum":" 1741","line":"    //!@name Number"},
{"lineNum":" 1742","line":"    //@{"},
{"lineNum":" 1743","line":""},
{"lineNum":" 1744","line":"    int GetInt() const          { CEREAL_RAPIDJSON_ASSERT(data_.f.flags & kIntFlag);   return data_.n.i.i;   }","class":"lineNoCov","hits":"0","possible_hits":"100",},
{"lineNum":" 1745","line":"    unsigned GetUint() const    { CEREAL_RAPIDJSON_ASSERT(data_.f.flags & kUintFlag);  return data_.n.u.u;   }","class":"lineNoCov","hits":"0","possible_hits":"118",},
{"lineNum":" 1746","line":"    int64_t GetInt64() const    { CEREAL_RAPIDJSON_ASSERT(data_.f.flags & kInt64Flag); return data_.n.i64; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1747","line":"    uint64_t GetUint64() const  { CEREAL_RAPIDJSON_ASSERT(data_.f.flags & kUint64Flag); return data_.n.u64; }"},
{"lineNum":" 1748","line":""},
{"lineNum":" 1749","line":"    //! Get the value as double type."},
{"lineNum":" 1750","line":"    /*! \\note If the value is 64-bit integer type, it may lose precision. Use \\c IsLosslessDouble() to check whether the converison is lossless."},
{"lineNum":" 1751","line":"    */"},
{"lineNum":" 1752","line":"    double GetDouble() const {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1753","line":"        CEREAL_RAPIDJSON_ASSERT(IsNumber());","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1754","line":"        if ((data_.f.flags & kDoubleFlag) != 0)                return data_.n.d;   // exact type, no conversion.","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1755","line":"        if ((data_.f.flags & kIntFlag) != 0)                   return data_.n.i.i; // int -> double","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1756","line":"        if ((data_.f.flags & kUintFlag) != 0)                  return data_.n.u.u; // unsigned -> double","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1757","line":"        if ((data_.f.flags & kInt64Flag) != 0)                 return static_cast<double>(data_.n.i64); // int64_t -> double (may lose precision)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1758","line":"        CEREAL_RAPIDJSON_ASSERT((data_.f.flags & kUint64Flag) != 0);  return static_cast<double>(data_.n.u64); // uint64_t -> double (may lose precision)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1759","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 1760","line":""},
{"lineNum":" 1761","line":"    //! Get the value as float type."},
{"lineNum":" 1762","line":"    /*! \\note If the value is 64-bit integer type, it may lose precision. Use \\c IsLosslessFloat() to check whether the converison is lossless."},
{"lineNum":" 1763","line":"    */"},
{"lineNum":" 1764","line":"    float GetFloat() const {"},
{"lineNum":" 1765","line":"        return static_cast<float>(GetDouble());"},
{"lineNum":" 1766","line":"    }"},
{"lineNum":" 1767","line":""},
{"lineNum":" 1768","line":"    GenericValue& SetInt(int i)             { this->~GenericValue(); new (this) GenericValue(i);    return *this; }"},
{"lineNum":" 1769","line":"    GenericValue& SetUint(unsigned u)       { this->~GenericValue(); new (this) GenericValue(u);    return *this; }"},
{"lineNum":" 1770","line":"    GenericValue& SetInt64(int64_t i64)     { this->~GenericValue(); new (this) GenericValue(i64);  return *this; }"},
{"lineNum":" 1771","line":"    GenericValue& SetUint64(uint64_t u64)   { this->~GenericValue(); new (this) GenericValue(u64);  return *this; }"},
{"lineNum":" 1772","line":"    GenericValue& SetDouble(double d)       { this->~GenericValue(); new (this) GenericValue(d);    return *this; }"},
{"lineNum":" 1773","line":"    GenericValue& SetFloat(float f)         { this->~GenericValue(); new (this) GenericValue(static_cast<double>(f)); return *this; }"},
{"lineNum":" 1774","line":""},
{"lineNum":" 1775","line":"    //@}"},
{"lineNum":" 1776","line":""},
{"lineNum":" 1777","line":"    //!@name String"},
{"lineNum":" 1778","line":"    //@{"},
{"lineNum":" 1779","line":""},
{"lineNum":" 1780","line":"    const Ch* GetString() const { CEREAL_RAPIDJSON_ASSERT(IsString()); return (data_.f.flags & kInlineStrFlag) ? data_.ss.str : GetStringPointer(); }","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":" 1781","line":""},
{"lineNum":" 1782","line":"    //! Get the length of string."},
{"lineNum":" 1783","line":"    /*! Since rapidjson permits \"\\\\u0000\" in the json string, strlen(v.GetString()) may not equal to v.GetStringLength()."},
{"lineNum":" 1784","line":"    */"},
{"lineNum":" 1785","line":"    SizeType GetStringLength() const { CEREAL_RAPIDJSON_ASSERT(IsString()); return ((data_.f.flags & kInlineStrFlag) ? (data_.ss.GetLength()) : data_.s.length); }"},
{"lineNum":" 1786","line":""},
{"lineNum":" 1787","line":"    //! Set this value as a string without copying source string."},
{"lineNum":" 1788","line":"    /*! This version has better performance with supplied length, and also support string containing null character."},
{"lineNum":" 1789","line":"        \\param s source string pointer."},
{"lineNum":" 1790","line":"        \\param length The length of source string, excluding the trailing null terminator."},
{"lineNum":" 1791","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1792","line":"        \\post IsString() == true && GetString() == s && GetStringLength() == length"},
{"lineNum":" 1793","line":"        \\see SetString(StringRefType)"},
{"lineNum":" 1794","line":"    */"},
{"lineNum":" 1795","line":"    GenericValue& SetString(const Ch* s, SizeType length) { return SetString(StringRef(s, length)); }"},
{"lineNum":" 1796","line":""},
{"lineNum":" 1797","line":"    //! Set this value as a string without copying source string."},
{"lineNum":" 1798","line":"    /*! \\param s source string reference"},
{"lineNum":" 1799","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1800","line":"        \\post IsString() == true && GetString() == s && GetStringLength() == s.length"},
{"lineNum":" 1801","line":"    */"},
{"lineNum":" 1802","line":"    GenericValue& SetString(StringRefType s) { this->~GenericValue(); SetStringRaw(s); return *this; }"},
{"lineNum":" 1803","line":""},
{"lineNum":" 1804","line":"    //! Set this value as a string by copying from source string."},
{"lineNum":" 1805","line":"    /*! This version has better performance with supplied length, and also support string containing null character."},
{"lineNum":" 1806","line":"        \\param s source string."},
{"lineNum":" 1807","line":"        \\param length The length of source string, excluding the trailing null terminator."},
{"lineNum":" 1808","line":"        \\param allocator Allocator for allocating copied buffer. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1809","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1810","line":"        \\post IsString() == true && GetString() != s && strcmp(GetString(),s) == 0 && GetStringLength() == length"},
{"lineNum":" 1811","line":"    */"},
{"lineNum":" 1812","line":"    GenericValue& SetString(const Ch* s, SizeType length, Allocator& allocator) { return SetString(StringRef(s, length), allocator); }"},
{"lineNum":" 1813","line":""},
{"lineNum":" 1814","line":"    //! Set this value as a string by copying from source string."},
{"lineNum":" 1815","line":"    /*! \\param s source string."},
{"lineNum":" 1816","line":"        \\param allocator Allocator for allocating copied buffer. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1817","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1818","line":"        \\post IsString() == true && GetString() != s && strcmp(GetString(),s) == 0 && GetStringLength() == length"},
{"lineNum":" 1819","line":"    */"},
{"lineNum":" 1820","line":"    GenericValue& SetString(const Ch* s, Allocator& allocator) { return SetString(StringRef(s), allocator); }"},
{"lineNum":" 1821","line":""},
{"lineNum":" 1822","line":"    //! Set this value as a string by copying from source string."},
{"lineNum":" 1823","line":"    /*! \\param s source string reference"},
{"lineNum":" 1824","line":"        \\param allocator Allocator for allocating copied buffer. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1825","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1826","line":"        \\post IsString() == true && GetString() != s.s && strcmp(GetString(),s) == 0 && GetStringLength() == length"},
{"lineNum":" 1827","line":"    */"},
{"lineNum":" 1828","line":"    GenericValue& SetString(StringRefType s, Allocator& allocator) { this->~GenericValue(); SetStringRaw(s, allocator); return *this; }"},
{"lineNum":" 1829","line":""},
{"lineNum":" 1830","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 1831","line":"    //! Set this value as a string by copying from source string."},
{"lineNum":" 1832","line":"    /*! \\param s source string."},
{"lineNum":" 1833","line":"        \\param allocator Allocator for allocating copied buffer. Commonly use GenericDocument::GetAllocator()."},
{"lineNum":" 1834","line":"        \\return The value itself for fluent API."},
{"lineNum":" 1835","line":"        \\post IsString() == true && GetString() != s.data() && strcmp(GetString(),s.data() == 0 && GetStringLength() == s.size()"},
{"lineNum":" 1836","line":"        \\note Requires the definition of the preprocessor symbol \\ref CEREAL_RAPIDJSON_HAS_STDSTRING."},
{"lineNum":" 1837","line":"    */"},
{"lineNum":" 1838","line":"    GenericValue& SetString(const std::basic_string<Ch>& s, Allocator& allocator) { return SetString(StringRef(s), allocator); }"},
{"lineNum":" 1839","line":"#endif"},
{"lineNum":" 1840","line":""},
{"lineNum":" 1841","line":"    //@}"},
{"lineNum":" 1842","line":""},
{"lineNum":" 1843","line":"    //!@name Array"},
{"lineNum":" 1844","line":"    //@{"},
{"lineNum":" 1845","line":""},
{"lineNum":" 1846","line":"    //! Templated version for checking whether this value is type T."},
{"lineNum":" 1847","line":"    /*!"},
{"lineNum":" 1848","line":"        \\tparam T Either \\c bool, \\c int, \\c unsigned, \\c int64_t, \\c uint64_t, \\c double, \\c float, \\c const \\c char*, \\c std::basic_string<Ch>"},
{"lineNum":" 1849","line":"    */"},
{"lineNum":" 1850","line":"    template <typename T>"},
{"lineNum":" 1851","line":"    bool Is() const { return internal::TypeHelper<ValueType, T>::Is(*this); }"},
{"lineNum":" 1852","line":""},
{"lineNum":" 1853","line":"    template <typename T>"},
{"lineNum":" 1854","line":"    T Get() const { return internal::TypeHelper<ValueType, T>::Get(*this); }"},
{"lineNum":" 1855","line":""},
{"lineNum":" 1856","line":"    template <typename T>"},
{"lineNum":" 1857","line":"    T Get() { return internal::TypeHelper<ValueType, T>::Get(*this); }"},
{"lineNum":" 1858","line":""},
{"lineNum":" 1859","line":"    template<typename T>"},
{"lineNum":" 1860","line":"    ValueType& Set(const T& data) { return internal::TypeHelper<ValueType, T>::Set(*this, data); }"},
{"lineNum":" 1861","line":""},
{"lineNum":" 1862","line":"    template<typename T>"},
{"lineNum":" 1863","line":"    ValueType& Set(const T& data, AllocatorType& allocator) { return internal::TypeHelper<ValueType, T>::Set(*this, data, allocator); }"},
{"lineNum":" 1864","line":""},
{"lineNum":" 1865","line":"    //@}"},
{"lineNum":" 1866","line":""},
{"lineNum":" 1867","line":"    //! Generate events of this value to a Handler."},
{"lineNum":" 1868","line":"    /*! This function adopts the GoF visitor pattern."},
{"lineNum":" 1869","line":"        Typical usage is to output this JSON value as JSON text via Writer, which is a Handler."},
{"lineNum":" 1870","line":"        It can also be used to deep clone this value via GenericDocument, which is also a Handler."},
{"lineNum":" 1871","line":"        \\tparam Handler type of handler."},
{"lineNum":" 1872","line":"        \\param handler An object implementing concept Handler."},
{"lineNum":" 1873","line":"    */"},
{"lineNum":" 1874","line":"    template <typename Handler>"},
{"lineNum":" 1875","line":"    bool Accept(Handler& handler) const {"},
{"lineNum":" 1876","line":"        switch(GetType()) {"},
{"lineNum":" 1877","line":"        case kNullType:     return handler.Null();"},
{"lineNum":" 1878","line":"        case kFalseType:    return handler.Bool(false);"},
{"lineNum":" 1879","line":"        case kTrueType:     return handler.Bool(true);"},
{"lineNum":" 1880","line":""},
{"lineNum":" 1881","line":"        case kObjectType:"},
{"lineNum":" 1882","line":"            if (CEREAL_RAPIDJSON_UNLIKELY(!handler.StartObject()))"},
{"lineNum":" 1883","line":"                return false;"},
{"lineNum":" 1884","line":"            for (ConstMemberIterator m = MemberBegin(); m != MemberEnd(); ++m) {"},
{"lineNum":" 1885","line":"                CEREAL_RAPIDJSON_ASSERT(m->name.IsString()); // User may change the type of name by MemberIterator."},
{"lineNum":" 1886","line":"                if (CEREAL_RAPIDJSON_UNLIKELY(!handler.Key(m->name.GetString(), m->name.GetStringLength(), (m->name.data_.f.flags & kCopyFlag) != 0)))"},
{"lineNum":" 1887","line":"                    return false;"},
{"lineNum":" 1888","line":"                if (CEREAL_RAPIDJSON_UNLIKELY(!m->value.Accept(handler)))"},
{"lineNum":" 1889","line":"                    return false;"},
{"lineNum":" 1890","line":"            }"},
{"lineNum":" 1891","line":"            return handler.EndObject(data_.o.size);"},
{"lineNum":" 1892","line":""},
{"lineNum":" 1893","line":"        case kArrayType:"},
{"lineNum":" 1894","line":"            if (CEREAL_RAPIDJSON_UNLIKELY(!handler.StartArray()))"},
{"lineNum":" 1895","line":"                return false;"},
{"lineNum":" 1896","line":"            for (const GenericValue* v = Begin(); v != End(); ++v)"},
{"lineNum":" 1897","line":"                if (CEREAL_RAPIDJSON_UNLIKELY(!v->Accept(handler)))"},
{"lineNum":" 1898","line":"                    return false;"},
{"lineNum":" 1899","line":"            return handler.EndArray(data_.a.size);"},
{"lineNum":" 1900","line":""},
{"lineNum":" 1901","line":"        case kStringType:"},
{"lineNum":" 1902","line":"            return handler.String(GetString(), GetStringLength(), (data_.f.flags & kCopyFlag) != 0);"},
{"lineNum":" 1903","line":""},
{"lineNum":" 1904","line":"        default:"},
{"lineNum":" 1905","line":"            CEREAL_RAPIDJSON_ASSERT(GetType() == kNumberType);"},
{"lineNum":" 1906","line":"            if (IsDouble())         return handler.Double(data_.n.d);"},
{"lineNum":" 1907","line":"            else if (IsInt())       return handler.Int(data_.n.i.i);"},
{"lineNum":" 1908","line":"            else if (IsUint())      return handler.Uint(data_.n.u.u);"},
{"lineNum":" 1909","line":"            else if (IsInt64())     return handler.Int64(data_.n.i64);"},
{"lineNum":" 1910","line":"            else                    return handler.Uint64(data_.n.u64);"},
{"lineNum":" 1911","line":"        }"},
{"lineNum":" 1912","line":"    }"},
{"lineNum":" 1913","line":""},
{"lineNum":" 1914","line":"private:"},
{"lineNum":" 1915","line":"    template <typename, typename> friend class GenericValue;"},
{"lineNum":" 1916","line":"    template <typename, typename, typename> friend class GenericDocument;"},
{"lineNum":" 1917","line":""},
{"lineNum":" 1918","line":"    enum {"},
{"lineNum":" 1919","line":"        kBoolFlag       = 0x0008,"},
{"lineNum":" 1920","line":"        kNumberFlag     = 0x0010,"},
{"lineNum":" 1921","line":"        kIntFlag        = 0x0020,"},
{"lineNum":" 1922","line":"        kUintFlag       = 0x0040,"},
{"lineNum":" 1923","line":"        kInt64Flag      = 0x0080,"},
{"lineNum":" 1924","line":"        kUint64Flag     = 0x0100,"},
{"lineNum":" 1925","line":"        kDoubleFlag     = 0x0200,"},
{"lineNum":" 1926","line":"        kStringFlag     = 0x0400,"},
{"lineNum":" 1927","line":"        kCopyFlag       = 0x0800,"},
{"lineNum":" 1928","line":"        kInlineStrFlag  = 0x1000,"},
{"lineNum":" 1929","line":""},
{"lineNum":" 1930","line":"        // Initial flags of different types."},
{"lineNum":" 1931","line":"        kNullFlag = kNullType,"},
{"lineNum":" 1932","line":"        kTrueFlag = kTrueType | kBoolFlag,"},
{"lineNum":" 1933","line":"        kFalseFlag = kFalseType | kBoolFlag,"},
{"lineNum":" 1934","line":"        kNumberIntFlag = kNumberType | kNumberFlag | kIntFlag | kInt64Flag,"},
{"lineNum":" 1935","line":"        kNumberUintFlag = kNumberType | kNumberFlag | kUintFlag | kUint64Flag | kInt64Flag,"},
{"lineNum":" 1936","line":"        kNumberInt64Flag = kNumberType | kNumberFlag | kInt64Flag,"},
{"lineNum":" 1937","line":"        kNumberUint64Flag = kNumberType | kNumberFlag | kUint64Flag,"},
{"lineNum":" 1938","line":"        kNumberDoubleFlag = kNumberType | kNumberFlag | kDoubleFlag,"},
{"lineNum":" 1939","line":"        kNumberAnyFlag = kNumberType | kNumberFlag | kIntFlag | kInt64Flag | kUintFlag | kUint64Flag | kDoubleFlag,"},
{"lineNum":" 1940","line":"        kConstStringFlag = kStringType | kStringFlag,"},
{"lineNum":" 1941","line":"        kCopyStringFlag = kStringType | kStringFlag | kCopyFlag,"},
{"lineNum":" 1942","line":"        kShortStringFlag = kStringType | kStringFlag | kCopyFlag | kInlineStrFlag,"},
{"lineNum":" 1943","line":"        kObjectFlag = kObjectType,"},
{"lineNum":" 1944","line":"        kArrayFlag = kArrayType,"},
{"lineNum":" 1945","line":""},
{"lineNum":" 1946","line":"        kTypeMask = 0x07"},
{"lineNum":" 1947","line":"    };"},
{"lineNum":" 1948","line":""},
{"lineNum":" 1949","line":"    static const SizeType kDefaultArrayCapacity = 16;"},
{"lineNum":" 1950","line":"    static const SizeType kDefaultObjectCapacity = 16;"},
{"lineNum":" 1951","line":""},
{"lineNum":" 1952","line":"    struct Flag {"},
{"lineNum":" 1953","line":"#if CEREAL_RAPIDJSON_48BITPOINTER_OPTIMIZATION"},
{"lineNum":" 1954","line":"        char payload[sizeof(SizeType) * 2 + 6];     // 2 x SizeType + lower 48-bit pointer"},
{"lineNum":" 1955","line":"#elif CEREAL_RAPIDJSON_64BIT"},
{"lineNum":" 1956","line":"        char payload[sizeof(SizeType) * 2 + sizeof(void*) + 6]; // 6 padding bytes"},
{"lineNum":" 1957","line":"#else"},
{"lineNum":" 1958","line":"        char payload[sizeof(SizeType) * 2 + sizeof(void*) + 2]; // 2 padding bytes"},
{"lineNum":" 1959","line":"#endif"},
{"lineNum":" 1960","line":"        uint16_t flags;"},
{"lineNum":" 1961","line":"    };"},
{"lineNum":" 1962","line":""},
{"lineNum":" 1963","line":"    struct String {"},
{"lineNum":" 1964","line":"        SizeType length;"},
{"lineNum":" 1965","line":"        SizeType hashcode;  //!< reserved"},
{"lineNum":" 1966","line":"        const Ch* str;"},
{"lineNum":" 1967","line":"    };  // 12 bytes in 32-bit mode, 16 bytes in 64-bit mode"},
{"lineNum":" 1968","line":""},
{"lineNum":" 1969","line":"    // implementation detail: ShortString can represent zero-terminated strings up to MaxSize chars"},
{"lineNum":" 1970","line":"    // (excluding the terminating zero) and store a value to determine the length of the contained"},
{"lineNum":" 1971","line":"    // string in the last character str[LenPos] by storing \"MaxSize - length\" there. If the string"},
{"lineNum":" 1972","line":"    // to store has the maximal length of MaxSize then str[LenPos] will be 0 and therefore act as"},
{"lineNum":" 1973","line":"    // the string terminator as well. For getting the string length back from that value just use"},
{"lineNum":" 1974","line":"    // \"MaxSize - str[LenPos]\"."},
{"lineNum":" 1975","line":"    // This allows to store 13-chars strings in 32-bit mode, 21-chars strings in 64-bit mode,"},
{"lineNum":" 1976","line":"    // 13-chars strings for CEREAL_RAPIDJSON_48BITPOINTER_OPTIMIZATION=1 inline (for `UTF8`-encoded strings)."},
{"lineNum":" 1977","line":"    struct ShortString {"},
{"lineNum":" 1978","line":"        enum { MaxChars = sizeof(static_cast<Flag*>(0)->payload) / sizeof(Ch), MaxSize = MaxChars - 1, LenPos = MaxSize };"},
{"lineNum":" 1979","line":"        Ch str[MaxChars];"},
{"lineNum":" 1980","line":""},
{"lineNum":" 1981","line":"        inline static bool Usable(SizeType len) { return                       (MaxSize >= len); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1982","line":"        inline void     SetLength(SizeType len) { str[LenPos] = static_cast<Ch>(MaxSize -  len); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1983","line":"        inline SizeType GetLength() const       { return  static_cast<SizeType>(MaxSize -  str[LenPos]); }"},
{"lineNum":" 1984","line":"    };  // at most as many bytes as \"String\" above => 12 bytes in 32-bit mode, 16 bytes in 64-bit mode"},
{"lineNum":" 1985","line":""},
{"lineNum":" 1986","line":"    // By using proper binary layout, retrieval of different integer types do not need conversions."},
{"lineNum":" 1987","line":"    union Number {"},
{"lineNum":" 1988","line":"#if CEREAL_RAPIDJSON_ENDIAN == CEREAL_RAPIDJSON_LITTLEENDIAN"},
{"lineNum":" 1989","line":"        struct I {"},
{"lineNum":" 1990","line":"            int i;"},
{"lineNum":" 1991","line":"            char padding[4];"},
{"lineNum":" 1992","line":"        }i;"},
{"lineNum":" 1993","line":"        struct U {"},
{"lineNum":" 1994","line":"            unsigned u;"},
{"lineNum":" 1995","line":"            char padding2[4];"},
{"lineNum":" 1996","line":"        }u;"},
{"lineNum":" 1997","line":"#else"},
{"lineNum":" 1998","line":"        struct I {"},
{"lineNum":" 1999","line":"            char padding[4];"},
{"lineNum":" 2000","line":"            int i;"},
{"lineNum":" 2001","line":"        }i;"},
{"lineNum":" 2002","line":"        struct U {"},
{"lineNum":" 2003","line":"            char padding2[4];"},
{"lineNum":" 2004","line":"            unsigned u;"},
{"lineNum":" 2005","line":"        }u;"},
{"lineNum":" 2006","line":"#endif"},
{"lineNum":" 2007","line":"        int64_t i64;"},
{"lineNum":" 2008","line":"        uint64_t u64;"},
{"lineNum":" 2009","line":"        double d;"},
{"lineNum":" 2010","line":"    };  // 8 bytes"},
{"lineNum":" 2011","line":""},
{"lineNum":" 2012","line":"    struct ObjectData {"},
{"lineNum":" 2013","line":"        SizeType size;"},
{"lineNum":" 2014","line":"        SizeType capacity;"},
{"lineNum":" 2015","line":"        Member* members;"},
{"lineNum":" 2016","line":"    };  // 12 bytes in 32-bit mode, 16 bytes in 64-bit mode"},
{"lineNum":" 2017","line":""},
{"lineNum":" 2018","line":"    struct ArrayData {"},
{"lineNum":" 2019","line":"        SizeType size;"},
{"lineNum":" 2020","line":"        SizeType capacity;"},
{"lineNum":" 2021","line":"        GenericValue* elements;"},
{"lineNum":" 2022","line":"    };  // 12 bytes in 32-bit mode, 16 bytes in 64-bit mode"},
{"lineNum":" 2023","line":""},
{"lineNum":" 2024","line":"    union Data {"},
{"lineNum":" 2025","line":"        String s;"},
{"lineNum":" 2026","line":"        ShortString ss;"},
{"lineNum":" 2027","line":"        Number n;"},
{"lineNum":" 2028","line":"        ObjectData o;"},
{"lineNum":" 2029","line":"        ArrayData a;"},
{"lineNum":" 2030","line":"        Flag f;"},
{"lineNum":" 2031","line":"    };  // 16 bytes in 32-bit mode, 24 bytes in 64-bit mode, 16 bytes in 64-bit with CEREAL_RAPIDJSON_48BITPOINTER_OPTIMIZATION"},
{"lineNum":" 2032","line":""},
{"lineNum":" 2033","line":"    CEREAL_RAPIDJSON_FORCEINLINE const Ch* GetStringPointer() const { return CEREAL_RAPIDJSON_GETPOINTER(Ch, data_.s.str); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2034","line":"    CEREAL_RAPIDJSON_FORCEINLINE const Ch* SetStringPointer(const Ch* str) { return CEREAL_RAPIDJSON_SETPOINTER(Ch, data_.s.str, str); }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2035","line":"    CEREAL_RAPIDJSON_FORCEINLINE GenericValue* GetElementsPointer() const { return CEREAL_RAPIDJSON_GETPOINTER(GenericValue, data_.a.elements); }","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":" 2036","line":"    CEREAL_RAPIDJSON_FORCEINLINE GenericValue* SetElementsPointer(GenericValue* elements) { return CEREAL_RAPIDJSON_SETPOINTER(GenericValue, data_.a.elements, elements); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2037","line":"    CEREAL_RAPIDJSON_FORCEINLINE Member* GetMembersPointer() const { return CEREAL_RAPIDJSON_GETPOINTER(Member, data_.o.members); }","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":" 2038","line":"    CEREAL_RAPIDJSON_FORCEINLINE Member* SetMembersPointer(Member* members) { return CEREAL_RAPIDJSON_SETPOINTER(Member, data_.o.members, members); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2039","line":""},
{"lineNum":" 2040","line":"    // Initialize this value as array with initial data, without calling destructor."},
{"lineNum":" 2041","line":"    void SetArrayRaw(GenericValue* values, SizeType count, Allocator& allocator) {"},
{"lineNum":" 2042","line":"        data_.f.flags = kArrayFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2043","line":"        if (count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2044","line":"            GenericValue* e = static_cast<GenericValue*>(allocator.Malloc(count * sizeof(GenericValue)));"},
{"lineNum":" 2045","line":"            SetElementsPointer(e);"},
{"lineNum":" 2046","line":"            std::memcpy(static_cast<void*>(e), values, count * sizeof(GenericValue));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2047","line":"        }"},
{"lineNum":" 2048","line":"        else"},
{"lineNum":" 2049","line":"            SetElementsPointer(0);"},
{"lineNum":" 2050","line":"        data_.a.size = data_.a.capacity = count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2051","line":"    }"},
{"lineNum":" 2052","line":""},
{"lineNum":" 2053","line":"    //! Initialize this value as object with initial data, without calling destructor."},
{"lineNum":" 2054","line":"    void SetObjectRaw(Member* members, SizeType count, Allocator& allocator) {"},
{"lineNum":" 2055","line":"        data_.f.flags = kObjectFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2056","line":"        if (count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2057","line":"            Member* m = static_cast<Member*>(allocator.Malloc(count * sizeof(Member)));"},
{"lineNum":" 2058","line":"            SetMembersPointer(m);"},
{"lineNum":" 2059","line":"            std::memcpy(static_cast<void*>(m), members, count * sizeof(Member));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2060","line":"        }"},
{"lineNum":" 2061","line":"        else"},
{"lineNum":" 2062","line":"            SetMembersPointer(0);"},
{"lineNum":" 2063","line":"        data_.o.size = data_.o.capacity = count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2064","line":"    }"},
{"lineNum":" 2065","line":""},
{"lineNum":" 2066","line":"    //! Initialize this value as constant string, without calling destructor."},
{"lineNum":" 2067","line":"    void SetStringRaw(StringRefType s) CEREAL_RAPIDJSON_NOEXCEPT {"},
{"lineNum":" 2068","line":"        data_.f.flags = kConstStringFlag;"},
{"lineNum":" 2069","line":"        SetStringPointer(s);"},
{"lineNum":" 2070","line":"        data_.s.length = s.length;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2071","line":"    }"},
{"lineNum":" 2072","line":""},
{"lineNum":" 2073","line":"    //! Initialize this value as copy string with initial data, without calling destructor."},
{"lineNum":" 2074","line":"    void SetStringRaw(StringRefType s, Allocator& allocator) {"},
{"lineNum":" 2075","line":"        Ch* str = 0;"},
{"lineNum":" 2076","line":"        if (ShortString::Usable(s.length)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2077","line":"            data_.f.flags = kShortStringFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2078","line":"            data_.ss.SetLength(s.length);"},
{"lineNum":" 2079","line":"            str = data_.ss.str;"},
{"lineNum":" 2080","line":"        } else {"},
{"lineNum":" 2081","line":"            data_.f.flags = kCopyStringFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2082","line":"            data_.s.length = s.length;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2083","line":"            str = static_cast<Ch *>(allocator.Malloc((s.length + 1) * sizeof(Ch)));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2084","line":"            SetStringPointer(str);"},
{"lineNum":" 2085","line":"        }"},
{"lineNum":" 2086","line":"        std::memcpy(str, s, s.length * sizeof(Ch));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2087","line":"        str[s.length] = \'\\0\';","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2088","line":"    }"},
{"lineNum":" 2089","line":""},
{"lineNum":" 2090","line":"    //! Assignment without calling destructor"},
{"lineNum":" 2091","line":"    void RawAssign(GenericValue& rhs) CEREAL_RAPIDJSON_NOEXCEPT {"},
{"lineNum":" 2092","line":"        data_ = rhs.data_;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2093","line":"        // data_.f.flags = rhs.data_.f.flags;"},
{"lineNum":" 2094","line":"        rhs.data_.f.flags = kNullFlag;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2095","line":"    }"},
{"lineNum":" 2096","line":""},
{"lineNum":" 2097","line":"    template <typename SourceAllocator>"},
{"lineNum":" 2098","line":"    bool StringEqual(const GenericValue<Encoding, SourceAllocator>& rhs) const {"},
{"lineNum":" 2099","line":"        CEREAL_RAPIDJSON_ASSERT(IsString());"},
{"lineNum":" 2100","line":"        CEREAL_RAPIDJSON_ASSERT(rhs.IsString());"},
{"lineNum":" 2101","line":""},
{"lineNum":" 2102","line":"        const SizeType len1 = GetStringLength();"},
{"lineNum":" 2103","line":"        const SizeType len2 = rhs.GetStringLength();"},
{"lineNum":" 2104","line":"        if(len1 != len2) { return false; }"},
{"lineNum":" 2105","line":""},
{"lineNum":" 2106","line":"        const Ch* const str1 = GetString();"},
{"lineNum":" 2107","line":"        const Ch* const str2 = rhs.GetString();"},
{"lineNum":" 2108","line":"        if(str1 == str2) { return true; } // fast path for constant string"},
{"lineNum":" 2109","line":""},
{"lineNum":" 2110","line":"        return (std::memcmp(str1, str2, sizeof(Ch) * len1) == 0);"},
{"lineNum":" 2111","line":"    }"},
{"lineNum":" 2112","line":""},
{"lineNum":" 2113","line":"    Data data_;"},
{"lineNum":" 2114","line":"};"},
{"lineNum":" 2115","line":""},
{"lineNum":" 2116","line":"//! GenericValue with UTF8 encoding"},
{"lineNum":" 2117","line":"typedef GenericValue<UTF8<> > Value;"},
{"lineNum":" 2118","line":""},
{"lineNum":" 2119","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":" 2120","line":"// GenericDocument"},
{"lineNum":" 2121","line":""},
{"lineNum":" 2122","line":"//! A document for parsing JSON text as DOM."},
{"lineNum":" 2123","line":"/*!"},
{"lineNum":" 2124","line":"    \\note implements Handler concept"},
{"lineNum":" 2125","line":"    \\tparam Encoding Encoding for both parsing and string storage."},
{"lineNum":" 2126","line":"    \\tparam Allocator Allocator for allocating memory for the DOM"},
{"lineNum":" 2127","line":"    \\tparam StackAllocator Allocator for allocating memory for stack during parsing."},
{"lineNum":" 2128","line":"    \\warning Although GenericDocument inherits from GenericValue, the API does \\b not provide any virtual functions, especially no virtual destructor.  To avoid memory leaks, do not \\c delete a GenericDocument object via a pointer to a GenericValue."},
{"lineNum":" 2129","line":"*/"},
{"lineNum":" 2130","line":"template <typename Encoding, typename Allocator = MemoryPoolAllocator<>, typename StackAllocator = CrtAllocator>"},
{"lineNum":" 2131","line":"class GenericDocument : public GenericValue<Encoding, Allocator> {"},
{"lineNum":" 2132","line":"public:"},
{"lineNum":" 2133","line":"    typedef typename Encoding::Ch Ch;                       //!< Character type derived from Encoding."},
{"lineNum":" 2134","line":"    typedef GenericValue<Encoding, Allocator> ValueType;    //!< Value type of the document."},
{"lineNum":" 2135","line":"    typedef Allocator AllocatorType;                        //!< Allocator type from template parameter."},
{"lineNum":" 2136","line":""},
{"lineNum":" 2137","line":"    //! Constructor"},
{"lineNum":" 2138","line":"    /*! Creates an empty document of specified type."},
{"lineNum":" 2139","line":"        \\param type             Mandatory type of object to create."},
{"lineNum":" 2140","line":"        \\param allocator        Optional allocator for allocating memory."},
{"lineNum":" 2141","line":"        \\param stackCapacity    Optional initial capacity of stack in bytes."},
{"lineNum":" 2142","line":"        \\param stackAllocator   Optional allocator for allocating memory for stack."},
{"lineNum":" 2143","line":"    */"},
{"lineNum":" 2144","line":"    explicit GenericDocument(Type type, Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :"},
{"lineNum":" 2145","line":"        GenericValue<Encoding, Allocator>(type),  allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()"},
{"lineNum":" 2146","line":"    {"},
{"lineNum":" 2147","line":"        if (!allocator_)"},
{"lineNum":" 2148","line":"            ownAllocator_ = allocator_ = CEREAL_RAPIDJSON_NEW(Allocator)();"},
{"lineNum":" 2149","line":"    }"},
{"lineNum":" 2150","line":""},
{"lineNum":" 2151","line":"    //! Constructor"},
{"lineNum":" 2152","line":"    /*! Creates an empty document which type is Null."},
{"lineNum":" 2153","line":"        \\param allocator        Optional allocator for allocating memory."},
{"lineNum":" 2154","line":"        \\param stackCapacity    Optional initial capacity of stack in bytes."},
{"lineNum":" 2155","line":"        \\param stackAllocator   Optional allocator for allocating memory for stack."},
{"lineNum":" 2156","line":"    */"},
{"lineNum":" 2157","line":"    GenericDocument(Allocator* allocator = 0, size_t stackCapacity = kDefaultStackCapacity, StackAllocator* stackAllocator = 0) :"},
{"lineNum":" 2158","line":"        allocator_(allocator), ownAllocator_(0), stack_(stackAllocator, stackCapacity), parseResult_()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2159","line":"    {"},
{"lineNum":" 2160","line":"        if (!allocator_)"},
{"lineNum":" 2161","line":"            ownAllocator_ = allocator_ = CEREAL_RAPIDJSON_NEW(Allocator)();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2162","line":"    }"},
{"lineNum":" 2163","line":""},
{"lineNum":" 2164","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 2165","line":"    //! Move constructor in C++11"},
{"lineNum":" 2166","line":"    GenericDocument(GenericDocument&& rhs) CEREAL_RAPIDJSON_NOEXCEPT"},
{"lineNum":" 2167","line":"        : ValueType(std::forward<ValueType>(rhs)), // explicit cast to avoid prohibited move from Document"},
{"lineNum":" 2168","line":"          allocator_(rhs.allocator_),"},
{"lineNum":" 2169","line":"          ownAllocator_(rhs.ownAllocator_),"},
{"lineNum":" 2170","line":"          stack_(std::move(rhs.stack_)),"},
{"lineNum":" 2171","line":"          parseResult_(rhs.parseResult_)"},
{"lineNum":" 2172","line":"    {"},
{"lineNum":" 2173","line":"        rhs.allocator_ = 0;"},
{"lineNum":" 2174","line":"        rhs.ownAllocator_ = 0;"},
{"lineNum":" 2175","line":"        rhs.parseResult_ = ParseResult();"},
{"lineNum":" 2176","line":"    }"},
{"lineNum":" 2177","line":"#endif"},
{"lineNum":" 2178","line":""},
{"lineNum":" 2179","line":"    ~GenericDocument() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2180","line":"        Destroy();"},
{"lineNum":" 2181","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2182","line":""},
{"lineNum":" 2183","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 2184","line":"    //! Move assignment in C++11"},
{"lineNum":" 2185","line":"    GenericDocument& operator=(GenericDocument&& rhs) CEREAL_RAPIDJSON_NOEXCEPT"},
{"lineNum":" 2186","line":"    {"},
{"lineNum":" 2187","line":"        // The cast to ValueType is necessary here, because otherwise it would"},
{"lineNum":" 2188","line":"        // attempt to call GenericValue\'s templated assignment operator."},
{"lineNum":" 2189","line":"        ValueType::operator=(std::forward<ValueType>(rhs));"},
{"lineNum":" 2190","line":""},
{"lineNum":" 2191","line":"        // Calling the destructor here would prematurely call stack_\'s destructor"},
{"lineNum":" 2192","line":"        Destroy();"},
{"lineNum":" 2193","line":""},
{"lineNum":" 2194","line":"        allocator_ = rhs.allocator_;"},
{"lineNum":" 2195","line":"        ownAllocator_ = rhs.ownAllocator_;"},
{"lineNum":" 2196","line":"        stack_ = std::move(rhs.stack_);"},
{"lineNum":" 2197","line":"        parseResult_ = rhs.parseResult_;"},
{"lineNum":" 2198","line":""},
{"lineNum":" 2199","line":"        rhs.allocator_ = 0;"},
{"lineNum":" 2200","line":"        rhs.ownAllocator_ = 0;"},
{"lineNum":" 2201","line":"        rhs.parseResult_ = ParseResult();"},
{"lineNum":" 2202","line":""},
{"lineNum":" 2203","line":"        return *this;"},
{"lineNum":" 2204","line":"    }"},
{"lineNum":" 2205","line":"#endif"},
{"lineNum":" 2206","line":""},
{"lineNum":" 2207","line":"    //! Exchange the contents of this document with those of another."},
{"lineNum":" 2208","line":"    /*!"},
{"lineNum":" 2209","line":"        \\param rhs Another document."},
{"lineNum":" 2210","line":"        \\note Constant complexity."},
{"lineNum":" 2211","line":"        \\see GenericValue::Swap"},
{"lineNum":" 2212","line":"    */"},
{"lineNum":" 2213","line":"    GenericDocument& Swap(GenericDocument& rhs) CEREAL_RAPIDJSON_NOEXCEPT {"},
{"lineNum":" 2214","line":"        ValueType::Swap(rhs);"},
{"lineNum":" 2215","line":"        stack_.Swap(rhs.stack_);"},
{"lineNum":" 2216","line":"        internal::Swap(allocator_, rhs.allocator_);"},
{"lineNum":" 2217","line":"        internal::Swap(ownAllocator_, rhs.ownAllocator_);"},
{"lineNum":" 2218","line":"        internal::Swap(parseResult_, rhs.parseResult_);"},
{"lineNum":" 2219","line":"        return *this;"},
{"lineNum":" 2220","line":"    }"},
{"lineNum":" 2221","line":""},
{"lineNum":" 2222","line":"    // Allow Swap with ValueType."},
{"lineNum":" 2223","line":"    // Refer to Effective C++ 3rd Edition/Item 33: Avoid hiding inherited names."},
{"lineNum":" 2224","line":"    using ValueType::Swap;"},
{"lineNum":" 2225","line":""},
{"lineNum":" 2226","line":"    //! free-standing swap function helper"},
{"lineNum":" 2227","line":"    /*!"},
{"lineNum":" 2228","line":"        Helper function to enable support for common swap implementation pattern based on \\c std::swap:"},
{"lineNum":" 2229","line":"        \\code"},
{"lineNum":" 2230","line":"        void swap(MyClass& a, MyClass& b) {"},
{"lineNum":" 2231","line":"            using std::swap;"},
{"lineNum":" 2232","line":"            swap(a.doc, b.doc);"},
{"lineNum":" 2233","line":"            // ..."},
{"lineNum":" 2234","line":"        }"},
{"lineNum":" 2235","line":"        \\endcode"},
{"lineNum":" 2236","line":"        \\see Swap()"},
{"lineNum":" 2237","line":"     */"},
{"lineNum":" 2238","line":"    friend inline void swap(GenericDocument& a, GenericDocument& b) CEREAL_RAPIDJSON_NOEXCEPT { a.Swap(b); }"},
{"lineNum":" 2239","line":""},
{"lineNum":" 2240","line":"    //! Populate this document by a generator which produces SAX events."},
{"lineNum":" 2241","line":"    /*! \\tparam Generator A functor with <tt>bool f(Handler)</tt> prototype."},
{"lineNum":" 2242","line":"        \\param g Generator functor which sends SAX events to the parameter."},
{"lineNum":" 2243","line":"        \\return The document itself for fluent API."},
{"lineNum":" 2244","line":"    */"},
{"lineNum":" 2245","line":"    template <typename Generator>"},
{"lineNum":" 2246","line":"    GenericDocument& Populate(Generator& g) {"},
{"lineNum":" 2247","line":"        ClearStackOnExit scope(*this);"},
{"lineNum":" 2248","line":"        if (g(*this)) {"},
{"lineNum":" 2249","line":"            CEREAL_RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); // Got one and only one root object"},
{"lineNum":" 2250","line":"            ValueType::operator=(*stack_.template Pop<ValueType>(1));// Move value from stack to document"},
{"lineNum":" 2251","line":"        }"},
{"lineNum":" 2252","line":"        return *this;"},
{"lineNum":" 2253","line":"    }"},
{"lineNum":" 2254","line":""},
{"lineNum":" 2255","line":"    //!@name Parse from stream"},
{"lineNum":" 2256","line":"    //!@{"},
{"lineNum":" 2257","line":""},
{"lineNum":" 2258","line":"    //! Parse JSON text from an input stream (with Encoding conversion)"},
{"lineNum":" 2259","line":"    /*! \\tparam parseFlags Combination of \\ref ParseFlag."},
{"lineNum":" 2260","line":"        \\tparam SourceEncoding Encoding of input stream"},
{"lineNum":" 2261","line":"        \\tparam InputStream Type of input stream, implementing Stream concept"},
{"lineNum":" 2262","line":"        \\param is Input stream to be parsed."},
{"lineNum":" 2263","line":"        \\return The document itself for fluent API."},
{"lineNum":" 2264","line":"    */"},
{"lineNum":" 2265","line":"    template <unsigned parseFlags, typename SourceEncoding, typename InputStream>"},
{"lineNum":" 2266","line":"    GenericDocument& ParseStream(InputStream& is) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2267","line":"        GenericReader<SourceEncoding, Encoding, StackAllocator> reader("},
{"lineNum":" 2268","line":"            stack_.HasAllocator() ? &stack_.GetAllocator() : 0);"},
{"lineNum":" 2269","line":"        ClearStackOnExit scope(*this);"},
{"lineNum":" 2270","line":"        parseResult_ = reader.template Parse<parseFlags>(is, *this);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2271","line":"        if (parseResult_) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2272","line":"            CEREAL_RAPIDJSON_ASSERT(stack_.GetSize() == sizeof(ValueType)); // Got one and only one root object","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 2273","line":"            ValueType::operator=(*stack_.template Pop<ValueType>(1));// Move value from stack to document"},
{"lineNum":" 2274","line":"        }"},
{"lineNum":" 2275","line":"        return *this;"},
{"lineNum":" 2276","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2277","line":""},
{"lineNum":" 2278","line":"    //! Parse JSON text from an input stream"},
{"lineNum":" 2279","line":"    /*! \\tparam parseFlags Combination of \\ref ParseFlag."},
{"lineNum":" 2280","line":"        \\tparam InputStream Type of input stream, implementing Stream concept"},
{"lineNum":" 2281","line":"        \\param is Input stream to be parsed."},
{"lineNum":" 2282","line":"        \\return The document itself for fluent API."},
{"lineNum":" 2283","line":"    */"},
{"lineNum":" 2284","line":"    template <unsigned parseFlags, typename InputStream>"},
{"lineNum":" 2285","line":"    GenericDocument& ParseStream(InputStream& is) {"},
{"lineNum":" 2286","line":"        return ParseStream<parseFlags, Encoding, InputStream>(is);"},
{"lineNum":" 2287","line":"    }"},
{"lineNum":" 2288","line":""},
{"lineNum":" 2289","line":"    //! Parse JSON text from an input stream (with \\ref kParseDefaultFlags)"},
{"lineNum":" 2290","line":"    /*! \\tparam InputStream Type of input stream, implementing Stream concept"},
{"lineNum":" 2291","line":"        \\param is Input stream to be parsed."},
{"lineNum":" 2292","line":"        \\return The document itself for fluent API."},
{"lineNum":" 2293","line":"    */"},
{"lineNum":" 2294","line":"    template <typename InputStream>"},
{"lineNum":" 2295","line":"    GenericDocument& ParseStream(InputStream& is) {"},
{"lineNum":" 2296","line":"        return ParseStream<kParseDefaultFlags, Encoding, InputStream>(is);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2297","line":"    }"},
{"lineNum":" 2298","line":"    //!@}"},
{"lineNum":" 2299","line":""},
{"lineNum":" 2300","line":"    //!@name Parse in-place from mutable string"},
{"lineNum":" 2301","line":"    //!@{"},
{"lineNum":" 2302","line":""},
{"lineNum":" 2303","line":"    //! Parse JSON text from a mutable string"},
{"lineNum":" 2304","line":"    /*! \\tparam parseFlags Combination of \\ref ParseFlag."},
{"lineNum":" 2305","line":"        \\param str Mutable zero-terminated string to be parsed."},
{"lineNum":" 2306","line":"        \\return The document itself for fluent API."},
{"lineNum":" 2307","line":"    */"},
{"lineNum":" 2308","line":"    template <unsigned parseFlags>"},
{"lineNum":" 2309","line":"    GenericDocument& ParseInsitu(Ch* str) {"},
{"lineNum":" 2310","line":"        GenericInsituStringStream<Encoding> s(str);"},
{"lineNum":" 2311","line":"        return ParseStream<parseFlags | kParseInsituFlag>(s);"},
{"lineNum":" 2312","line":"    }"},
{"lineNum":" 2313","line":""},
{"lineNum":" 2314","line":"    //! Parse JSON text from a mutable string (with \\ref kParseDefaultFlags)"},
{"lineNum":" 2315","line":"    /*! \\param str Mutable zero-terminated string to be parsed."},
{"lineNum":" 2316","line":"        \\return The document itself for fluent API."},
{"lineNum":" 2317","line":"    */"},
{"lineNum":" 2318","line":"    GenericDocument& ParseInsitu(Ch* str) {"},
{"lineNum":" 2319","line":"        return ParseInsitu<kParseDefaultFlags>(str);"},
{"lineNum":" 2320","line":"    }"},
{"lineNum":" 2321","line":"    //!@}"},
{"lineNum":" 2322","line":""},
{"lineNum":" 2323","line":"    //!@name Parse from read-only string"},
{"lineNum":" 2324","line":"    //!@{"},
{"lineNum":" 2325","line":""},
{"lineNum":" 2326","line":"    //! Parse JSON text from a read-only string (with Encoding conversion)"},
{"lineNum":" 2327","line":"    /*! \\tparam parseFlags Combination of \\ref ParseFlag (must not contain \\ref kParseInsituFlag)."},
{"lineNum":" 2328","line":"        \\tparam SourceEncoding Transcoding from input Encoding"},
{"lineNum":" 2329","line":"        \\param str Read-only zero-terminated string to be parsed."},
{"lineNum":" 2330","line":"    */"},
{"lineNum":" 2331","line":"    template <unsigned parseFlags, typename SourceEncoding>"},
{"lineNum":" 2332","line":"    GenericDocument& Parse(const typename SourceEncoding::Ch* str) {"},
{"lineNum":" 2333","line":"        CEREAL_RAPIDJSON_ASSERT(!(parseFlags & kParseInsituFlag));"},
{"lineNum":" 2334","line":"        GenericStringStream<SourceEncoding> s(str);"},
{"lineNum":" 2335","line":"        return ParseStream<parseFlags, SourceEncoding>(s);"},
{"lineNum":" 2336","line":"    }"},
{"lineNum":" 2337","line":""},
{"lineNum":" 2338","line":"    //! Parse JSON text from a read-only string"},
{"lineNum":" 2339","line":"    /*! \\tparam parseFlags Combination of \\ref ParseFlag (must not contain \\ref kParseInsituFlag)."},
{"lineNum":" 2340","line":"        \\param str Read-only zero-terminated string to be parsed."},
{"lineNum":" 2341","line":"    */"},
{"lineNum":" 2342","line":"    template <unsigned parseFlags>"},
{"lineNum":" 2343","line":"    GenericDocument& Parse(const Ch* str) {"},
{"lineNum":" 2344","line":"        return Parse<parseFlags, Encoding>(str);"},
{"lineNum":" 2345","line":"    }"},
{"lineNum":" 2346","line":""},
{"lineNum":" 2347","line":"    //! Parse JSON text from a read-only string (with \\ref kParseDefaultFlags)"},
{"lineNum":" 2348","line":"    /*! \\param str Read-only zero-terminated string to be parsed."},
{"lineNum":" 2349","line":"    */"},
{"lineNum":" 2350","line":"    GenericDocument& Parse(const Ch* str) {"},
{"lineNum":" 2351","line":"        return Parse<kParseDefaultFlags>(str);"},
{"lineNum":" 2352","line":"    }"},
{"lineNum":" 2353","line":""},
{"lineNum":" 2354","line":"    template <unsigned parseFlags, typename SourceEncoding>"},
{"lineNum":" 2355","line":"    GenericDocument& Parse(const typename SourceEncoding::Ch* str, size_t length) {"},
{"lineNum":" 2356","line":"        CEREAL_RAPIDJSON_ASSERT(!(parseFlags & kParseInsituFlag));"},
{"lineNum":" 2357","line":"        MemoryStream ms(reinterpret_cast<const char*>(str), length * sizeof(typename SourceEncoding::Ch));"},
{"lineNum":" 2358","line":"        EncodedInputStream<SourceEncoding, MemoryStream> is(ms);"},
{"lineNum":" 2359","line":"        ParseStream<parseFlags, SourceEncoding>(is);"},
{"lineNum":" 2360","line":"        return *this;"},
{"lineNum":" 2361","line":"    }"},
{"lineNum":" 2362","line":""},
{"lineNum":" 2363","line":"    template <unsigned parseFlags>"},
{"lineNum":" 2364","line":"    GenericDocument& Parse(const Ch* str, size_t length) {"},
{"lineNum":" 2365","line":"        return Parse<parseFlags, Encoding>(str, length);"},
{"lineNum":" 2366","line":"    }"},
{"lineNum":" 2367","line":""},
{"lineNum":" 2368","line":"    GenericDocument& Parse(const Ch* str, size_t length) {"},
{"lineNum":" 2369","line":"        return Parse<kParseDefaultFlags>(str, length);"},
{"lineNum":" 2370","line":"    }"},
{"lineNum":" 2371","line":""},
{"lineNum":" 2372","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 2373","line":"    template <unsigned parseFlags, typename SourceEncoding>"},
{"lineNum":" 2374","line":"    GenericDocument& Parse(const std::basic_string<typename SourceEncoding::Ch>& str) {"},
{"lineNum":" 2375","line":"        // c_str() is constant complexity according to standard. Should be faster than Parse(const char*, size_t)"},
{"lineNum":" 2376","line":"        return Parse<parseFlags, SourceEncoding>(str.c_str());"},
{"lineNum":" 2377","line":"    }"},
{"lineNum":" 2378","line":""},
{"lineNum":" 2379","line":"    template <unsigned parseFlags>"},
{"lineNum":" 2380","line":"    GenericDocument& Parse(const std::basic_string<Ch>& str) {"},
{"lineNum":" 2381","line":"        return Parse<parseFlags, Encoding>(str.c_str());"},
{"lineNum":" 2382","line":"    }"},
{"lineNum":" 2383","line":""},
{"lineNum":" 2384","line":"    GenericDocument& Parse(const std::basic_string<Ch>& str) {"},
{"lineNum":" 2385","line":"        return Parse<kParseDefaultFlags>(str);"},
{"lineNum":" 2386","line":"    }"},
{"lineNum":" 2387","line":"#endif // CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 2388","line":""},
{"lineNum":" 2389","line":"    //!@}"},
{"lineNum":" 2390","line":""},
{"lineNum":" 2391","line":"    //!@name Handling parse errors"},
{"lineNum":" 2392","line":"    //!@{"},
{"lineNum":" 2393","line":""},
{"lineNum":" 2394","line":"    //! Whether a parse error has occurred in the last parsing."},
{"lineNum":" 2395","line":"    bool HasParseError() const { return parseResult_.IsError(); }"},
{"lineNum":" 2396","line":""},
{"lineNum":" 2397","line":"    //! Get the \\ref ParseErrorCode of last parsing."},
{"lineNum":" 2398","line":"    ParseErrorCode GetParseError() const { return parseResult_.Code(); }"},
{"lineNum":" 2399","line":""},
{"lineNum":" 2400","line":"    //! Get the position of last parsing error in input, 0 otherwise."},
{"lineNum":" 2401","line":"    size_t GetErrorOffset() const { return parseResult_.Offset(); }"},
{"lineNum":" 2402","line":""},
{"lineNum":" 2403","line":"    //! Implicit conversion to get the last parse result"},
{"lineNum":" 2404","line":"#ifndef __clang // -Wdocumentation"},
{"lineNum":" 2405","line":"    /*! \\return \\ref ParseResult of the last parse operation"},
{"lineNum":" 2406","line":""},
{"lineNum":" 2407","line":"        \\code"},
{"lineNum":" 2408","line":"          Document doc;"},
{"lineNum":" 2409","line":"          ParseResult ok = doc.Parse(json);"},
{"lineNum":" 2410","line":"          if (!ok)"},
{"lineNum":" 2411","line":"            printf( \"JSON parse error: %s (%u)\\n\", GetParseError_En(ok.Code()), ok.Offset());"},
{"lineNum":" 2412","line":"        \\endcode"},
{"lineNum":" 2413","line":"     */"},
{"lineNum":" 2414","line":"#endif"},
{"lineNum":" 2415","line":"    operator ParseResult() const { return parseResult_; }"},
{"lineNum":" 2416","line":"    //!@}"},
{"lineNum":" 2417","line":""},
{"lineNum":" 2418","line":"    //! Get the allocator of this document."},
{"lineNum":" 2419","line":"    Allocator& GetAllocator() {"},
{"lineNum":" 2420","line":"        CEREAL_RAPIDJSON_ASSERT(allocator_);","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 2421","line":"        return *allocator_;"},
{"lineNum":" 2422","line":"    }"},
{"lineNum":" 2423","line":""},
{"lineNum":" 2424","line":"    //! Get the capacity of stack in bytes."},
{"lineNum":" 2425","line":"    size_t GetStackCapacity() const { return stack_.GetCapacity(); }"},
{"lineNum":" 2426","line":""},
{"lineNum":" 2427","line":"private:"},
{"lineNum":" 2428","line":"    // clear stack on any exit from ParseStream, e.g. due to exception"},
{"lineNum":" 2429","line":"    struct ClearStackOnExit {"},
{"lineNum":" 2430","line":"        explicit ClearStackOnExit(GenericDocument& d) : d_(d) {}"},
{"lineNum":" 2431","line":"        ~ClearStackOnExit() { d_.ClearStack(); }"},
{"lineNum":" 2432","line":"    private:"},
{"lineNum":" 2433","line":"        ClearStackOnExit(const ClearStackOnExit&);"},
{"lineNum":" 2434","line":"        ClearStackOnExit& operator=(const ClearStackOnExit&);"},
{"lineNum":" 2435","line":"        GenericDocument& d_;"},
{"lineNum":" 2436","line":"    };"},
{"lineNum":" 2437","line":""},
{"lineNum":" 2438","line":"    // callers of the following private Handler functions"},
{"lineNum":" 2439","line":"    // template <typename,typename,typename> friend class GenericReader; // for parsing"},
{"lineNum":" 2440","line":"    template <typename, typename> friend class GenericValue; // for deep copying"},
{"lineNum":" 2441","line":""},
{"lineNum":" 2442","line":"public:"},
{"lineNum":" 2443","line":"    // Implementation of Handler"},
{"lineNum":" 2444","line":"    bool Null() { new (stack_.template Push<ValueType>()) ValueType(); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2445","line":"    bool Bool(bool b) { new (stack_.template Push<ValueType>()) ValueType(b); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2446","line":"    bool Int(int i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2447","line":"    bool Uint(unsigned i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2448","line":"    bool Int64(int64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2449","line":"    bool Uint64(uint64_t i) { new (stack_.template Push<ValueType>()) ValueType(i); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2450","line":"    bool Double(double d) { new (stack_.template Push<ValueType>()) ValueType(d); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2451","line":""},
{"lineNum":" 2452","line":"    bool RawNumber(const Ch* str, SizeType length, bool copy) {"},
{"lineNum":" 2453","line":"        if (copy)"},
{"lineNum":" 2454","line":"            new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());"},
{"lineNum":" 2455","line":"        else"},
{"lineNum":" 2456","line":"            new (stack_.template Push<ValueType>()) ValueType(str, length);"},
{"lineNum":" 2457","line":"        return true;"},
{"lineNum":" 2458","line":"    }"},
{"lineNum":" 2459","line":""},
{"lineNum":" 2460","line":"    bool String(const Ch* str, SizeType length, bool copy) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2461","line":"        if (copy)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2462","line":"            new (stack_.template Push<ValueType>()) ValueType(str, length, GetAllocator());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2463","line":"        else"},
{"lineNum":" 2464","line":"            new (stack_.template Push<ValueType>()) ValueType(str, length);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2465","line":"        return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2466","line":"    }"},
{"lineNum":" 2467","line":""},
{"lineNum":" 2468","line":"    bool StartObject() { new (stack_.template Push<ValueType>()) ValueType(kObjectType); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2469","line":""},
{"lineNum":" 2470","line":"    bool Key(const Ch* str, SizeType length, bool copy) { return String(str, length, copy); }"},
{"lineNum":" 2471","line":""},
{"lineNum":" 2472","line":"    bool EndObject(SizeType memberCount) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2473","line":"        typename ValueType::Member* members = stack_.template Pop<typename ValueType::Member>(memberCount);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2474","line":"        stack_.template Top<ValueType>()->SetObjectRaw(members, memberCount, GetAllocator());"},
{"lineNum":" 2475","line":"        return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2476","line":"    }"},
{"lineNum":" 2477","line":""},
{"lineNum":" 2478","line":"    bool StartArray() { new (stack_.template Push<ValueType>()) ValueType(kArrayType); return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2479","line":""},
{"lineNum":" 2480","line":"    bool EndArray(SizeType elementCount) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2481","line":"        ValueType* elements = stack_.template Pop<ValueType>(elementCount);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2482","line":"        stack_.template Top<ValueType>()->SetArrayRaw(elements, elementCount, GetAllocator());"},
{"lineNum":" 2483","line":"        return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 2484","line":"    }"},
{"lineNum":" 2485","line":""},
{"lineNum":" 2486","line":"private:"},
{"lineNum":" 2487","line":"    //! Prohibit copying"},
{"lineNum":" 2488","line":"    GenericDocument(const GenericDocument&);"},
{"lineNum":" 2489","line":"    //! Prohibit assignment"},
{"lineNum":" 2490","line":"    GenericDocument& operator=(const GenericDocument&);"},
{"lineNum":" 2491","line":""},
{"lineNum":" 2492","line":"    void ClearStack() {"},
{"lineNum":" 2493","line":"        if (Allocator::kNeedFree)"},
{"lineNum":" 2494","line":"            while (stack_.GetSize() > 0)    // Here assumes all elements in stack array are GenericValue (Member is actually 2 GenericValue objects)"},
{"lineNum":" 2495","line":"                (stack_.template Pop<ValueType>(1))->~ValueType();"},
{"lineNum":" 2496","line":"        else"},
{"lineNum":" 2497","line":"            stack_.Clear();"},
{"lineNum":" 2498","line":"        stack_.ShrinkToFit();"},
{"lineNum":" 2499","line":"    }"},
{"lineNum":" 2500","line":""},
{"lineNum":" 2501","line":"    void Destroy() {"},
{"lineNum":" 2502","line":"        CEREAL_RAPIDJSON_DELETE(ownAllocator_);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 2503","line":"    }"},
{"lineNum":" 2504","line":""},
{"lineNum":" 2505","line":"    static const size_t kDefaultStackCapacity = 1024;"},
{"lineNum":" 2506","line":"    Allocator* allocator_;"},
{"lineNum":" 2507","line":"    Allocator* ownAllocator_;"},
{"lineNum":" 2508","line":"    internal::Stack<StackAllocator> stack_;"},
{"lineNum":" 2509","line":"    ParseResult parseResult_;"},
{"lineNum":" 2510","line":"};"},
{"lineNum":" 2511","line":""},
{"lineNum":" 2512","line":"//! GenericDocument with UTF8 encoding"},
{"lineNum":" 2513","line":"typedef GenericDocument<UTF8<> > Document;"},
{"lineNum":" 2514","line":""},
{"lineNum":" 2515","line":"//! Helper class for accessing Value of array type."},
{"lineNum":" 2516","line":"/*!"},
{"lineNum":" 2517","line":"    Instance of this helper class is obtained by \\c GenericValue::GetArray()."},
{"lineNum":" 2518","line":"    In addition to all APIs for array type, it provides range-based for loop if \\c CEREAL_RAPIDJSON_HAS_CXX11_RANGE_FOR=1."},
{"lineNum":" 2519","line":"*/"},
{"lineNum":" 2520","line":"template <bool Const, typename ValueT>"},
{"lineNum":" 2521","line":"class GenericArray {"},
{"lineNum":" 2522","line":"public:"},
{"lineNum":" 2523","line":"    typedef GenericArray<true, ValueT> ConstArray;"},
{"lineNum":" 2524","line":"    typedef GenericArray<false, ValueT> Array;"},
{"lineNum":" 2525","line":"    typedef ValueT PlainType;"},
{"lineNum":" 2526","line":"    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;"},
{"lineNum":" 2527","line":"    typedef ValueType* ValueIterator;  // This may be const or non-const iterator"},
{"lineNum":" 2528","line":"    typedef const ValueT* ConstValueIterator;"},
{"lineNum":" 2529","line":"    typedef typename ValueType::AllocatorType AllocatorType;"},
{"lineNum":" 2530","line":"    typedef typename ValueType::StringRefType StringRefType;"},
{"lineNum":" 2531","line":""},
{"lineNum":" 2532","line":"    template <typename, typename>"},
{"lineNum":" 2533","line":"    friend class GenericValue;"},
{"lineNum":" 2534","line":""},
{"lineNum":" 2535","line":"    GenericArray(const GenericArray& rhs) : value_(rhs.value_) {}"},
{"lineNum":" 2536","line":"    GenericArray& operator=(const GenericArray& rhs) { value_ = rhs.value_; return *this; }"},
{"lineNum":" 2537","line":"    ~GenericArray() {}"},
{"lineNum":" 2538","line":""},
{"lineNum":" 2539","line":"    SizeType Size() const { return value_.Size(); }"},
{"lineNum":" 2540","line":"    SizeType Capacity() const { return value_.Capacity(); }"},
{"lineNum":" 2541","line":"    bool Empty() const { return value_.Empty(); }"},
{"lineNum":" 2542","line":"    void Clear() const { value_.Clear(); }"},
{"lineNum":" 2543","line":"    ValueType& operator[](SizeType index) const {  return value_[index]; }"},
{"lineNum":" 2544","line":"    ValueIterator Begin() const { return value_.Begin(); }"},
{"lineNum":" 2545","line":"    ValueIterator End() const { return value_.End(); }"},
{"lineNum":" 2546","line":"    GenericArray Reserve(SizeType newCapacity, AllocatorType &allocator) const { value_.Reserve(newCapacity, allocator); return *this; }"},
{"lineNum":" 2547","line":"    GenericArray PushBack(ValueType& value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }"},
{"lineNum":" 2548","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 2549","line":"    GenericArray PushBack(ValueType&& value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }"},
{"lineNum":" 2550","line":"#endif // CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 2551","line":"    GenericArray PushBack(StringRefType value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }"},
{"lineNum":" 2552","line":"    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (const GenericArray&)) PushBack(T value, AllocatorType& allocator) const { value_.PushBack(value, allocator); return *this; }"},
{"lineNum":" 2553","line":"    GenericArray PopBack() const { value_.PopBack(); return *this; }"},
{"lineNum":" 2554","line":"    ValueIterator Erase(ConstValueIterator pos) const { return value_.Erase(pos); }"},
{"lineNum":" 2555","line":"    ValueIterator Erase(ConstValueIterator first, ConstValueIterator last) const { return value_.Erase(first, last); }"},
{"lineNum":" 2556","line":""},
{"lineNum":" 2557","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RANGE_FOR"},
{"lineNum":" 2558","line":"    ValueIterator begin() const { return value_.Begin(); }"},
{"lineNum":" 2559","line":"    ValueIterator end() const { return value_.End(); }"},
{"lineNum":" 2560","line":"#endif"},
{"lineNum":" 2561","line":""},
{"lineNum":" 2562","line":"private:"},
{"lineNum":" 2563","line":"    GenericArray();"},
{"lineNum":" 2564","line":"    GenericArray(ValueType& value) : value_(value) {}"},
{"lineNum":" 2565","line":"    ValueType& value_;"},
{"lineNum":" 2566","line":"};"},
{"lineNum":" 2567","line":""},
{"lineNum":" 2568","line":"//! Helper class for accessing Value of object type."},
{"lineNum":" 2569","line":"/*!"},
{"lineNum":" 2570","line":"    Instance of this helper class is obtained by \\c GenericValue::GetObject()."},
{"lineNum":" 2571","line":"    In addition to all APIs for array type, it provides range-based for loop if \\c CEREAL_RAPIDJSON_HAS_CXX11_RANGE_FOR=1."},
{"lineNum":" 2572","line":"*/"},
{"lineNum":" 2573","line":"template <bool Const, typename ValueT>"},
{"lineNum":" 2574","line":"class GenericObject {"},
{"lineNum":" 2575","line":"public:"},
{"lineNum":" 2576","line":"    typedef GenericObject<true, ValueT> ConstObject;"},
{"lineNum":" 2577","line":"    typedef GenericObject<false, ValueT> Object;"},
{"lineNum":" 2578","line":"    typedef ValueT PlainType;"},
{"lineNum":" 2579","line":"    typedef typename internal::MaybeAddConst<Const,PlainType>::Type ValueType;"},
{"lineNum":" 2580","line":"    typedef GenericMemberIterator<Const, typename ValueT::EncodingType, typename ValueT::AllocatorType> MemberIterator;  // This may be const or non-const iterator"},
{"lineNum":" 2581","line":"    typedef GenericMemberIterator<true, typename ValueT::EncodingType, typename ValueT::AllocatorType> ConstMemberIterator;"},
{"lineNum":" 2582","line":"    typedef typename ValueType::AllocatorType AllocatorType;"},
{"lineNum":" 2583","line":"    typedef typename ValueType::StringRefType StringRefType;"},
{"lineNum":" 2584","line":"    typedef typename ValueType::EncodingType EncodingType;"},
{"lineNum":" 2585","line":"    typedef typename ValueType::Ch Ch;"},
{"lineNum":" 2586","line":""},
{"lineNum":" 2587","line":"    template <typename, typename>"},
{"lineNum":" 2588","line":"    friend class GenericValue;"},
{"lineNum":" 2589","line":""},
{"lineNum":" 2590","line":"    GenericObject(const GenericObject& rhs) : value_(rhs.value_) {}"},
{"lineNum":" 2591","line":"    GenericObject& operator=(const GenericObject& rhs) { value_ = rhs.value_; return *this; }"},
{"lineNum":" 2592","line":"    ~GenericObject() {}"},
{"lineNum":" 2593","line":""},
{"lineNum":" 2594","line":"    SizeType MemberCount() const { return value_.MemberCount(); }"},
{"lineNum":" 2595","line":"    SizeType MemberCapacity() const { return value_.MemberCapacity(); }"},
{"lineNum":" 2596","line":"    bool ObjectEmpty() const { return value_.ObjectEmpty(); }"},
{"lineNum":" 2597","line":"    template <typename T> ValueType& operator[](T* name) const { return value_[name]; }"},
{"lineNum":" 2598","line":"    template <typename SourceAllocator> ValueType& operator[](const GenericValue<EncodingType, SourceAllocator>& name) const { return value_[name]; }"},
{"lineNum":" 2599","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 2600","line":"    ValueType& operator[](const std::basic_string<Ch>& name) const { return value_[name]; }"},
{"lineNum":" 2601","line":"#endif"},
{"lineNum":" 2602","line":"    MemberIterator MemberBegin() const { return value_.MemberBegin(); }"},
{"lineNum":" 2603","line":"    MemberIterator MemberEnd() const { return value_.MemberEnd(); }"},
{"lineNum":" 2604","line":"    GenericObject MemberReserve(SizeType newCapacity, AllocatorType &allocator) const { value_.MemberReserve(newCapacity, allocator); return *this; }"},
{"lineNum":" 2605","line":"    bool HasMember(const Ch* name) const { return value_.HasMember(name); }"},
{"lineNum":" 2606","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 2607","line":"    bool HasMember(const std::basic_string<Ch>& name) const { return value_.HasMember(name); }"},
{"lineNum":" 2608","line":"#endif"},
{"lineNum":" 2609","line":"    template <typename SourceAllocator> bool HasMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.HasMember(name); }"},
{"lineNum":" 2610","line":"    MemberIterator FindMember(const Ch* name) const { return value_.FindMember(name); }"},
{"lineNum":" 2611","line":"    template <typename SourceAllocator> MemberIterator FindMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.FindMember(name); }"},
{"lineNum":" 2612","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 2613","line":"    MemberIterator FindMember(const std::basic_string<Ch>& name) const { return value_.FindMember(name); }"},
{"lineNum":" 2614","line":"#endif"},
{"lineNum":" 2615","line":"    GenericObject AddMember(ValueType& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2616","line":"    GenericObject AddMember(ValueType& name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2617","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 2618","line":"    GenericObject AddMember(ValueType& name, std::basic_string<Ch>& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2619","line":"#endif"},
{"lineNum":" 2620","line":"    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (ValueType&)) AddMember(ValueType& name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2621","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 2622","line":"    GenericObject AddMember(ValueType&& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2623","line":"    GenericObject AddMember(ValueType&& name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2624","line":"    GenericObject AddMember(ValueType& name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2625","line":"    GenericObject AddMember(StringRefType name, ValueType&& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2626","line":"#endif // CEREAL_RAPIDJSON_HAS_CXX11_RVALUE_REFS"},
{"lineNum":" 2627","line":"    GenericObject AddMember(StringRefType name, ValueType& value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2628","line":"    GenericObject AddMember(StringRefType name, StringRefType value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2629","line":"    template <typename T> CEREAL_RAPIDJSON_DISABLEIF_RETURN((internal::OrExpr<internal::IsPointer<T>, internal::IsGenericValue<T> >), (GenericObject)) AddMember(StringRefType name, T value, AllocatorType& allocator) const { value_.AddMember(name, value, allocator); return *this; }"},
{"lineNum":" 2630","line":"    void RemoveAllMembers() { value_.RemoveAllMembers(); }"},
{"lineNum":" 2631","line":"    bool RemoveMember(const Ch* name) const { return value_.RemoveMember(name); }"},
{"lineNum":" 2632","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 2633","line":"    bool RemoveMember(const std::basic_string<Ch>& name) const { return value_.RemoveMember(name); }"},
{"lineNum":" 2634","line":"#endif"},
{"lineNum":" 2635","line":"    template <typename SourceAllocator> bool RemoveMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.RemoveMember(name); }"},
{"lineNum":" 2636","line":"    MemberIterator RemoveMember(MemberIterator m) const { return value_.RemoveMember(m); }"},
{"lineNum":" 2637","line":"    MemberIterator EraseMember(ConstMemberIterator pos) const { return value_.EraseMember(pos); }"},
{"lineNum":" 2638","line":"    MemberIterator EraseMember(ConstMemberIterator first, ConstMemberIterator last) const { return value_.EraseMember(first, last); }"},
{"lineNum":" 2639","line":"    bool EraseMember(const Ch* name) const { return value_.EraseMember(name); }"},
{"lineNum":" 2640","line":"#if CEREAL_RAPIDJSON_HAS_STDSTRING"},
{"lineNum":" 2641","line":"    bool EraseMember(const std::basic_string<Ch>& name) const { return EraseMember(ValueType(StringRef(name))); }"},
{"lineNum":" 2642","line":"#endif"},
{"lineNum":" 2643","line":"    template <typename SourceAllocator> bool EraseMember(const GenericValue<EncodingType, SourceAllocator>& name) const { return value_.EraseMember(name); }"},
{"lineNum":" 2644","line":""},
{"lineNum":" 2645","line":"#if CEREAL_RAPIDJSON_HAS_CXX11_RANGE_FOR"},
{"lineNum":" 2646","line":"    MemberIterator begin() const { return value_.MemberBegin(); }"},
{"lineNum":" 2647","line":"    MemberIterator end() const { return value_.MemberEnd(); }"},
{"lineNum":" 2648","line":"#endif"},
{"lineNum":" 2649","line":""},
{"lineNum":" 2650","line":"private:"},
{"lineNum":" 2651","line":"    GenericObject();"},
{"lineNum":" 2652","line":"    GenericObject(ValueType& value) : value_(value) {}"},
{"lineNum":" 2653","line":"    ValueType& value_;"},
{"lineNum":" 2654","line":"};"},
{"lineNum":" 2655","line":""},
{"lineNum":" 2656","line":"CEREAL_RAPIDJSON_NAMESPACE_END"},
{"lineNum":" 2657","line":"CEREAL_RAPIDJSON_DIAG_POP"},
{"lineNum":" 2658","line":""},
{"lineNum":" 2659","line":"#endif // CEREAL_RAPIDJSON_DOCUMENT_H_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 121, "covered" : 0,};
var merged_data = [];
