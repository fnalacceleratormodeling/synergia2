var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2009-2010 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_BLASUTIL_H"},
{"lineNum":"   11","line":"#define EIGEN_BLASUTIL_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"// This file contains many lightweight helper classes used to"},
{"lineNum":"   14","line":"// implement and control fast level 2 and level 3 BLAS-like routines."},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"#include \"../InternalHeaderCheck.h\""},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace Eigen {"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"namespace internal {"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"// forward declarations"},
{"lineNum":"   23","line":"template<typename LhsScalar, typename RhsScalar, typename Index, typename DataMapper, int mr, int nr, bool ConjugateLhs=false, bool ConjugateRhs=false>"},
{"lineNum":"   24","line":"struct gebp_kernel;"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"template<typename Scalar, typename Index, typename DataMapper, int nr, int StorageOrder, bool Conjugate = false, bool PanelMode=false>"},
{"lineNum":"   27","line":"struct gemm_pack_rhs;"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"template<typename Scalar, typename Index, typename DataMapper, int Pack1, int Pack2, typename Packet, int StorageOrder, bool Conjugate = false, bool PanelMode = false>"},
{"lineNum":"   30","line":"struct gemm_pack_lhs;"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"template<"},
{"lineNum":"   33","line":"  typename Index,"},
{"lineNum":"   34","line":"  typename LhsScalar, int LhsStorageOrder, bool ConjugateLhs,"},
{"lineNum":"   35","line":"  typename RhsScalar, int RhsStorageOrder, bool ConjugateRhs,"},
{"lineNum":"   36","line":"  int ResStorageOrder, int ResInnerStride>"},
{"lineNum":"   37","line":"struct general_matrix_matrix_product;"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"template<typename Index,"},
{"lineNum":"   40","line":"         typename LhsScalar, typename LhsMapper, int LhsStorageOrder, bool ConjugateLhs,"},
{"lineNum":"   41","line":"         typename RhsScalar, typename RhsMapper, bool ConjugateRhs, int Version=Specialized>"},
{"lineNum":"   42","line":"struct general_matrix_vector_product;"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"template<typename From,typename To> struct get_factor {"},
{"lineNum":"   45","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE To run(const From& x) { return To(x); }"},
{"lineNum":"   46","line":"};"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {"},
{"lineNum":"   49","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   50","line":"  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return numext::real(x); }"},
{"lineNum":"   51","line":"};"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"template<typename Scalar, typename Index>"},
{"lineNum":"   55","line":"class BlasVectorMapper {"},
{"lineNum":"   56","line":"  public:"},
{"lineNum":"   57","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasVectorMapper(Scalar *data) : m_data(data) {}"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar operator()(Index i) const {"},
{"lineNum":"   60","line":"    return m_data[i];"},
{"lineNum":"   61","line":"  }"},
{"lineNum":"   62","line":"  template <typename Packet, int AlignmentType>"},
{"lineNum":"   63","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Packet load(Index i) const {"},
{"lineNum":"   64","line":"    return ploadt<Packet, AlignmentType>(m_data + i);"},
{"lineNum":"   65","line":"  }"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"  template <typename Packet>"},
{"lineNum":"   68","line":"  EIGEN_DEVICE_FUNC bool aligned(Index i) const {"},
{"lineNum":"   69","line":"    return (UIntPtr(m_data+i)%sizeof(Packet))==0;"},
{"lineNum":"   70","line":"  }"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"  protected:"},
{"lineNum":"   73","line":"  Scalar* m_data;"},
{"lineNum":"   74","line":"};"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"template<typename Scalar, typename Index, int AlignmentType, int Incr=1>"},
{"lineNum":"   77","line":"class BlasLinearMapper;"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"template<typename Scalar, typename Index, int AlignmentType>"},
{"lineNum":"   80","line":"class BlasLinearMapper<Scalar,Index,AlignmentType>"},
{"lineNum":"   81","line":"{"},
{"lineNum":"   82","line":"public:"},
{"lineNum":"   83","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasLinearMapper(Scalar *data, Index incr=1)"},
{"lineNum":"   84","line":"    : m_data(data)"},
{"lineNum":"   85","line":"  {"},
{"lineNum":"   86","line":"    EIGEN_ONLY_USED_FOR_DEBUG(incr);"},
{"lineNum":"   87","line":"    eigen_assert(incr==1);"},
{"lineNum":"   88","line":"  }"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void prefetch(int i) const {"},
{"lineNum":"   91","line":"    internal::prefetch(&operator()(i));"},
{"lineNum":"   92","line":"  }"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar& operator()(Index i) const {"},
{"lineNum":"   95","line":"    return m_data[i];","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   96","line":"  }"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"  template<typename PacketType>"},
{"lineNum":"   99","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketType loadPacket(Index i) const {"},
{"lineNum":"  100","line":"    return ploadt<PacketType, AlignmentType>(m_data + i);"},
{"lineNum":"  101","line":"  }"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"  template<typename PacketType>"},
{"lineNum":"  104","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacket(Index i, const PacketType &p) const {"},
{"lineNum":"  105","line":"    pstoret<Scalar, PacketType, AlignmentType>(m_data + i, p);"},
{"lineNum":"  106","line":"  }"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"protected:"},
{"lineNum":"  109","line":"  Scalar *m_data;"},
{"lineNum":"  110","line":"};"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"// Lightweight helper class to access matrix coefficients."},
{"lineNum":"  113","line":"template<typename Scalar, typename Index, int StorageOrder, int AlignmentType = Unaligned, int Incr = 1>"},
{"lineNum":"  114","line":"class blas_data_mapper;"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"// TMP to help PacketBlock store implementation."},
{"lineNum":"  117","line":"// There\'s currently no known use case for PacketBlock load."},
{"lineNum":"  118","line":"// The default implementation assumes ColMajor order."},
{"lineNum":"  119","line":"// It always store each packet sequentially one `stride` apart."},
{"lineNum":"  120","line":"template<typename Index, typename Scalar, typename Packet, int n, int idx, int StorageOrder>"},
{"lineNum":"  121","line":"struct PacketBlockManagement"},
{"lineNum":"  122","line":"{"},
{"lineNum":"  123","line":"  PacketBlockManagement<Index, Scalar, Packet, n, idx - 1, StorageOrder> pbm;"},
{"lineNum":"  124","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(Scalar *to, const Index stride, Index i, Index j, const PacketBlock<Packet, n> &block) const {"},
{"lineNum":"  125","line":"    pbm.store(to, stride, i, j, block);"},
{"lineNum":"  126","line":"    pstoreu<Scalar>(to + i + (j + idx)*stride, block.packet[idx]);"},
{"lineNum":"  127","line":"  }"},
{"lineNum":"  128","line":"};"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"// PacketBlockManagement specialization to take care of RowMajor order without ifs."},
{"lineNum":"  131","line":"template<typename Index, typename Scalar, typename Packet, int n, int idx>"},
{"lineNum":"  132","line":"struct PacketBlockManagement<Index, Scalar, Packet, n, idx, RowMajor>"},
{"lineNum":"  133","line":"{"},
{"lineNum":"  134","line":"  PacketBlockManagement<Index, Scalar, Packet, n, idx - 1, RowMajor> pbm;"},
{"lineNum":"  135","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(Scalar *to, const Index stride, Index i, Index j, const PacketBlock<Packet, n> &block) const {"},
{"lineNum":"  136","line":"    pbm.store(to, stride, i, j, block);"},
{"lineNum":"  137","line":"    pstoreu<Scalar>(to + j + (i + idx)*stride, block.packet[idx]);"},
{"lineNum":"  138","line":"  }"},
{"lineNum":"  139","line":"};"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"template<typename Index, typename Scalar, typename Packet, int n, int StorageOrder>"},
{"lineNum":"  142","line":"struct PacketBlockManagement<Index, Scalar, Packet, n, -1, StorageOrder>"},
{"lineNum":"  143","line":"{"},
{"lineNum":"  144","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(Scalar *to, const Index stride, Index i, Index j, const PacketBlock<Packet, n> &block) const {"},
{"lineNum":"  145","line":"    EIGEN_UNUSED_VARIABLE(to);"},
{"lineNum":"  146","line":"    EIGEN_UNUSED_VARIABLE(stride);"},
{"lineNum":"  147","line":"    EIGEN_UNUSED_VARIABLE(i);"},
{"lineNum":"  148","line":"    EIGEN_UNUSED_VARIABLE(j);"},
{"lineNum":"  149","line":"    EIGEN_UNUSED_VARIABLE(block);"},
{"lineNum":"  150","line":"  }"},
{"lineNum":"  151","line":"};"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"template<typename Index, typename Scalar, typename Packet, int n>"},
{"lineNum":"  154","line":"struct PacketBlockManagement<Index, Scalar, Packet, n, -1, RowMajor>"},
{"lineNum":"  155","line":"{"},
{"lineNum":"  156","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(Scalar *to, const Index stride, Index i, Index j, const PacketBlock<Packet, n> &block) const {"},
{"lineNum":"  157","line":"    EIGEN_UNUSED_VARIABLE(to);"},
{"lineNum":"  158","line":"    EIGEN_UNUSED_VARIABLE(stride);"},
{"lineNum":"  159","line":"    EIGEN_UNUSED_VARIABLE(i);"},
{"lineNum":"  160","line":"    EIGEN_UNUSED_VARIABLE(j);"},
{"lineNum":"  161","line":"    EIGEN_UNUSED_VARIABLE(block);"},
{"lineNum":"  162","line":"  }"},
{"lineNum":"  163","line":"};"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"template<typename Scalar, typename Index, int StorageOrder, int AlignmentType>"},
{"lineNum":"  166","line":"class blas_data_mapper<Scalar,Index,StorageOrder,AlignmentType,1>"},
{"lineNum":"  167","line":"{"},
{"lineNum":"  168","line":"public:"},
{"lineNum":"  169","line":"  typedef BlasLinearMapper<Scalar, Index, AlignmentType> LinearMapper;"},
{"lineNum":"  170","line":"  typedef BlasVectorMapper<Scalar, Index> VectorMapper;"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE blas_data_mapper(Scalar* data, Index stride, Index incr=1)"},
{"lineNum":"  173","line":"   : m_data(data), m_stride(stride)","class":"lineNoCov","hits":"0","possible_hits":"46",},
{"lineNum":"  174","line":"  {"},
{"lineNum":"  175","line":"    EIGEN_ONLY_USED_FOR_DEBUG(incr);"},
{"lineNum":"  176","line":"    eigen_assert(incr==1);"},
{"lineNum":"  177","line":"  }"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType>"},
{"lineNum":"  180","line":"  getSubMapper(Index i, Index j) const {"},
{"lineNum":"  181","line":"    return blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType>(&operator()(i, j), m_stride);"},
{"lineNum":"  182","line":"  }"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE LinearMapper getLinearMapper(Index i, Index j) const {"},
{"lineNum":"  185","line":"    return LinearMapper(&operator()(i, j));"},
{"lineNum":"  186","line":"  }"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE VectorMapper getVectorMapper(Index i, Index j) const {"},
{"lineNum":"  189","line":"    return VectorMapper(&operator()(i, j));"},
{"lineNum":"  190","line":"  }"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  194","line":"  EIGEN_ALWAYS_INLINE Scalar& operator()(Index i, Index j) const {"},
{"lineNum":"  195","line":"    return m_data[StorageOrder==RowMajor ? j + i*m_stride : i + j*m_stride];","class":"lineNoCov","hits":"0","possible_hits":"231",},
{"lineNum":"  196","line":"  }"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"  template<typename PacketType>"},
{"lineNum":"  199","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketType loadPacket(Index i, Index j) const {"},
{"lineNum":"  200","line":"    return ploadt<PacketType, AlignmentType>(&operator()(i, j));"},
{"lineNum":"  201","line":"  }"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"  template <typename PacketT, int AlignmentT>"},
{"lineNum":"  204","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketT load(Index i, Index j) const {"},
{"lineNum":"  205","line":"    return ploadt<PacketT, AlignmentT>(&operator()(i, j));"},
{"lineNum":"  206","line":"  }"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"  template<typename SubPacket>"},
{"lineNum":"  209","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void scatterPacket(Index i, Index j, const SubPacket &p) const {"},
{"lineNum":"  210","line":"    pscatter<Scalar, SubPacket>(&operator()(i, j), p, m_stride);"},
{"lineNum":"  211","line":"  }"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"  template<typename SubPacket>"},
{"lineNum":"  214","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE SubPacket gatherPacket(Index i, Index j) const {"},
{"lineNum":"  215","line":"    return pgather<Scalar, SubPacket>(&operator()(i, j), m_stride);"},
{"lineNum":"  216","line":"  }"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"  EIGEN_DEVICE_FUNC const Index stride() const { return m_stride; }"},
{"lineNum":"  219","line":"  EIGEN_DEVICE_FUNC const Scalar* data() const { return m_data; }"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"  EIGEN_DEVICE_FUNC Index firstAligned(Index size) const {"},
{"lineNum":"  222","line":"    if (UIntPtr(m_data)%sizeof(Scalar)) {"},
{"lineNum":"  223","line":"      return -1;"},
{"lineNum":"  224","line":"    }"},
{"lineNum":"  225","line":"    return internal::first_default_aligned(m_data, size);"},
{"lineNum":"  226","line":"  }"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"  template<typename SubPacket, int n>"},
{"lineNum":"  229","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacketBlock(Index i, Index j, const PacketBlock<SubPacket, n> &block) const {"},
{"lineNum":"  230","line":"    PacketBlockManagement<Index, Scalar, SubPacket, n, n-1, StorageOrder> pbm;"},
{"lineNum":"  231","line":"    pbm.store(m_data, m_stride, i, j, block);"},
{"lineNum":"  232","line":"  }"},
{"lineNum":"  233","line":"protected:"},
{"lineNum":"  234","line":"  Scalar* EIGEN_RESTRICT m_data;"},
{"lineNum":"  235","line":"  const Index m_stride;"},
{"lineNum":"  236","line":"};"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"// Implementation of non-natural increment (i.e. inner-stride != 1)"},
{"lineNum":"  239","line":"// The exposed API is not complete yet compared to the Incr==1 case"},
{"lineNum":"  240","line":"// because some features makes less sense in this case."},
{"lineNum":"  241","line":"template<typename Scalar, typename Index, int AlignmentType, int Incr>"},
{"lineNum":"  242","line":"class BlasLinearMapper"},
{"lineNum":"  243","line":"{"},
{"lineNum":"  244","line":"public:"},
{"lineNum":"  245","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE BlasLinearMapper(Scalar *data,Index incr) : m_data(data), m_incr(incr) {}"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void prefetch(int i) const {"},
{"lineNum":"  248","line":"    internal::prefetch(&operator()(i));"},
{"lineNum":"  249","line":"  }"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE Scalar& operator()(Index i) const {"},
{"lineNum":"  252","line":"    return m_data[i*m_incr.value()];"},
{"lineNum":"  253","line":"  }"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"  template<typename PacketType>"},
{"lineNum":"  256","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketType loadPacket(Index i) const {"},
{"lineNum":"  257","line":"    return pgather<Scalar,PacketType>(m_data + i*m_incr.value(), m_incr.value());"},
{"lineNum":"  258","line":"  }"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"  template<typename PacketType>"},
{"lineNum":"  261","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacket(Index i, const PacketType &p) const {"},
{"lineNum":"  262","line":"    pscatter<Scalar, PacketType>(m_data + i*m_incr.value(), p, m_incr.value());"},
{"lineNum":"  263","line":"  }"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"protected:"},
{"lineNum":"  266","line":"  Scalar *m_data;"},
{"lineNum":"  267","line":"  const internal::variable_if_dynamic<Index,Incr> m_incr;"},
{"lineNum":"  268","line":"};"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"template<typename Scalar, typename Index, int StorageOrder, int AlignmentType,int Incr>"},
{"lineNum":"  271","line":"class blas_data_mapper"},
{"lineNum":"  272","line":"{"},
{"lineNum":"  273","line":"public:"},
{"lineNum":"  274","line":"  typedef BlasLinearMapper<Scalar, Index, AlignmentType,Incr> LinearMapper;"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE blas_data_mapper(Scalar* data, Index stride, Index incr) : m_data(data), m_stride(stride), m_incr(incr) {}"},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE blas_data_mapper"},
{"lineNum":"  279","line":"  getSubMapper(Index i, Index j) const {"},
{"lineNum":"  280","line":"    return blas_data_mapper(&operator()(i, j), m_stride, m_incr.value());"},
{"lineNum":"  281","line":"  }"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"  EIGEN_DEVICE_FUNC  EIGEN_ALWAYS_INLINE LinearMapper getLinearMapper(Index i, Index j) const {"},
{"lineNum":"  284","line":"    return LinearMapper(&operator()(i, j), m_incr.value());"},
{"lineNum":"  285","line":"  }"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  288","line":"  EIGEN_ALWAYS_INLINE Scalar& operator()(Index i, Index j) const {"},
{"lineNum":"  289","line":"    return m_data[StorageOrder==RowMajor ? j*m_incr.value() + i*m_stride : i*m_incr.value() + j*m_stride];"},
{"lineNum":"  290","line":"  }"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"  template<typename PacketType>"},
{"lineNum":"  293","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketType loadPacket(Index i, Index j) const {"},
{"lineNum":"  294","line":"    return pgather<Scalar,PacketType>(&operator()(i, j),m_incr.value());"},
{"lineNum":"  295","line":"  }"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"  template <typename PacketT, int AlignmentT>"},
{"lineNum":"  298","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE PacketT load(Index i, Index j) const {"},
{"lineNum":"  299","line":"    return pgather<Scalar,PacketT>(&operator()(i, j),m_incr.value());"},
{"lineNum":"  300","line":"  }"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"  template<typename SubPacket>"},
{"lineNum":"  303","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void scatterPacket(Index i, Index j, const SubPacket &p) const {"},
{"lineNum":"  304","line":"    pscatter<Scalar, SubPacket>(&operator()(i, j), p, m_stride);"},
{"lineNum":"  305","line":"  }"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"  template<typename SubPacket>"},
{"lineNum":"  308","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE SubPacket gatherPacket(Index i, Index j) const {"},
{"lineNum":"  309","line":"    return pgather<Scalar, SubPacket>(&operator()(i, j), m_stride);"},
{"lineNum":"  310","line":"  }"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"  // storePacketBlock_helper defines a way to access values inside the PacketBlock, this is essentially required by the Complex types."},
{"lineNum":"  313","line":"  template<typename SubPacket, typename Scalar_, int n, int idx>"},
{"lineNum":"  314","line":"  struct storePacketBlock_helper"},
{"lineNum":"  315","line":"  {"},
{"lineNum":"  316","line":"    storePacketBlock_helper<SubPacket, Scalar_, n, idx-1> spbh;"},
{"lineNum":"  317","line":"    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>* sup, Index i, Index j, const PacketBlock<SubPacket, n>& block) const {"},
{"lineNum":"  318","line":"      spbh.store(sup, i,j,block);"},
{"lineNum":"  319","line":"      for(int l = 0; l < unpacket_traits<SubPacket>::size; l++)"},
{"lineNum":"  320","line":"      {"},
{"lineNum":"  321","line":"        Scalar_ *v = &sup->operator()(i+l, j+idx);"},
{"lineNum":"  322","line":"        *v = block.packet[idx][l];"},
{"lineNum":"  323","line":"      }"},
{"lineNum":"  324","line":"    }"},
{"lineNum":"  325","line":"  };"},
{"lineNum":"  326","line":""},
{"lineNum":"  327","line":"  template<typename SubPacket, int n, int idx>"},
{"lineNum":"  328","line":"  struct storePacketBlock_helper<SubPacket, std::complex<float>, n, idx>"},
{"lineNum":"  329","line":"  {"},
{"lineNum":"  330","line":"    storePacketBlock_helper<SubPacket, std::complex<float>, n, idx-1> spbh;"},
{"lineNum":"  331","line":"    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>* sup, Index i, Index j, const PacketBlock<SubPacket, n>& block) const {"},
{"lineNum":"  332","line":"      spbh.store(sup,i,j,block);"},
{"lineNum":"  333","line":"      for(int l = 0; l < unpacket_traits<SubPacket>::size; l++)"},
{"lineNum":"  334","line":"      {"},
{"lineNum":"  335","line":"        std::complex<float> *v = &sup->operator()(i+l, j+idx);"},
{"lineNum":"  336","line":"        v->real(block.packet[idx].v[2*l+0]);"},
{"lineNum":"  337","line":"        v->imag(block.packet[idx].v[2*l+1]);"},
{"lineNum":"  338","line":"      }"},
{"lineNum":"  339","line":"    }"},
{"lineNum":"  340","line":"  };"},
{"lineNum":"  341","line":""},
{"lineNum":"  342","line":"  template<typename SubPacket, int n, int idx>"},
{"lineNum":"  343","line":"  struct storePacketBlock_helper<SubPacket, std::complex<double>, n, idx>"},
{"lineNum":"  344","line":"  {"},
{"lineNum":"  345","line":"    storePacketBlock_helper<SubPacket, std::complex<double>, n, idx-1> spbh;"},
{"lineNum":"  346","line":"    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>* sup, Index i, Index j, const PacketBlock<SubPacket, n>& block) const {"},
{"lineNum":"  347","line":"      spbh.store(sup,i,j,block);"},
{"lineNum":"  348","line":"      for(int l = 0; l < unpacket_traits<SubPacket>::size; l++)"},
{"lineNum":"  349","line":"      {"},
{"lineNum":"  350","line":"        std::complex<double> *v = &sup->operator()(i+l, j+idx);"},
{"lineNum":"  351","line":"        v->real(block.packet[idx].v[2*l+0]);"},
{"lineNum":"  352","line":"        v->imag(block.packet[idx].v[2*l+1]);"},
{"lineNum":"  353","line":"      }"},
{"lineNum":"  354","line":"    }"},
{"lineNum":"  355","line":"  };"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"  template<typename SubPacket, typename Scalar_, int n>"},
{"lineNum":"  358","line":"  struct storePacketBlock_helper<SubPacket, Scalar_, n, -1>"},
{"lineNum":"  359","line":"  {"},
{"lineNum":"  360","line":"    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>*, Index, Index, const PacketBlock<SubPacket, n>& ) const {"},
{"lineNum":"  361","line":"    }"},
{"lineNum":"  362","line":"  };"},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"  template<typename SubPacket, int n>"},
{"lineNum":"  365","line":"  struct storePacketBlock_helper<SubPacket, std::complex<float>, n, -1>"},
{"lineNum":"  366","line":"  {"},
{"lineNum":"  367","line":"    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>*, Index, Index, const PacketBlock<SubPacket, n>& ) const {"},
{"lineNum":"  368","line":"    }"},
{"lineNum":"  369","line":"  };"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"  template<typename SubPacket, int n>"},
{"lineNum":"  372","line":"  struct storePacketBlock_helper<SubPacket, std::complex<double>, n, -1>"},
{"lineNum":"  373","line":"  {"},
{"lineNum":"  374","line":"    EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void store(const blas_data_mapper<Scalar, Index, StorageOrder, AlignmentType, Incr>*, Index, Index, const PacketBlock<SubPacket, n>& ) const {"},
{"lineNum":"  375","line":"    }"},
{"lineNum":"  376","line":"  };"},
{"lineNum":"  377","line":"  // This function stores a PacketBlock on m_data, this approach is really quite slow compare to Incr=1 and should be avoided when possible."},
{"lineNum":"  378","line":"  template<typename SubPacket, int n>"},
{"lineNum":"  379","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void storePacketBlock(Index i, Index j, const PacketBlock<SubPacket, n>&block) const {"},
{"lineNum":"  380","line":"    storePacketBlock_helper<SubPacket, Scalar, n, n-1> spb;"},
{"lineNum":"  381","line":"    spb.store(this, i,j,block);"},
{"lineNum":"  382","line":"  }"},
{"lineNum":"  383","line":"protected:"},
{"lineNum":"  384","line":"  Scalar* EIGEN_RESTRICT m_data;"},
{"lineNum":"  385","line":"  const Index m_stride;"},
{"lineNum":"  386","line":"  const internal::variable_if_dynamic<Index,Incr> m_incr;"},
{"lineNum":"  387","line":"};"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"// lightweight helper class to access matrix coefficients (const version)"},
{"lineNum":"  390","line":"template<typename Scalar, typename Index, int StorageOrder>"},
{"lineNum":"  391","line":"class const_blas_data_mapper : public blas_data_mapper<const Scalar, Index, StorageOrder> {"},
{"lineNum":"  392","line":"  public:"},
{"lineNum":"  393","line":"  EIGEN_ALWAYS_INLINE const_blas_data_mapper(const Scalar *data, Index stride) : blas_data_mapper<const Scalar, Index, StorageOrder>(data, stride) {}"},
{"lineNum":"  394","line":""},
{"lineNum":"  395","line":"  EIGEN_ALWAYS_INLINE const_blas_data_mapper<Scalar, Index, StorageOrder> getSubMapper(Index i, Index j) const {"},
{"lineNum":"  396","line":"    return const_blas_data_mapper<Scalar, Index, StorageOrder>(&(this->operator()(i, j)), this->m_stride);"},
{"lineNum":"  397","line":"  }"},
{"lineNum":"  398","line":"};"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":""},
{"lineNum":"  401","line":"/* Helper class to analyze the factors of a Product expression."},
{"lineNum":"  402","line":" * In particular it allows to pop out operator-, scalar multiples,"},
{"lineNum":"  403","line":" * and conjugate */"},
{"lineNum":"  404","line":"template<typename XprType> struct blas_traits"},
{"lineNum":"  405","line":"{"},
{"lineNum":"  406","line":"  typedef typename traits<XprType>::Scalar Scalar;"},
{"lineNum":"  407","line":"  typedef const XprType& ExtractType;"},
{"lineNum":"  408","line":"  typedef XprType _ExtractType;"},
{"lineNum":"  409","line":"  enum {"},
{"lineNum":"  410","line":"    IsComplex = NumTraits<Scalar>::IsComplex,"},
{"lineNum":"  411","line":"    IsTransposed = false,"},
{"lineNum":"  412","line":"    NeedToConjugate = false,"},
{"lineNum":"  413","line":"    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)"},
{"lineNum":"  414","line":"                              && (   bool(XprType::IsVectorAtCompileTime)"},
{"lineNum":"  415","line":"                                  || int(inner_stride_at_compile_time<XprType>::ret) == 1)"},
{"lineNum":"  416","line":"                             ) ?  1 : 0,"},
{"lineNum":"  417","line":"    HasScalarFactor = false"},
{"lineNum":"  418","line":"  };"},
{"lineNum":"  419","line":"  typedef typename conditional<bool(HasUsableDirectAccess),"},
{"lineNum":"  420","line":"    ExtractType,"},
{"lineNum":"  421","line":"    typename _ExtractType::PlainObject"},
{"lineNum":"  422","line":"    >::type DirectLinearAccessType;"},
{"lineNum":"  423","line":"  static inline EIGEN_DEVICE_FUNC ExtractType extract(const XprType& x) { return x; }"},
{"lineNum":"  424","line":"  static inline EIGEN_DEVICE_FUNC const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }"},
{"lineNum":"  425","line":"};"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"// pop conjugate"},
{"lineNum":"  428","line":"template<typename Scalar, typename NestedXpr>"},
{"lineNum":"  429","line":"struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> >"},
{"lineNum":"  430","line":" : blas_traits<NestedXpr>"},
{"lineNum":"  431","line":"{"},
{"lineNum":"  432","line":"  typedef blas_traits<NestedXpr> Base;"},
{"lineNum":"  433","line":"  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, NestedXpr> XprType;"},
{"lineNum":"  434","line":"  typedef typename Base::ExtractType ExtractType;"},
{"lineNum":"  435","line":""},
{"lineNum":"  436","line":"  enum {"},
{"lineNum":"  437","line":"    IsComplex = NumTraits<Scalar>::IsComplex,"},
{"lineNum":"  438","line":"    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex"},
{"lineNum":"  439","line":"  };"},
{"lineNum":"  440","line":"  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }"},
{"lineNum":"  441","line":"  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }"},
{"lineNum":"  442","line":"};"},
{"lineNum":"  443","line":""},
{"lineNum":"  444","line":"// pop scalar multiple"},
{"lineNum":"  445","line":"template<typename Scalar, typename NestedXpr, typename Plain>"},
{"lineNum":"  446","line":"struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain>, NestedXpr> >"},
{"lineNum":"  447","line":" : blas_traits<NestedXpr>"},
{"lineNum":"  448","line":"{"},
{"lineNum":"  449","line":"  enum {"},
{"lineNum":"  450","line":"    HasScalarFactor = true"},
{"lineNum":"  451","line":"  };"},
{"lineNum":"  452","line":"  typedef blas_traits<NestedXpr> Base;"},
{"lineNum":"  453","line":"  typedef CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain>, NestedXpr> XprType;"},
{"lineNum":"  454","line":"  typedef typename Base::ExtractType ExtractType;"},
{"lineNum":"  455","line":"  static inline EIGEN_DEVICE_FUNC ExtractType extract(const XprType& x) { return Base::extract(x.rhs()); }"},
{"lineNum":"  456","line":"  static inline EIGEN_DEVICE_FUNC Scalar extractScalarFactor(const XprType& x)"},
{"lineNum":"  457","line":"  { return x.lhs().functor().m_other * Base::extractScalarFactor(x.rhs()); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  458","line":"};"},
{"lineNum":"  459","line":"template<typename Scalar, typename NestedXpr, typename Plain>"},
{"lineNum":"  460","line":"struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, NestedXpr, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain> > >"},
{"lineNum":"  461","line":" : blas_traits<NestedXpr>"},
{"lineNum":"  462","line":"{"},
{"lineNum":"  463","line":"  enum {"},
{"lineNum":"  464","line":"    HasScalarFactor = true"},
{"lineNum":"  465","line":"  };"},
{"lineNum":"  466","line":"  typedef blas_traits<NestedXpr> Base;"},
{"lineNum":"  467","line":"  typedef CwiseBinaryOp<scalar_product_op<Scalar>, NestedXpr, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain> > XprType;"},
{"lineNum":"  468","line":"  typedef typename Base::ExtractType ExtractType;"},
{"lineNum":"  469","line":"  static inline ExtractType extract(const XprType& x) { return Base::extract(x.lhs()); }"},
{"lineNum":"  470","line":"  static inline Scalar extractScalarFactor(const XprType& x)"},
{"lineNum":"  471","line":"  { return Base::extractScalarFactor(x.lhs()) * x.rhs().functor().m_other; }"},
{"lineNum":"  472","line":"};"},
{"lineNum":"  473","line":"template<typename Scalar, typename Plain1, typename Plain2>"},
{"lineNum":"  474","line":"struct blas_traits<CwiseBinaryOp<scalar_product_op<Scalar>, const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain1>,"},
{"lineNum":"  475","line":"                                                            const CwiseNullaryOp<scalar_constant_op<Scalar>,Plain2> > >"},
{"lineNum":"  476","line":" : blas_traits<CwiseNullaryOp<scalar_constant_op<Scalar>,Plain1> >"},
{"lineNum":"  477","line":"{};"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"// pop opposite"},
{"lineNum":"  480","line":"template<typename Scalar, typename NestedXpr>"},
{"lineNum":"  481","line":"struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> >"},
{"lineNum":"  482","line":" : blas_traits<NestedXpr>"},
{"lineNum":"  483","line":"{"},
{"lineNum":"  484","line":"  enum {"},
{"lineNum":"  485","line":"    HasScalarFactor = true"},
{"lineNum":"  486","line":"  };"},
{"lineNum":"  487","line":"  typedef blas_traits<NestedXpr> Base;"},
{"lineNum":"  488","line":"  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, NestedXpr> XprType;"},
{"lineNum":"  489","line":"  typedef typename Base::ExtractType ExtractType;"},
{"lineNum":"  490","line":"  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }"},
{"lineNum":"  491","line":"  static inline Scalar extractScalarFactor(const XprType& x)"},
{"lineNum":"  492","line":"  { return - Base::extractScalarFactor(x.nestedExpression()); }"},
{"lineNum":"  493","line":"};"},
{"lineNum":"  494","line":""},
{"lineNum":"  495","line":"// pop/push transpose"},
{"lineNum":"  496","line":"template<typename NestedXpr>"},
{"lineNum":"  497","line":"struct blas_traits<Transpose<NestedXpr> >"},
{"lineNum":"  498","line":" : blas_traits<NestedXpr>"},
{"lineNum":"  499","line":"{"},
{"lineNum":"  500","line":"  typedef typename NestedXpr::Scalar Scalar;"},
{"lineNum":"  501","line":"  typedef blas_traits<NestedXpr> Base;"},
{"lineNum":"  502","line":"  typedef Transpose<NestedXpr> XprType;"},
{"lineNum":"  503","line":"  typedef Transpose<const typename Base::_ExtractType>  ExtractType; // const to get rid of a compile error; anyway blas traits are only used on the RHS"},
{"lineNum":"  504","line":"  typedef Transpose<const typename Base::_ExtractType> _ExtractType;"},
{"lineNum":"  505","line":"  typedef typename conditional<bool(Base::HasUsableDirectAccess),"},
{"lineNum":"  506","line":"    ExtractType,"},
{"lineNum":"  507","line":"    typename ExtractType::PlainObject"},
{"lineNum":"  508","line":"    >::type DirectLinearAccessType;"},
{"lineNum":"  509","line":"  enum {"},
{"lineNum":"  510","line":"    IsTransposed = Base::IsTransposed ? 0 : 1"},
{"lineNum":"  511","line":"  };"},
{"lineNum":"  512","line":"  static inline ExtractType extract(const XprType& x) { return ExtractType(Base::extract(x.nestedExpression())); }"},
{"lineNum":"  513","line":"  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }"},
{"lineNum":"  514","line":"};"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"template<typename T>"},
{"lineNum":"  517","line":"struct blas_traits<const T>"},
{"lineNum":"  518","line":"     : blas_traits<T>"},
{"lineNum":"  519","line":"{};"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"template<typename T, bool HasUsableDirectAccess=blas_traits<T>::HasUsableDirectAccess>"},
{"lineNum":"  522","line":"struct extract_data_selector {"},
{"lineNum":"  523","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static const typename T::Scalar* run(const T& m)"},
{"lineNum":"  524","line":"  {"},
{"lineNum":"  525","line":"    return blas_traits<T>::extract(m).data();"},
{"lineNum":"  526","line":"  }"},
{"lineNum":"  527","line":"};"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"template<typename T>"},
{"lineNum":"  530","line":"struct extract_data_selector<T,false> {"},
{"lineNum":"  531","line":"  static typename T::Scalar* run(const T&) { return 0; }"},
{"lineNum":"  532","line":"};"},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":"template<typename T>"},
{"lineNum":"  535","line":"EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE const typename T::Scalar* extract_data(const T& m)"},
{"lineNum":"  536","line":"{"},
{"lineNum":"  537","line":"  return extract_data_selector<T>::run(m);"},
{"lineNum":"  538","line":"}"},
{"lineNum":"  539","line":""},
{"lineNum":"  540","line":"/**"},
{"lineNum":"  541","line":" * \\c combine_scalar_factors extracts and multiplies factors from GEMM and GEMV products."},
{"lineNum":"  542","line":" * There is a specialization for booleans"},
{"lineNum":"  543","line":" */"},
{"lineNum":"  544","line":"template<typename ResScalar, typename Lhs, typename Rhs>"},
{"lineNum":"  545","line":"struct combine_scalar_factors_impl"},
{"lineNum":"  546","line":"{"},
{"lineNum":"  547","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static ResScalar run(const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  548","line":"  {"},
{"lineNum":"  549","line":"    return blas_traits<Lhs>::extractScalarFactor(lhs) * blas_traits<Rhs>::extractScalarFactor(rhs);"},
{"lineNum":"  550","line":"  }"},
{"lineNum":"  551","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static ResScalar run(const ResScalar& alpha, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  552","line":"  {"},
{"lineNum":"  553","line":"    return alpha * blas_traits<Lhs>::extractScalarFactor(lhs) * blas_traits<Rhs>::extractScalarFactor(rhs);","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  554","line":"  }"},
{"lineNum":"  555","line":"};"},
{"lineNum":"  556","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"  557","line":"struct combine_scalar_factors_impl<bool, Lhs, Rhs>"},
{"lineNum":"  558","line":"{"},
{"lineNum":"  559","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static bool run(const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  560","line":"  {"},
{"lineNum":"  561","line":"    return blas_traits<Lhs>::extractScalarFactor(lhs) && blas_traits<Rhs>::extractScalarFactor(rhs);"},
{"lineNum":"  562","line":"  }"},
{"lineNum":"  563","line":"  EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE static bool run(const bool& alpha, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  564","line":"  {"},
{"lineNum":"  565","line":"    return alpha && blas_traits<Lhs>::extractScalarFactor(lhs) && blas_traits<Rhs>::extractScalarFactor(rhs);"},
{"lineNum":"  566","line":"  }"},
{"lineNum":"  567","line":"};"},
{"lineNum":"  568","line":""},
{"lineNum":"  569","line":"template<typename ResScalar, typename Lhs, typename Rhs>"},
{"lineNum":"  570","line":"EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE ResScalar combine_scalar_factors(const ResScalar& alpha, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  571","line":"{"},
{"lineNum":"  572","line":"  return combine_scalar_factors_impl<ResScalar,Lhs,Rhs>::run(alpha, lhs, rhs);"},
{"lineNum":"  573","line":"}"},
{"lineNum":"  574","line":"template<typename ResScalar, typename Lhs, typename Rhs>"},
{"lineNum":"  575","line":"EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE ResScalar combine_scalar_factors(const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  576","line":"{"},
{"lineNum":"  577","line":"  return combine_scalar_factors_impl<ResScalar,Lhs,Rhs>::run(lhs, rhs);"},
{"lineNum":"  578","line":"}"},
{"lineNum":"  579","line":""},
{"lineNum":"  580","line":""},
{"lineNum":"  581","line":"} // end namespace internal"},
{"lineNum":"  582","line":""},
{"lineNum":"  583","line":"} // end namespace Eigen"},
{"lineNum":"  584","line":""},
{"lineNum":"  585","line":"#endif // EIGEN_BLASUTIL_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 5, "covered" : 0,};
var merged_data = [];
