var data = {lines:[
{"lineNum":"    1","line":"/*============================================================================="},
{"lineNum":"    2","line":"    Copyright (c) 2001-2011 Joel de Guzman"},
{"lineNum":"    3","line":"    Copyright (c) 2001-2011 Hartmut Kaiser"},
{"lineNum":"    4","line":"    http://spirit.sourceforge.net/"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"    Distributed under the Boost Software License, Version 1.0. (See accompanying"},
{"lineNum":"    7","line":"    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    8","line":"=============================================================================*/"},
{"lineNum":"    9","line":"#if !defined(SPIRIT_REAL_IMPL_APRIL_18_2006_0901AM)"},
{"lineNum":"   10","line":"#define SPIRIT_REAL_IMPL_APRIL_18_2006_0901AM"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"#if defined(_MSC_VER)"},
{"lineNum":"   13","line":"#pragma once"},
{"lineNum":"   14","line":"#endif"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"#include <cmath>"},
{"lineNum":"   17","line":"#include <boost/limits.hpp>"},
{"lineNum":"   18","line":"#include <boost/type_traits/is_same.hpp>"},
{"lineNum":"   19","line":"#include <boost/spirit/home/support/unused.hpp>"},
{"lineNum":"   20","line":"#include <boost/spirit/home/qi/detail/attributes.hpp>"},
{"lineNum":"   21","line":"#include <boost/spirit/home/support/detail/pow10.hpp>"},
{"lineNum":"   22","line":"#include <boost/spirit/home/support/detail/sign.hpp>"},
{"lineNum":"   23","line":"#include <boost/integer.hpp>"},
{"lineNum":"   24","line":"#include <boost/assert.hpp>"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)"},
{"lineNum":"   27","line":"# pragma warning(push)"},
{"lineNum":"   28","line":"# pragma warning(disable: 4100)   // \'p\': unreferenced formal parameter"},
{"lineNum":"   29","line":"# pragma warning(disable: 4127)   // conditional expression is constant"},
{"lineNum":"   30","line":"#endif"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"namespace boost { namespace spirit { namespace traits"},
{"lineNum":"   33","line":"{"},
{"lineNum":"   34","line":"    using spirit::traits::pow10;"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"    namespace detail"},
{"lineNum":"   37","line":"    {"},
{"lineNum":"   38","line":"        template <typename T, typename AccT>"},
{"lineNum":"   39","line":"        void compensate_roundoff(T& n, AccT acc_n, mpl::true_)"},
{"lineNum":"   40","line":"        {"},
{"lineNum":"   41","line":"            // at the lowest extremes, we compensate for floating point"},
{"lineNum":"   42","line":"            // roundoff errors by doing imprecise computation using T"},
{"lineNum":"   43","line":"            int const comp = 10;"},
{"lineNum":"   44","line":"            n = T((acc_n / comp) * comp);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   45","line":"            n += T(acc_n % comp);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   46","line":"        }"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"        template <typename T, typename AccT>"},
{"lineNum":"   49","line":"        void compensate_roundoff(T& n, AccT acc_n, mpl::false_)"},
{"lineNum":"   50","line":"        {"},
{"lineNum":"   51","line":"            // no need to compensate"},
{"lineNum":"   52","line":"            n = acc_n;"},
{"lineNum":"   53","line":"        }"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"        template <typename T, typename AccT>"},
{"lineNum":"   56","line":"        void compensate_roundoff(T& n, AccT acc_n)"},
{"lineNum":"   57","line":"        {"},
{"lineNum":"   58","line":"            compensate_roundoff(n, acc_n, is_integral<AccT>());"},
{"lineNum":"   59","line":"        }"},
{"lineNum":"   60","line":"    }"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"    template <typename T, typename AccT>"},
{"lineNum":"   63","line":"    inline bool"},
{"lineNum":"   64","line":"    scale(int exp, T& n, AccT acc_n)"},
{"lineNum":"   65","line":"    {"},
{"lineNum":"   66","line":"        if (exp >= 0)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   67","line":"        {"},
{"lineNum":"   68","line":"            int max_exp = std::numeric_limits<T>::max_exponent10;"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"            // return false if exp exceeds the max_exp"},
{"lineNum":"   71","line":"            // do this check only for primitive types!"},
{"lineNum":"   72","line":"            if (is_floating_point<T>() && exp > max_exp)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   73","line":"                return false;"},
{"lineNum":"   74","line":"            n = acc_n * pow10<T>(exp);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   75","line":"        }"},
{"lineNum":"   76","line":"        else"},
{"lineNum":"   77","line":"        {"},
{"lineNum":"   78","line":"            if (exp < std::numeric_limits<T>::min_exponent10)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   79","line":"            {"},
{"lineNum":"   80","line":"                int min_exp = std::numeric_limits<T>::min_exponent10;"},
{"lineNum":"   81","line":"                detail::compensate_roundoff(n, acc_n);"},
{"lineNum":"   82","line":"                n /= pow10<T>(-min_exp);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"                // return false if exp still exceeds the min_exp"},
{"lineNum":"   85","line":"                // do this check only for primitive types!"},
{"lineNum":"   86","line":"                exp += -min_exp;"},
{"lineNum":"   87","line":"                if (is_floating_point<T>() && exp < min_exp)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   88","line":"                    return false;"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"                n /= pow10<T>(-exp);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   91","line":"            }"},
{"lineNum":"   92","line":"            else"},
{"lineNum":"   93","line":"            {"},
{"lineNum":"   94","line":"                n = T(acc_n) / pow10<T>(-exp);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   95","line":"            }"},
{"lineNum":"   96","line":"        }"},
{"lineNum":"   97","line":"        return true;"},
{"lineNum":"   98","line":"    }"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"    inline bool"},
{"lineNum":"  101","line":"    scale(int /*exp*/, unused_type /*n*/, unused_type /*acc_n*/)"},
{"lineNum":"  102","line":"    {"},
{"lineNum":"  103","line":"        // no-op for unused_type"},
{"lineNum":"  104","line":"        return true;"},
{"lineNum":"  105","line":"    }"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"    template <typename T, typename AccT>"},
{"lineNum":"  108","line":"    inline bool"},
{"lineNum":"  109","line":"    scale(int exp, int frac, T& n, AccT acc_n)"},
{"lineNum":"  110","line":"    {"},
{"lineNum":"  111","line":"        return scale(exp - frac, n, acc_n);"},
{"lineNum":"  112","line":"    }"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"    inline bool"},
{"lineNum":"  115","line":"    scale(int /*exp*/, int /*frac*/, unused_type /*n*/)"},
{"lineNum":"  116","line":"    {"},
{"lineNum":"  117","line":"        // no-op for unused_type"},
{"lineNum":"  118","line":"        return true;"},
{"lineNum":"  119","line":"    }"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"    inline float"},
{"lineNum":"  122","line":"    negate(bool neg, float n)"},
{"lineNum":"  123","line":"    {"},
{"lineNum":"  124","line":"        return neg ? spirit::detail::changesign(n) : n;"},
{"lineNum":"  125","line":"    }"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    inline double"},
{"lineNum":"  128","line":"    negate(bool neg, double n)"},
{"lineNum":"  129","line":"    {"},
{"lineNum":"  130","line":"        return neg ? spirit::detail::changesign(n) : n;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  131","line":"    }"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"    inline long double"},
{"lineNum":"  134","line":"    negate(bool neg, long double n)"},
{"lineNum":"  135","line":"    {"},
{"lineNum":"  136","line":"        return neg ? spirit::detail::changesign(n) : n;"},
{"lineNum":"  137","line":"    }"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"    template <typename T>"},
{"lineNum":"  140","line":"    inline T"},
{"lineNum":"  141","line":"    negate(bool neg, T const& n)"},
{"lineNum":"  142","line":"    {"},
{"lineNum":"  143","line":"        return neg ? -n : n;"},
{"lineNum":"  144","line":"    }"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"    inline unused_type"},
{"lineNum":"  147","line":"    negate(bool /*neg*/, unused_type n)"},
{"lineNum":"  148","line":"    {"},
{"lineNum":"  149","line":"        // no-op for unused_type"},
{"lineNum":"  150","line":"        return n;"},
{"lineNum":"  151","line":"    }"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"    template <typename T>"},
{"lineNum":"  154","line":"    struct real_accumulator : mpl::identity<T> {};"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"    template <>"},
{"lineNum":"  157","line":"    struct real_accumulator<float>"},
{"lineNum":"  158","line":"        : mpl::identity<uint_t<(sizeof(float)*CHAR_BIT)>::least> {};"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"    template <>"},
{"lineNum":"  161","line":"    struct real_accumulator<double>"},
{"lineNum":"  162","line":"        : mpl::identity<uint_t<(sizeof(double)*CHAR_BIT)>::least> {};"},
{"lineNum":"  163","line":"}}}"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"namespace boost { namespace spirit { namespace qi  { namespace detail"},
{"lineNum":"  166","line":"{"},
{"lineNum":"  167","line":"    template <typename T, typename RealPolicies>"},
{"lineNum":"  168","line":"    struct real_impl"},
{"lineNum":"  169","line":"    {"},
{"lineNum":"  170","line":"        template <typename Iterator, typename Attribute>"},
{"lineNum":"  171","line":"        static bool"},
{"lineNum":"  172","line":"        parse(Iterator& first, Iterator const& last, Attribute& attr,"},
{"lineNum":"  173","line":"            RealPolicies const& p)"},
{"lineNum":"  174","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  175","line":"            if (first == last)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  176","line":"                return false;"},
{"lineNum":"  177","line":"            Iterator save = first;"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"            // Start by parsing the sign. neg will be true if"},
{"lineNum":"  180","line":"            // we got a \"-\" sign, false otherwise."},
{"lineNum":"  181","line":"            bool neg = p.parse_sign(first, last);"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"            // Now attempt to parse an integer"},
{"lineNum":"  184","line":"            T n;"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"            typename traits::real_accumulator<T>::type acc_n = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  187","line":"            bool got_a_number = p.parse_n(first, last, acc_n);"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"            // If we did not get a number it might be a NaN, Inf or a leading"},
{"lineNum":"  190","line":"            // dot."},
{"lineNum":"  191","line":"            if (!got_a_number)"},
{"lineNum":"  192","line":"            {"},
{"lineNum":"  193","line":"                // Check whether the number to parse is a NaN or Inf"},
{"lineNum":"  194","line":"                if (p.parse_nan(first, last, n) ||","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  195","line":"                    p.parse_inf(first, last, n))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  196","line":"                {"},
{"lineNum":"  197","line":"                    // If we got a negative sign, negate the number"},
{"lineNum":"  198","line":"                    traits::assign_to(traits::negate(neg, n), attr);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  199","line":"                    return true;    // got a NaN or Inf, return early"},
{"lineNum":"  200","line":"                }"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"                // If we did not get a number and our policies do not"},
{"lineNum":"  203","line":"                // allow a leading dot, fail and return early (no-match)"},
{"lineNum":"  204","line":"                if (!p.allow_leading_dot)"},
{"lineNum":"  205","line":"                {"},
{"lineNum":"  206","line":"                    first = save;"},
{"lineNum":"  207","line":"                    return false;"},
{"lineNum":"  208","line":"                }"},
{"lineNum":"  209","line":"            }"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"            bool e_hit = false;"},
{"lineNum":"  212","line":"            Iterator e_pos;"},
{"lineNum":"  213","line":"            int frac_digits = 0;"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"            // Try to parse the dot (\'.\' decimal point)"},
{"lineNum":"  216","line":"            if (p.parse_dot(first, last))"},
{"lineNum":"  217","line":"            {"},
{"lineNum":"  218","line":"                // We got the decimal point. Now we will try to parse"},
{"lineNum":"  219","line":"                // the fraction if it is there. If not, it defaults"},
{"lineNum":"  220","line":"                // to zero (0) only if we already got a number."},
{"lineNum":"  221","line":"                if (p.parse_frac_n(first, last, acc_n, frac_digits))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  222","line":"                {"},
{"lineNum":"  223","line":"                    BOOST_ASSERT(frac_digits >= 0);"},
{"lineNum":"  224","line":"                }"},
{"lineNum":"  225","line":"                else if (!got_a_number || !p.allow_trailing_dot)"},
{"lineNum":"  226","line":"                {"},
{"lineNum":"  227","line":"                    // We did not get a fraction. If we still haven\'t got a"},
{"lineNum":"  228","line":"                    // number and our policies do not allow a trailing dot,"},
{"lineNum":"  229","line":"                    // return no-match."},
{"lineNum":"  230","line":"                    first = save;"},
{"lineNum":"  231","line":"                    return false;"},
{"lineNum":"  232","line":"                }"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"                // Now, let\'s see if we can parse the exponent prefix"},
{"lineNum":"  235","line":"                e_pos = first;"},
{"lineNum":"  236","line":"                e_hit = p.parse_exp(first, last);"},
{"lineNum":"  237","line":"            }"},
{"lineNum":"  238","line":"            else"},
{"lineNum":"  239","line":"            {"},
{"lineNum":"  240","line":"                // No dot and no number! Return no-match."},
{"lineNum":"  241","line":"                if (!got_a_number)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  242","line":"                {"},
{"lineNum":"  243","line":"                    first = save;"},
{"lineNum":"  244","line":"                    return false;"},
{"lineNum":"  245","line":"                }"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"                // If we must expect a dot and we didn\'t see an exponent"},
{"lineNum":"  248","line":"                // prefix, return no-match."},
{"lineNum":"  249","line":"                e_pos = first;"},
{"lineNum":"  250","line":"                e_hit = p.parse_exp(first, last);"},
{"lineNum":"  251","line":"                if (p.expect_dot && !e_hit)"},
{"lineNum":"  252","line":"                {"},
{"lineNum":"  253","line":"                    first = save;"},
{"lineNum":"  254","line":"                    return false;"},
{"lineNum":"  255","line":"                }"},
{"lineNum":"  256","line":"            }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"            if (e_hit)"},
{"lineNum":"  259","line":"            {"},
{"lineNum":"  260","line":"                // We got the exponent prefix. Now we will try to parse the"},
{"lineNum":"  261","line":"                // actual exponent."},
{"lineNum":"  262","line":"                int exp = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  263","line":"                if (p.parse_exp_n(first, last, exp))"},
{"lineNum":"  264","line":"                {"},
{"lineNum":"  265","line":"                    // Got the exponent value. Scale the number by"},
{"lineNum":"  266","line":"                    // exp-frac_digits."},
{"lineNum":"  267","line":"                    if (!traits::scale(exp, frac_digits, n, acc_n))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  268","line":"                        return false;"},
{"lineNum":"  269","line":"                }"},
{"lineNum":"  270","line":"                else"},
{"lineNum":"  271","line":"                {"},
{"lineNum":"  272","line":"                    // If there is no number, disregard the exponent altogether."},
{"lineNum":"  273","line":"                    // by resetting \'first\' prior to the exponent prefix (e|E)"},
{"lineNum":"  274","line":"                    first = e_pos;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  275","line":"                    // Scale the number by -frac_digits."},
{"lineNum":"  276","line":"                    bool r = traits::scale(-frac_digits, n, acc_n);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  277","line":"                    BOOST_VERIFY(r);"},
{"lineNum":"  278","line":"                }"},
{"lineNum":"  279","line":"            }"},
{"lineNum":"  280","line":"            else if (frac_digits)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  281","line":"            {"},
{"lineNum":"  282","line":"                // No exponent found. Scale the number by -frac_digits."},
{"lineNum":"  283","line":"                bool r = traits::scale(-frac_digits, n, acc_n);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  284","line":"                BOOST_VERIFY(r);"},
{"lineNum":"  285","line":"            }"},
{"lineNum":"  286","line":"            else"},
{"lineNum":"  287","line":"            {"},
{"lineNum":"  288","line":"                n = static_cast<T>(acc_n);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  289","line":"            }"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"            // If we got a negative sign, negate the number"},
{"lineNum":"  292","line":"            traits::assign_to(traits::negate(neg, n), attr);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"            // Success!!!"},
{"lineNum":"  295","line":"            return true;"},
{"lineNum":"  296","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  297","line":"    };"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)"},
{"lineNum":"  300","line":"# pragma warning(pop)"},
{"lineNum":"  301","line":"#endif"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"}}}}"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 28, "covered" : 0,};
var merged_data = [];
