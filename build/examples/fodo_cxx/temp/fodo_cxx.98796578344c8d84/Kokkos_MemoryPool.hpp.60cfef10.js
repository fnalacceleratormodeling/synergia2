var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_MEMORYPOOL_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_MEMORYPOOL_HPP"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include <Kokkos_Core_fwd.hpp>"},
{"lineNum":"   49","line":"#include <Kokkos_Parallel.hpp>"},
{"lineNum":"   50","line":"#include <Kokkos_Atomic.hpp>"},
{"lineNum":"   51","line":"#include <impl/Kokkos_ConcurrentBitset.hpp>"},
{"lineNum":"   52","line":"#include <impl/Kokkos_Error.hpp>"},
{"lineNum":"   53","line":"#include <impl/Kokkos_SharedAlloc.hpp>"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"#include <iostream>"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"namespace Kokkos {"},
{"lineNum":"   58","line":"namespace Impl {"},
{"lineNum":"   59","line":"/* Report violation of size constraints:"},
{"lineNum":"   60","line":" *   min_block_alloc_size <= max_block_alloc_size"},
{"lineNum":"   61","line":" *   max_block_alloc_size <= min_superblock_size"},
{"lineNum":"   62","line":" *   min_superblock_size  <= max_superblock_size"},
{"lineNum":"   63","line":" *   min_superblock_size  <= min_total_alloc_size"},
{"lineNum":"   64","line":" *   min_superblock_size  <= min_block_alloc_size *"},
{"lineNum":"   65","line":" *                           max_block_per_superblock"},
{"lineNum":"   66","line":" */"},
{"lineNum":"   67","line":"void memory_pool_bounds_verification(size_t min_block_alloc_size,"},
{"lineNum":"   68","line":"                                     size_t max_block_alloc_size,"},
{"lineNum":"   69","line":"                                     size_t min_superblock_size,"},
{"lineNum":"   70","line":"                                     size_t max_superblock_size,"},
{"lineNum":"   71","line":"                                     size_t max_block_per_superblock,"},
{"lineNum":"   72","line":"                                     size_t min_total_alloc_size);"},
{"lineNum":"   73","line":"}  // namespace Impl"},
{"lineNum":"   74","line":"}  // namespace Kokkos"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"namespace Kokkos {"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"namespace Impl {"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"void _print_memory_pool_state(std::ostream &s, uint32_t const *sb_state_ptr,"},
{"lineNum":"   81","line":"                              int32_t sb_count, uint32_t sb_size_lg2,"},
{"lineNum":"   82","line":"                              uint32_t sb_state_size, uint32_t state_shift,"},
{"lineNum":"   83","line":"                              uint32_t state_used_mask);"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"}  // end namespace Impl"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"template <typename DeviceType>"},
{"lineNum":"   88","line":"class MemoryPool {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   89","line":" private:"},
{"lineNum":"   90","line":"  using CB = Kokkos::Impl::concurrent_bitset;"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"  enum : uint32_t { bits_per_int_lg2 = CB::bits_per_int_lg2 };"},
{"lineNum":"   93","line":"  enum : uint32_t { state_shift = CB::state_shift };"},
{"lineNum":"   94","line":"  enum : uint32_t { state_used_mask = CB::state_used_mask };"},
{"lineNum":"   95","line":"  enum : uint32_t { state_header_mask = CB::state_header_mask };"},
{"lineNum":"   96","line":"  enum : uint32_t { max_bit_count_lg2 = CB::max_bit_count_lg2 };"},
{"lineNum":"   97","line":"  enum : uint32_t { max_bit_count = CB::max_bit_count };"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"  enum : uint32_t { HINT_PER_BLOCK_SIZE = 2 };"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"  /*  Each superblock has a concurrent bitset state"},
{"lineNum":"  102","line":"   *  which is an array of uint32_t integers."},
{"lineNum":"  103","line":"   *    [ { block_count_lg2  : state_shift bits"},
{"lineNum":"  104","line":"   *      , used_block_count : ( 32 - state_shift ) bits"},
{"lineNum":"  105","line":"   *      }"},
{"lineNum":"  106","line":"   *    , { block allocation bit set }* ]"},
{"lineNum":"  107","line":"   *"},
{"lineNum":"  108","line":"   *  As superblocks are assigned (allocated) to a block size"},
{"lineNum":"  109","line":"   *  and released (deallocated) back to empty the superblock state"},
{"lineNum":"  110","line":"   *  is concurrently updated."},
{"lineNum":"  111","line":"   */"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"  /*  Mapping between block_size <-> block_state"},
{"lineNum":"  114","line":"   *"},
{"lineNum":"  115","line":"   *  block_state = ( m_sb_size_lg2 - block_size_lg2 ) << state_shift"},
{"lineNum":"  116","line":"   *  block_size  = m_sb_size_lg2 - ( block_state >> state_shift )"},
{"lineNum":"  117","line":"   *"},
{"lineNum":"  118","line":"   *  Thus A_block_size < B_block_size  <=>  A_block_state > B_block_state"},
{"lineNum":"  119","line":"   */"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"  using base_memory_space = typename DeviceType::memory_space;"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"  enum {"},
{"lineNum":"  124","line":"    accessible = Kokkos::Impl::MemorySpaceAccess<Kokkos::HostSpace,"},
{"lineNum":"  125","line":"                                                 base_memory_space>::accessible"},
{"lineNum":"  126","line":"  };"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"  using Tracker = Kokkos::Impl::SharedAllocationTracker;"},
{"lineNum":"  129","line":"  using Record  = Kokkos::Impl::SharedAllocationRecord<base_memory_space>;"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"  Tracker m_tracker;"},
{"lineNum":"  132","line":"  uint32_t *m_sb_state_array;"},
{"lineNum":"  133","line":"  uint32_t m_sb_state_size;"},
{"lineNum":"  134","line":"  uint32_t m_sb_size_lg2;"},
{"lineNum":"  135","line":"  uint32_t m_max_block_size_lg2;"},
{"lineNum":"  136","line":"  uint32_t m_min_block_size_lg2;"},
{"lineNum":"  137","line":"  int32_t m_sb_count;"},
{"lineNum":"  138","line":"  int32_t m_hint_offset;  // Offset to K * #block_size array of hints"},
{"lineNum":"  139","line":"  int32_t m_data_offset;  // Offset to 0th superblock data"},
{"lineNum":"  140","line":"  int32_t m_unused_padding;"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":" public:"},
{"lineNum":"  143","line":"  using memory_space = typename DeviceType::memory_space;"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"  /**\\brief  The maximum size of a superblock and block */"},
{"lineNum":"  146","line":"  enum : uint32_t { max_superblock_size = 1LU << 31 /* 2 gigabytes */ };"},
{"lineNum":"  147","line":"  enum : uint32_t { max_block_per_superblock = max_bit_count };"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"  //--------------------------------------------------------------------------"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  152","line":"  bool operator==(MemoryPool const &other) const {"},
{"lineNum":"  153","line":"    return m_sb_state_array == other.m_sb_state_array;"},
{"lineNum":"  154","line":"  }"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  157","line":"  size_t capacity() const noexcept {"},
{"lineNum":"  158","line":"    return size_t(m_sb_count) << m_sb_size_lg2;"},
{"lineNum":"  159","line":"  }"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  162","line":"  size_t min_block_size() const noexcept {"},
{"lineNum":"  163","line":"    return (1LU << m_min_block_size_lg2);"},
{"lineNum":"  164","line":"  }"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  167","line":"  size_t max_block_size() const noexcept {"},
{"lineNum":"  168","line":"    return (1LU << m_max_block_size_lg2);"},
{"lineNum":"  169","line":"  }"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"  struct usage_statistics {"},
{"lineNum":"  172","line":"    size_t capacity_bytes;        ///<  Capacity in bytes"},
{"lineNum":"  173","line":"    size_t superblock_bytes;      ///<  Superblock size in bytes"},
{"lineNum":"  174","line":"    size_t max_block_bytes;       ///<  Maximum block size in bytes"},
{"lineNum":"  175","line":"    size_t min_block_bytes;       ///<  Minimum block size in bytes"},
{"lineNum":"  176","line":"    size_t capacity_superblocks;  ///<  Number of superblocks"},
{"lineNum":"  177","line":"    size_t consumed_superblocks;  ///<  Superblocks assigned to allocations"},
{"lineNum":"  178","line":"    size_t consumed_blocks;       ///<  Number of allocations"},
{"lineNum":"  179","line":"    size_t consumed_bytes;        ///<  Bytes allocated"},
{"lineNum":"  180","line":"    size_t reserved_blocks;  ///<  Unallocated blocks in assigned superblocks"},
{"lineNum":"  181","line":"    size_t reserved_bytes;   ///<  Unallocated bytes in assigned superblocks"},
{"lineNum":"  182","line":"  };"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"  void get_usage_statistics(usage_statistics &stats) const {"},
{"lineNum":"  185","line":"    Kokkos::HostSpace host;"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"    const size_t alloc_size = m_hint_offset * sizeof(uint32_t);"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"    uint32_t *const sb_state_array ="},
{"lineNum":"  190","line":"        accessible ? m_sb_state_array : (uint32_t *)host.allocate(alloc_size);"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"    if (!accessible) {"},
{"lineNum":"  193","line":"      Kokkos::Impl::DeepCopy<Kokkos::HostSpace, base_memory_space>("},
{"lineNum":"  194","line":"          sb_state_array, m_sb_state_array, alloc_size);"},
{"lineNum":"  195","line":"    }"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"    stats.superblock_bytes     = (1LU << m_sb_size_lg2);"},
{"lineNum":"  198","line":"    stats.max_block_bytes      = (1LU << m_max_block_size_lg2);"},
{"lineNum":"  199","line":"    stats.min_block_bytes      = (1LU << m_min_block_size_lg2);"},
{"lineNum":"  200","line":"    stats.capacity_bytes       = stats.superblock_bytes * m_sb_count;"},
{"lineNum":"  201","line":"    stats.capacity_superblocks = m_sb_count;"},
{"lineNum":"  202","line":"    stats.consumed_superblocks = 0;"},
{"lineNum":"  203","line":"    stats.consumed_blocks      = 0;"},
{"lineNum":"  204","line":"    stats.consumed_bytes       = 0;"},
{"lineNum":"  205","line":"    stats.reserved_blocks      = 0;"},
{"lineNum":"  206","line":"    stats.reserved_bytes       = 0;"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"    const uint32_t *sb_state_ptr = sb_state_array;"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"    for (int32_t i = 0; i < m_sb_count; ++i, sb_state_ptr += m_sb_state_size) {"},
{"lineNum":"  211","line":"      const uint32_t block_count_lg2 = (*sb_state_ptr) >> state_shift;"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"      if (block_count_lg2) {"},
{"lineNum":"  214","line":"        const uint32_t block_count    = 1u << block_count_lg2;"},
{"lineNum":"  215","line":"        const uint32_t block_size_lg2 = m_sb_size_lg2 - block_count_lg2;"},
{"lineNum":"  216","line":"        const uint32_t block_size     = 1u << block_size_lg2;"},
{"lineNum":"  217","line":"        const uint32_t block_used     = (*sb_state_ptr) & state_used_mask;"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"        stats.consumed_superblocks++;"},
{"lineNum":"  220","line":"        stats.consumed_blocks += block_used;"},
{"lineNum":"  221","line":"        stats.consumed_bytes += block_used * block_size;"},
{"lineNum":"  222","line":"        stats.reserved_blocks += block_count - block_used;"},
{"lineNum":"  223","line":"        stats.reserved_bytes += (block_count - block_used) * block_size;"},
{"lineNum":"  224","line":"      }"},
{"lineNum":"  225","line":"    }"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"    if (!accessible) {"},
{"lineNum":"  228","line":"      host.deallocate(sb_state_array, alloc_size);"},
{"lineNum":"  229","line":"    }"},
{"lineNum":"  230","line":"  }"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"  void print_state(std::ostream &s) const {"},
{"lineNum":"  233","line":"    Kokkos::HostSpace host;"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"    const size_t alloc_size = m_hint_offset * sizeof(uint32_t);"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"    uint32_t *const sb_state_array ="},
{"lineNum":"  238","line":"        accessible ? m_sb_state_array : (uint32_t *)host.allocate(alloc_size);"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"    if (!accessible) {"},
{"lineNum":"  241","line":"      Kokkos::Impl::DeepCopy<Kokkos::HostSpace, base_memory_space>("},
{"lineNum":"  242","line":"          sb_state_array, m_sb_state_array, alloc_size);"},
{"lineNum":"  243","line":"    }"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"    Impl::_print_memory_pool_state(s, sb_state_array, m_sb_count, m_sb_size_lg2,"},
{"lineNum":"  246","line":"                                   m_sb_state_size, state_shift,"},
{"lineNum":"  247","line":"                                   state_used_mask);"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"    if (!accessible) {"},
{"lineNum":"  250","line":"      host.deallocate(sb_state_array, alloc_size);"},
{"lineNum":"  251","line":"    }"},
{"lineNum":"  252","line":"  }"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"  //--------------------------------------------------------------------------"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"  KOKKOS_DEFAULTED_FUNCTION MemoryPool(MemoryPool &&)      = default;"},
{"lineNum":"  257","line":"  KOKKOS_DEFAULTED_FUNCTION MemoryPool(const MemoryPool &) = default;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  258","line":"  KOKKOS_DEFAULTED_FUNCTION MemoryPool &operator=(MemoryPool &&) = default;"},
{"lineNum":"  259","line":"  KOKKOS_DEFAULTED_FUNCTION MemoryPool &operator=(const MemoryPool &) = default;"},
{"lineNum":"  260","line":""},
{"lineNum":"  261","line":"  KOKKOS_INLINE_FUNCTION MemoryPool()"},
{"lineNum":"  262","line":"      : m_tracker(),"},
{"lineNum":"  263","line":"        m_sb_state_array(nullptr),"},
{"lineNum":"  264","line":"        m_sb_state_size(0),"},
{"lineNum":"  265","line":"        m_sb_size_lg2(0),"},
{"lineNum":"  266","line":"        m_max_block_size_lg2(0),"},
{"lineNum":"  267","line":"        m_min_block_size_lg2(0),"},
{"lineNum":"  268","line":"        m_sb_count(0),"},
{"lineNum":"  269","line":"        m_hint_offset(0),"},
{"lineNum":"  270","line":"        m_data_offset(0),"},
{"lineNum":"  271","line":"        m_unused_padding(0) {}"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"  /**\\brief  Allocate a memory pool from \'memspace\'."},
{"lineNum":"  274","line":"   *"},
{"lineNum":"  275","line":"   *  The memory pool will have at least \'min_total_alloc_size\' bytes"},
{"lineNum":"  276","line":"   *  of memory to allocate divided among superblocks of at least"},
{"lineNum":"  277","line":"   *  \'min_superblock_size\' bytes.  A single allocation must fit"},
{"lineNum":"  278","line":"   *  within a single superblock, so \'min_superblock_size\' must be"},
{"lineNum":"  279","line":"   *  at least as large as the maximum single allocation."},
{"lineNum":"  280","line":"   *  Both \'min_total_alloc_size\' and \'min_superblock_size\'"},
{"lineNum":"  281","line":"   *  are rounded up to the smallest power-of-two value that"},
{"lineNum":"  282","line":"   *  contains the corresponding sizes."},
{"lineNum":"  283","line":"   *  Individual allocations will always consume a block of memory that"},
{"lineNum":"  284","line":"   *  is also a power-of-two.  These roundings are made to enable"},
{"lineNum":"  285","line":"   *  significant runtime performance improvements."},
{"lineNum":"  286","line":"   */"},
{"lineNum":"  287","line":"  MemoryPool(const base_memory_space &memspace,"},
{"lineNum":"  288","line":"             const size_t min_total_alloc_size, size_t min_block_alloc_size = 0,"},
{"lineNum":"  289","line":"             size_t max_block_alloc_size = 0, size_t min_superblock_size = 0)"},
{"lineNum":"  290","line":"      : m_tracker(),"},
{"lineNum":"  291","line":"        m_sb_state_array(nullptr),"},
{"lineNum":"  292","line":"        m_sb_state_size(0),"},
{"lineNum":"  293","line":"        m_sb_size_lg2(0),"},
{"lineNum":"  294","line":"        m_max_block_size_lg2(0),"},
{"lineNum":"  295","line":"        m_min_block_size_lg2(0),"},
{"lineNum":"  296","line":"        m_sb_count(0),"},
{"lineNum":"  297","line":"        m_hint_offset(0),"},
{"lineNum":"  298","line":"        m_data_offset(0),"},
{"lineNum":"  299","line":"        m_unused_padding(0) {"},
{"lineNum":"  300","line":"    const uint32_t int_align_lg2               = 3; /* align as int[8] */"},
{"lineNum":"  301","line":"    const uint32_t int_align_mask              = (1u << int_align_lg2) - 1;"},
{"lineNum":"  302","line":"    const uint32_t default_min_block_size      = 1u << 6;  /* 64 bytes */"},
{"lineNum":"  303","line":"    const uint32_t default_max_block_size      = 1u << 12; /* 4k bytes */"},
{"lineNum":"  304","line":"    const uint32_t default_min_superblock_size = 1u << 20; /* 1M bytes */"},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"    //--------------------------------------------------"},
{"lineNum":"  307","line":"    // Default block and superblock sizes:"},
{"lineNum":"  308","line":""},
{"lineNum":"  309","line":"    if (0 == min_block_alloc_size) {"},
{"lineNum":"  310","line":"      // Default all sizes:"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"      min_superblock_size ="},
{"lineNum":"  313","line":"          std::min(size_t(default_min_superblock_size), min_total_alloc_size);"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"      min_block_alloc_size ="},
{"lineNum":"  316","line":"          std::min(size_t(default_min_block_size), min_superblock_size);"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"      max_block_alloc_size ="},
{"lineNum":"  319","line":"          std::min(size_t(default_max_block_size), min_superblock_size);"},
{"lineNum":"  320","line":"    } else if (0 == min_superblock_size) {"},
{"lineNum":"  321","line":"      // Choose superblock size as minimum of:"},
{"lineNum":"  322","line":"      //   max_block_per_superblock * min_block_size"},
{"lineNum":"  323","line":"      //   max_superblock_size"},
{"lineNum":"  324","line":"      //   min_total_alloc_size"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"      const size_t max_superblock ="},
{"lineNum":"  327","line":"          min_block_alloc_size * max_block_per_superblock;"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"      min_superblock_size ="},
{"lineNum":"  330","line":"          std::min(max_superblock,"},
{"lineNum":"  331","line":"                   std::min(size_t(max_superblock_size), min_total_alloc_size));"},
{"lineNum":"  332","line":"    }"},
{"lineNum":"  333","line":""},
{"lineNum":"  334","line":"    if (0 == max_block_alloc_size) {"},
{"lineNum":"  335","line":"      max_block_alloc_size = min_superblock_size;"},
{"lineNum":"  336","line":"    }"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"    //--------------------------------------------------"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"    /* Enforce size constraints:"},
{"lineNum":"  341","line":"     *   min_block_alloc_size <= max_block_alloc_size"},
{"lineNum":"  342","line":"     *   max_block_alloc_size <= min_superblock_size"},
{"lineNum":"  343","line":"     *   min_superblock_size  <= max_superblock_size"},
{"lineNum":"  344","line":"     *   min_superblock_size  <= min_total_alloc_size"},
{"lineNum":"  345","line":"     *   min_superblock_size  <= min_block_alloc_size *"},
{"lineNum":"  346","line":"     *                           max_block_per_superblock"},
{"lineNum":"  347","line":"     */"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"    Kokkos::Impl::memory_pool_bounds_verification("},
{"lineNum":"  350","line":"        min_block_alloc_size, max_block_alloc_size, min_superblock_size,"},
{"lineNum":"  351","line":"        max_superblock_size, max_block_per_superblock, min_total_alloc_size);"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"    //--------------------------------------------------"},
{"lineNum":"  354","line":"    // Block and superblock size is power of two:"},
{"lineNum":"  355","line":"    // Maximum value is \'max_superblock_size\'"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"    m_min_block_size_lg2 ="},
{"lineNum":"  358","line":"        Kokkos::Impl::integral_power_of_two_that_contains(min_block_alloc_size);"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"    m_max_block_size_lg2 ="},
{"lineNum":"  361","line":"        Kokkos::Impl::integral_power_of_two_that_contains(max_block_alloc_size);"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"    m_sb_size_lg2 ="},
{"lineNum":"  364","line":"        Kokkos::Impl::integral_power_of_two_that_contains(min_superblock_size);"},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"    {"},
{"lineNum":"  367","line":"      // number of superblocks is multiple of superblock size that"},
{"lineNum":"  368","line":"      // can hold min_total_alloc_size."},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"      const uint64_t sb_size_mask = (1LU << m_sb_size_lg2) - 1;"},
{"lineNum":"  371","line":""},
{"lineNum":"  372","line":"      m_sb_count = (min_total_alloc_size + sb_size_mask) >> m_sb_size_lg2;"},
{"lineNum":"  373","line":"    }"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"    {"},
{"lineNum":"  376","line":"      // Any superblock can be assigned to the smallest size block"},
{"lineNum":"  377","line":"      // Size the block bitset to maximum number of blocks"},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"      const uint32_t max_block_count_lg2 = m_sb_size_lg2 - m_min_block_size_lg2;"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"      m_sb_state_size ="},
{"lineNum":"  382","line":"          (CB::buffer_bound_lg2(max_block_count_lg2) + int_align_mask) &"},
{"lineNum":"  383","line":"          ~int_align_mask;"},
{"lineNum":"  384","line":"    }"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"    // Array of all superblock states"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"    const size_t all_sb_state_size ="},
{"lineNum":"  389","line":"        (m_sb_count * m_sb_state_size + int_align_mask) & ~int_align_mask;"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"    // Number of block sizes"},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"    const int32_t number_block_sizes ="},
{"lineNum":"  394","line":"        1 + m_max_block_size_lg2 - m_min_block_size_lg2;"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"    // Array length for possible block sizes"},
{"lineNum":"  397","line":"    // Hint array is one uint32_t per block size"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"    const int32_t block_size_array_size ="},
{"lineNum":"  400","line":"        (number_block_sizes + int_align_mask) & ~int_align_mask;"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"    m_hint_offset = all_sb_state_size;"},
{"lineNum":"  403","line":"    m_data_offset = m_hint_offset + block_size_array_size * HINT_PER_BLOCK_SIZE;"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"    // Allocation:"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"    const size_t header_size = m_data_offset * sizeof(uint32_t);"},
{"lineNum":"  408","line":"    const size_t alloc_size ="},
{"lineNum":"  409","line":"        header_size + (size_t(m_sb_count) << m_sb_size_lg2);"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"    Record *rec = Record::allocate(memspace, \"Kokkos::MemoryPool\", alloc_size);"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"    m_tracker.assign_allocated_record_to_uninitialized(rec);"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"    m_sb_state_array = (uint32_t *)rec->data();"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"    Kokkos::HostSpace host;"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"    uint32_t *const sb_state_array ="},
{"lineNum":"  420","line":"        accessible ? m_sb_state_array : (uint32_t *)host.allocate(header_size);"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"    for (int32_t i = 0; i < m_data_offset; ++i) sb_state_array[i] = 0;"},
{"lineNum":"  423","line":""},
{"lineNum":"  424","line":"    // Initial assignment of empty superblocks to block sizes:"},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"    for (int32_t i = 0; i < number_block_sizes; ++i) {"},
{"lineNum":"  427","line":"      const uint32_t block_size_lg2  = i + m_min_block_size_lg2;"},
{"lineNum":"  428","line":"      const uint32_t block_count_lg2 = m_sb_size_lg2 - block_size_lg2;"},
{"lineNum":"  429","line":"      const uint32_t block_state     = block_count_lg2 << state_shift;"},
{"lineNum":"  430","line":"      const uint32_t hint_begin      = m_hint_offset + i * HINT_PER_BLOCK_SIZE;"},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"      // for block size index \'i\':"},
{"lineNum":"  433","line":"      //   sb_id_hint  = sb_state_array[ hint_begin ];"},
{"lineNum":"  434","line":"      //   sb_id_begin = sb_state_array[ hint_begin + 1 ];"},
{"lineNum":"  435","line":""},
{"lineNum":"  436","line":"      const int32_t jbeg = (i * m_sb_count) / number_block_sizes;"},
{"lineNum":"  437","line":"      const int32_t jend = ((i + 1) * m_sb_count) / number_block_sizes;"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"      sb_state_array[hint_begin]     = uint32_t(jbeg);"},
{"lineNum":"  440","line":"      sb_state_array[hint_begin + 1] = uint32_t(jbeg);"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"      for (int32_t j = jbeg; j < jend; ++j) {"},
{"lineNum":"  443","line":"        sb_state_array[j * m_sb_state_size] = block_state;"},
{"lineNum":"  444","line":"      }"},
{"lineNum":"  445","line":"    }"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"    // Write out initialized state:"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"    if (!accessible) {"},
{"lineNum":"  450","line":"      Kokkos::Impl::DeepCopy<base_memory_space, Kokkos::HostSpace>("},
{"lineNum":"  451","line":"          m_sb_state_array, sb_state_array, header_size);"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"      host.deallocate(sb_state_array, header_size);"},
{"lineNum":"  454","line":"    } else {"},
{"lineNum":"  455","line":"      Kokkos::memory_fence();"},
{"lineNum":"  456","line":"    }"},
{"lineNum":"  457","line":"  }"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"  //--------------------------------------------------------------------------"},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":" private:"},
{"lineNum":"  462","line":"  /* Given a size \'n\' get the block size in which it can be allocated."},
{"lineNum":"  463","line":"   * Restrict lower bound to minimum block size."},
{"lineNum":"  464","line":"   */"},
{"lineNum":"  465","line":"  KOKKOS_FORCEINLINE_FUNCTION"},
{"lineNum":"  466","line":"  uint32_t get_block_size_lg2(uint32_t n) const noexcept {"},
{"lineNum":"  467","line":"    const unsigned i = Kokkos::Impl::integral_power_of_two_that_contains(n);"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"    return i < m_min_block_size_lg2 ? m_min_block_size_lg2 : i;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  470","line":"  }"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":" public:"},
{"lineNum":"  473","line":"  /* Return 0 for invalid block size */"},
{"lineNum":"  474","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  475","line":"  uint32_t allocate_block_size(uint64_t alloc_size) const noexcept {"},
{"lineNum":"  476","line":"    return alloc_size <= (1UL << m_max_block_size_lg2)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  477","line":"               ? (1UL << get_block_size_lg2(uint32_t(alloc_size)))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  478","line":"               : 0;"},
{"lineNum":"  479","line":"  }"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"  //--------------------------------------------------------------------------"},
{"lineNum":"  482","line":"  /**\\brief  Allocate a block of memory that is at least \'alloc_size\'"},
{"lineNum":"  483","line":"   *"},
{"lineNum":"  484","line":"   *  The block of memory is aligned to the minimum block size,"},
{"lineNum":"  485","line":"   *  currently is 64 bytes, will never be less than 32 bytes."},
{"lineNum":"  486","line":"   *"},
{"lineNum":"  487","line":"   *  If concurrent allocations and deallocations are taking place"},
{"lineNum":"  488","line":"   *  then a single allocation attempt may fail due to lack of available space."},
{"lineNum":"  489","line":"   *  The allocation attempt will try up to \'attempt_limit\' times."},
{"lineNum":"  490","line":"   */"},
{"lineNum":"  491","line":"  KOKKOS_FUNCTION"},
{"lineNum":"  492","line":"  void *allocate(size_t alloc_size, int32_t attempt_limit = 1) const noexcept {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  493","line":"    if (size_t(1LU << m_max_block_size_lg2) < alloc_size) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  494","line":"      Kokkos::abort(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  495","line":"          \"Kokkos MemoryPool allocation request exceeded specified maximum \""},
{"lineNum":"  496","line":"          \"allocation size\");"},
{"lineNum":"  497","line":"    }"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"    if (0 == alloc_size) return nullptr;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  500","line":""},
{"lineNum":"  501","line":"    void *p = nullptr;"},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"    const uint32_t block_size_lg2 = get_block_size_lg2(alloc_size);"},
{"lineNum":"  504","line":""},
{"lineNum":"  505","line":"    // Allocation will fit within a superblock"},
{"lineNum":"  506","line":"    // that has block sizes ( 1 << block_size_lg2 )"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"    const uint32_t block_count_lg2 = m_sb_size_lg2 - block_size_lg2;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  509","line":"    const uint32_t block_state     = block_count_lg2 << state_shift;"},
{"lineNum":"  510","line":"    const uint32_t block_count     = 1u << block_count_lg2;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"    // Superblock hints for this block size:"},
{"lineNum":"  513","line":"    //   hint_sb_id_ptr[0] is the dynamically changing hint"},
{"lineNum":"  514","line":"    //   hint_sb_id_ptr[1] is the static start point"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"    volatile uint32_t *const hint_sb_id_ptr ="},
{"lineNum":"  517","line":"        m_sb_state_array      /* memory pool state array */","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  518","line":"        + m_hint_offset       /* offset to hint portion of array */","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  519","line":"        + HINT_PER_BLOCK_SIZE /* number of hints per block size */","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  520","line":"              * (block_size_lg2 - m_min_block_size_lg2); /* block size id */","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"    const int32_t sb_id_begin = int32_t(hint_sb_id_ptr[1]);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  523","line":""},
{"lineNum":"  524","line":"    // Fast query clock register \'tic\' to pseudo-randomize"},
{"lineNum":"  525","line":"    // the guess for which block within a superblock should"},
{"lineNum":"  526","line":"    // be claimed.  If not available then a search occurs."},
{"lineNum":"  527","line":"#if defined(KOKKOS_ENABLE_SYCL) && !defined(KOKKOS_ARCH_INTEL_GEN)"},
{"lineNum":"  528","line":"    const uint32_t block_id_hint = alloc_size;"},
{"lineNum":"  529","line":"#else"},
{"lineNum":"  530","line":"    const uint32_t block_id_hint ="},
{"lineNum":"  531","line":"        (uint32_t)(Kokkos::Impl::clock_tic()"},
{"lineNum":"  532","line":"#if defined(KOKKOS_ACTIVE_EXECUTION_MEMORY_SPACE_CUDA)"},
{"lineNum":"  533","line":"                   // Spread out potentially concurrent access"},
{"lineNum":"  534","line":"                   // by threads within a warp or thread block."},
{"lineNum":"  535","line":"                   + (threadIdx.x + blockDim.x * threadIdx.y)"},
{"lineNum":"  536","line":"#endif"},
{"lineNum":"  537","line":"        );"},
{"lineNum":"  538","line":"#endif"},
{"lineNum":"  539","line":""},
{"lineNum":"  540","line":"    // expected state of superblock for allocation"},
{"lineNum":"  541","line":"    uint32_t sb_state = block_state;"},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"    int32_t sb_id = -1;"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"    volatile uint32_t *sb_state_array = nullptr;"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"    while (attempt_limit) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  548","line":"      int32_t hint_sb_id = -1;"},
{"lineNum":"  549","line":""},
{"lineNum":"  550","line":"      if (sb_id < 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  551","line":"        // No superblock specified, try the hint for this block size"},
{"lineNum":"  552","line":""},
{"lineNum":"  553","line":"        sb_id = hint_sb_id = int32_t(*hint_sb_id_ptr);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"        sb_state_array = m_sb_state_array + (sb_id * m_sb_state_size);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  556","line":"      }"},
{"lineNum":"  557","line":""},
{"lineNum":"  558","line":"      // Require:"},
{"lineNum":"  559","line":"      //   0 <= sb_id"},
{"lineNum":"  560","line":"      //   sb_state_array == m_sb_state_array + m_sb_state_size * sb_id"},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"      if (sb_state == (state_header_mask & *sb_state_array)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  563","line":"        // This superblock state is as expected, for the moment."},
{"lineNum":"  564","line":"        // Attempt to claim a bit.  The attempt updates the state"},
{"lineNum":"  565","line":"        // so have already made sure the state header is as expected."},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"        const uint32_t count_lg2 = sb_state >> state_shift;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  568","line":"        const uint32_t mask      = (1u << count_lg2) - 1;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"        const Kokkos::pair<int, int> result = CB::acquire_bounded_lg2("},
{"lineNum":"  571","line":"            sb_state_array, count_lg2, block_id_hint & mask, sb_state);"},
{"lineNum":"  572","line":""},
{"lineNum":"  573","line":"        // If result.first < 0 then failed to acquire"},
{"lineNum":"  574","line":"        // due to either full or buffer was wrong state."},
{"lineNum":"  575","line":"        // Could be wrong state if a deallocation raced the"},
{"lineNum":"  576","line":"        // superblock to empty before the acquire could succeed."},
{"lineNum":"  577","line":""},
{"lineNum":"  578","line":"        if (0 <= result.first) {  // acquired a bit","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  579","line":""},
{"lineNum":"  580","line":"          const uint32_t size_lg2 = m_sb_size_lg2 - count_lg2;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  581","line":""},
{"lineNum":"  582","line":"          // Set the allocated block pointer"},
{"lineNum":"  583","line":""},
{"lineNum":"  584","line":"          p = ((char *)(m_sb_state_array + m_data_offset)) +","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  585","line":"              (uint64_t(sb_id) << m_sb_size_lg2)       // superblock memory","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  586","line":"              + (uint64_t(result.first) << size_lg2);  // block memory","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  587","line":""},
{"lineNum":"  588","line":"#if 0"},
{"lineNum":"  589","line":"  printf( \"  MemoryPool(0x%lx) pointer(0x%lx) allocate(%lu) sb_id(%d) sb_state(0x%x) block_size(%d) block_capacity(%d) block_id(%d) block_claimed(%d)\\n\""},
{"lineNum":"  590","line":"        , (uintptr_t)m_sb_state_array"},
{"lineNum":"  591","line":"        , (uintptr_t)p"},
{"lineNum":"  592","line":"        , alloc_size"},
{"lineNum":"  593","line":"        , sb_id"},
{"lineNum":"  594","line":"        , sb_state"},
{"lineNum":"  595","line":"        , (1u << size_lg2)"},
{"lineNum":"  596","line":"        , (1u << count_lg2)"},
{"lineNum":"  597","line":"        , result.first"},
{"lineNum":"  598","line":"        , result.second );"},
{"lineNum":"  599","line":"#endif"},
{"lineNum":"  600","line":""},
{"lineNum":"  601","line":"          break;  // Success"},
{"lineNum":"  602","line":"        }"},
{"lineNum":"  603","line":"      }"},
{"lineNum":"  604","line":"      //------------------------------------------------------------------"},
{"lineNum":"  605","line":"      //  Arrive here if failed to acquire a block."},
{"lineNum":"  606","line":"      //  Must find a new superblock."},
{"lineNum":"  607","line":""},
{"lineNum":"  608","line":"      //  Start searching at designated index for this block size."},
{"lineNum":"  609","line":"      //  Look for superblock that, in preferential order,"},
{"lineNum":"  610","line":"      //  1) part-full superblock of this block size"},
{"lineNum":"  611","line":"      //  2) empty superblock to claim for this block size"},
{"lineNum":"  612","line":"      //  3) part-full superblock of the next larger block size"},
{"lineNum":"  613","line":""},
{"lineNum":"  614","line":"      sb_state = block_state;  // Expect to find the desired state"},
{"lineNum":"  615","line":"      sb_id    = -1;"},
{"lineNum":"  616","line":""},
{"lineNum":"  617","line":"      bool update_hint        = false;"},
{"lineNum":"  618","line":"      int32_t sb_id_empty     = -1;"},
{"lineNum":"  619","line":"      int32_t sb_id_large     = -1;"},
{"lineNum":"  620","line":"      uint32_t sb_state_large = 0;"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"      sb_state_array = m_sb_state_array + sb_id_begin * m_sb_state_size;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"      for (int32_t i = 0, id = sb_id_begin; i < m_sb_count; ++i) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  625","line":"        //  Query state of the candidate superblock."},
{"lineNum":"  626","line":"        //  Note that the state may change at any moment"},
{"lineNum":"  627","line":"        //  as concurrent allocations and deallocations occur."},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"        const uint32_t full_state = *sb_state_array;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  630","line":"        const uint32_t used       = full_state & state_used_mask;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  631","line":"        const uint32_t state      = full_state & state_header_mask;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"        if (state == block_state) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  634","line":"          //  Superblock is assigned to this block size"},
{"lineNum":"  635","line":""},
{"lineNum":"  636","line":"          if (used < block_count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  637","line":"            // There is room to allocate one block"},
{"lineNum":"  638","line":""},
{"lineNum":"  639","line":"            sb_id = id;"},
{"lineNum":"  640","line":""},
{"lineNum":"  641","line":"            // Is there room to allocate more than one block?"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"            update_hint = used + 1 < block_count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  644","line":""},
{"lineNum":"  645","line":"            break;"},
{"lineNum":"  646","line":"          }"},
{"lineNum":"  647","line":"        } else if (0 == used) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  648","line":"          // Superblock is empty"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"          if (-1 == sb_id_empty) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  651","line":"            // Superblock is not assigned to this block size"},
{"lineNum":"  652","line":"            // and is the first empty superblock encountered."},
{"lineNum":"  653","line":"            // Save this id to use if a partfull superblock is not found."},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"            sb_id_empty = id;"},
{"lineNum":"  656","line":"          }"},
{"lineNum":"  657","line":"        } else if ((-1 == sb_id_empty /* have not found an empty */) &&","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  658","line":"                   (-1 == sb_id_large /* have not found a larger */) &&"},
{"lineNum":"  659","line":"                   (state < block_state /* a larger block */) &&","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  660","line":"                   // is not full:"},
{"lineNum":"  661","line":"                   (used < (1u << (state >> state_shift)))) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  662","line":"          //  First superblock encountered that is"},
{"lineNum":"  663","line":"          //  larger than this block size and"},
{"lineNum":"  664","line":"          //  has room for an allocation."},
{"lineNum":"  665","line":"          //  Save this id to use of partfull or empty superblock not found"},
{"lineNum":"  666","line":"          sb_id_large    = id;"},
{"lineNum":"  667","line":"          sb_state_large = state;"},
{"lineNum":"  668","line":"        }"},
{"lineNum":"  669","line":""},
{"lineNum":"  670","line":"        // Iterate around the superblock array:"},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":"        if (++id < m_sb_count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  673","line":"          sb_state_array += m_sb_state_size;"},
{"lineNum":"  674","line":"        } else {"},
{"lineNum":"  675","line":"          id             = 0;"},
{"lineNum":"  676","line":"          sb_state_array = m_sb_state_array;"},
{"lineNum":"  677","line":"        }"},
{"lineNum":"  678","line":"      }"},
{"lineNum":"  679","line":""},
{"lineNum":"  680","line":"      // printf(\"  search m_sb_count(%d) sb_id(%d) sb_id_empty(%d)"},
{"lineNum":"  681","line":"      // sb_id_large(%d)\\n\" , m_sb_count , sb_id , sb_id_empty , sb_id_large);"},
{"lineNum":"  682","line":""},
{"lineNum":"  683","line":"      if (sb_id < 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  684","line":"        //  Did not find a partfull superblock for this block size."},
{"lineNum":"  685","line":""},
{"lineNum":"  686","line":"        if (0 <= sb_id_empty) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  687","line":"          //  Found first empty superblock following designated superblock"},
{"lineNum":"  688","line":"          //  Attempt to claim it for this block size."},
{"lineNum":"  689","line":"          //  If the claim fails assume that another thread claimed it"},
{"lineNum":"  690","line":"          //  for this block size and try to use it anyway,"},
{"lineNum":"  691","line":"          //  but do not update hint."},
{"lineNum":"  692","line":""},
{"lineNum":"  693","line":"          sb_id = sb_id_empty;"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"          sb_state_array = m_sb_state_array + (sb_id * m_sb_state_size);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  696","line":""},
{"lineNum":"  697","line":"          //  If successfully changed assignment of empty superblock \'sb_id\'"},
{"lineNum":"  698","line":"          //  to this block_size then update the hint."},
{"lineNum":"  699","line":""},
{"lineNum":"  700","line":"          const uint32_t state_empty = state_header_mask & *sb_state_array;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"          // If this thread claims the empty block then update the hint"},
{"lineNum":"  703","line":"          update_hint ="},
{"lineNum":"  704","line":"              state_empty == Kokkos::atomic_compare_exchange(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  705","line":"                                 sb_state_array, state_empty, block_state);"},
{"lineNum":"  706","line":"        } else if (0 <= sb_id_large) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  707","line":"          // Found a larger superblock with space available"},
{"lineNum":"  708","line":""},
{"lineNum":"  709","line":"          sb_id    = sb_id_large;"},
{"lineNum":"  710","line":"          sb_state = sb_state_large;"},
{"lineNum":"  711","line":""},
{"lineNum":"  712","line":"          sb_state_array = m_sb_state_array + (sb_id * m_sb_state_size);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  713","line":"        } else {"},
{"lineNum":"  714","line":"          // Did not find a potentially usable superblock"},
{"lineNum":"  715","line":"          --attempt_limit;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  716","line":"        }"},
{"lineNum":"  717","line":"      }"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"      if (update_hint) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  720","line":"        Kokkos::atomic_compare_exchange(hint_sb_id_ptr, uint32_t(hint_sb_id),"},
{"lineNum":"  721","line":"                                        uint32_t(sb_id));"},
{"lineNum":"  722","line":"      }"},
{"lineNum":"  723","line":"    }  // end allocation attempt loop"},
{"lineNum":"  724","line":"    //--------------------------------------------------------------------"},
{"lineNum":"  725","line":""},
{"lineNum":"  726","line":"    return p;"},
{"lineNum":"  727","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  728","line":"  // end allocate"},
{"lineNum":"  729","line":"  //--------------------------------------------------------------------------"},
{"lineNum":"  730","line":""},
{"lineNum":"  731","line":"  /**\\brief  Return an allocated block of memory to the pool."},
{"lineNum":"  732","line":"   *"},
{"lineNum":"  733","line":"   *  Requires: p is return value from allocate( alloc_size );"},
{"lineNum":"  734","line":"   *"},
{"lineNum":"  735","line":"   *  For now the alloc_size is ignored."},
{"lineNum":"  736","line":"   */"},
{"lineNum":"  737","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  738","line":"  void deallocate(void *p, size_t /* alloc_size */) const noexcept {"},
{"lineNum":"  739","line":"    if (nullptr == p) return;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  740","line":""},
{"lineNum":"  741","line":"    // Determine which superblock and block"},
{"lineNum":"  742","line":"    const ptrdiff_t d ="},
{"lineNum":"  743","line":"        ((char *)p) - ((char *)(m_sb_state_array + m_data_offset));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  744","line":""},
{"lineNum":"  745","line":"    // Verify contained within the memory pool\'s superblocks:"},
{"lineNum":"  746","line":"    const int ok_contains ="},
{"lineNum":"  747","line":"        (0 <= d) && (size_t(d) < (size_t(m_sb_count) << m_sb_size_lg2));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  748","line":""},
{"lineNum":"  749","line":"    int ok_block_aligned = 0;"},
{"lineNum":"  750","line":"    int ok_dealloc_once  = 0;"},
{"lineNum":"  751","line":""},
{"lineNum":"  752","line":"    if (ok_contains) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  753","line":"      const int sb_id = d >> m_sb_size_lg2;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  754","line":""},
{"lineNum":"  755","line":"      // State array for the superblock."},
{"lineNum":"  756","line":"      volatile uint32_t *const sb_state_array ="},
{"lineNum":"  757","line":"          m_sb_state_array + (sb_id * m_sb_state_size);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":"      const uint32_t block_state = (*sb_state_array) & state_header_mask;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  760","line":"      const uint32_t block_size_lg2 ="},
{"lineNum":"  761","line":"          m_sb_size_lg2 - (block_state >> state_shift);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  762","line":""},
{"lineNum":"  763","line":"      ok_block_aligned = 0 == (d & ((1UL << block_size_lg2) - 1));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  764","line":""},
{"lineNum":"  765","line":"      if (ok_block_aligned) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  766","line":"        // Map address to block\'s bit"},
{"lineNum":"  767","line":"        // mask into superblock and then shift down for block index"},
{"lineNum":"  768","line":""},
{"lineNum":"  769","line":"        const uint32_t bit ="},
{"lineNum":"  770","line":"            (d & (ptrdiff_t(1LU << m_sb_size_lg2) - 1)) >> block_size_lg2;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  771","line":""},
{"lineNum":"  772","line":"        const int result = CB::release(sb_state_array, bit, block_state);"},
{"lineNum":"  773","line":""},
{"lineNum":"  774","line":"        ok_dealloc_once = 0 <= result;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  775","line":""},
{"lineNum":"  776","line":"#if 0"},
{"lineNum":"  777","line":"  printf( \"  MemoryPool(0x%lx) pointer(0x%lx) deallocate sb_id(%d) block_size(%d) block_capacity(%d) block_id(%d) block_claimed(%d)\\n\""},
{"lineNum":"  778","line":"        , (uintptr_t)m_sb_state_array"},
{"lineNum":"  779","line":"        , (uintptr_t)p"},
{"lineNum":"  780","line":"        , sb_id"},
{"lineNum":"  781","line":"        , (1u << block_size_lg2)"},
{"lineNum":"  782","line":"        , (1u << (m_sb_size_lg2 - block_size_lg2))"},
{"lineNum":"  783","line":"        , bit"},
{"lineNum":"  784","line":"        , result );"},
{"lineNum":"  785","line":"#endif"},
{"lineNum":"  786","line":"      }"},
{"lineNum":"  787","line":"    }"},
{"lineNum":"  788","line":""},
{"lineNum":"  789","line":"    if (!ok_contains || !ok_block_aligned || !ok_dealloc_once) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  790","line":"#if 0"},
{"lineNum":"  791","line":"  printf( \"  MemoryPool(0x%lx) pointer(0x%lx) deallocate ok_contains(%d) ok_block_aligned(%d) ok_dealloc_once(%d)\\n\""},
{"lineNum":"  792","line":"        , (uintptr_t)m_sb_state_array"},
{"lineNum":"  793","line":"        , (uintptr_t)p"},
{"lineNum":"  794","line":"        , int(ok_contains)"},
{"lineNum":"  795","line":"        , int(ok_block_aligned)"},
{"lineNum":"  796","line":"        , int(ok_dealloc_once) );"},
{"lineNum":"  797","line":"#endif"},
{"lineNum":"  798","line":"      Kokkos::abort(\"Kokkos MemoryPool::deallocate given erroneous pointer\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  799","line":"    }"},
{"lineNum":"  800","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  801","line":"  // end deallocate"},
{"lineNum":"  802","line":"  //--------------------------------------------------------------------------"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  805","line":"  int number_of_superblocks() const noexcept { return m_sb_count; }"},
{"lineNum":"  806","line":""},
{"lineNum":"  807","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  808","line":"  void superblock_state(int sb_id, int &block_size, int &block_count_capacity,"},
{"lineNum":"  809","line":"                        int &block_count_used) const noexcept {"},
{"lineNum":"  810","line":"    block_size           = 0;"},
{"lineNum":"  811","line":"    block_count_capacity = 0;"},
{"lineNum":"  812","line":"    block_count_used     = 0;"},
{"lineNum":"  813","line":""},
{"lineNum":"  814","line":"    if (Kokkos::Impl::MemorySpaceAccess<"},
{"lineNum":"  815","line":"            Kokkos::Impl::ActiveExecutionMemorySpace,"},
{"lineNum":"  816","line":"            base_memory_space>::accessible) {"},
{"lineNum":"  817","line":"      // Can access the state array"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"      const uint32_t state ="},
{"lineNum":"  820","line":"          ((uint32_t volatile *)m_sb_state_array)[sb_id * m_sb_state_size];"},
{"lineNum":"  821","line":""},
{"lineNum":"  822","line":"      const uint32_t block_count_lg2 = state >> state_shift;"},
{"lineNum":"  823","line":"      const uint32_t block_used      = state & state_used_mask;"},
{"lineNum":"  824","line":""},
{"lineNum":"  825","line":"      block_size           = 1LU << (m_sb_size_lg2 - block_count_lg2);"},
{"lineNum":"  826","line":"      block_count_capacity = 1LU << block_count_lg2;"},
{"lineNum":"  827","line":"      block_count_used     = block_used;"},
{"lineNum":"  828","line":"    }"},
{"lineNum":"  829","line":"  }"},
{"lineNum":"  830","line":"};"},
{"lineNum":"  831","line":""},
{"lineNum":"  832","line":"}  // namespace Kokkos"},
{"lineNum":"  833","line":""},
{"lineNum":"  834","line":"#endif /* #ifndef KOKKOS_MEMORYPOOL_HPP */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 67, "covered" : 0,};
var merged_data = [];
