var data = {lines:[
{"lineNum":"    1","line":"/*! \\file json.hpp"},
{"lineNum":"    2","line":"    \\brief JSON input and output archives */"},
{"lineNum":"    3","line":"/*"},
{"lineNum":"    4","line":"  Copyright (c) 2014, Randolph Voorhies, Shane Grant"},
{"lineNum":"    5","line":"  All rights reserved."},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"  Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    8","line":"  modification, are permitted provided that the following conditions are met:"},
{"lineNum":"    9","line":"      * Redistributions of source code must retain the above copyright"},
{"lineNum":"   10","line":"        notice, this list of conditions and the following disclaimer."},
{"lineNum":"   11","line":"      * Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   12","line":"        notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   13","line":"        documentation and/or other materials provided with the distribution."},
{"lineNum":"   14","line":"      * Neither the name of cereal nor the"},
{"lineNum":"   15","line":"        names of its contributors may be used to endorse or promote products"},
{"lineNum":"   16","line":"        derived from this software without specific prior written permission."},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"},
{"lineNum":"   19","line":"  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"},
{"lineNum":"   20","line":"  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"},
{"lineNum":"   21","line":"  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES OR SHANE GRANT BE LIABLE FOR ANY"},
{"lineNum":"   22","line":"  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"},
{"lineNum":"   23","line":"  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"},
{"lineNum":"   24","line":"  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"},
{"lineNum":"   25","line":"  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   26","line":"  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   27","line":"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   28","line":"*/"},
{"lineNum":"   29","line":"#ifndef CEREAL_ARCHIVES_JSON_HPP_"},
{"lineNum":"   30","line":"#define CEREAL_ARCHIVES_JSON_HPP_"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"#include \"cereal/cereal.hpp\""},
{"lineNum":"   33","line":"#include \"cereal/details/util.hpp\""},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"namespace cereal"},
{"lineNum":"   36","line":"{"},
{"lineNum":"   37","line":"  //! An exception thrown when rapidjson fails an internal assertion"},
{"lineNum":"   38","line":"  /*! @ingroup Utility */"},
{"lineNum":"   39","line":"  struct RapidJSONException : Exception","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"   40","line":"  { RapidJSONException( const char * what_ ) : Exception( what_ ) {} };","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"   41","line":"}"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"// Inform rapidjson that assert will throw"},
{"lineNum":"   44","line":"#ifndef CEREAL_RAPIDJSON_ASSERT_THROWS"},
{"lineNum":"   45","line":"#define CEREAL_RAPIDJSON_ASSERT_THROWS"},
{"lineNum":"   46","line":"#endif // CEREAL_RAPIDJSON_ASSERT_THROWS"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"// Override rapidjson assertions to throw exceptions by default"},
{"lineNum":"   49","line":"#ifndef CEREAL_RAPIDJSON_ASSERT"},
{"lineNum":"   50","line":"#define CEREAL_RAPIDJSON_ASSERT(x) if(!(x)){ \\"},
{"lineNum":"   51","line":"  throw ::cereal::RapidJSONException(\"rapidjson internal assertion failure: \" #x); }"},
{"lineNum":"   52","line":"#endif // RAPIDJSON_ASSERT"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"// Enable support for parsing of nan, inf, -inf"},
{"lineNum":"   55","line":"#ifndef CEREAL_RAPIDJSON_WRITE_DEFAULT_FLAGS"},
{"lineNum":"   56","line":"#define CEREAL_RAPIDJSON_WRITE_DEFAULT_FLAGS kWriteNanAndInfFlag"},
{"lineNum":"   57","line":"#endif"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"// Enable support for parsing of nan, inf, -inf"},
{"lineNum":"   60","line":"#ifndef CEREAL_RAPIDJSON_PARSE_DEFAULT_FLAGS"},
{"lineNum":"   61","line":"#define CEREAL_RAPIDJSON_PARSE_DEFAULT_FLAGS kParseFullPrecisionFlag | kParseNanAndInfFlag"},
{"lineNum":"   62","line":"#endif"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"#include \"cereal/external/rapidjson/prettywriter.h\""},
{"lineNum":"   65","line":"#include \"cereal/external/rapidjson/ostreamwrapper.h\""},
{"lineNum":"   66","line":"#include \"cereal/external/rapidjson/istreamwrapper.h\""},
{"lineNum":"   67","line":"#include \"cereal/external/rapidjson/document.h\""},
{"lineNum":"   68","line":"#include \"cereal/external/base64.hpp\""},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"#include <limits>"},
{"lineNum":"   71","line":"#include <sstream>"},
{"lineNum":"   72","line":"#include <stack>"},
{"lineNum":"   73","line":"#include <vector>"},
{"lineNum":"   74","line":"#include <string>"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"namespace cereal"},
{"lineNum":"   77","line":"{"},
{"lineNum":"   78","line":"  // ######################################################################"},
{"lineNum":"   79","line":"  //! An output archive designed to save data to JSON"},
{"lineNum":"   80","line":"  /*! This archive uses RapidJSON to build serialize data to JSON."},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"      JSON archives provides a human readable output but at decreased"},
{"lineNum":"   83","line":"      performance (both in time and space) compared to binary archives."},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"      JSON archives are only guaranteed to finish flushing their contents"},
{"lineNum":"   86","line":"      upon destruction and should thus be used in an RAII fashion."},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"      JSON benefits greatly from name-value pairs, which if present, will"},
{"lineNum":"   89","line":"      name the nodes in the output.  If these are not present, each level"},
{"lineNum":"   90","line":"      of the output will be given an automatically generated delimited name."},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"      The precision of the output archive controls the number of decimals output"},
{"lineNum":"   93","line":"      for floating point numbers and should be sufficiently large (i.e. at least 20)"},
{"lineNum":"   94","line":"      if there is a desire to have binary equality between the numbers output and"},
{"lineNum":"   95","line":"      those read in.  In general you should expect a loss of precision when going"},
{"lineNum":"   96","line":"      from floating point to text and back."},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"      JSON archives do not output the size information for any dynamically sized structure"},
{"lineNum":"   99","line":"      and instead infer it from the number of children for a node.  This means that data"},
{"lineNum":"  100","line":"      can be hand edited for dynamic sized structures and will still be readable.  This"},
{"lineNum":"  101","line":"      is accomplished through the cereal::SizeTag object, which will cause the archive"},
{"lineNum":"  102","line":"      to output the data as a JSON array (e.g. marked by [] instead of {}), which indicates"},
{"lineNum":"  103","line":"      that the container is variable sized and may be edited."},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"      \\ingroup Archives */"},
{"lineNum":"  106","line":"  class JSONOutputArchive : public OutputArchive<JSONOutputArchive>, public traits::TextArchive"},
{"lineNum":"  107","line":"  {"},
{"lineNum":"  108","line":"    enum class NodeType { StartObject, InObject, StartArray, InArray };"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"    using WriteStream = CEREAL_RAPIDJSON_NAMESPACE::OStreamWrapper;"},
{"lineNum":"  111","line":"    using JSONWriter = CEREAL_RAPIDJSON_NAMESPACE::PrettyWriter<WriteStream>;"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"    public:"},
{"lineNum":"  114","line":"      /*! @name Common Functionality"},
{"lineNum":"  115","line":"          Common use cases for directly interacting with an JSONOutputArchive */"},
{"lineNum":"  116","line":"      //! @{"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"      //! A class containing various advanced options for the JSON archive"},
{"lineNum":"  119","line":"      class Options"},
{"lineNum":"  120","line":"      {"},
{"lineNum":"  121","line":"        public:"},
{"lineNum":"  122","line":"          //! Default options"},
{"lineNum":"  123","line":"          static Options Default(){ return Options(); }"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"          //! Default options with no indentation"},
{"lineNum":"  126","line":"          static Options NoIndent(){ return Options( JSONWriter::kDefaultMaxDecimalPlaces, IndentChar::space, 0 ); }"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"          //! The character to use for indenting"},
{"lineNum":"  129","line":"          enum class IndentChar : char"},
{"lineNum":"  130","line":"          {"},
{"lineNum":"  131","line":"            space = \' \',"},
{"lineNum":"  132","line":"            tab = \'\\t\',"},
{"lineNum":"  133","line":"            newline = \'\\n\',"},
{"lineNum":"  134","line":"            carriage_return = \'\\r\'"},
{"lineNum":"  135","line":"          };"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"          //! Specify specific options for the JSONOutputArchive"},
{"lineNum":"  138","line":"          /*! @param precision The precision used for floating point numbers"},
{"lineNum":"  139","line":"              @param indentChar The type of character to indent with"},
{"lineNum":"  140","line":"              @param indentLength The number of indentChar to use for indentation"},
{"lineNum":"  141","line":"                             (0 corresponds to no indentation) */"},
{"lineNum":"  142","line":"          explicit Options( int precision = JSONWriter::kDefaultMaxDecimalPlaces,"},
{"lineNum":"  143","line":"                            IndentChar indentChar = IndentChar::space,"},
{"lineNum":"  144","line":"                            unsigned int indentLength = 4 ) :"},
{"lineNum":"  145","line":"            itsPrecision( precision ),"},
{"lineNum":"  146","line":"            itsIndentChar( static_cast<char>(indentChar) ),"},
{"lineNum":"  147","line":"            itsIndentLength( indentLength ) { }"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"        private:"},
{"lineNum":"  150","line":"          friend class JSONOutputArchive;"},
{"lineNum":"  151","line":"          int itsPrecision;"},
{"lineNum":"  152","line":"          char itsIndentChar;"},
{"lineNum":"  153","line":"          unsigned int itsIndentLength;"},
{"lineNum":"  154","line":"      };"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"      //! Construct, outputting to the provided stream"},
{"lineNum":"  157","line":"      /*! @param stream The stream to output to."},
{"lineNum":"  158","line":"          @param options The JSON specific options to use.  See the Options struct"},
{"lineNum":"  159","line":"                         for the values of default parameters */"},
{"lineNum":"  160","line":"      JSONOutputArchive(std::ostream & stream, Options const & options = Options::Default() ) :","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  161","line":"        OutputArchive<JSONOutputArchive>(this),"},
{"lineNum":"  162","line":"        itsWriteStream(stream),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  163","line":"        itsWriter(itsWriteStream),"},
{"lineNum":"  164","line":"        itsNextName(nullptr)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  165","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  166","line":"        itsWriter.SetMaxDecimalPlaces( options.itsPrecision );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  167","line":"        itsWriter.SetIndent( options.itsIndentChar, options.itsIndentLength );","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  168","line":"        itsNameCounter.push(0);"},
{"lineNum":"  169","line":"        itsNodeStack.push(NodeType::StartObject);"},
{"lineNum":"  170","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"      //! Destructor, flushes the JSON"},
{"lineNum":"  173","line":"      ~JSONOutputArchive() CEREAL_NOEXCEPT"},
{"lineNum":"  174","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  175","line":"        if (itsNodeStack.top() == NodeType::InObject)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  176","line":"          itsWriter.EndObject();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  177","line":"        else if (itsNodeStack.top() == NodeType::InArray)"},
{"lineNum":"  178","line":"          itsWriter.EndArray();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  179","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"      //! Saves some binary data, encoded as a base64 string, with an optional name"},
{"lineNum":"  182","line":"      /*! This will create a new node, optionally named, and insert a value that consists of"},
{"lineNum":"  183","line":"          the data encoded as a base64 string */"},
{"lineNum":"  184","line":"      void saveBinaryValue( const void * data, size_t size, const char * name = nullptr )"},
{"lineNum":"  185","line":"      {"},
{"lineNum":"  186","line":"        setNextName( name );"},
{"lineNum":"  187","line":"        writeName();"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"        auto base64string = base64::encode( reinterpret_cast<const unsigned char *>( data ), size );"},
{"lineNum":"  190","line":"        saveValue( base64string );"},
{"lineNum":"  191","line":"      };"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"      //! @}"},
{"lineNum":"  194","line":"      /*! @name Internal Functionality"},
{"lineNum":"  195","line":"          Functionality designed for use by those requiring control over the inner mechanisms of"},
{"lineNum":"  196","line":"          the JSONOutputArchive */"},
{"lineNum":"  197","line":"      //! @{"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"      //! Starts a new node in the JSON output"},
{"lineNum":"  200","line":"      /*! The node can optionally be given a name by calling setNextName prior"},
{"lineNum":"  201","line":"          to creating the node"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"          Nodes only need to be started for types that are themselves objects or arrays */"},
{"lineNum":"  204","line":"      void startNode()"},
{"lineNum":"  205","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  206","line":"        writeName();","class":"lineNoCov","hits":"0","possible_hits":"43",},
{"lineNum":"  207","line":"        itsNodeStack.push(NodeType::StartObject);","class":"lineNoCov","hits":"0","possible_hits":"40",},
{"lineNum":"  208","line":"        itsNameCounter.push(0);","class":"lineNoCov","hits":"0","possible_hits":"40",},
{"lineNum":"  209","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"      //! Designates the most recently added node as finished"},
{"lineNum":"  212","line":"      void finishNode()"},
{"lineNum":"  213","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  214","line":"        // if we ended up serializing an empty object or array, writeName"},
{"lineNum":"  215","line":"        // will never have been called - so start and then immediately end"},
{"lineNum":"  216","line":"        // the object/array."},
{"lineNum":"  217","line":"        //"},
{"lineNum":"  218","line":"        // We\'ll also end any object/arrays we happen to be in"},
{"lineNum":"  219","line":"        switch(itsNodeStack.top())","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  220","line":"        {"},
{"lineNum":"  221","line":"          case NodeType::StartArray:"},
{"lineNum":"  222","line":"            itsWriter.StartArray();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  223","line":"            // fall through"},
{"lineNum":"  224","line":"          case NodeType::InArray:"},
{"lineNum":"  225","line":"            itsWriter.EndArray();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  226","line":"            break;"},
{"lineNum":"  227","line":"          case NodeType::StartObject:"},
{"lineNum":"  228","line":"            itsWriter.StartObject();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  229","line":"            // fall through"},
{"lineNum":"  230","line":"          case NodeType::InObject:"},
{"lineNum":"  231","line":"            itsWriter.EndObject();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  232","line":"            break;"},
{"lineNum":"  233","line":"        }"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"        itsNodeStack.pop();"},
{"lineNum":"  236","line":"        itsNameCounter.pop();"},
{"lineNum":"  237","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"      //! Sets the name for the next node created with startNode"},
{"lineNum":"  240","line":"      void setNextName( const char * name )"},
{"lineNum":"  241","line":"      {"},
{"lineNum":"  242","line":"        itsNextName = name;","class":"lineNoCov","hits":"0","possible_hits":"340",},
{"lineNum":"  243","line":"      }"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"      //! Saves a bool to the current node"},
{"lineNum":"  246","line":"      void saveValue(bool b)                { itsWriter.Bool(b);                                                         }","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  247","line":"      //! Saves an int to the current node"},
{"lineNum":"  248","line":"      void saveValue(int i)                 { itsWriter.Int(i);                                                          }","class":"lineNoCov","hits":"0","possible_hits":"104",},
{"lineNum":"  249","line":"      //! Saves a uint to the current node"},
{"lineNum":"  250","line":"      void saveValue(unsigned u)            { itsWriter.Uint(u);                                                         }","class":"lineNoCov","hits":"0","possible_hits":"63",},
{"lineNum":"  251","line":"      //! Saves an int64 to the current node"},
{"lineNum":"  252","line":"      void saveValue(int64_t i64)           { itsWriter.Int64(i64);                                                      }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  253","line":"      //! Saves a uint64 to the current node"},
{"lineNum":"  254","line":"      void saveValue(uint64_t u64)          { itsWriter.Uint64(u64);                                                     }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  255","line":"      //! Saves a double to the current node"},
{"lineNum":"  256","line":"      void saveValue(double d)              { itsWriter.Double(d);                                                       }","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  257","line":"      //! Saves a string to the current node"},
{"lineNum":"  258","line":"      void saveValue(std::string const & s) { itsWriter.String(s.c_str(), static_cast<CEREAL_RAPIDJSON_NAMESPACE::SizeType>( s.size() )); }","class":"lineNoCov","hits":"0","possible_hits":"80",},
{"lineNum":"  259","line":"      //! Saves a const char * to the current node"},
{"lineNum":"  260","line":"      void saveValue(char const * s)        { itsWriter.String(s);                                                       }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  261","line":"      //! Saves a nullptr to the current node"},
{"lineNum":"  262","line":"      void saveValue(std::nullptr_t)        { itsWriter.Null();                                                          }"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"    private:"},
{"lineNum":"  265","line":"      // Some compilers/OS have difficulty disambiguating the above for various flavors of longs, so we provide"},
{"lineNum":"  266","line":"      // special overloads to handle these cases."},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"      //! 32 bit signed long saving to current node"},
{"lineNum":"  269","line":"      template <class T, traits::EnableIf<sizeof(T) == sizeof(std::int32_t),"},
{"lineNum":"  270","line":"                                          std::is_signed<T>::value> = traits::sfinae> inline"},
{"lineNum":"  271","line":"      void saveLong(T l){ saveValue( static_cast<std::int32_t>( l ) ); }"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"      //! non 32 bit signed long saving to current node"},
{"lineNum":"  274","line":"      template <class T, traits::EnableIf<sizeof(T) != sizeof(std::int32_t),"},
{"lineNum":"  275","line":"                                          std::is_signed<T>::value> = traits::sfinae> inline"},
{"lineNum":"  276","line":"      void saveLong(T l){ saveValue( static_cast<std::int64_t>( l ) ); }"},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"      //! 32 bit unsigned long saving to current node"},
{"lineNum":"  279","line":"      template <class T, traits::EnableIf<sizeof(T) == sizeof(std::int32_t),"},
{"lineNum":"  280","line":"                                          std::is_unsigned<T>::value> = traits::sfinae> inline"},
{"lineNum":"  281","line":"      void saveLong(T lu){ saveValue( static_cast<std::uint32_t>( lu ) ); }"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"      //! non 32 bit unsigned long saving to current node"},
{"lineNum":"  284","line":"      template <class T, traits::EnableIf<sizeof(T) != sizeof(std::int32_t),"},
{"lineNum":"  285","line":"                                          std::is_unsigned<T>::value> = traits::sfinae> inline"},
{"lineNum":"  286","line":"      void saveLong(T lu){ saveValue( static_cast<std::uint64_t>( lu ) ); }"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"    public:"},
{"lineNum":"  289","line":"#if defined(_MSC_VER) && _MSC_VER < 1916"},
{"lineNum":"  290","line":"      //! MSVC only long overload to current node"},
{"lineNum":"  291","line":"      void saveValue( unsigned long lu ){ saveLong( lu ); };"},
{"lineNum":"  292","line":"#else // _MSC_VER"},
{"lineNum":"  293","line":"      //! Serialize a long if it would not be caught otherwise"},
{"lineNum":"  294","line":"      template <class T, traits::EnableIf<std::is_same<T, long>::value,"},
{"lineNum":"  295","line":"                                          !std::is_same<T, int>::value,"},
{"lineNum":"  296","line":"                                          !std::is_same<T, std::int64_t>::value> = traits::sfinae> inline"},
{"lineNum":"  297","line":"      void saveValue( T t ){ saveLong( t ); }"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"      //! Serialize an unsigned long if it would not be caught otherwise"},
{"lineNum":"  300","line":"      template <class T, traits::EnableIf<std::is_same<T, unsigned long>::value,"},
{"lineNum":"  301","line":"                                          !std::is_same<T, unsigned>::value,"},
{"lineNum":"  302","line":"                                          !std::is_same<T, std::uint64_t>::value> = traits::sfinae> inline"},
{"lineNum":"  303","line":"      void saveValue( T t ){ saveLong( t ); }"},
{"lineNum":"  304","line":"#endif // _MSC_VER"},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"      //! Save exotic arithmetic as strings to current node"},
{"lineNum":"  307","line":"      /*! Handles long long (if distinct from other types), unsigned long (if distinct), and long double */"},
{"lineNum":"  308","line":"      template <class T, traits::EnableIf<std::is_arithmetic<T>::value,"},
{"lineNum":"  309","line":"                                          !std::is_same<T, long>::value,"},
{"lineNum":"  310","line":"                                          !std::is_same<T, unsigned long>::value,"},
{"lineNum":"  311","line":"                                          !std::is_same<T, std::int64_t>::value,"},
{"lineNum":"  312","line":"                                          !std::is_same<T, std::uint64_t>::value,"},
{"lineNum":"  313","line":"                                          (sizeof(T) >= sizeof(long double) || sizeof(T) >= sizeof(long long))> = traits::sfinae> inline"},
{"lineNum":"  314","line":"      void saveValue(T const & t)"},
{"lineNum":"  315","line":"      {"},
{"lineNum":"  316","line":"        std::stringstream ss; ss.precision( std::numeric_limits<long double>::max_digits10 );"},
{"lineNum":"  317","line":"        ss << t;"},
{"lineNum":"  318","line":"        saveValue( ss.str() );"},
{"lineNum":"  319","line":"      }"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"      //! Write the name of the upcoming node and prepare object/array state"},
{"lineNum":"  322","line":"      /*! Since writeName is called for every value that is output, regardless of"},
{"lineNum":"  323","line":"          whether it has a name or not, it is the place where we will do a deferred"},
{"lineNum":"  324","line":"          check of our node state and decide whether we are in an array or an object."},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"          The general workflow of saving to the JSON archive is:"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"            1. (optional) Set the name for the next node to be created, usually done by an NVP"},
{"lineNum":"  329","line":"            2. Start the node"},
{"lineNum":"  330","line":"            3. (if there is data to save) Write the name of the node (this function)"},
{"lineNum":"  331","line":"            4. (if there is data to save) Save the data (with saveValue)"},
{"lineNum":"  332","line":"            5. Finish the node"},
{"lineNum":"  333","line":"          */"},
{"lineNum":"  334","line":"      void writeName()"},
{"lineNum":"  335","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  336","line":"        NodeType const & nodeType = itsNodeStack.top();"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"        // Start up either an object or an array, depending on state"},
{"lineNum":"  339","line":"        if(nodeType == NodeType::StartArray)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  340","line":"        {"},
{"lineNum":"  341","line":"          itsWriter.StartArray();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  342","line":"          itsNodeStack.top() = NodeType::InArray;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  343","line":"        }"},
{"lineNum":"  344","line":"        else if(nodeType == NodeType::StartObject)"},
{"lineNum":"  345","line":"        {"},
{"lineNum":"  346","line":"          itsNodeStack.top() = NodeType::InObject;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  347","line":"          itsWriter.StartObject();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  348","line":"        }"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"        // Array types do not output names"},
{"lineNum":"  351","line":"        if(nodeType == NodeType::InArray) return;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"        if(itsNextName == nullptr)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  354","line":"        {"},
{"lineNum":"  355","line":"          std::string name = \"value\" + std::to_string( itsNameCounter.top()++ ) + \"\\0\";","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  356","line":"          saveValue(name);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  357","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  358","line":"        else"},
{"lineNum":"  359","line":"        {"},
{"lineNum":"  360","line":"          saveValue(itsNextName);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  361","line":"          itsNextName = nullptr;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  362","line":"        }"},
{"lineNum":"  363","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"      //! Designates that the current node should be output as an array, not an object"},
{"lineNum":"  366","line":"      void makeArray()"},
{"lineNum":"  367","line":"      {"},
{"lineNum":"  368","line":"        itsNodeStack.top() = NodeType::StartArray;","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  369","line":"      }"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"      //! @}"},
{"lineNum":"  372","line":""},
{"lineNum":"  373","line":"    private:"},
{"lineNum":"  374","line":"      WriteStream itsWriteStream;          //!< Rapidjson write stream"},
{"lineNum":"  375","line":"      JSONWriter itsWriter;                //!< Rapidjson writer"},
{"lineNum":"  376","line":"      char const * itsNextName;            //!< The next name"},
{"lineNum":"  377","line":"      std::stack<uint32_t> itsNameCounter; //!< Counter for creating unique names for unnamed nodes"},
{"lineNum":"  378","line":"      std::stack<NodeType> itsNodeStack;"},
{"lineNum":"  379","line":"  }; // JSONOutputArchive"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"  // ######################################################################"},
{"lineNum":"  382","line":"  //! An input archive designed to load data from JSON"},
{"lineNum":"  383","line":"  /*! This archive uses RapidJSON to read in a JSON archive."},
{"lineNum":"  384","line":""},
{"lineNum":"  385","line":"      As with the output JSON archive, the preferred way to use this archive is in"},
{"lineNum":"  386","line":"      an RAII fashion, ensuring its destruction after all data has been read."},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"      Input JSON should have been produced by the JSONOutputArchive.  Data can"},
{"lineNum":"  389","line":"      only be added to dynamically sized containers (marked by JSON arrays) -"},
{"lineNum":"  390","line":"      the input archive will determine their size by looking at the number of child nodes."},
{"lineNum":"  391","line":"      Only JSON originating from a JSONOutputArchive is officially supported, but data"},
{"lineNum":"  392","line":"      from other sources may work if properly formatted."},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"      The JSONInputArchive does not require that nodes are loaded in the same"},
{"lineNum":"  395","line":"      order they were saved by JSONOutputArchive.  Using name value pairs (NVPs),"},
{"lineNum":"  396","line":"      it is possible to load in an out of order fashion or otherwise skip/select"},
{"lineNum":"  397","line":"      specific nodes to load."},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"      The default behavior of the input archive is to read sequentially starting"},
{"lineNum":"  400","line":"      with the first node and exploring its children.  When a given NVP does"},
{"lineNum":"  401","line":"      not match the read in name for a node, the archive will search for that"},
{"lineNum":"  402","line":"      node at the current level and load it if it exists.  After loading an out of"},
{"lineNum":"  403","line":"      order node, the archive will then proceed back to loading sequentially from"},
{"lineNum":"  404","line":"      its new position."},
{"lineNum":"  405","line":""},
{"lineNum":"  406","line":"      Consider this simple example where loading of some data is skipped:"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"      @code{cpp}"},
{"lineNum":"  409","line":"      // imagine the input file has someData(1-9) saved in order at the top level node"},
{"lineNum":"  410","line":"      ar( someData1, someData2, someData3 );        // XML loads in the order it sees in the file"},
{"lineNum":"  411","line":"      ar( cereal::make_nvp( \"hello\", someData6 ) ); // NVP given does not"},
{"lineNum":"  412","line":"                                                    // match expected NVP name, so we search"},
{"lineNum":"  413","line":"                                                    // for the given NVP and load that value"},
{"lineNum":"  414","line":"      ar( someData7, someData8, someData9 );        // with no NVP given, loading resumes at its"},
{"lineNum":"  415","line":"                                                    // current location, proceeding sequentially"},
{"lineNum":"  416","line":"      @endcode"},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"      \\ingroup Archives */"},
{"lineNum":"  419","line":"  class JSONInputArchive : public InputArchive<JSONInputArchive>, public traits::TextArchive"},
{"lineNum":"  420","line":"  {"},
{"lineNum":"  421","line":"    private:"},
{"lineNum":"  422","line":"      using ReadStream = CEREAL_RAPIDJSON_NAMESPACE::IStreamWrapper;"},
{"lineNum":"  423","line":"      typedef CEREAL_RAPIDJSON_NAMESPACE::GenericValue<CEREAL_RAPIDJSON_NAMESPACE::UTF8<>> JSONValue;"},
{"lineNum":"  424","line":"      typedef JSONValue::ConstMemberIterator MemberIterator;"},
{"lineNum":"  425","line":"      typedef JSONValue::ConstValueIterator ValueIterator;"},
{"lineNum":"  426","line":"      typedef CEREAL_RAPIDJSON_NAMESPACE::Document::GenericValue GenericValue;"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"    public:"},
{"lineNum":"  429","line":"      /*! @name Common Functionality"},
{"lineNum":"  430","line":"          Common use cases for directly interacting with an JSONInputArchive */"},
{"lineNum":"  431","line":"      //! @{"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"      //! Construct, reading from the provided stream"},
{"lineNum":"  434","line":"      /*! @param stream The stream to read from */"},
{"lineNum":"  435","line":"      JSONInputArchive(std::istream & stream) :","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  436","line":"        InputArchive<JSONInputArchive>(this),"},
{"lineNum":"  437","line":"        itsNextName( nullptr ),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  438","line":"        itsReadStream(stream)"},
{"lineNum":"  439","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  440","line":"        itsDocument.ParseStream<>(itsReadStream);"},
{"lineNum":"  441","line":"        if (itsDocument.IsArray())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  442","line":"          itsIteratorStack.emplace_back(itsDocument.Begin(), itsDocument.End());"},
{"lineNum":"  443","line":"        else"},
{"lineNum":"  444","line":"          itsIteratorStack.emplace_back(itsDocument.MemberBegin(), itsDocument.MemberEnd());"},
{"lineNum":"  445","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"      ~JSONInputArchive() CEREAL_NOEXCEPT = default;","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"      //! Loads some binary data, encoded as a base64 string"},
{"lineNum":"  450","line":"      /*! This will automatically start and finish a node to load the data, and can be called directly by"},
{"lineNum":"  451","line":"          users."},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"          Note that this follows the same ordering rules specified in the class description in regards"},
{"lineNum":"  454","line":"          to loading in/out of order */"},
{"lineNum":"  455","line":"      void loadBinaryValue( void * data, size_t size, const char * name = nullptr )"},
{"lineNum":"  456","line":"      {"},
{"lineNum":"  457","line":"        itsNextName = name;"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"        std::string encoded;"},
{"lineNum":"  460","line":"        loadValue( encoded );"},
{"lineNum":"  461","line":"        auto decoded = base64::decode( encoded );"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"        if( size != decoded.size() )"},
{"lineNum":"  464","line":"          throw Exception(\"Decoded binary data size does not match specified size\");"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"        std::memcpy( data, decoded.data(), decoded.size() );"},
{"lineNum":"  467","line":"        itsNextName = nullptr;"},
{"lineNum":"  468","line":"      };"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"    private:"},
{"lineNum":"  471","line":"      //! @}"},
{"lineNum":"  472","line":"      /*! @name Internal Functionality"},
{"lineNum":"  473","line":"          Functionality designed for use by those requiring control over the inner mechanisms of"},
{"lineNum":"  474","line":"          the JSONInputArchive */"},
{"lineNum":"  475","line":"      //! @{"},
{"lineNum":"  476","line":""},
{"lineNum":"  477","line":"      //! An internal iterator that handles both array and object types"},
{"lineNum":"  478","line":"      /*! This class is a variant and holds both types of iterators that"},
{"lineNum":"  479","line":"          rapidJSON supports - one for arrays and one for objects. */"},
{"lineNum":"  480","line":"      class Iterator"},
{"lineNum":"  481","line":"      {"},
{"lineNum":"  482","line":"        public:"},
{"lineNum":"  483","line":"          Iterator() : itsIndex( 0 ), itsType(Null_) {}"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"          Iterator(MemberIterator begin, MemberIterator end) :"},
{"lineNum":"  486","line":"            itsMemberItBegin(begin), itsMemberItEnd(end), itsIndex(0), itsSize(std::distance(begin, end)), itsType(Member)","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  487","line":"          {"},
{"lineNum":"  488","line":"            if( itsSize == 0 )","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  489","line":"              itsType = Null_;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  490","line":"          }"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"          Iterator(ValueIterator begin, ValueIterator end) :"},
{"lineNum":"  493","line":"            itsValueItBegin(begin), itsIndex(0), itsSize(std::distance(begin, end)), itsType(Value)","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  494","line":"          {"},
{"lineNum":"  495","line":"            if( itsSize == 0 )","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  496","line":"              itsType = Null_;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  497","line":"          }"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"          //! Advance to the next node"},
{"lineNum":"  500","line":"          Iterator & operator++()"},
{"lineNum":"  501","line":"          {"},
{"lineNum":"  502","line":"            ++itsIndex;","class":"lineNoCov","hits":"0","possible_hits":"357",},
{"lineNum":"  503","line":"            return *this;"},
{"lineNum":"  504","line":"          }"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"          //! Get the value of the current node"},
{"lineNum":"  507","line":"          GenericValue const & value()"},
{"lineNum":"  508","line":"          {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  509","line":"            if( itsIndex >= itsSize )","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  510","line":"              throw cereal::Exception(\"No more objects in input\");","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"            switch(itsType)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  513","line":"            {"},
{"lineNum":"  514","line":"              case Value : return itsValueItBegin[itsIndex];","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  515","line":"              case Member: return itsMemberItBegin[itsIndex].value;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  516","line":"              default: throw cereal::Exception(\"JSONInputArchive internal error: null or empty iterator to object or array!\");","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  517","line":"            }"},
{"lineNum":"  518","line":"          }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"          //! Get the name of the current node, or nullptr if it has no name"},
{"lineNum":"  521","line":"          const char * name() const"},
{"lineNum":"  522","line":"          {"},
{"lineNum":"  523","line":"            if( itsType == Member && (itsMemberItBegin + itsIndex) != itsMemberItEnd )","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  524","line":"              return itsMemberItBegin[itsIndex].name.GetString();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  525","line":"            else"},
{"lineNum":"  526","line":"              return nullptr;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  527","line":"          }"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"          //! Adjust our position such that we are at the node with the given name"},
{"lineNum":"  530","line":"          /*! @throws Exception if no such named node exists */"},
{"lineNum":"  531","line":"          inline void search( const char * searchName )"},
{"lineNum":"  532","line":"          {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  533","line":"            const auto len = std::strlen( searchName );","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  534","line":"            size_t index = 0;"},
{"lineNum":"  535","line":"            for( auto it = itsMemberItBegin; it != itsMemberItEnd; ++it, ++index )","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  536","line":"            {"},
{"lineNum":"  537","line":"              const auto currentName = it->name.GetString();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  538","line":"              if( ( std::strncmp( searchName, currentName, len ) == 0 ) &&","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  539","line":"                  ( std::strlen( currentName ) == len ) )","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  540","line":"              {"},
{"lineNum":"  541","line":"                itsIndex = index;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  542","line":"                return;"},
{"lineNum":"  543","line":"              }"},
{"lineNum":"  544","line":"            }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  545","line":""},
{"lineNum":"  546","line":"            throw Exception(\"JSON Parsing failed - provided NVP (\" + std::string(searchName) + \") not found\");","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  547","line":"          }","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  548","line":""},
{"lineNum":"  549","line":"        private:"},
{"lineNum":"  550","line":"          MemberIterator itsMemberItBegin, itsMemberItEnd; //!< The member iterator (object)"},
{"lineNum":"  551","line":"          ValueIterator itsValueItBegin;                   //!< The value iterator (array)"},
{"lineNum":"  552","line":"          size_t itsIndex, itsSize;                        //!< The current index of this iterator"},
{"lineNum":"  553","line":"          enum Type {Value, Member, Null_} itsType;        //!< Whether this holds values (array) or members (objects) or nothing"},
{"lineNum":"  554","line":"      };"},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"      //! Searches for the expectedName node if it doesn\'t match the actualName"},
{"lineNum":"  557","line":"      /*! This needs to be called before every load or node start occurs.  This function will"},
{"lineNum":"  558","line":"          check to see if an NVP has been provided (with setNextName) and if so, see if that name matches the actual"},
{"lineNum":"  559","line":"          next name given.  If the names do not match, it will search in the current level of the JSON for that name."},
{"lineNum":"  560","line":"          If the name is not found, an exception will be thrown."},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"          Resets the NVP name after called."},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"          @throws Exception if an expectedName is given and not found */"},
{"lineNum":"  565","line":"      inline void search()"},
{"lineNum":"  566","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  567","line":"        // store pointer to itsNextName locally and reset to nullptr in case search() throws"},
{"lineNum":"  568","line":"        auto localNextName = itsNextName;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  569","line":"        itsNextName = nullptr;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"        // The name an NVP provided with setNextName()"},
{"lineNum":"  572","line":"        if( localNextName )","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  573","line":"        {"},
{"lineNum":"  574","line":"          // The actual name of the current node"},
{"lineNum":"  575","line":"          auto const actualName = itsIteratorStack.back().name();"},
{"lineNum":"  576","line":""},
{"lineNum":"  577","line":"          // Do a search if we don\'t see a name coming up, or if the names don\'t match"},
{"lineNum":"  578","line":"          if( !actualName || std::strcmp( localNextName, actualName ) != 0 )","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  579","line":"            itsIteratorStack.back().search( localNextName );","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  580","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  581","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  582","line":""},
{"lineNum":"  583","line":"    public:"},
{"lineNum":"  584","line":"      //! Starts a new node, going into its proper iterator"},
{"lineNum":"  585","line":"      /*! This places an iterator for the next node to be parsed onto the iterator stack.  If the next"},
{"lineNum":"  586","line":"          node is an array, this will be a value iterator, otherwise it will be a member iterator."},
{"lineNum":"  587","line":""},
{"lineNum":"  588","line":"          By default our strategy is to start with the document root node and then recursively iterate through"},
{"lineNum":"  589","line":"          all children in the order they show up in the document."},
{"lineNum":"  590","line":"          We don\'t need to know NVPs to do this; we\'ll just blindly load in the order things appear in."},
{"lineNum":"  591","line":""},
{"lineNum":"  592","line":"          If we were given an NVP, we will search for it if it does not match our the name of the next node"},
{"lineNum":"  593","line":"          that would normally be loaded.  This functionality is provided by search(). */"},
{"lineNum":"  594","line":"      void startNode()"},
{"lineNum":"  595","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  596","line":"        search();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"        if(itsIteratorStack.back().value().IsArray())","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  599","line":"          itsIteratorStack.emplace_back(itsIteratorStack.back().value().Begin(), itsIteratorStack.back().value().End());","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  600","line":"        else"},
{"lineNum":"  601","line":"          itsIteratorStack.emplace_back(itsIteratorStack.back().value().MemberBegin(), itsIteratorStack.back().value().MemberEnd());","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  602","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"      //! Finishes the most recently started node"},
{"lineNum":"  605","line":"      void finishNode()"},
{"lineNum":"  606","line":"      {"},
{"lineNum":"  607","line":"        itsIteratorStack.pop_back();","class":"lineNoCov","hits":"0","possible_hits":"46",},
{"lineNum":"  608","line":"        ++itsIteratorStack.back();"},
{"lineNum":"  609","line":"      }"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"      //! Retrieves the current node name"},
{"lineNum":"  612","line":"      /*! @return nullptr if no name exists */"},
{"lineNum":"  613","line":"      const char * getNodeName() const"},
{"lineNum":"  614","line":"      {"},
{"lineNum":"  615","line":"        return itsIteratorStack.back().name();"},
{"lineNum":"  616","line":"      }"},
{"lineNum":"  617","line":""},
{"lineNum":"  618","line":"      //! Sets the name for the next node created with startNode"},
{"lineNum":"  619","line":"      void setNextName( const char * name )"},
{"lineNum":"  620","line":"      {"},
{"lineNum":"  621","line":"        itsNextName = name;","class":"lineNoCov","hits":"0","possible_hits":"314",},
{"lineNum":"  622","line":"      }"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"      //! Loads a value from the current node - small signed overload"},
{"lineNum":"  625","line":"      template <class T, traits::EnableIf<std::is_signed<T>::value,"},
{"lineNum":"  626","line":"                                          sizeof(T) < sizeof(int64_t)> = traits::sfinae> inline"},
{"lineNum":"  627","line":"      void loadValue(T & val)"},
{"lineNum":"  628","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  629","line":"        search();","class":"lineNoCov","hits":"0","possible_hits":"59",},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"        val = static_cast<T>( itsIteratorStack.back().value().GetInt() );","class":"lineNoCov","hits":"0","possible_hits":"110",},
{"lineNum":"  632","line":"        ++itsIteratorStack.back();"},
{"lineNum":"  633","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"      //! Loads a value from the current node - small unsigned overload"},
{"lineNum":"  636","line":"      template <class T, traits::EnableIf<std::is_unsigned<T>::value,"},
{"lineNum":"  637","line":"                                          sizeof(T) < sizeof(uint64_t),"},
{"lineNum":"  638","line":"                                          !std::is_same<bool, T>::value> = traits::sfinae> inline"},
{"lineNum":"  639","line":"      void loadValue(T & val)"},
{"lineNum":"  640","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  641","line":"        search();","class":"lineNoCov","hits":"0","possible_hits":"48",},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"        val = static_cast<T>( itsIteratorStack.back().value().GetUint() );","class":"lineNoCov","hits":"0","possible_hits":"50",},
{"lineNum":"  644","line":"        ++itsIteratorStack.back();"},
{"lineNum":"  645","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  646","line":""},
{"lineNum":"  647","line":"      //! Loads a value from the current node - bool overload"},
{"lineNum":"  648","line":"      void loadValue(bool & val)        { search(); val = itsIteratorStack.back().value().GetBool(); ++itsIteratorStack.back(); }","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  649","line":"      //! Loads a value from the current node - int64 overload"},
{"lineNum":"  650","line":"      void loadValue(int64_t & val)     { search(); val = itsIteratorStack.back().value().GetInt64(); ++itsIteratorStack.back(); }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  651","line":"      //! Loads a value from the current node - uint64 overload"},
{"lineNum":"  652","line":"      void loadValue(uint64_t & val)    { search(); val = itsIteratorStack.back().value().GetUint64(); ++itsIteratorStack.back(); }"},
{"lineNum":"  653","line":"      //! Loads a value from the current node - float overload"},
{"lineNum":"  654","line":"      void loadValue(float & val)       { search(); val = static_cast<float>(itsIteratorStack.back().value().GetDouble()); ++itsIteratorStack.back(); }"},
{"lineNum":"  655","line":"      //! Loads a value from the current node - double overload"},
{"lineNum":"  656","line":"      void loadValue(double & val)      { search(); val = itsIteratorStack.back().value().GetDouble(); ++itsIteratorStack.back(); }","class":"lineNoCov","hits":"0","possible_hits":"52",},
{"lineNum":"  657","line":"      //! Loads a value from the current node - string overload"},
{"lineNum":"  658","line":"      void loadValue(std::string & val) { search(); val = itsIteratorStack.back().value().GetString(); ++itsIteratorStack.back(); }","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  659","line":"      //! Loads a nullptr from the current node"},
{"lineNum":"  660","line":"      void loadValue(std::nullptr_t&)   { search(); CEREAL_RAPIDJSON_ASSERT(itsIteratorStack.back().value().IsNull()); ++itsIteratorStack.back(); }"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"      // Special cases to handle various flavors of long, which tend to conflict with"},
{"lineNum":"  663","line":"      // the int32_t or int64_t on various compiler/OS combinations.  MSVC doesn\'t need any of this."},
{"lineNum":"  664","line":"      #ifndef _MSC_VER"},
{"lineNum":"  665","line":"    private:"},
{"lineNum":"  666","line":"      //! 32 bit signed long loading from current node"},
{"lineNum":"  667","line":"      template <class T> inline"},
{"lineNum":"  668","line":"      typename std::enable_if<sizeof(T) == sizeof(std::int32_t) && std::is_signed<T>::value, void>::type"},
{"lineNum":"  669","line":"      loadLong(T & l){ loadValue( reinterpret_cast<std::int32_t&>( l ) ); }"},
{"lineNum":"  670","line":""},
{"lineNum":"  671","line":"      //! non 32 bit signed long loading from current node"},
{"lineNum":"  672","line":"      template <class T> inline"},
{"lineNum":"  673","line":"      typename std::enable_if<sizeof(T) == sizeof(std::int64_t) && std::is_signed<T>::value, void>::type"},
{"lineNum":"  674","line":"      loadLong(T & l){ loadValue( reinterpret_cast<std::int64_t&>( l ) ); }"},
{"lineNum":"  675","line":""},
{"lineNum":"  676","line":"      //! 32 bit unsigned long loading from current node"},
{"lineNum":"  677","line":"      template <class T> inline"},
{"lineNum":"  678","line":"      typename std::enable_if<sizeof(T) == sizeof(std::uint32_t) && !std::is_signed<T>::value, void>::type"},
{"lineNum":"  679","line":"      loadLong(T & lu){ loadValue( reinterpret_cast<std::uint32_t&>( lu ) ); }"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"      //! non 32 bit unsigned long loading from current node"},
{"lineNum":"  682","line":"      template <class T> inline"},
{"lineNum":"  683","line":"      typename std::enable_if<sizeof(T) == sizeof(std::uint64_t) && !std::is_signed<T>::value, void>::type"},
{"lineNum":"  684","line":"      loadLong(T & lu){ loadValue( reinterpret_cast<std::uint64_t&>( lu ) ); }"},
{"lineNum":"  685","line":""},
{"lineNum":"  686","line":"    public:"},
{"lineNum":"  687","line":"      //! Serialize a long if it would not be caught otherwise"},
{"lineNum":"  688","line":"      template <class T> inline"},
{"lineNum":"  689","line":"      typename std::enable_if<std::is_same<T, long>::value &&"},
{"lineNum":"  690","line":"                              sizeof(T) >= sizeof(std::int64_t) &&"},
{"lineNum":"  691","line":"                              !std::is_same<T, std::int64_t>::value, void>::type"},
{"lineNum":"  692","line":"      loadValue( T & t ){ loadLong(t); }"},
{"lineNum":"  693","line":""},
{"lineNum":"  694","line":"      //! Serialize an unsigned long if it would not be caught otherwise"},
{"lineNum":"  695","line":"      template <class T> inline"},
{"lineNum":"  696","line":"      typename std::enable_if<std::is_same<T, unsigned long>::value &&"},
{"lineNum":"  697","line":"                              sizeof(T) >= sizeof(std::uint64_t) &&"},
{"lineNum":"  698","line":"                              !std::is_same<T, std::uint64_t>::value, void>::type"},
{"lineNum":"  699","line":"      loadValue( T & t ){ loadLong(t); }"},
{"lineNum":"  700","line":"      #endif // _MSC_VER"},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"    private:"},
{"lineNum":"  703","line":"      //! Convert a string to a long long"},
{"lineNum":"  704","line":"      void stringToNumber( std::string const & str, long long & val ) { val = std::stoll( str ); }"},
{"lineNum":"  705","line":"      //! Convert a string to an unsigned long long"},
{"lineNum":"  706","line":"      void stringToNumber( std::string const & str, unsigned long long & val ) { val = std::stoull( str ); }"},
{"lineNum":"  707","line":"      //! Convert a string to a long double"},
{"lineNum":"  708","line":"      void stringToNumber( std::string const & str, long double & val ) { val = std::stold( str ); }"},
{"lineNum":"  709","line":""},
{"lineNum":"  710","line":"    public:"},
{"lineNum":"  711","line":"      //! Loads a value from the current node - long double and long long overloads"},
{"lineNum":"  712","line":"      template <class T, traits::EnableIf<std::is_arithmetic<T>::value,"},
{"lineNum":"  713","line":"                                          !std::is_same<T, long>::value,"},
{"lineNum":"  714","line":"                                          !std::is_same<T, unsigned long>::value,"},
{"lineNum":"  715","line":"                                          !std::is_same<T, std::int64_t>::value,"},
{"lineNum":"  716","line":"                                          !std::is_same<T, std::uint64_t>::value,"},
{"lineNum":"  717","line":"                                          (sizeof(T) >= sizeof(long double) || sizeof(T) >= sizeof(long long))> = traits::sfinae>"},
{"lineNum":"  718","line":"      inline void loadValue(T & val)"},
{"lineNum":"  719","line":"      {"},
{"lineNum":"  720","line":"        std::string encoded;"},
{"lineNum":"  721","line":"        loadValue( encoded );"},
{"lineNum":"  722","line":"        stringToNumber( encoded, val );"},
{"lineNum":"  723","line":"      }"},
{"lineNum":"  724","line":""},
{"lineNum":"  725","line":"      //! Loads the size for a SizeTag"},
{"lineNum":"  726","line":"      void loadSize(size_type & size)"},
{"lineNum":"  727","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  728","line":"        if (itsIteratorStack.size() == 1)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  729","line":"          size = itsDocument.Size();"},
{"lineNum":"  730","line":"        else"},
{"lineNum":"  731","line":"          size = (itsIteratorStack.rbegin() + 1)->value().Size();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  732","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  733","line":""},
{"lineNum":"  734","line":"      //! @}"},
{"lineNum":"  735","line":""},
{"lineNum":"  736","line":"    private:"},
{"lineNum":"  737","line":"      const char * itsNextName;               //!< Next name set by NVP"},
{"lineNum":"  738","line":"      ReadStream itsReadStream;               //!< Rapidjson write stream"},
{"lineNum":"  739","line":"      std::vector<Iterator> itsIteratorStack; //!< \'Stack\' of rapidJSON iterators"},
{"lineNum":"  740","line":"      CEREAL_RAPIDJSON_NAMESPACE::Document itsDocument; //!< Rapidjson document"},
{"lineNum":"  741","line":"  };"},
{"lineNum":"  742","line":""},
{"lineNum":"  743","line":"  // ######################################################################"},
{"lineNum":"  744","line":"  // JSONArchive prologue and epilogue functions"},
{"lineNum":"  745","line":"  // ######################################################################"},
{"lineNum":"  746","line":""},
{"lineNum":"  747","line":"  // ######################################################################"},
{"lineNum":"  748","line":"  //! Prologue for NVPs for JSON archives"},
{"lineNum":"  749","line":"  /*! NVPs do not start or finish nodes - they just set up the names */"},
{"lineNum":"  750","line":"  template <class T> inline"},
{"lineNum":"  751","line":"  void prologue( JSONOutputArchive &, NameValuePair<T> const & )"},
{"lineNum":"  752","line":"  { }"},
{"lineNum":"  753","line":""},
{"lineNum":"  754","line":"  //! Prologue for NVPs for JSON archives"},
{"lineNum":"  755","line":"  template <class T> inline"},
{"lineNum":"  756","line":"  void prologue( JSONInputArchive &, NameValuePair<T> const & )"},
{"lineNum":"  757","line":"  { }"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":"  // ######################################################################"},
{"lineNum":"  760","line":"  //! Epilogue for NVPs for JSON archives"},
{"lineNum":"  761","line":"  /*! NVPs do not start or finish nodes - they just set up the names */"},
{"lineNum":"  762","line":"  template <class T> inline"},
{"lineNum":"  763","line":"  void epilogue( JSONOutputArchive &, NameValuePair<T> const & )"},
{"lineNum":"  764","line":"  { }"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"  //! Epilogue for NVPs for JSON archives"},
{"lineNum":"  767","line":"  /*! NVPs do not start or finish nodes - they just set up the names */"},
{"lineNum":"  768","line":"  template <class T> inline"},
{"lineNum":"  769","line":"  void epilogue( JSONInputArchive &, NameValuePair<T> const & )"},
{"lineNum":"  770","line":"  { }"},
{"lineNum":"  771","line":""},
{"lineNum":"  772","line":"  // ######################################################################"},
{"lineNum":"  773","line":"  //! Prologue for deferred data for JSON archives"},
{"lineNum":"  774","line":"  /*! Do nothing for the defer wrapper */"},
{"lineNum":"  775","line":"  template <class T> inline"},
{"lineNum":"  776","line":"  void prologue( JSONOutputArchive &, DeferredData<T> const & )"},
{"lineNum":"  777","line":"  { }"},
{"lineNum":"  778","line":""},
{"lineNum":"  779","line":"  //! Prologue for deferred data for JSON archives"},
{"lineNum":"  780","line":"  template <class T> inline"},
{"lineNum":"  781","line":"  void prologue( JSONInputArchive &, DeferredData<T> const & )"},
{"lineNum":"  782","line":"  { }"},
{"lineNum":"  783","line":""},
{"lineNum":"  784","line":"  // ######################################################################"},
{"lineNum":"  785","line":"  //! Epilogue for deferred for JSON archives"},
{"lineNum":"  786","line":"  /*! NVPs do not start or finish nodes - they just set up the names */"},
{"lineNum":"  787","line":"  template <class T> inline"},
{"lineNum":"  788","line":"  void epilogue( JSONOutputArchive &, DeferredData<T> const & )"},
{"lineNum":"  789","line":"  { }"},
{"lineNum":"  790","line":""},
{"lineNum":"  791","line":"  //! Epilogue for deferred for JSON archives"},
{"lineNum":"  792","line":"  /*! Do nothing for the defer wrapper */"},
{"lineNum":"  793","line":"  template <class T> inline"},
{"lineNum":"  794","line":"  void epilogue( JSONInputArchive &, DeferredData<T> const & )"},
{"lineNum":"  795","line":"  { }"},
{"lineNum":"  796","line":""},
{"lineNum":"  797","line":"  // ######################################################################"},
{"lineNum":"  798","line":"  //! Prologue for SizeTags for JSON archives"},
{"lineNum":"  799","line":"  /*! SizeTags are strictly ignored for JSON, they just indicate"},
{"lineNum":"  800","line":"      that the current node should be made into an array */"},
{"lineNum":"  801","line":"  template <class T> inline"},
{"lineNum":"  802","line":"  void prologue( JSONOutputArchive & ar, SizeTag<T> const & )"},
{"lineNum":"  803","line":"  {"},
{"lineNum":"  804","line":"    ar.makeArray();"},
{"lineNum":"  805","line":"  }"},
{"lineNum":"  806","line":""},
{"lineNum":"  807","line":"  //! Prologue for SizeTags for JSON archives"},
{"lineNum":"  808","line":"  template <class T> inline"},
{"lineNum":"  809","line":"  void prologue( JSONInputArchive &, SizeTag<T> const & )"},
{"lineNum":"  810","line":"  { }"},
{"lineNum":"  811","line":""},
{"lineNum":"  812","line":"  // ######################################################################"},
{"lineNum":"  813","line":"  //! Epilogue for SizeTags for JSON archives"},
{"lineNum":"  814","line":"  /*! SizeTags are strictly ignored for JSON */"},
{"lineNum":"  815","line":"  template <class T> inline"},
{"lineNum":"  816","line":"  void epilogue( JSONOutputArchive &, SizeTag<T> const & )"},
{"lineNum":"  817","line":"  { }"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"  //! Epilogue for SizeTags for JSON archives"},
{"lineNum":"  820","line":"  template <class T> inline"},
{"lineNum":"  821","line":"  void epilogue( JSONInputArchive &, SizeTag<T> const & )"},
{"lineNum":"  822","line":"  { }"},
{"lineNum":"  823","line":""},
{"lineNum":"  824","line":"  // ######################################################################"},
{"lineNum":"  825","line":"  //! Prologue for all other types for JSON archives (except minimal types)"},
{"lineNum":"  826","line":"  /*! Starts a new node, named either automatically or by some NVP,"},
{"lineNum":"  827","line":"      that may be given data by the type about to be archived"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"      Minimal types do not start or finish nodes */"},
{"lineNum":"  830","line":"  template <class T, traits::EnableIf<!std::is_arithmetic<T>::value,"},
{"lineNum":"  831","line":"                                      !traits::has_minimal_base_class_serialization<T, traits::has_minimal_output_serialization, JSONOutputArchive>::value,"},
{"lineNum":"  832","line":"                                      !traits::has_minimal_output_serialization<T, JSONOutputArchive>::value> = traits::sfinae>"},
{"lineNum":"  833","line":"  inline void prologue( JSONOutputArchive & ar, T const & )"},
{"lineNum":"  834","line":"  {"},
{"lineNum":"  835","line":"    ar.startNode();","class":"lineNoCov","hits":"0","possible_hits":"183",},
{"lineNum":"  836","line":"  }"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"  //! Prologue for all other types for JSON archives"},
{"lineNum":"  839","line":"  template <class T, traits::EnableIf<!std::is_arithmetic<T>::value,"},
{"lineNum":"  840","line":"                                      !traits::has_minimal_base_class_serialization<T, traits::has_minimal_input_serialization, JSONInputArchive>::value,"},
{"lineNum":"  841","line":"                                      !traits::has_minimal_input_serialization<T, JSONInputArchive>::value> = traits::sfinae>"},
{"lineNum":"  842","line":"  inline void prologue( JSONInputArchive & ar, T const & )"},
{"lineNum":"  843","line":"  {"},
{"lineNum":"  844","line":"    ar.startNode();","class":"lineNoCov","hits":"0","possible_hits":"213",},
{"lineNum":"  845","line":"  }"},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"  // ######################################################################"},
{"lineNum":"  848","line":"  //! Epilogue for all other types other for JSON archives (except minimal types)"},
{"lineNum":"  849","line":"  /*! Finishes the node created in the prologue"},
{"lineNum":"  850","line":""},
{"lineNum":"  851","line":"      Minimal types do not start or finish nodes */"},
{"lineNum":"  852","line":"  template <class T, traits::EnableIf<!std::is_arithmetic<T>::value,"},
{"lineNum":"  853","line":"                                      !traits::has_minimal_base_class_serialization<T, traits::has_minimal_output_serialization, JSONOutputArchive>::value,"},
{"lineNum":"  854","line":"                                      !traits::has_minimal_output_serialization<T, JSONOutputArchive>::value> = traits::sfinae>"},
{"lineNum":"  855","line":"  inline void epilogue( JSONOutputArchive & ar, T const & )"},
{"lineNum":"  856","line":"  {"},
{"lineNum":"  857","line":"    ar.finishNode();","class":"lineNoCov","hits":"0","possible_hits":"222",},
{"lineNum":"  858","line":"  }"},
{"lineNum":"  859","line":""},
{"lineNum":"  860","line":"  //! Epilogue for all other types other for JSON archives"},
{"lineNum":"  861","line":"  template <class T, traits::EnableIf<!std::is_arithmetic<T>::value,"},
{"lineNum":"  862","line":"                                      !traits::has_minimal_base_class_serialization<T, traits::has_minimal_input_serialization, JSONInputArchive>::value,"},
{"lineNum":"  863","line":"                                      !traits::has_minimal_input_serialization<T, JSONInputArchive>::value> = traits::sfinae>"},
{"lineNum":"  864","line":"  inline void epilogue( JSONInputArchive & ar, T const & )"},
{"lineNum":"  865","line":"  {"},
{"lineNum":"  866","line":"    ar.finishNode();"},
{"lineNum":"  867","line":"  }"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"  // ######################################################################"},
{"lineNum":"  870","line":"  //! Prologue for arithmetic types for JSON archives"},
{"lineNum":"  871","line":"  inline"},
{"lineNum":"  872","line":"  void prologue( JSONOutputArchive & ar, std::nullptr_t const & )"},
{"lineNum":"  873","line":"  {"},
{"lineNum":"  874","line":"    ar.writeName();"},
{"lineNum":"  875","line":"  }"},
{"lineNum":"  876","line":""},
{"lineNum":"  877","line":"  //! Prologue for arithmetic types for JSON archives"},
{"lineNum":"  878","line":"  inline"},
{"lineNum":"  879","line":"  void prologue( JSONInputArchive &, std::nullptr_t const & )"},
{"lineNum":"  880","line":"  { }"},
{"lineNum":"  881","line":""},
{"lineNum":"  882","line":"  // ######################################################################"},
{"lineNum":"  883","line":"  //! Epilogue for arithmetic types for JSON archives"},
{"lineNum":"  884","line":"  inline"},
{"lineNum":"  885","line":"  void epilogue( JSONOutputArchive &, std::nullptr_t const & )"},
{"lineNum":"  886","line":"  { }"},
{"lineNum":"  887","line":""},
{"lineNum":"  888","line":"  //! Epilogue for arithmetic types for JSON archives"},
{"lineNum":"  889","line":"  inline"},
{"lineNum":"  890","line":"  void epilogue( JSONInputArchive &, std::nullptr_t const & )"},
{"lineNum":"  891","line":"  { }"},
{"lineNum":"  892","line":""},
{"lineNum":"  893","line":"  // ######################################################################"},
{"lineNum":"  894","line":"  //! Prologue for arithmetic types for JSON archives"},
{"lineNum":"  895","line":"  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline"},
{"lineNum":"  896","line":"  void prologue( JSONOutputArchive & ar, T const & )"},
{"lineNum":"  897","line":"  {"},
{"lineNum":"  898","line":"    ar.writeName();","class":"lineNoCov","hits":"0","possible_hits":"205",},
{"lineNum":"  899","line":"  }"},
{"lineNum":"  900","line":""},
{"lineNum":"  901","line":"  //! Prologue for arithmetic types for JSON archives"},
{"lineNum":"  902","line":"  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline"},
{"lineNum":"  903","line":"  void prologue( JSONInputArchive &, T const & )"},
{"lineNum":"  904","line":"  { }"},
{"lineNum":"  905","line":""},
{"lineNum":"  906","line":"  // ######################################################################"},
{"lineNum":"  907","line":"  //! Epilogue for arithmetic types for JSON archives"},
{"lineNum":"  908","line":"  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline"},
{"lineNum":"  909","line":"  void epilogue( JSONOutputArchive &, T const & )"},
{"lineNum":"  910","line":"  { }"},
{"lineNum":"  911","line":""},
{"lineNum":"  912","line":"  //! Epilogue for arithmetic types for JSON archives"},
{"lineNum":"  913","line":"  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline"},
{"lineNum":"  914","line":"  void epilogue( JSONInputArchive &, T const & )"},
{"lineNum":"  915","line":"  { }"},
{"lineNum":"  916","line":""},
{"lineNum":"  917","line":"  // ######################################################################"},
{"lineNum":"  918","line":"  //! Prologue for strings for JSON archives"},
{"lineNum":"  919","line":"  template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  920","line":"  void prologue(JSONOutputArchive & ar, std::basic_string<CharT, Traits, Alloc> const &)"},
{"lineNum":"  921","line":"  {"},
{"lineNum":"  922","line":"    ar.writeName();","class":"lineNoCov","hits":"0","possible_hits":"56",},
{"lineNum":"  923","line":"  }"},
{"lineNum":"  924","line":""},
{"lineNum":"  925","line":"  //! Prologue for strings for JSON archives"},
{"lineNum":"  926","line":"  template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  927","line":"  void prologue(JSONInputArchive &, std::basic_string<CharT, Traits, Alloc> const &)"},
{"lineNum":"  928","line":"  { }"},
{"lineNum":"  929","line":""},
{"lineNum":"  930","line":"  // ######################################################################"},
{"lineNum":"  931","line":"  //! Epilogue for strings for JSON archives"},
{"lineNum":"  932","line":"  template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  933","line":"  void epilogue(JSONOutputArchive &, std::basic_string<CharT, Traits, Alloc> const &)"},
{"lineNum":"  934","line":"  { }"},
{"lineNum":"  935","line":""},
{"lineNum":"  936","line":"  //! Epilogue for strings for JSON archives"},
{"lineNum":"  937","line":"  template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  938","line":"  void epilogue(JSONInputArchive &, std::basic_string<CharT, Traits, Alloc> const &)"},
{"lineNum":"  939","line":"  { }"},
{"lineNum":"  940","line":""},
{"lineNum":"  941","line":"  // ######################################################################"},
{"lineNum":"  942","line":"  // Common JSONArchive serialization functions"},
{"lineNum":"  943","line":"  // ######################################################################"},
{"lineNum":"  944","line":"  //! Serializing NVP types to JSON"},
{"lineNum":"  945","line":"  template <class T> inline"},
{"lineNum":"  946","line":"  void CEREAL_SAVE_FUNCTION_NAME( JSONOutputArchive & ar, NameValuePair<T> const & t )"},
{"lineNum":"  947","line":"  {"},
{"lineNum":"  948","line":"    ar.setNextName( t.name );","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  949","line":"    ar( t.value );","class":"lineNoCov","hits":"0","possible_hits":"29",},
{"lineNum":"  950","line":"  }"},
{"lineNum":"  951","line":""},
{"lineNum":"  952","line":"  template <class T> inline"},
{"lineNum":"  953","line":"  void CEREAL_LOAD_FUNCTION_NAME( JSONInputArchive & ar, NameValuePair<T> & t )"},
{"lineNum":"  954","line":"  {"},
{"lineNum":"  955","line":"    ar.setNextName( t.name );","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  956","line":"    ar( t.value );","class":"lineNoCov","hits":"0","possible_hits":"64",},
{"lineNum":"  957","line":"  }"},
{"lineNum":"  958","line":""},
{"lineNum":"  959","line":"  //! Saving for nullptr to JSON"},
{"lineNum":"  960","line":"  inline"},
{"lineNum":"  961","line":"  void CEREAL_SAVE_FUNCTION_NAME(JSONOutputArchive & ar, std::nullptr_t const & t)"},
{"lineNum":"  962","line":"  {"},
{"lineNum":"  963","line":"    ar.saveValue( t );"},
{"lineNum":"  964","line":"  }"},
{"lineNum":"  965","line":""},
{"lineNum":"  966","line":"  //! Loading arithmetic from JSON"},
{"lineNum":"  967","line":"  inline"},
{"lineNum":"  968","line":"  void CEREAL_LOAD_FUNCTION_NAME(JSONInputArchive & ar, std::nullptr_t & t)"},
{"lineNum":"  969","line":"  {"},
{"lineNum":"  970","line":"    ar.loadValue( t );"},
{"lineNum":"  971","line":"  }"},
{"lineNum":"  972","line":""},
{"lineNum":"  973","line":"  //! Saving for arithmetic to JSON"},
{"lineNum":"  974","line":"  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline"},
{"lineNum":"  975","line":"  void CEREAL_SAVE_FUNCTION_NAME(JSONOutputArchive & ar, T const & t)"},
{"lineNum":"  976","line":"  {"},
{"lineNum":"  977","line":"    ar.saveValue( t );","class":"lineNoCov","hits":"0","possible_hits":"116",},
{"lineNum":"  978","line":"  }"},
{"lineNum":"  979","line":""},
{"lineNum":"  980","line":"  //! Loading arithmetic from JSON"},
{"lineNum":"  981","line":"  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline"},
{"lineNum":"  982","line":"  void CEREAL_LOAD_FUNCTION_NAME(JSONInputArchive & ar, T & t)"},
{"lineNum":"  983","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  984","line":"    ar.loadValue( t );","class":"lineNoCov","hits":"0","possible_hits":"70",},
{"lineNum":"  985","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  986","line":""},
{"lineNum":"  987","line":"  //! saving string to JSON"},
{"lineNum":"  988","line":"  template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  989","line":"  void CEREAL_SAVE_FUNCTION_NAME(JSONOutputArchive & ar, std::basic_string<CharT, Traits, Alloc> const & str)"},
{"lineNum":"  990","line":"  {"},
{"lineNum":"  991","line":"    ar.saveValue( str );","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  992","line":"  }"},
{"lineNum":"  993","line":""},
{"lineNum":"  994","line":"  //! loading string from JSON"},
{"lineNum":"  995","line":"  template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  996","line":"  void CEREAL_LOAD_FUNCTION_NAME(JSONInputArchive & ar, std::basic_string<CharT, Traits, Alloc> & str)"},
{"lineNum":"  997","line":"  {"},
{"lineNum":"  998","line":"    ar.loadValue( str );","class":"lineNoCov","hits":"0","possible_hits":"41",},
{"lineNum":"  999","line":"  }"},
{"lineNum":" 1000","line":""},
{"lineNum":" 1001","line":"  // ######################################################################"},
{"lineNum":" 1002","line":"  //! Saving SizeTags to JSON"},
{"lineNum":" 1003","line":"  template <class T> inline"},
{"lineNum":" 1004","line":"  void CEREAL_SAVE_FUNCTION_NAME( JSONOutputArchive &, SizeTag<T> const & )"},
{"lineNum":" 1005","line":"  {"},
{"lineNum":" 1006","line":"    // nothing to do here, we don\'t explicitly save the size"},
{"lineNum":" 1007","line":"  }"},
{"lineNum":" 1008","line":""},
{"lineNum":" 1009","line":"  //! Loading SizeTags from JSON"},
{"lineNum":" 1010","line":"  template <class T> inline"},
{"lineNum":" 1011","line":"  void CEREAL_LOAD_FUNCTION_NAME( JSONInputArchive & ar, SizeTag<T> & st )"},
{"lineNum":" 1012","line":"  {"},
{"lineNum":" 1013","line":"    ar.loadSize( st.size );","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":" 1014","line":"  }"},
{"lineNum":" 1015","line":"} // namespace cereal"},
{"lineNum":" 1016","line":""},
{"lineNum":" 1017","line":"// register archives for polymorphic support"},
{"lineNum":" 1018","line":"CEREAL_REGISTER_ARCHIVE(cereal::JSONInputArchive)"},
{"lineNum":" 1019","line":"CEREAL_REGISTER_ARCHIVE(cereal::JSONOutputArchive)"},
{"lineNum":" 1020","line":""},
{"lineNum":" 1021","line":"// tie input and output archives together"},
{"lineNum":" 1022","line":"CEREAL_SETUP_ARCHIVE_TRAITS(cereal::JSONInputArchive, cereal::JSONOutputArchive)"},
{"lineNum":" 1023","line":""},
{"lineNum":" 1024","line":"#endif // CEREAL_ARCHIVES_JSON_HPP_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 132, "covered" : 0,};
var merged_data = [];
