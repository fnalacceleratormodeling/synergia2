var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2006-2009 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"// Copyright (C) 2010-2013 Hauke Heibel <hauke.heibel@gmail.com>"},
{"lineNum":"    7","line":"//"},
{"lineNum":"    8","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    9","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"   10","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"#ifndef EIGEN_MATRIXSTORAGE_H"},
{"lineNum":"   13","line":"#define EIGEN_MATRIXSTORAGE_H"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"#ifdef EIGEN_DENSE_STORAGE_CTOR_PLUGIN"},
{"lineNum":"   16","line":"  #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(X) X; EIGEN_DENSE_STORAGE_CTOR_PLUGIN;"},
{"lineNum":"   17","line":"#else"},
{"lineNum":"   18","line":"  #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(X)"},
{"lineNum":"   19","line":"#endif"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"namespace Eigen {"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"namespace internal {"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"struct constructor_without_unaligned_array_assert {};"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"template<typename T, int Size>"},
{"lineNum":"   30","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"   31","line":"void check_static_allocation_size()"},
{"lineNum":"   32","line":"{"},
{"lineNum":"   33","line":"  // if EIGEN_STACK_ALLOCATION_LIMIT is defined to 0, then no limit"},
{"lineNum":"   34","line":"  #if EIGEN_STACK_ALLOCATION_LIMIT"},
{"lineNum":"   35","line":"  EIGEN_STATIC_ASSERT(Size * sizeof(T) <= EIGEN_STACK_ALLOCATION_LIMIT, OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG);"},
{"lineNum":"   36","line":"  #endif"},
{"lineNum":"   37","line":"}"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"/** \\internal"},
{"lineNum":"   40","line":"  * Static array. If the MatrixOrArrayOptions require auto-alignment, the array will be automatically aligned:"},
{"lineNum":"   41","line":"  * to 16 bytes boundary if the total size is a multiple of 16 bytes."},
{"lineNum":"   42","line":"  */"},
{"lineNum":"   43","line":"template <typename T, int Size, int MatrixOrArrayOptions,"},
{"lineNum":"   44","line":"          int Alignment = (MatrixOrArrayOptions&DontAlign) ? 0"},
{"lineNum":"   45","line":"                        : compute_default_alignment<T,Size>::value >"},
{"lineNum":"   46","line":"struct plain_array"},
{"lineNum":"   47","line":"{"},
{"lineNum":"   48","line":"  T array[Size];"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   51","line":"  plain_array()"},
{"lineNum":"   52","line":"  {"},
{"lineNum":"   53","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"   54","line":"  }"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   57","line":"  plain_array(constructor_without_unaligned_array_assert)"},
{"lineNum":"   58","line":"  {"},
{"lineNum":"   59","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"   60","line":"  }"},
{"lineNum":"   61","line":"};"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"#if defined(EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT)"},
{"lineNum":"   64","line":"  #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask)"},
{"lineNum":"   65","line":"#elif EIGEN_GNUC_AT_LEAST(4,7)"},
{"lineNum":"   66","line":"  // GCC 4.7 is too aggressive in its optimizations and remove the alignment test based on the fact the array is declared to be aligned."},
{"lineNum":"   67","line":"  // See this bug report: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=53900"},
{"lineNum":"   68","line":"  // Hiding the origin of the array pointer behind a function argument seems to do the trick even if the function is inlined:"},
{"lineNum":"   69","line":"  template<typename PtrType>"},
{"lineNum":"   70","line":"  EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }"},
{"lineNum":"   71","line":"  #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \\"},
{"lineNum":"   72","line":"    eigen_assert((internal::UIntPtr(eigen_unaligned_array_assert_workaround_gcc47(array)) & (sizemask)) == 0 \\"},
{"lineNum":"   73","line":"              && \"this assertion is explained here: \" \\"},
{"lineNum":"   74","line":"              \"http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html\" \\"},
{"lineNum":"   75","line":"              \" **** READ THIS WEB PAGE !!! ****\");"},
{"lineNum":"   76","line":"#else"},
{"lineNum":"   77","line":"  #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(sizemask) \\"},
{"lineNum":"   78","line":"    eigen_assert((internal::UIntPtr(array) & (sizemask)) == 0 \\"},
{"lineNum":"   79","line":"              && \"this assertion is explained here: \" \\"},
{"lineNum":"   80","line":"              \"http://eigen.tuxfamily.org/dox-devel/group__TopicUnalignedArrayAssert.html\" \\"},
{"lineNum":"   81","line":"              \" **** READ THIS WEB PAGE !!! ****\");"},
{"lineNum":"   82","line":"#endif"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"template <typename T, int Size, int MatrixOrArrayOptions>"},
{"lineNum":"   85","line":"struct plain_array<T, Size, MatrixOrArrayOptions, 8>"},
{"lineNum":"   86","line":"{"},
{"lineNum":"   87","line":"  EIGEN_ALIGN_TO_BOUNDARY(8) T array[Size];"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   90","line":"  plain_array()"},
{"lineNum":"   91","line":"  {"},
{"lineNum":"   92","line":"    EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(7);"},
{"lineNum":"   93","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"   94","line":"  }"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   97","line":"  plain_array(constructor_without_unaligned_array_assert)"},
{"lineNum":"   98","line":"  {"},
{"lineNum":"   99","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"  100","line":"  }"},
{"lineNum":"  101","line":"};"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"template <typename T, int Size, int MatrixOrArrayOptions>"},
{"lineNum":"  104","line":"struct plain_array<T, Size, MatrixOrArrayOptions, 16>"},
{"lineNum":"  105","line":"{"},
{"lineNum":"  106","line":"  EIGEN_ALIGN_TO_BOUNDARY(16) T array[Size];"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  109","line":"  plain_array()"},
{"lineNum":"  110","line":"  {"},
{"lineNum":"  111","line":"    EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(15);"},
{"lineNum":"  112","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"  113","line":"  }"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  116","line":"  plain_array(constructor_without_unaligned_array_assert)"},
{"lineNum":"  117","line":"  {"},
{"lineNum":"  118","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"  119","line":"  }"},
{"lineNum":"  120","line":"};"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"template <typename T, int Size, int MatrixOrArrayOptions>"},
{"lineNum":"  123","line":"struct plain_array<T, Size, MatrixOrArrayOptions, 32>"},
{"lineNum":"  124","line":"{"},
{"lineNum":"  125","line":"  EIGEN_ALIGN_TO_BOUNDARY(32) T array[Size];"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  128","line":"  plain_array()"},
{"lineNum":"  129","line":"  {"},
{"lineNum":"  130","line":"    EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(31);"},
{"lineNum":"  131","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"  132","line":"  }"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  135","line":"  plain_array(constructor_without_unaligned_array_assert)"},
{"lineNum":"  136","line":"  {"},
{"lineNum":"  137","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"  138","line":"  }"},
{"lineNum":"  139","line":"};"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"template <typename T, int Size, int MatrixOrArrayOptions>"},
{"lineNum":"  142","line":"struct plain_array<T, Size, MatrixOrArrayOptions, 64>"},
{"lineNum":"  143","line":"{"},
{"lineNum":"  144","line":"  EIGEN_ALIGN_TO_BOUNDARY(64) T array[Size];"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  147","line":"  plain_array()"},
{"lineNum":"  148","line":"  {"},
{"lineNum":"  149","line":"    EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(63);"},
{"lineNum":"  150","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"  151","line":"  }"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  154","line":"  plain_array(constructor_without_unaligned_array_assert)"},
{"lineNum":"  155","line":"  {"},
{"lineNum":"  156","line":"    check_static_allocation_size<T,Size>();"},
{"lineNum":"  157","line":"  }"},
{"lineNum":"  158","line":"};"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"template <typename T, int MatrixOrArrayOptions, int Alignment>"},
{"lineNum":"  161","line":"struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>"},
{"lineNum":"  162","line":"{"},
{"lineNum":"  163","line":"  T array[1];"},
{"lineNum":"  164","line":"  EIGEN_DEVICE_FUNC plain_array() {}"},
{"lineNum":"  165","line":"  EIGEN_DEVICE_FUNC plain_array(constructor_without_unaligned_array_assert) {}"},
{"lineNum":"  166","line":"};"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"struct plain_array_helper {"},
{"lineNum":"  169","line":"  template<typename T, int Size, int MatrixOrArrayOptions, int Alignment>"},
{"lineNum":"  170","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  171","line":"  static void copy(const plain_array<T, Size, MatrixOrArrayOptions, Alignment>& src, const Eigen::Index size,"},
{"lineNum":"  172","line":"                         plain_array<T, Size, MatrixOrArrayOptions, Alignment>& dst) {"},
{"lineNum":"  173","line":"    smart_copy(src.array, src.array + size, dst.array);"},
{"lineNum":"  174","line":"  }"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"  template<typename T, int Size, int MatrixOrArrayOptions, int Alignment>"},
{"lineNum":"  177","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  178","line":"  static void swap(plain_array<T, Size, MatrixOrArrayOptions, Alignment>& a, const Eigen::Index a_size,"},
{"lineNum":"  179","line":"                   plain_array<T, Size, MatrixOrArrayOptions, Alignment>& b, const Eigen::Index b_size) {"},
{"lineNum":"  180","line":"    if (a_size < b_size) {"},
{"lineNum":"  181","line":"      std::swap_ranges(b.array, b.array + a_size, a.array);"},
{"lineNum":"  182","line":"      smart_move(b.array + a_size, b.array + b_size, a.array + a_size);"},
{"lineNum":"  183","line":"    } else if (a_size > b_size) {"},
{"lineNum":"  184","line":"      std::swap_ranges(a.array, a.array + b_size, b.array);"},
{"lineNum":"  185","line":"      smart_move(a.array + b_size, a.array + a_size, b.array + b_size);"},
{"lineNum":"  186","line":"    } else {"},
{"lineNum":"  187","line":"      std::swap_ranges(a.array, a.array + a_size, b.array);"},
{"lineNum":"  188","line":"    }"},
{"lineNum":"  189","line":"  }"},
{"lineNum":"  190","line":"};"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"} // end namespace internal"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"/** \\internal"},
{"lineNum":"  195","line":"  *"},
{"lineNum":"  196","line":"  * \\class DenseStorage"},
{"lineNum":"  197","line":"  * \\ingroup Core_Module"},
{"lineNum":"  198","line":"  *"},
{"lineNum":"  199","line":"  * \\brief Stores the data of a matrix"},
{"lineNum":"  200","line":"  *"},
{"lineNum":"  201","line":"  * This class stores the data of fixed-size, dynamic-size or mixed matrices"},
{"lineNum":"  202","line":"  * in a way as compact as possible."},
{"lineNum":"  203","line":"  *"},
{"lineNum":"  204","line":"  * \\sa Matrix"},
{"lineNum":"  205","line":"  */"},
{"lineNum":"  206","line":"template<typename T, int Size, int Rows_, int Cols_, int Options_> class DenseStorage;"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"// purely fixed-size matrix"},
{"lineNum":"  209","line":"template<typename T, int Size, int Rows_, int Cols_, int Options_> class DenseStorage"},
{"lineNum":"  210","line":"{"},
{"lineNum":"  211","line":"    internal::plain_array<T,Size,Options_> m_data;"},
{"lineNum":"  212","line":"  public:"},
{"lineNum":"  213","line":"    EIGEN_DEVICE_FUNC DenseStorage() {"},
{"lineNum":"  214","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)"},
{"lineNum":"  215","line":"    }"},
{"lineNum":"  216","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  217","line":"    explicit DenseStorage(internal::constructor_without_unaligned_array_assert)"},
{"lineNum":"  218","line":"      : m_data(internal::constructor_without_unaligned_array_assert()) {}"},
{"lineNum":"  219","line":"#if !EIGEN_HAS_CXX11 || defined(EIGEN_DENSE_STORAGE_CTOR_PLUGIN)"},
{"lineNum":"  220","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  221","line":"    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {"},
{"lineNum":"  222","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = Size)"},
{"lineNum":"  223","line":"    }"},
{"lineNum":"  224","line":"#else"},
{"lineNum":"  225","line":"    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&) = default;"},
{"lineNum":"  226","line":"#endif"},
{"lineNum":"  227","line":"#if !EIGEN_HAS_CXX11"},
{"lineNum":"  228","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  229","line":"    DenseStorage& operator=(const DenseStorage& other)"},
{"lineNum":"  230","line":"    {"},
{"lineNum":"  231","line":"      if (this != &other) m_data = other.m_data;"},
{"lineNum":"  232","line":"      return *this;"},
{"lineNum":"  233","line":"    }"},
{"lineNum":"  234","line":"#else"},
{"lineNum":"  235","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage&) = default;"},
{"lineNum":"  236","line":"#endif"},
{"lineNum":"  237","line":"#if EIGEN_HAS_RVALUE_REFERENCES"},
{"lineNum":"  238","line":"#if !EIGEN_HAS_CXX11"},
{"lineNum":"  239","line":"    EIGEN_DEVICE_FUNC DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  240","line":"      : m_data(std::move(other.m_data))"},
{"lineNum":"  241","line":"    {"},
{"lineNum":"  242","line":"    }"},
{"lineNum":"  243","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  244","line":"    {"},
{"lineNum":"  245","line":"      if (this != &other)"},
{"lineNum":"  246","line":"        m_data = std::move(other.m_data);"},
{"lineNum":"  247","line":"      return *this;"},
{"lineNum":"  248","line":"    }"},
{"lineNum":"  249","line":"#else"},
{"lineNum":"  250","line":"    EIGEN_DEVICE_FUNC DenseStorage(DenseStorage&&) = default;"},
{"lineNum":"  251","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(DenseStorage&&) = default;"},
{"lineNum":"  252","line":"#endif"},
{"lineNum":"  253","line":"#endif"},
{"lineNum":"  254","line":"    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) {"},
{"lineNum":"  255","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})"},
{"lineNum":"  256","line":"      eigen_internal_assert(size==rows*cols && rows==Rows_ && cols==Cols_);"},
{"lineNum":"  257","line":"      EIGEN_UNUSED_VARIABLE(size);"},
{"lineNum":"  258","line":"      EIGEN_UNUSED_VARIABLE(rows);"},
{"lineNum":"  259","line":"      EIGEN_UNUSED_VARIABLE(cols);"},
{"lineNum":"  260","line":"    }"},
{"lineNum":"  261","line":"    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {"},
{"lineNum":"  262","line":"      numext::swap(m_data, other.m_data);"},
{"lineNum":"  263","line":"    }"},
{"lineNum":"  264","line":"    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return Rows_;}"},
{"lineNum":"  265","line":"    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index cols(void) EIGEN_NOEXCEPT {return Cols_;}"},
{"lineNum":"  266","line":"    EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}"},
{"lineNum":"  267","line":"    EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}"},
{"lineNum":"  268","line":"    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }"},
{"lineNum":"  269","line":"    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }"},
{"lineNum":"  270","line":"};"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"// null matrix"},
{"lineNum":"  273","line":"template<typename T, int Rows_, int Cols_, int Options_> class DenseStorage<T, 0, Rows_, Cols_, Options_>"},
{"lineNum":"  274","line":"{"},
{"lineNum":"  275","line":"  public:"},
{"lineNum":"  276","line":"    EIGEN_DEVICE_FUNC DenseStorage() {}"},
{"lineNum":"  277","line":"    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert) {}"},
{"lineNum":"  278","line":"    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage&) {}"},
{"lineNum":"  279","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage&) { return *this; }"},
{"lineNum":"  280","line":"    EIGEN_DEVICE_FUNC DenseStorage(Index,Index,Index) {}"},
{"lineNum":"  281","line":"    EIGEN_DEVICE_FUNC void swap(DenseStorage& ) {}"},
{"lineNum":"  282","line":"    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return Rows_;}"},
{"lineNum":"  283","line":"    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index cols(void) EIGEN_NOEXCEPT {return Cols_;}"},
{"lineNum":"  284","line":"    EIGEN_DEVICE_FUNC void conservativeResize(Index,Index,Index) {}"},
{"lineNum":"  285","line":"    EIGEN_DEVICE_FUNC void resize(Index,Index,Index) {}"},
{"lineNum":"  286","line":"    EIGEN_DEVICE_FUNC const T *data() const { return 0; }"},
{"lineNum":"  287","line":"    EIGEN_DEVICE_FUNC T *data() { return 0; }"},
{"lineNum":"  288","line":"};"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"// more specializations for null matrices; these are necessary to resolve ambiguities"},
{"lineNum":"  291","line":"template<typename T, int Options_> class DenseStorage<T, 0, Dynamic, Dynamic, Options_>"},
{"lineNum":"  292","line":": public DenseStorage<T, 0, 0, 0, Options_> { };"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"template<typename T, int Rows_, int Options_> class DenseStorage<T, 0, Rows_, Dynamic, Options_>"},
{"lineNum":"  295","line":": public DenseStorage<T, 0, 0, 0, Options_> { };"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"template<typename T, int Cols_, int Options_> class DenseStorage<T, 0, Dynamic, Cols_, Options_>"},
{"lineNum":"  298","line":": public DenseStorage<T, 0, 0, 0, Options_> { };"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"// dynamic-size matrix with fixed-size storage"},
{"lineNum":"  301","line":"template<typename T, int Size, int Options_> class DenseStorage<T, Size, Dynamic, Dynamic, Options_>"},
{"lineNum":"  302","line":"{"},
{"lineNum":"  303","line":"    internal::plain_array<T,Size,Options_> m_data;"},
{"lineNum":"  304","line":"    Index m_rows;"},
{"lineNum":"  305","line":"    Index m_cols;"},
{"lineNum":"  306","line":"  public:"},
{"lineNum":"  307","line":"    EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0), m_cols(0) {}"},
{"lineNum":"  308","line":"    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)"},
{"lineNum":"  309","line":"      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0), m_cols(0) {}"},
{"lineNum":"  310","line":"    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)"},
{"lineNum":"  311","line":"      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(other.m_rows), m_cols(other.m_cols)"},
{"lineNum":"  312","line":"    {"},
{"lineNum":"  313","line":"      internal::plain_array_helper::copy(other.m_data, m_rows * m_cols, m_data);"},
{"lineNum":"  314","line":"    }"},
{"lineNum":"  315","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)"},
{"lineNum":"  316","line":"    {"},
{"lineNum":"  317","line":"      if (this != &other)"},
{"lineNum":"  318","line":"      {"},
{"lineNum":"  319","line":"        m_rows = other.m_rows;"},
{"lineNum":"  320","line":"        m_cols = other.m_cols;"},
{"lineNum":"  321","line":"        internal::plain_array_helper::copy(other.m_data, m_rows * m_cols, m_data);"},
{"lineNum":"  322","line":"      }"},
{"lineNum":"  323","line":"      return *this;"},
{"lineNum":"  324","line":"    }"},
{"lineNum":"  325","line":"    EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index cols) : m_rows(rows), m_cols(cols) {}"},
{"lineNum":"  326","line":"    EIGEN_DEVICE_FUNC void swap(DenseStorage& other)"},
{"lineNum":"  327","line":"    {"},
{"lineNum":"  328","line":"      internal::plain_array_helper::swap(m_data, m_rows * m_cols, other.m_data, other.m_rows * other.m_cols);"},
{"lineNum":"  329","line":"      numext::swap(m_rows,other.m_rows);"},
{"lineNum":"  330","line":"      numext::swap(m_cols,other.m_cols);"},
{"lineNum":"  331","line":"    }"},
{"lineNum":"  332","line":"    EIGEN_DEVICE_FUNC Index rows() const {return m_rows;}"},
{"lineNum":"  333","line":"    EIGEN_DEVICE_FUNC Index cols() const {return m_cols;}"},
{"lineNum":"  334","line":"    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }"},
{"lineNum":"  335","line":"    EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index cols) { m_rows = rows; m_cols = cols; }"},
{"lineNum":"  336","line":"    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }"},
{"lineNum":"  337","line":"    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }"},
{"lineNum":"  338","line":"};"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"// dynamic-size matrix with fixed-size storage and fixed width"},
{"lineNum":"  341","line":"template<typename T, int Size, int Cols_, int Options_> class DenseStorage<T, Size, Dynamic, Cols_, Options_>"},
{"lineNum":"  342","line":"{"},
{"lineNum":"  343","line":"    internal::plain_array<T,Size,Options_> m_data;"},
{"lineNum":"  344","line":"    Index m_rows;"},
{"lineNum":"  345","line":"  public:"},
{"lineNum":"  346","line":"    EIGEN_DEVICE_FUNC DenseStorage() : m_rows(0) {}"},
{"lineNum":"  347","line":"    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)"},
{"lineNum":"  348","line":"      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(0) {}"},
{"lineNum":"  349","line":"    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)"},
{"lineNum":"  350","line":"      : m_data(internal::constructor_without_unaligned_array_assert()), m_rows(other.m_rows)"},
{"lineNum":"  351","line":"    {"},
{"lineNum":"  352","line":"      internal::plain_array_helper::copy(other.m_data, m_rows * Cols_, m_data);"},
{"lineNum":"  353","line":"    }"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)"},
{"lineNum":"  356","line":"    {"},
{"lineNum":"  357","line":"      if (this != &other)"},
{"lineNum":"  358","line":"      {"},
{"lineNum":"  359","line":"        m_rows = other.m_rows;"},
{"lineNum":"  360","line":"        internal::plain_array_helper::copy(other.m_data, m_rows * Cols_, m_data);"},
{"lineNum":"  361","line":"      }"},
{"lineNum":"  362","line":"      return *this;"},
{"lineNum":"  363","line":"    }"},
{"lineNum":"  364","line":"    EIGEN_DEVICE_FUNC DenseStorage(Index, Index rows, Index) : m_rows(rows) {}"},
{"lineNum":"  365","line":"    EIGEN_DEVICE_FUNC void swap(DenseStorage& other)"},
{"lineNum":"  366","line":"    {"},
{"lineNum":"  367","line":"      internal::plain_array_helper::swap(m_data, m_rows * Cols_, other.m_data, other.m_rows * Cols_);"},
{"lineNum":"  368","line":"      numext::swap(m_rows, other.m_rows);"},
{"lineNum":"  369","line":"    }"},
{"lineNum":"  370","line":"    EIGEN_DEVICE_FUNC Index rows(void) const EIGEN_NOEXCEPT {return m_rows;}"},
{"lineNum":"  371","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index cols(void) const EIGEN_NOEXCEPT {return Cols_;}"},
{"lineNum":"  372","line":"    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index rows, Index) { m_rows = rows; }"},
{"lineNum":"  373","line":"    EIGEN_DEVICE_FUNC void resize(Index, Index rows, Index) { m_rows = rows; }"},
{"lineNum":"  374","line":"    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }"},
{"lineNum":"  375","line":"    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }"},
{"lineNum":"  376","line":"};"},
{"lineNum":"  377","line":""},
{"lineNum":"  378","line":"// dynamic-size matrix with fixed-size storage and fixed height"},
{"lineNum":"  379","line":"template<typename T, int Size, int Rows_, int Options_> class DenseStorage<T, Size, Rows_, Dynamic, Options_>"},
{"lineNum":"  380","line":"{"},
{"lineNum":"  381","line":"    internal::plain_array<T,Size,Options_> m_data;"},
{"lineNum":"  382","line":"    Index m_cols;"},
{"lineNum":"  383","line":"  public:"},
{"lineNum":"  384","line":"    EIGEN_DEVICE_FUNC DenseStorage() : m_cols(0) {}"},
{"lineNum":"  385","line":"    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)"},
{"lineNum":"  386","line":"      : m_data(internal::constructor_without_unaligned_array_assert()), m_cols(0) {}"},
{"lineNum":"  387","line":"    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)"},
{"lineNum":"  388","line":"      : m_data(internal::constructor_without_unaligned_array_assert()), m_cols(other.m_cols)"},
{"lineNum":"  389","line":"    {"},
{"lineNum":"  390","line":"      internal::plain_array_helper::copy(other.m_data, Rows_ * m_cols, m_data);"},
{"lineNum":"  391","line":"    }"},
{"lineNum":"  392","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)"},
{"lineNum":"  393","line":"    {"},
{"lineNum":"  394","line":"      if (this != &other)"},
{"lineNum":"  395","line":"      {"},
{"lineNum":"  396","line":"        m_cols = other.m_cols;"},
{"lineNum":"  397","line":"        internal::plain_array_helper::copy(other.m_data, Rows_ * m_cols, m_data);"},
{"lineNum":"  398","line":"      }"},
{"lineNum":"  399","line":"      return *this;"},
{"lineNum":"  400","line":"    }"},
{"lineNum":"  401","line":"    EIGEN_DEVICE_FUNC DenseStorage(Index, Index, Index cols) : m_cols(cols) {}"},
{"lineNum":"  402","line":"    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {"},
{"lineNum":"  403","line":"      internal::plain_array_helper::swap(m_data, Rows_ * m_cols, other.m_data, Rows_ * other.m_cols);"},
{"lineNum":"  404","line":"      numext::swap(m_cols, other.m_cols);"},
{"lineNum":"  405","line":"    }"},
{"lineNum":"  406","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index rows(void) const EIGEN_NOEXCEPT {return Rows_;}"},
{"lineNum":"  407","line":"    EIGEN_DEVICE_FUNC Index cols(void) const EIGEN_NOEXCEPT {return m_cols;}"},
{"lineNum":"  408","line":"    EIGEN_DEVICE_FUNC void conservativeResize(Index, Index, Index cols) { m_cols = cols; }"},
{"lineNum":"  409","line":"    EIGEN_DEVICE_FUNC void resize(Index, Index, Index cols) { m_cols = cols; }"},
{"lineNum":"  410","line":"    EIGEN_DEVICE_FUNC const T *data() const { return m_data.array; }"},
{"lineNum":"  411","line":"    EIGEN_DEVICE_FUNC T *data() { return m_data.array; }"},
{"lineNum":"  412","line":"};"},
{"lineNum":"  413","line":""},
{"lineNum":"  414","line":"// purely dynamic matrix."},
{"lineNum":"  415","line":"template<typename T, int Options_> class DenseStorage<T, Dynamic, Dynamic, Dynamic, Options_>"},
{"lineNum":"  416","line":"{"},
{"lineNum":"  417","line":"    T *m_data;"},
{"lineNum":"  418","line":"    Index m_rows;"},
{"lineNum":"  419","line":"    Index m_cols;"},
{"lineNum":"  420","line":"  public:"},
{"lineNum":"  421","line":"    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}","class":"lineNoCov","hits":"0","possible_hits":"62",},
{"lineNum":"  422","line":"    EIGEN_DEVICE_FUNC explicit DenseStorage(internal::constructor_without_unaligned_array_assert)"},
{"lineNum":"  423","line":"       : m_data(0), m_rows(0), m_cols(0) {}"},
{"lineNum":"  424","line":"    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols)"},
{"lineNum":"  425","line":"      : m_data(internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(size)), m_rows(rows), m_cols(cols)"},
{"lineNum":"  426","line":"    {"},
{"lineNum":"  427","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})"},
{"lineNum":"  428","line":"      eigen_internal_assert(size==rows*cols && rows>=0 && cols >=0);"},
{"lineNum":"  429","line":"    }"},
{"lineNum":"  430","line":"    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)"},
{"lineNum":"  431","line":"      : m_data(internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(other.m_rows*other.m_cols))","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  432","line":"      , m_rows(other.m_rows)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  433","line":"      , m_cols(other.m_cols)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  434","line":"    {"},
{"lineNum":"  435","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_rows*m_cols)"},
{"lineNum":"  436","line":"      internal::smart_copy(other.m_data, other.m_data+other.m_rows*other.m_cols, m_data);","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  437","line":"    }"},
{"lineNum":"  438","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)"},
{"lineNum":"  439","line":"    {"},
{"lineNum":"  440","line":"      if (this != &other)"},
{"lineNum":"  441","line":"      {"},
{"lineNum":"  442","line":"        DenseStorage tmp(other);"},
{"lineNum":"  443","line":"        this->swap(tmp);"},
{"lineNum":"  444","line":"      }"},
{"lineNum":"  445","line":"      return *this;"},
{"lineNum":"  446","line":"    }"},
{"lineNum":"  447","line":"#if EIGEN_HAS_RVALUE_REFERENCES"},
{"lineNum":"  448","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  449","line":"    DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  450","line":"      : m_data(std::move(other.m_data))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  451","line":"      , m_rows(std::move(other.m_rows))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  452","line":"      , m_cols(std::move(other.m_cols))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  453","line":"    {"},
{"lineNum":"  454","line":"      other.m_data = nullptr;"},
{"lineNum":"  455","line":"      other.m_rows = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  456","line":"      other.m_cols = 0;"},
{"lineNum":"  457","line":"    }"},
{"lineNum":"  458","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  459","line":"    DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  460","line":"    {"},
{"lineNum":"  461","line":"      numext::swap(m_data, other.m_data);"},
{"lineNum":"  462","line":"      numext::swap(m_rows, other.m_rows);"},
{"lineNum":"  463","line":"      numext::swap(m_cols, other.m_cols);"},
{"lineNum":"  464","line":"      return *this;"},
{"lineNum":"  465","line":"    }"},
{"lineNum":"  466","line":"#endif"},
{"lineNum":"  467","line":"    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(Options_&DontAlign)==0>(m_data, m_rows*m_cols); }","class":"lineNoCov","hits":"0","possible_hits":"120",},
{"lineNum":"  468","line":"    EIGEN_DEVICE_FUNC void swap(DenseStorage& other)"},
{"lineNum":"  469","line":"    {"},
{"lineNum":"  470","line":"      numext::swap(m_data,other.m_data);"},
{"lineNum":"  471","line":"      numext::swap(m_rows,other.m_rows);"},
{"lineNum":"  472","line":"      numext::swap(m_cols,other.m_cols);"},
{"lineNum":"  473","line":"    }"},
{"lineNum":"  474","line":"    EIGEN_DEVICE_FUNC Index rows(void) const EIGEN_NOEXCEPT {return m_rows;}","class":"lineNoCov","hits":"0","possible_hits":"345",},
{"lineNum":"  475","line":"    EIGEN_DEVICE_FUNC Index cols(void) const EIGEN_NOEXCEPT {return m_cols;}","class":"lineNoCov","hits":"0","possible_hits":"324",},
{"lineNum":"  476","line":"    void conservativeResize(Index size, Index rows, Index cols)"},
{"lineNum":"  477","line":"    {"},
{"lineNum":"  478","line":"      m_data = internal::conditional_aligned_realloc_new_auto<T,(Options_&DontAlign)==0>(m_data, size, m_rows*m_cols);"},
{"lineNum":"  479","line":"      m_rows = rows;"},
{"lineNum":"  480","line":"      m_cols = cols;"},
{"lineNum":"  481","line":"    }"},
{"lineNum":"  482","line":"    EIGEN_DEVICE_FUNC void resize(Index size, Index rows, Index cols)"},
{"lineNum":"  483","line":"    {"},
{"lineNum":"  484","line":"      if(size != m_rows*m_cols)","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  485","line":"      {"},
{"lineNum":"  486","line":"        internal::conditional_aligned_delete_auto<T,(Options_&DontAlign)==0>(m_data, m_rows*m_cols);","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  487","line":"        if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  488","line":"          m_data = internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(size);"},
{"lineNum":"  489","line":"        else"},
{"lineNum":"  490","line":"          m_data = 0;"},
{"lineNum":"  491","line":"        EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})"},
{"lineNum":"  492","line":"      }"},
{"lineNum":"  493","line":"      m_rows = rows;","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  494","line":"      m_cols = cols;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  495","line":"    }"},
{"lineNum":"  496","line":"    EIGEN_DEVICE_FUNC const T *data() const { return m_data; }","class":"lineNoCov","hits":"0","possible_hits":"204",},
{"lineNum":"  497","line":"    EIGEN_DEVICE_FUNC T *data() { return m_data; }","class":"lineNoCov","hits":"0","possible_hits":"114",},
{"lineNum":"  498","line":"};"},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"// matrix with dynamic width and fixed height (so that matrix has dynamic size)."},
{"lineNum":"  501","line":"template<typename T, int Rows_, int Options_> class DenseStorage<T, Dynamic, Rows_, Dynamic, Options_>"},
{"lineNum":"  502","line":"{"},
{"lineNum":"  503","line":"    T *m_data;"},
{"lineNum":"  504","line":"    Index m_cols;"},
{"lineNum":"  505","line":"  public:"},
{"lineNum":"  506","line":"    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_cols(0) {}","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  507","line":"    explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}"},
{"lineNum":"  508","line":"    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(size)), m_cols(cols)"},
{"lineNum":"  509","line":"    {"},
{"lineNum":"  510","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})"},
{"lineNum":"  511","line":"      eigen_internal_assert(size==rows*cols && rows==Rows_ && cols >=0);"},
{"lineNum":"  512","line":"      EIGEN_UNUSED_VARIABLE(rows);"},
{"lineNum":"  513","line":"    }"},
{"lineNum":"  514","line":"    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)"},
{"lineNum":"  515","line":"      : m_data(internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(Rows_*other.m_cols))"},
{"lineNum":"  516","line":"      , m_cols(other.m_cols)"},
{"lineNum":"  517","line":"    {"},
{"lineNum":"  518","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_cols*Rows_)"},
{"lineNum":"  519","line":"      internal::smart_copy(other.m_data, other.m_data+Rows_*m_cols, m_data);"},
{"lineNum":"  520","line":"    }"},
{"lineNum":"  521","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)"},
{"lineNum":"  522","line":"    {"},
{"lineNum":"  523","line":"      if (this != &other)"},
{"lineNum":"  524","line":"      {"},
{"lineNum":"  525","line":"        DenseStorage tmp(other);"},
{"lineNum":"  526","line":"        this->swap(tmp);"},
{"lineNum":"  527","line":"      }"},
{"lineNum":"  528","line":"      return *this;"},
{"lineNum":"  529","line":"    }"},
{"lineNum":"  530","line":"#if EIGEN_HAS_RVALUE_REFERENCES"},
{"lineNum":"  531","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  532","line":"    DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  533","line":"      : m_data(std::move(other.m_data))"},
{"lineNum":"  534","line":"      , m_cols(std::move(other.m_cols))"},
{"lineNum":"  535","line":"    {"},
{"lineNum":"  536","line":"      other.m_data = nullptr;"},
{"lineNum":"  537","line":"      other.m_cols = 0;"},
{"lineNum":"  538","line":"    }"},
{"lineNum":"  539","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  540","line":"    DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  541","line":"    {"},
{"lineNum":"  542","line":"      numext::swap(m_data, other.m_data);"},
{"lineNum":"  543","line":"      numext::swap(m_cols, other.m_cols);"},
{"lineNum":"  544","line":"      return *this;"},
{"lineNum":"  545","line":"    }"},
{"lineNum":"  546","line":"#endif"},
{"lineNum":"  547","line":"    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(Options_&DontAlign)==0>(m_data, Rows_*m_cols); }","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  548","line":"    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {"},
{"lineNum":"  549","line":"      numext::swap(m_data,other.m_data);"},
{"lineNum":"  550","line":"      numext::swap(m_cols,other.m_cols);"},
{"lineNum":"  551","line":"    }"},
{"lineNum":"  552","line":"    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index rows(void) EIGEN_NOEXCEPT {return Rows_;}"},
{"lineNum":"  553","line":"    EIGEN_DEVICE_FUNC Index cols(void) const EIGEN_NOEXCEPT {return m_cols;}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  554","line":"    EIGEN_DEVICE_FUNC void conservativeResize(Index size, Index, Index cols)"},
{"lineNum":"  555","line":"    {"},
{"lineNum":"  556","line":"      m_data = internal::conditional_aligned_realloc_new_auto<T,(Options_&DontAlign)==0>(m_data, size, Rows_*m_cols);"},
{"lineNum":"  557","line":"      m_cols = cols;"},
{"lineNum":"  558","line":"    }"},
{"lineNum":"  559","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index, Index cols)"},
{"lineNum":"  560","line":"    {"},
{"lineNum":"  561","line":"      if(size != Rows_*m_cols)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  562","line":"      {"},
{"lineNum":"  563","line":"        internal::conditional_aligned_delete_auto<T,(Options_&DontAlign)==0>(m_data, Rows_*m_cols);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  564","line":"        if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  565","line":"          m_data = internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(size);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  566","line":"        else"},
{"lineNum":"  567","line":"          m_data = 0;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  568","line":"        EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})"},
{"lineNum":"  569","line":"      }"},
{"lineNum":"  570","line":"      m_cols = cols;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  571","line":"    }"},
{"lineNum":"  572","line":"    EIGEN_DEVICE_FUNC const T *data() const { return m_data; }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  573","line":"    EIGEN_DEVICE_FUNC T *data() { return m_data; }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  574","line":"};"},
{"lineNum":"  575","line":""},
{"lineNum":"  576","line":"// matrix with dynamic height and fixed width (so that matrix has dynamic size)."},
{"lineNum":"  577","line":"template<typename T, int Cols_, int Options_> class DenseStorage<T, Dynamic, Dynamic, Cols_, Options_>"},
{"lineNum":"  578","line":"{"},
{"lineNum":"  579","line":"    T *m_data;"},
{"lineNum":"  580","line":"    Index m_rows;"},
{"lineNum":"  581","line":"  public:"},
{"lineNum":"  582","line":"    EIGEN_DEVICE_FUNC DenseStorage() : m_data(0), m_rows(0) {}","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  583","line":"    explicit DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}"},
{"lineNum":"  584","line":"    EIGEN_DEVICE_FUNC DenseStorage(Index size, Index rows, Index cols) : m_data(internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(size)), m_rows(rows)"},
{"lineNum":"  585","line":"    {"},
{"lineNum":"  586","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})"},
{"lineNum":"  587","line":"      eigen_internal_assert(size==rows*cols && rows>=0 && cols == Cols_);"},
{"lineNum":"  588","line":"      EIGEN_UNUSED_VARIABLE(cols);"},
{"lineNum":"  589","line":"    }"},
{"lineNum":"  590","line":"    EIGEN_DEVICE_FUNC DenseStorage(const DenseStorage& other)"},
{"lineNum":"  591","line":"      : m_data(internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(other.m_rows*Cols_))","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  592","line":"      , m_rows(other.m_rows)","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  593","line":"    {"},
{"lineNum":"  594","line":"      EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN(Index size = m_rows*Cols_)"},
{"lineNum":"  595","line":"      internal::smart_copy(other.m_data, other.m_data+other.m_rows*Cols_, m_data);","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  596","line":"    }"},
{"lineNum":"  597","line":"    EIGEN_DEVICE_FUNC DenseStorage& operator=(const DenseStorage& other)"},
{"lineNum":"  598","line":"    {"},
{"lineNum":"  599","line":"      if (this != &other)"},
{"lineNum":"  600","line":"      {"},
{"lineNum":"  601","line":"        DenseStorage tmp(other);"},
{"lineNum":"  602","line":"        this->swap(tmp);"},
{"lineNum":"  603","line":"      }"},
{"lineNum":"  604","line":"      return *this;"},
{"lineNum":"  605","line":"    }"},
{"lineNum":"  606","line":"#if EIGEN_HAS_RVALUE_REFERENCES"},
{"lineNum":"  607","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  608","line":"    DenseStorage(DenseStorage&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  609","line":"      : m_data(std::move(other.m_data))"},
{"lineNum":"  610","line":"      , m_rows(std::move(other.m_rows))"},
{"lineNum":"  611","line":"    {"},
{"lineNum":"  612","line":"      other.m_data = nullptr;"},
{"lineNum":"  613","line":"      other.m_rows = 0;"},
{"lineNum":"  614","line":"    }"},
{"lineNum":"  615","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  616","line":"    DenseStorage& operator=(DenseStorage&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  617","line":"    {"},
{"lineNum":"  618","line":"      numext::swap(m_data, other.m_data);"},
{"lineNum":"  619","line":"      numext::swap(m_rows, other.m_rows);"},
{"lineNum":"  620","line":"      return *this;"},
{"lineNum":"  621","line":"    }"},
{"lineNum":"  622","line":"#endif"},
{"lineNum":"  623","line":"    EIGEN_DEVICE_FUNC ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(Options_&DontAlign)==0>(m_data, Cols_*m_rows); }","class":"lineNoCov","hits":"0","possible_hits":"48",},
{"lineNum":"  624","line":"    EIGEN_DEVICE_FUNC void swap(DenseStorage& other) {"},
{"lineNum":"  625","line":"      numext::swap(m_data,other.m_data);"},
{"lineNum":"  626","line":"      numext::swap(m_rows,other.m_rows);"},
{"lineNum":"  627","line":"    }"},
{"lineNum":"  628","line":"    EIGEN_DEVICE_FUNC Index rows(void) const EIGEN_NOEXCEPT {return m_rows;}","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  629","line":"    EIGEN_DEVICE_FUNC static EIGEN_CONSTEXPR Index cols(void) {return Cols_;}"},
{"lineNum":"  630","line":"    void conservativeResize(Index size, Index rows, Index)"},
{"lineNum":"  631","line":"    {"},
{"lineNum":"  632","line":"      m_data = internal::conditional_aligned_realloc_new_auto<T,(Options_&DontAlign)==0>(m_data, size, m_rows*Cols_);"},
{"lineNum":"  633","line":"      m_rows = rows;"},
{"lineNum":"  634","line":"    }"},
{"lineNum":"  635","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void resize(Index size, Index rows, Index)"},
{"lineNum":"  636","line":"    {"},
{"lineNum":"  637","line":"      if(size != m_rows*Cols_)","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  638","line":"      {"},
{"lineNum":"  639","line":"        internal::conditional_aligned_delete_auto<T,(Options_&DontAlign)==0>(m_data, Cols_*m_rows);","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  640","line":"        if (size>0) // >0 and not simply !=0 to let the compiler knows that size cannot be negative","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  641","line":"          m_data = internal::conditional_aligned_new_auto<T,(Options_&DontAlign)==0>(size);","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  642","line":"        else"},
{"lineNum":"  643","line":"          m_data = 0;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  644","line":"        EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN({})"},
{"lineNum":"  645","line":"      }"},
{"lineNum":"  646","line":"      m_rows = rows;","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  647","line":"    }"},
{"lineNum":"  648","line":"    EIGEN_DEVICE_FUNC const T *data() const { return m_data; }","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  649","line":"    EIGEN_DEVICE_FUNC T *data() { return m_data; }","class":"lineNoCov","hits":"0","possible_hits":"31",},
{"lineNum":"  650","line":"};"},
{"lineNum":"  651","line":""},
{"lineNum":"  652","line":"} // end namespace Eigen"},
{"lineNum":"  653","line":""},
{"lineNum":"  654","line":"#endif // EIGEN_MATRIX_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 44, "covered" : 0,};
var merged_data = [];
