var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_LLT_H"},
{"lineNum":"   11","line":"#define EIGEN_LLT_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal{"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"template<typename MatrixType_, int UpLo_> struct traits<LLT<MatrixType_, UpLo_> >"},
{"lineNum":"   20","line":" : traits<MatrixType_>"},
{"lineNum":"   21","line":"{"},
{"lineNum":"   22","line":"  typedef MatrixXpr XprKind;"},
{"lineNum":"   23","line":"  typedef SolverStorage StorageKind;"},
{"lineNum":"   24","line":"  typedef int StorageIndex;"},
{"lineNum":"   25","line":"  enum { Flags = 0 };"},
{"lineNum":"   26","line":"};"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"template<typename MatrixType, int UpLo> struct LLT_Traits;"},
{"lineNum":"   29","line":"}"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"/** \\ingroup Cholesky_Module"},
{"lineNum":"   32","line":"  *"},
{"lineNum":"   33","line":"  * \\class LLT"},
{"lineNum":"   34","line":"  *"},
{"lineNum":"   35","line":"  * \\brief Standard Cholesky decomposition (LL^T) of a matrix and associated features"},
{"lineNum":"   36","line":"  *"},
{"lineNum":"   37","line":"  * \\tparam MatrixType_ the type of the matrix of which we are computing the LL^T Cholesky decomposition"},
{"lineNum":"   38","line":"  * \\tparam UpLo_ the triangular part that will be used for the decomposition: Lower (default) or Upper."},
{"lineNum":"   39","line":"  *               The other triangular part won\'t be read."},
{"lineNum":"   40","line":"  *"},
{"lineNum":"   41","line":"  * This class performs a LL^T Cholesky decomposition of a symmetric, positive definite"},
{"lineNum":"   42","line":"  * matrix A such that A = LL^* = U^*U, where L is lower triangular."},
{"lineNum":"   43","line":"  *"},
{"lineNum":"   44","line":"  * While the Cholesky decomposition is particularly useful to solve selfadjoint problems like  D^*D x = b,"},
{"lineNum":"   45","line":"  * for that purpose, we recommend the Cholesky decomposition without square root which is more stable"},
{"lineNum":"   46","line":"  * and even faster. Nevertheless, this standard Cholesky decomposition remains useful in many other"},
{"lineNum":"   47","line":"  * situations like generalised eigen problems with hermitian matrices."},
{"lineNum":"   48","line":"  *"},
{"lineNum":"   49","line":"  * Remember that Cholesky decompositions are not rank-revealing. This LLT decomposition is only stable on positive definite matrices,"},
{"lineNum":"   50","line":"  * use LDLT instead for the semidefinite case. Also, do not use a Cholesky decomposition to determine whether a system of equations"},
{"lineNum":"   51","line":"  * has a solution."},
{"lineNum":"   52","line":"  *"},
{"lineNum":"   53","line":"  * Example: \\include LLT_example.cpp"},
{"lineNum":"   54","line":"  * Output: \\verbinclude LLT_example.out"},
{"lineNum":"   55","line":"  *"},
{"lineNum":"   56","line":"  * \\b Performance: for best performance, it is recommended to use a column-major storage format"},
{"lineNum":"   57","line":"  * with the Lower triangular part (the default), or, equivalently, a row-major storage format"},
{"lineNum":"   58","line":"  * with the Upper triangular part. Otherwise, you might get a 20% slowdown for the full factorization"},
{"lineNum":"   59","line":"  * step, and rank-updates can be up to 3 times slower."},
{"lineNum":"   60","line":"  *"},
{"lineNum":"   61","line":"  * This class supports the \\link InplaceDecomposition inplace decomposition \\endlink mechanism."},
{"lineNum":"   62","line":"  *"},
{"lineNum":"   63","line":"  * Note that during the decomposition, only the lower (or upper, as defined by UpLo_) triangular part of A is considered."},
{"lineNum":"   64","line":"  * Therefore, the strict lower part does not have to store correct values."},
{"lineNum":"   65","line":"  *"},
{"lineNum":"   66","line":"  * \\sa MatrixBase::llt(), SelfAdjointView::llt(), class LDLT"},
{"lineNum":"   67","line":"  */"},
{"lineNum":"   68","line":"template<typename MatrixType_, int UpLo_> class LLT"},
{"lineNum":"   69","line":"        : public SolverBase<LLT<MatrixType_, UpLo_> >"},
{"lineNum":"   70","line":"{"},
{"lineNum":"   71","line":"  public:"},
{"lineNum":"   72","line":"    typedef MatrixType_ MatrixType;"},
{"lineNum":"   73","line":"    typedef SolverBase<LLT> Base;"},
{"lineNum":"   74","line":"    friend class SolverBase<LLT>;"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"    EIGEN_GENERIC_PUBLIC_INTERFACE(LLT)"},
{"lineNum":"   77","line":"    enum {"},
{"lineNum":"   78","line":"      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime"},
{"lineNum":"   79","line":"    };"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"    enum {"},
{"lineNum":"   82","line":"      PacketSize = internal::packet_traits<Scalar>::size,"},
{"lineNum":"   83","line":"      AlignmentMask = int(PacketSize)-1,"},
{"lineNum":"   84","line":"      UpLo = UpLo_"},
{"lineNum":"   85","line":"    };"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"    /**"},
{"lineNum":"   90","line":"      * \\brief Default Constructor."},
{"lineNum":"   91","line":"      *"},
{"lineNum":"   92","line":"      * The default constructor is useful in cases in which the user intends to"},
{"lineNum":"   93","line":"      * perform decompositions via LLT::compute(const MatrixType&)."},
{"lineNum":"   94","line":"      */"},
{"lineNum":"   95","line":"    LLT() : m_matrix(), m_isInitialized(false) {}"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"    /** \\brief Default Constructor with memory preallocation"},
{"lineNum":"   98","line":"      *"},
{"lineNum":"   99","line":"      * Like the default constructor but with preallocation of the internal data"},
{"lineNum":"  100","line":"      * according to the specified problem \\a size."},
{"lineNum":"  101","line":"      * \\sa LLT()"},
{"lineNum":"  102","line":"      */"},
{"lineNum":"  103","line":"    explicit LLT(Index size) : m_matrix(size, size),"},
{"lineNum":"  104","line":"                    m_isInitialized(false) {}"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"    template<typename InputType>"},
{"lineNum":"  107","line":"    explicit LLT(const EigenBase<InputType>& matrix)"},
{"lineNum":"  108","line":"      : m_matrix(matrix.rows(), matrix.cols()),"},
{"lineNum":"  109","line":"        m_isInitialized(false)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  110","line":"    {"},
{"lineNum":"  111","line":"      compute(matrix.derived());"},
{"lineNum":"  112","line":"    }"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"    /** \\brief Constructs a LLT factorization from a given matrix"},
{"lineNum":"  115","line":"      *"},
{"lineNum":"  116","line":"      * This overloaded constructor is provided for \\link InplaceDecomposition inplace decomposition \\endlink when"},
{"lineNum":"  117","line":"      * \\c MatrixType is a Eigen::Ref."},
{"lineNum":"  118","line":"      *"},
{"lineNum":"  119","line":"      * \\sa LLT(const EigenBase&)"},
{"lineNum":"  120","line":"      */"},
{"lineNum":"  121","line":"    template<typename InputType>"},
{"lineNum":"  122","line":"    explicit LLT(EigenBase<InputType>& matrix)"},
{"lineNum":"  123","line":"      : m_matrix(matrix.derived()),"},
{"lineNum":"  124","line":"        m_isInitialized(false)"},
{"lineNum":"  125","line":"    {"},
{"lineNum":"  126","line":"      compute(matrix.derived());"},
{"lineNum":"  127","line":"    }"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    /** \\returns a view of the upper triangular matrix U */"},
{"lineNum":"  130","line":"    inline typename Traits::MatrixU matrixU() const"},
{"lineNum":"  131","line":"    {"},
{"lineNum":"  132","line":"      eigen_assert(m_isInitialized && \"LLT is not initialized.\");"},
{"lineNum":"  133","line":"      return Traits::getU(m_matrix);"},
{"lineNum":"  134","line":"    }"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"    /** \\returns a view of the lower triangular matrix L */"},
{"lineNum":"  137","line":"    inline typename Traits::MatrixL matrixL() const"},
{"lineNum":"  138","line":"    {"},
{"lineNum":"  139","line":"      eigen_assert(m_isInitialized && \"LLT is not initialized.\");"},
{"lineNum":"  140","line":"      return Traits::getL(m_matrix);"},
{"lineNum":"  141","line":"    }"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"    #ifdef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  144","line":"    /** \\returns the solution x of \\f$ A x = b \\f$ using the current decomposition of A."},
{"lineNum":"  145","line":"      *"},
{"lineNum":"  146","line":"      * Since this LLT class assumes anyway that the matrix A is invertible, the solution"},
{"lineNum":"  147","line":"      * theoretically exists and is unique regardless of b."},
{"lineNum":"  148","line":"      *"},
{"lineNum":"  149","line":"      * Example: \\include LLT_solve.cpp"},
{"lineNum":"  150","line":"      * Output: \\verbinclude LLT_solve.out"},
{"lineNum":"  151","line":"      *"},
{"lineNum":"  152","line":"      * \\sa solveInPlace(), MatrixBase::llt(), SelfAdjointView::llt()"},
{"lineNum":"  153","line":"      */"},
{"lineNum":"  154","line":"    template<typename Rhs>"},
{"lineNum":"  155","line":"    inline const Solve<LLT, Rhs>"},
{"lineNum":"  156","line":"    solve(const MatrixBase<Rhs>& b) const;"},
{"lineNum":"  157","line":"    #endif"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    template<typename Derived>"},
{"lineNum":"  160","line":"    void solveInPlace(const MatrixBase<Derived> &bAndX) const;"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"    template<typename InputType>"},
{"lineNum":"  163","line":"    LLT& compute(const EigenBase<InputType>& matrix);"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"    /** \\returns an estimate of the reciprocal condition number of the matrix of"},
{"lineNum":"  166","line":"      *  which \\c *this is the Cholesky decomposition."},
{"lineNum":"  167","line":"      */"},
{"lineNum":"  168","line":"    RealScalar rcond() const"},
{"lineNum":"  169","line":"    {"},
{"lineNum":"  170","line":"      eigen_assert(m_isInitialized && \"LLT is not initialized.\");"},
{"lineNum":"  171","line":"      eigen_assert(m_info == Success && \"LLT failed because matrix appears to be negative\");"},
{"lineNum":"  172","line":"      return internal::rcond_estimate_helper(m_l1_norm, *this);"},
{"lineNum":"  173","line":"    }"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"    /** \\returns the LLT decomposition matrix"},
{"lineNum":"  176","line":"      *"},
{"lineNum":"  177","line":"      * TODO: document the storage layout"},
{"lineNum":"  178","line":"      */"},
{"lineNum":"  179","line":"    inline const MatrixType& matrixLLT() const"},
{"lineNum":"  180","line":"    {"},
{"lineNum":"  181","line":"      eigen_assert(m_isInitialized && \"LLT is not initialized.\");"},
{"lineNum":"  182","line":"      return m_matrix;"},
{"lineNum":"  183","line":"    }"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"    MatrixType reconstructedMatrix() const;"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"    /** \\brief Reports whether previous computation was successful."},
{"lineNum":"  189","line":"      *"},
{"lineNum":"  190","line":"      * \\returns \\c Success if computation was successful,"},
{"lineNum":"  191","line":"      *          \\c NumericalIssue if the matrix.appears not to be positive definite."},
{"lineNum":"  192","line":"      */"},
{"lineNum":"  193","line":"    ComputationInfo info() const"},
{"lineNum":"  194","line":"    {"},
{"lineNum":"  195","line":"      eigen_assert(m_isInitialized && \"LLT is not initialized.\");"},
{"lineNum":"  196","line":"      return m_info;"},
{"lineNum":"  197","line":"    }"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"    /** \\returns the adjoint of \\c *this, that is, a const reference to the decomposition itself as the underlying matrix is self-adjoint."},
{"lineNum":"  200","line":"      *"},
{"lineNum":"  201","line":"      * This method is provided for compatibility with other matrix decompositions, thus enabling generic code such as:"},
{"lineNum":"  202","line":"      * \\code x = decomposition.adjoint().solve(b) \\endcode"},
{"lineNum":"  203","line":"      */"},
{"lineNum":"  204","line":"    const LLT& adjoint() const EIGEN_NOEXCEPT { return *this; };"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"    inline EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }"},
{"lineNum":"  207","line":"    inline EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"    template<typename VectorType>"},
{"lineNum":"  210","line":"    LLT & rankUpdate(const VectorType& vec, const RealScalar& sigma = 1);"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"    #ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  213","line":"    template<typename RhsType, typename DstType>"},
{"lineNum":"  214","line":"    void _solve_impl(const RhsType &rhs, DstType &dst) const;"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"    template<bool Conjugate, typename RhsType, typename DstType>"},
{"lineNum":"  217","line":"    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const;"},
{"lineNum":"  218","line":"    #endif"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"  protected:"},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"    EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"    /** \\internal"},
{"lineNum":"  225","line":"      * Used to compute and store L"},
{"lineNum":"  226","line":"      * The strict upper part is not used and even not initialized."},
{"lineNum":"  227","line":"      */"},
{"lineNum":"  228","line":"    MatrixType m_matrix;"},
{"lineNum":"  229","line":"    RealScalar m_l1_norm;"},
{"lineNum":"  230","line":"    bool m_isInitialized;"},
{"lineNum":"  231","line":"    ComputationInfo m_info;"},
{"lineNum":"  232","line":"};"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"namespace internal {"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"template<typename Scalar, int UpLo> struct llt_inplace;"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"template<typename MatrixType, typename VectorType>"},
{"lineNum":"  239","line":"static Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)"},
{"lineNum":"  240","line":"{"},
{"lineNum":"  241","line":"  using std::sqrt;"},
{"lineNum":"  242","line":"  typedef typename MatrixType::Scalar Scalar;"},
{"lineNum":"  243","line":"  typedef typename MatrixType::RealScalar RealScalar;"},
{"lineNum":"  244","line":"  typedef typename MatrixType::ColXpr ColXpr;"},
{"lineNum":"  245","line":"  typedef typename internal::remove_all<ColXpr>::type ColXprCleaned;"},
{"lineNum":"  246","line":"  typedef typename ColXprCleaned::SegmentReturnType ColXprSegment;"},
{"lineNum":"  247","line":"  typedef Matrix<Scalar,Dynamic,1> TempVectorType;"},
{"lineNum":"  248","line":"  typedef typename TempVectorType::SegmentReturnType TempVecSegment;"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"  Index n = mat.cols();"},
{"lineNum":"  251","line":"  eigen_assert(mat.rows()==n && vec.size()==n);"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"  TempVectorType temp;"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"  if(sigma>0)"},
{"lineNum":"  256","line":"  {"},
{"lineNum":"  257","line":"    // This version is based on Givens rotations."},
{"lineNum":"  258","line":"    // It is faster than the other one below, but only works for updates,"},
{"lineNum":"  259","line":"    // i.e., for sigma > 0"},
{"lineNum":"  260","line":"    temp = sqrt(sigma) * vec;"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"    for(Index i=0; i<n; ++i)"},
{"lineNum":"  263","line":"    {"},
{"lineNum":"  264","line":"      JacobiRotation<Scalar> g;"},
{"lineNum":"  265","line":"      g.makeGivens(mat(i,i), -temp(i), &mat(i,i));"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"      Index rs = n-i-1;"},
{"lineNum":"  268","line":"      if(rs>0)"},
{"lineNum":"  269","line":"      {"},
{"lineNum":"  270","line":"        ColXprSegment x(mat.col(i).tail(rs));"},
{"lineNum":"  271","line":"        TempVecSegment y(temp.tail(rs));"},
{"lineNum":"  272","line":"        apply_rotation_in_the_plane(x, y, g);"},
{"lineNum":"  273","line":"      }"},
{"lineNum":"  274","line":"    }"},
{"lineNum":"  275","line":"  }"},
{"lineNum":"  276","line":"  else"},
{"lineNum":"  277","line":"  {"},
{"lineNum":"  278","line":"    temp = vec;"},
{"lineNum":"  279","line":"    RealScalar beta = 1;"},
{"lineNum":"  280","line":"    for(Index j=0; j<n; ++j)"},
{"lineNum":"  281","line":"    {"},
{"lineNum":"  282","line":"      RealScalar Ljj = numext::real(mat.coeff(j,j));"},
{"lineNum":"  283","line":"      RealScalar dj = numext::abs2(Ljj);"},
{"lineNum":"  284","line":"      Scalar wj = temp.coeff(j);"},
{"lineNum":"  285","line":"      RealScalar swj2 = sigma*numext::abs2(wj);"},
{"lineNum":"  286","line":"      RealScalar gamma = dj*beta + swj2;"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"      RealScalar x = dj + swj2/beta;"},
{"lineNum":"  289","line":"      if (x<=RealScalar(0))"},
{"lineNum":"  290","line":"        return j;"},
{"lineNum":"  291","line":"      RealScalar nLjj = sqrt(x);"},
{"lineNum":"  292","line":"      mat.coeffRef(j,j) = nLjj;"},
{"lineNum":"  293","line":"      beta += swj2/dj;"},
{"lineNum":"  294","line":""},
{"lineNum":"  295","line":"      // Update the terms of L"},
{"lineNum":"  296","line":"      Index rs = n-j-1;"},
{"lineNum":"  297","line":"      if(rs)"},
{"lineNum":"  298","line":"      {"},
{"lineNum":"  299","line":"        temp.tail(rs) -= (wj/Ljj) * mat.col(j).tail(rs);"},
{"lineNum":"  300","line":"        if(gamma != 0)"},
{"lineNum":"  301","line":"          mat.col(j).tail(rs) = (nLjj/Ljj) * mat.col(j).tail(rs) + (nLjj * sigma*numext::conj(wj)/gamma)*temp.tail(rs);"},
{"lineNum":"  302","line":"      }"},
{"lineNum":"  303","line":"    }"},
{"lineNum":"  304","line":"  }"},
{"lineNum":"  305","line":"  return -1;"},
{"lineNum":"  306","line":"}"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"template<typename Scalar> struct llt_inplace<Scalar, Lower>"},
{"lineNum":"  309","line":"{"},
{"lineNum":"  310","line":"  typedef typename NumTraits<Scalar>::Real RealScalar;"},
{"lineNum":"  311","line":"  template<typename MatrixType>"},
{"lineNum":"  312","line":"  static Index unblocked(MatrixType& mat)"},
{"lineNum":"  313","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  314","line":"    using std::sqrt;"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"    eigen_assert(mat.rows()==mat.cols());"},
{"lineNum":"  317","line":"    const Index size = mat.rows();"},
{"lineNum":"  318","line":"    for(Index k = 0; k < size; ++k)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  319","line":"    {"},
{"lineNum":"  320","line":"      Index rs = size-k-1; // remaining size","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"      Block<MatrixType,Dynamic,1> A21(mat,k+1,k,rs,1);"},
{"lineNum":"  323","line":"      Block<MatrixType,1,Dynamic> A10(mat,k,0,1,k);"},
{"lineNum":"  324","line":"      Block<MatrixType,Dynamic,Dynamic> A20(mat,k+1,0,rs,k);"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"      RealScalar x = numext::real(mat.coeff(k,k));"},
{"lineNum":"  327","line":"      if (k>0) x -= A10.squaredNorm();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  328","line":"      if (x<=RealScalar(0))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  329","line":"        return k;"},
{"lineNum":"  330","line":"      mat.coeffRef(k,k) = x = sqrt(x);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  331","line":"      if (k>0 && rs>0) A21.noalias() -= A20 * A10.adjoint();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  332","line":"      if (rs>0) A21 /= x;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  333","line":"    }"},
{"lineNum":"  334","line":"    return -1;"},
{"lineNum":"  335","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"  template<typename MatrixType>"},
{"lineNum":"  338","line":"  static Index blocked(MatrixType& m)"},
{"lineNum":"  339","line":"  {"},
{"lineNum":"  340","line":"    eigen_assert(m.rows()==m.cols());"},
{"lineNum":"  341","line":"    Index size = m.rows();"},
{"lineNum":"  342","line":"    if(size<32)"},
{"lineNum":"  343","line":"      return unblocked(m);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"    Index blockSize = size/8;"},
{"lineNum":"  346","line":"    blockSize = (blockSize/16)*16;"},
{"lineNum":"  347","line":"    blockSize = (std::min)((std::max)(blockSize,Index(8)), Index(128));"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"    for (Index k=0; k<size; k+=blockSize)"},
{"lineNum":"  350","line":"    {"},
{"lineNum":"  351","line":"      // partition the matrix:"},
{"lineNum":"  352","line":"      //       A00 |  -  |  -"},
{"lineNum":"  353","line":"      // lu  = A10 | A11 |  -"},
{"lineNum":"  354","line":"      //       A20 | A21 | A22"},
{"lineNum":"  355","line":"      Index bs = (std::min)(blockSize, size-k);"},
{"lineNum":"  356","line":"      Index rs = size - k - bs;"},
{"lineNum":"  357","line":"      Block<MatrixType,Dynamic,Dynamic> A11(m,k,   k,   bs,bs);"},
{"lineNum":"  358","line":"      Block<MatrixType,Dynamic,Dynamic> A21(m,k+bs,k,   rs,bs);"},
{"lineNum":"  359","line":"      Block<MatrixType,Dynamic,Dynamic> A22(m,k+bs,k+bs,rs,rs);"},
{"lineNum":"  360","line":""},
{"lineNum":"  361","line":"      Index ret;"},
{"lineNum":"  362","line":"      if((ret=unblocked(A11))>=0) return k+ret;"},
{"lineNum":"  363","line":"      if(rs>0) A11.adjoint().template triangularView<Upper>().template solveInPlace<OnTheRight>(A21);"},
{"lineNum":"  364","line":"      if(rs>0) A22.template selfadjointView<Lower>().rankUpdate(A21,typename NumTraits<RealScalar>::Literal(-1)); // bottleneck"},
{"lineNum":"  365","line":"    }"},
{"lineNum":"  366","line":"    return -1;"},
{"lineNum":"  367","line":"  }"},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"  template<typename MatrixType, typename VectorType>"},
{"lineNum":"  370","line":"  static Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)"},
{"lineNum":"  371","line":"  {"},
{"lineNum":"  372","line":"    return Eigen::internal::llt_rank_update_lower(mat, vec, sigma);"},
{"lineNum":"  373","line":"  }"},
{"lineNum":"  374","line":"};"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"template<typename Scalar> struct llt_inplace<Scalar, Upper>"},
{"lineNum":"  377","line":"{"},
{"lineNum":"  378","line":"  typedef typename NumTraits<Scalar>::Real RealScalar;"},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":"  template<typename MatrixType>"},
{"lineNum":"  381","line":"  static EIGEN_STRONG_INLINE Index unblocked(MatrixType& mat)"},
{"lineNum":"  382","line":"  {"},
{"lineNum":"  383","line":"    Transpose<MatrixType> matt(mat);"},
{"lineNum":"  384","line":"    return llt_inplace<Scalar, Lower>::unblocked(matt);"},
{"lineNum":"  385","line":"  }"},
{"lineNum":"  386","line":"  template<typename MatrixType>"},
{"lineNum":"  387","line":"  static EIGEN_STRONG_INLINE Index blocked(MatrixType& mat)"},
{"lineNum":"  388","line":"  {"},
{"lineNum":"  389","line":"    Transpose<MatrixType> matt(mat);"},
{"lineNum":"  390","line":"    return llt_inplace<Scalar, Lower>::blocked(matt);"},
{"lineNum":"  391","line":"  }"},
{"lineNum":"  392","line":"  template<typename MatrixType, typename VectorType>"},
{"lineNum":"  393","line":"  static Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)"},
{"lineNum":"  394","line":"  {"},
{"lineNum":"  395","line":"    Transpose<MatrixType> matt(mat);"},
{"lineNum":"  396","line":"    return llt_inplace<Scalar, Lower>::rankUpdate(matt, vec.conjugate(), sigma);"},
{"lineNum":"  397","line":"  }"},
{"lineNum":"  398","line":"};"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>"},
{"lineNum":"  401","line":"{"},
{"lineNum":"  402","line":"  typedef const TriangularView<const MatrixType, Lower> MatrixL;"},
{"lineNum":"  403","line":"  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;"},
{"lineNum":"  404","line":"  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m); }"},
{"lineNum":"  405","line":"  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m.adjoint()); }"},
{"lineNum":"  406","line":"  static bool inplace_decomposition(MatrixType& m)"},
{"lineNum":"  407","line":"  { return llt_inplace<typename MatrixType::Scalar, Lower>::blocked(m)==-1; }"},
{"lineNum":"  408","line":"};"},
{"lineNum":"  409","line":""},
{"lineNum":"  410","line":"template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>"},
{"lineNum":"  411","line":"{"},
{"lineNum":"  412","line":"  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;"},
{"lineNum":"  413","line":"  typedef const TriangularView<const MatrixType, Upper> MatrixU;"},
{"lineNum":"  414","line":"  static inline MatrixL getL(const MatrixType& m) { return MatrixL(m.adjoint()); }"},
{"lineNum":"  415","line":"  static inline MatrixU getU(const MatrixType& m) { return MatrixU(m); }"},
{"lineNum":"  416","line":"  static bool inplace_decomposition(MatrixType& m)"},
{"lineNum":"  417","line":"  { return llt_inplace<typename MatrixType::Scalar, Upper>::blocked(m)==-1; }"},
{"lineNum":"  418","line":"};"},
{"lineNum":"  419","line":""},
{"lineNum":"  420","line":"} // end namespace internal"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"/** Computes / recomputes the Cholesky decomposition A = LL^* = U^*U of \\a matrix"},
{"lineNum":"  423","line":"  *"},
{"lineNum":"  424","line":"  * \\returns a reference to *this"},
{"lineNum":"  425","line":"  *"},
{"lineNum":"  426","line":"  * Example: \\include TutorialLinAlgComputeTwice.cpp"},
{"lineNum":"  427","line":"  * Output: \\verbinclude TutorialLinAlgComputeTwice.out"},
{"lineNum":"  428","line":"  */"},
{"lineNum":"  429","line":"template<typename MatrixType, int UpLo_>"},
{"lineNum":"  430","line":"template<typename InputType>"},
{"lineNum":"  431","line":"LLT<MatrixType,UpLo_>& LLT<MatrixType,UpLo_>::compute(const EigenBase<InputType>& a)"},
{"lineNum":"  432","line":"{"},
{"lineNum":"  433","line":"  eigen_assert(a.rows()==a.cols());"},
{"lineNum":"  434","line":"  const Index size = a.rows();"},
{"lineNum":"  435","line":"  m_matrix.resize(size, size);"},
{"lineNum":"  436","line":"  if (!internal::is_same_dense(m_matrix, a.derived()))"},
{"lineNum":"  437","line":"    m_matrix = a.derived();"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"  // Compute matrix L1 norm = max abs column sum."},
{"lineNum":"  440","line":"  m_l1_norm = RealScalar(0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  441","line":"  // TODO move this code to SelfAdjointView"},
{"lineNum":"  442","line":"  for (Index col = 0; col < size; ++col) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  443","line":"    RealScalar abs_col_sum;"},
{"lineNum":"  444","line":"    if (UpLo_ == Lower)"},
{"lineNum":"  445","line":"      abs_col_sum = m_matrix.col(col).tail(size - col).template lpNorm<1>() + m_matrix.row(col).head(col).template lpNorm<1>();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  446","line":"    else"},
{"lineNum":"  447","line":"      abs_col_sum = m_matrix.col(col).head(col).template lpNorm<1>() + m_matrix.row(col).tail(size - col).template lpNorm<1>();"},
{"lineNum":"  448","line":"    if (abs_col_sum > m_l1_norm)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  449","line":"      m_l1_norm = abs_col_sum;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  450","line":"  }"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"  m_isInitialized = true;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  453","line":"  bool ok = Traits::inplace_decomposition(m_matrix);"},
{"lineNum":"  454","line":"  m_info = ok ? Success : NumericalIssue;"},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"  return *this;"},
{"lineNum":"  457","line":"}"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"/** Performs a rank one update (or dowdate) of the current decomposition."},
{"lineNum":"  460","line":"  * If A = LL^* before the rank one update,"},
{"lineNum":"  461","line":"  * then after it we have LL^* = A + sigma * v v^* where \\a v must be a vector"},
{"lineNum":"  462","line":"  * of same dimension."},
{"lineNum":"  463","line":"  */"},
{"lineNum":"  464","line":"template<typename MatrixType_, int UpLo_>"},
{"lineNum":"  465","line":"template<typename VectorType>"},
{"lineNum":"  466","line":"LLT<MatrixType_,UpLo_> & LLT<MatrixType_,UpLo_>::rankUpdate(const VectorType& v, const RealScalar& sigma)"},
{"lineNum":"  467","line":"{"},
{"lineNum":"  468","line":"  EIGEN_STATIC_ASSERT_VECTOR_ONLY(VectorType);"},
{"lineNum":"  469","line":"  eigen_assert(v.size()==m_matrix.cols());"},
{"lineNum":"  470","line":"  eigen_assert(m_isInitialized);"},
{"lineNum":"  471","line":"  if(internal::llt_inplace<typename MatrixType::Scalar, UpLo>::rankUpdate(m_matrix,v,sigma)>=0)"},
{"lineNum":"  472","line":"    m_info = NumericalIssue;"},
{"lineNum":"  473","line":"  else"},
{"lineNum":"  474","line":"    m_info = Success;"},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"  return *this;"},
{"lineNum":"  477","line":"}"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"#ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  480","line":"template<typename MatrixType_,int UpLo_>"},
{"lineNum":"  481","line":"template<typename RhsType, typename DstType>"},
{"lineNum":"  482","line":"void LLT<MatrixType_,UpLo_>::_solve_impl(const RhsType &rhs, DstType &dst) const"},
{"lineNum":"  483","line":"{"},
{"lineNum":"  484","line":"  _solve_impl_transposed<true>(rhs, dst);"},
{"lineNum":"  485","line":"}"},
{"lineNum":"  486","line":""},
{"lineNum":"  487","line":"template<typename MatrixType_,int UpLo_>"},
{"lineNum":"  488","line":"template<bool Conjugate, typename RhsType, typename DstType>"},
{"lineNum":"  489","line":"void LLT<MatrixType_,UpLo_>::_solve_impl_transposed(const RhsType &rhs, DstType &dst) const"},
{"lineNum":"  490","line":"{"},
{"lineNum":"  491","line":"    dst = rhs;"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"    matrixL().template conjugateIf<!Conjugate>().solveInPlace(dst);"},
{"lineNum":"  494","line":"    matrixU().template conjugateIf<!Conjugate>().solveInPlace(dst);"},
{"lineNum":"  495","line":"}"},
{"lineNum":"  496","line":"#endif"},
{"lineNum":"  497","line":""},
{"lineNum":"  498","line":"/** \\internal use x = llt_object.solve(x);"},
{"lineNum":"  499","line":"  *"},
{"lineNum":"  500","line":"  * This is the \\em in-place version of solve()."},
{"lineNum":"  501","line":"  *"},
{"lineNum":"  502","line":"  * \\param bAndX represents both the right-hand side matrix b and result x."},
{"lineNum":"  503","line":"  *"},
{"lineNum":"  504","line":"  * This version avoids a copy when the right hand side matrix b is not needed anymore."},
{"lineNum":"  505","line":"  *"},
{"lineNum":"  506","line":"  * \\warning The parameter is only marked \'const\' to make the C++ compiler accept a temporary expression here."},
{"lineNum":"  507","line":"  * This function will const_cast it, so constness isn\'t honored here."},
{"lineNum":"  508","line":"  *"},
{"lineNum":"  509","line":"  * \\sa LLT::solve(), MatrixBase::llt()"},
{"lineNum":"  510","line":"  */"},
{"lineNum":"  511","line":"template<typename MatrixType, int UpLo_>"},
{"lineNum":"  512","line":"template<typename Derived>"},
{"lineNum":"  513","line":"void LLT<MatrixType,UpLo_>::solveInPlace(const MatrixBase<Derived> &bAndX) const"},
{"lineNum":"  514","line":"{"},
{"lineNum":"  515","line":"  eigen_assert(m_isInitialized && \"LLT is not initialized.\");"},
{"lineNum":"  516","line":"  eigen_assert(m_matrix.rows()==bAndX.rows());"},
{"lineNum":"  517","line":"  matrixL().solveInPlace(bAndX);"},
{"lineNum":"  518","line":"  matrixU().solveInPlace(bAndX);"},
{"lineNum":"  519","line":"}"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"/** \\returns the matrix represented by the decomposition,"},
{"lineNum":"  522","line":" * i.e., it returns the product: L L^*."},
{"lineNum":"  523","line":" * This function is provided for debug purpose. */"},
{"lineNum":"  524","line":"template<typename MatrixType, int UpLo_>"},
{"lineNum":"  525","line":"MatrixType LLT<MatrixType,UpLo_>::reconstructedMatrix() const"},
{"lineNum":"  526","line":"{"},
{"lineNum":"  527","line":"  eigen_assert(m_isInitialized && \"LLT is not initialized.\");"},
{"lineNum":"  528","line":"  return matrixL() * matrixL().adjoint().toDenseMatrix();"},
{"lineNum":"  529","line":"}"},
{"lineNum":"  530","line":""},
{"lineNum":"  531","line":"/** \\cholesky_module"},
{"lineNum":"  532","line":"  * \\returns the LLT decomposition of \\c *this"},
{"lineNum":"  533","line":"  * \\sa SelfAdjointView::llt()"},
{"lineNum":"  534","line":"  */"},
{"lineNum":"  535","line":"template<typename Derived>"},
{"lineNum":"  536","line":"inline const LLT<typename MatrixBase<Derived>::PlainObject>"},
{"lineNum":"  537","line":"MatrixBase<Derived>::llt() const"},
{"lineNum":"  538","line":"{"},
{"lineNum":"  539","line":"  return LLT<PlainObject>(derived());"},
{"lineNum":"  540","line":"}"},
{"lineNum":"  541","line":""},
{"lineNum":"  542","line":"/** \\cholesky_module"},
{"lineNum":"  543","line":"  * \\returns the LLT decomposition of \\c *this"},
{"lineNum":"  544","line":"  * \\sa SelfAdjointView::llt()"},
{"lineNum":"  545","line":"  */"},
{"lineNum":"  546","line":"template<typename MatrixType, unsigned int UpLo>"},
{"lineNum":"  547","line":"inline const LLT<typename SelfAdjointView<MatrixType, UpLo>::PlainObject, UpLo>"},
{"lineNum":"  548","line":"SelfAdjointView<MatrixType, UpLo>::llt() const"},
{"lineNum":"  549","line":"{"},
{"lineNum":"  550","line":"  return LLT<PlainObject,UpLo>(m_matrix);"},
{"lineNum":"  551","line":"}"},
{"lineNum":"  552","line":""},
{"lineNum":"  553","line":"} // end namespace Eigen"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"#endif // EIGEN_LLT_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 17, "covered" : 0,};
var merged_data = [];
