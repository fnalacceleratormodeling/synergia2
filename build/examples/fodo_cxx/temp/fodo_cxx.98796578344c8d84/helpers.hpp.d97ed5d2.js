var data = {lines:[
{"lineNum":"    1","line":"/*! \\file helpers.hpp"},
{"lineNum":"    2","line":"    \\brief Internal helper functionality"},
{"lineNum":"    3","line":"    \\ingroup Internal */"},
{"lineNum":"    4","line":"/*"},
{"lineNum":"    5","line":"  Copyright (c) 2014, Randolph Voorhies, Shane Grant"},
{"lineNum":"    6","line":"  All rights reserved."},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"  Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    9","line":"  modification, are permitted provided that the following conditions are met:"},
{"lineNum":"   10","line":"      * Redistributions of source code must retain the above copyright"},
{"lineNum":"   11","line":"        notice, this list of conditions and the following disclaimer."},
{"lineNum":"   12","line":"      * Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   13","line":"        notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   14","line":"        documentation and/or other materials provided with the distribution."},
{"lineNum":"   15","line":"      * Neither the name of cereal nor the"},
{"lineNum":"   16","line":"        names of its contributors may be used to endorse or promote products"},
{"lineNum":"   17","line":"        derived from this software without specific prior written permission."},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"},
{"lineNum":"   20","line":"  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"},
{"lineNum":"   21","line":"  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"},
{"lineNum":"   22","line":"  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES OR SHANE GRANT BE LIABLE FOR ANY"},
{"lineNum":"   23","line":"  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"},
{"lineNum":"   24","line":"  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"},
{"lineNum":"   25","line":"  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"},
{"lineNum":"   26","line":"  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   27","line":"  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   28","line":"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   29","line":"*/"},
{"lineNum":"   30","line":"#ifndef CEREAL_DETAILS_HELPERS_HPP_"},
{"lineNum":"   31","line":"#define CEREAL_DETAILS_HELPERS_HPP_"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"#include <type_traits>"},
{"lineNum":"   34","line":"#include <cstdint>"},
{"lineNum":"   35","line":"#include <utility>"},
{"lineNum":"   36","line":"#include <memory>"},
{"lineNum":"   37","line":"#include <unordered_map>"},
{"lineNum":"   38","line":"#include <stdexcept>"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"#include \"cereal/macros.hpp\""},
{"lineNum":"   41","line":"#include \"cereal/details/static_object.hpp\""},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"namespace cereal"},
{"lineNum":"   44","line":"{"},
{"lineNum":"   45","line":"  // ######################################################################"},
{"lineNum":"   46","line":"  //! An exception class thrown when things go wrong at runtime"},
{"lineNum":"   47","line":"  /*! @ingroup Utility */"},
{"lineNum":"   48","line":"  struct Exception : public std::runtime_error","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"   49","line":"  {"},
{"lineNum":"   50","line":"    explicit Exception( const std::string & what_ ) : std::runtime_error(what_) {}","class":"lineNoCov","hits":"0","possible_hits":"130",},
{"lineNum":"   51","line":"    explicit Exception( const char * what_ ) : std::runtime_error(what_) {}","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"   52","line":"  };"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"  // ######################################################################"},
{"lineNum":"   55","line":"  //! The size type used by cereal"},
{"lineNum":"   56","line":"  /*! To ensure compatability between 32, 64, etc bit machines, we need to use"},
{"lineNum":"   57","line":"      a fixed size type instead of size_t, which may vary from machine to"},
{"lineNum":"   58","line":"      machine."},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"      The default value for CEREAL_SIZE_TYPE is specified in cereal/macros.hpp */"},
{"lineNum":"   61","line":"  using size_type = CEREAL_SIZE_TYPE;"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"  // forward decls"},
{"lineNum":"   64","line":"  class BinaryOutputArchive;"},
{"lineNum":"   65","line":"  class BinaryInputArchive;"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"  // ######################################################################"},
{"lineNum":"   68","line":"  namespace detail"},
{"lineNum":"   69","line":"  {"},
{"lineNum":"   70","line":"    struct NameValuePairCore {}; //!< Traits struct for NVPs"},
{"lineNum":"   71","line":"    struct DeferredDataCore {}; //!< Traits struct for DeferredData"},
{"lineNum":"   72","line":"  }"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"  // ######################################################################"},
{"lineNum":"   75","line":"  //! For holding name value pairs"},
{"lineNum":"   76","line":"  /*! This pairs a name (some string) with some value such that an archive"},
{"lineNum":"   77","line":"      can potentially take advantage of the pairing."},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"      In serialization functions, NameValuePairs are usually created like so:"},
{"lineNum":"   80","line":"      @code{.cpp}"},
{"lineNum":"   81","line":"      struct MyStruct"},
{"lineNum":"   82","line":"      {"},
{"lineNum":"   83","line":"        int a, b, c, d, e;"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"        template<class Archive>"},
{"lineNum":"   86","line":"        void serialize(Archive & archive)"},
{"lineNum":"   87","line":"        {"},
{"lineNum":"   88","line":"          archive( CEREAL_NVP(a),"},
{"lineNum":"   89","line":"                   CEREAL_NVP(b),"},
{"lineNum":"   90","line":"                   CEREAL_NVP(c),"},
{"lineNum":"   91","line":"                   CEREAL_NVP(d),"},
{"lineNum":"   92","line":"                   CEREAL_NVP(e) );"},
{"lineNum":"   93","line":"        }"},
{"lineNum":"   94","line":"      };"},
{"lineNum":"   95","line":"      @endcode"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"      Alternatively, you can give you data members custom names like so:"},
{"lineNum":"   98","line":"      @code{.cpp}"},
{"lineNum":"   99","line":"      struct MyStruct"},
{"lineNum":"  100","line":"      {"},
{"lineNum":"  101","line":"        int a, b, my_embarrassing_variable_name, d, e;"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"        template<class Archive>"},
{"lineNum":"  104","line":"        void serialize(Archive & archive)"},
{"lineNum":"  105","line":"        {"},
{"lineNum":"  106","line":"          archive( CEREAL_NVP(a),"},
{"lineNum":"  107","line":"                   CEREAL_NVP(b),"},
{"lineNum":"  108","line":"                   cereal::make_nvp(\"var\", my_embarrassing_variable_name) );"},
{"lineNum":"  109","line":"                   CEREAL_NVP(d),"},
{"lineNum":"  110","line":"                   CEREAL_NVP(e) );"},
{"lineNum":"  111","line":"        }"},
{"lineNum":"  112","line":"      };"},
{"lineNum":"  113","line":"      @endcode"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"      There is a slight amount of overhead to creating NameValuePairs, so there"},
{"lineNum":"  116","line":"      is a third method which will elide the names when they are not used by"},
{"lineNum":"  117","line":"      the Archive:"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"      @code{.cpp}"},
{"lineNum":"  120","line":"      struct MyStruct"},
{"lineNum":"  121","line":"      {"},
{"lineNum":"  122","line":"        int a, b;"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"        template<class Archive>"},
{"lineNum":"  125","line":"        void serialize(Archive & archive)"},
{"lineNum":"  126","line":"        {"},
{"lineNum":"  127","line":"          archive( cereal::make_nvp<Archive>(a),"},
{"lineNum":"  128","line":"                   cereal::make_nvp<Archive>(b) );"},
{"lineNum":"  129","line":"        }"},
{"lineNum":"  130","line":"      };"},
{"lineNum":"  131","line":"      @endcode"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"      This third method is generally only used when providing generic type"},
{"lineNum":"  134","line":"      support.  Users writing their own serialize functions will normally"},
{"lineNum":"  135","line":"      explicitly control whether they want to use NVPs or not."},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"      @internal */"},
{"lineNum":"  138","line":"  template <class T>"},
{"lineNum":"  139","line":"  class NameValuePair : detail::NameValuePairCore"},
{"lineNum":"  140","line":"  {"},
{"lineNum":"  141","line":"    private:"},
{"lineNum":"  142","line":"      // If we get passed an array, keep the type as is, otherwise store"},
{"lineNum":"  143","line":"      // a reference if we were passed an l value reference, else copy the value"},
{"lineNum":"  144","line":"      using Type = typename std::conditional<std::is_array<typename std::remove_reference<T>::type>::value,"},
{"lineNum":"  145","line":"                                             typename std::remove_cv<T>::type,"},
{"lineNum":"  146","line":"                                             typename std::conditional<std::is_lvalue_reference<T>::value,"},
{"lineNum":"  147","line":"                                                                       T,"},
{"lineNum":"  148","line":"                                                                       typename std::decay<T>::type>::type>::type;"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"      // prevent nested nvps"},
{"lineNum":"  151","line":"      static_assert( !std::is_base_of<detail::NameValuePairCore, T>::value,"},
{"lineNum":"  152","line":"                     \"Cannot pair a name to a NameValuePair\" );"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"      NameValuePair & operator=( NameValuePair const & ) = delete;"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"    public:"},
{"lineNum":"  157","line":"      //! Constructs a new NameValuePair"},
{"lineNum":"  158","line":"      /*! @param n The name of the pair"},
{"lineNum":"  159","line":"          @param v The value to pair.  Ideally this should be an l-value reference so that"},
{"lineNum":"  160","line":"                   the value can be both loaded and saved to.  If you pass an r-value reference,"},
{"lineNum":"  161","line":"                   the NameValuePair will store a copy of it instead of a reference.  Thus you should"},
{"lineNum":"  162","line":"                   only pass r-values in cases where this makes sense, such as the result of some"},
{"lineNum":"  163","line":"                   size() call."},
{"lineNum":"  164","line":"          @internal */"},
{"lineNum":"  165","line":"      NameValuePair( char const * n, T && v ) : name(n), value(std::forward<T>(v)) {}"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"      char const * name;"},
{"lineNum":"  168","line":"      Type value;"},
{"lineNum":"  169","line":"  };"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"  //! A specialization of make_nvp<> that simply forwards the value for binary archives"},
{"lineNum":"  172","line":"  /*! @relates NameValuePair"},
{"lineNum":"  173","line":"      @internal */"},
{"lineNum":"  174","line":"  template<class Archive, class T> inline"},
{"lineNum":"  175","line":"  typename"},
{"lineNum":"  176","line":"  std::enable_if<std::is_same<Archive, ::cereal::BinaryInputArchive>::value ||"},
{"lineNum":"  177","line":"                 std::is_same<Archive, ::cereal::BinaryOutputArchive>::value,"},
{"lineNum":"  178","line":"  T && >::type"},
{"lineNum":"  179","line":"  make_nvp( const char *, T && value )"},
{"lineNum":"  180","line":"  {"},
{"lineNum":"  181","line":"    return std::forward<T>(value);"},
{"lineNum":"  182","line":"  }"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"  //! A specialization of make_nvp<> that actually creates an nvp for non-binary archives"},
{"lineNum":"  185","line":"  /*! @relates NameValuePair"},
{"lineNum":"  186","line":"      @internal */"},
{"lineNum":"  187","line":"  template<class Archive, class T> inline"},
{"lineNum":"  188","line":"  typename"},
{"lineNum":"  189","line":"  std::enable_if<!std::is_same<Archive, ::cereal::BinaryInputArchive>::value &&"},
{"lineNum":"  190","line":"                 !std::is_same<Archive, ::cereal::BinaryOutputArchive>::value,"},
{"lineNum":"  191","line":"  NameValuePair<T> >::type"},
{"lineNum":"  192","line":"  make_nvp( const char * name, T && value)"},
{"lineNum":"  193","line":"  {"},
{"lineNum":"  194","line":"    return {name, std::forward<T>(value)};"},
{"lineNum":"  195","line":"  }"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"  //! Convenience for creating a templated NVP"},
{"lineNum":"  198","line":"  /*! For use in internal generic typing functions which have an"},
{"lineNum":"  199","line":"      Archive type declared"},
{"lineNum":"  200","line":"      @internal */"},
{"lineNum":"  201","line":"  #define CEREAL_NVP_(name, value) ::cereal::make_nvp<Archive>(name, value)"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"  // ######################################################################"},
{"lineNum":"  204","line":"  //! A wrapper around data that can be serialized in a binary fashion"},
{"lineNum":"  205","line":"  /*! This class is used to demarcate data that can safely be serialized"},
{"lineNum":"  206","line":"      as a binary chunk of data.  Individual archives can then choose how"},
{"lineNum":"  207","line":"      best represent this during serialization."},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"      @internal */"},
{"lineNum":"  210","line":"  template <class T>"},
{"lineNum":"  211","line":"  struct BinaryData"},
{"lineNum":"  212","line":"  {"},
{"lineNum":"  213","line":"    //! Internally store the pointer as a void *, keeping const if created with"},
{"lineNum":"  214","line":"    //! a const pointer"},
{"lineNum":"  215","line":"    using PT = typename std::conditional<std::is_const<typename std::remove_pointer<typename std::remove_reference<T>::type>::type>::value,"},
{"lineNum":"  216","line":"                                         const void *,"},
{"lineNum":"  217","line":"                                         void *>::type;"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"    BinaryData( T && d, uint64_t s ) : data(std::forward<T>(d)), size(s) {}"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"    PT data;       //!< pointer to beginning of data"},
{"lineNum":"  222","line":"    uint64_t size; //!< size in bytes"},
{"lineNum":"  223","line":"  };"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"  // ######################################################################"},
{"lineNum":"  226","line":"  //! A wrapper around data that should be serialized after all non-deferred data"},
{"lineNum":"  227","line":"  /*! This class is used to demarcate data that can only be safely serialized after"},
{"lineNum":"  228","line":"      any data not wrapped in this class."},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"      @internal */"},
{"lineNum":"  231","line":"  template <class T>"},
{"lineNum":"  232","line":"  class DeferredData : detail::DeferredDataCore"},
{"lineNum":"  233","line":"  {"},
{"lineNum":"  234","line":"    private:"},
{"lineNum":"  235","line":"      // If we get passed an array, keep the type as is, otherwise store"},
{"lineNum":"  236","line":"      // a reference if we were passed an l value reference, else copy the value"},
{"lineNum":"  237","line":"      using Type = typename std::conditional<std::is_array<typename std::remove_reference<T>::type>::value,"},
{"lineNum":"  238","line":"                                             typename std::remove_cv<T>::type,"},
{"lineNum":"  239","line":"                                             typename std::conditional<std::is_lvalue_reference<T>::value,"},
{"lineNum":"  240","line":"                                                                       T,"},
{"lineNum":"  241","line":"                                                                       typename std::decay<T>::type>::type>::type;"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"      // prevent nested nvps"},
{"lineNum":"  244","line":"      static_assert( !std::is_base_of<detail::DeferredDataCore, T>::value,"},
{"lineNum":"  245","line":"                     \"Cannot defer DeferredData\" );"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"      DeferredData & operator=( DeferredData const & ) = delete;"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"    public:"},
{"lineNum":"  250","line":"      //! Constructs a new NameValuePair"},
{"lineNum":"  251","line":"      /*! @param v The value to defer.  Ideally this should be an l-value reference so that"},
{"lineNum":"  252","line":"                   the value can be both loaded and saved to.  If you pass an r-value reference,"},
{"lineNum":"  253","line":"                   the DeferredData will store a copy of it instead of a reference.  Thus you should"},
{"lineNum":"  254","line":"                   only pass r-values in cases where this makes sense, such as the result of some"},
{"lineNum":"  255","line":"                   size() call."},
{"lineNum":"  256","line":"          @internal */"},
{"lineNum":"  257","line":"      DeferredData( T && v ) : value(std::forward<T>(v)) {}"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"      Type value;"},
{"lineNum":"  260","line":"  };"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"  // ######################################################################"},
{"lineNum":"  263","line":"  namespace detail"},
{"lineNum":"  264","line":"  {"},
{"lineNum":"  265","line":"    // base classes for type checking"},
{"lineNum":"  266","line":"    /* The rtti virtual function only exists to enable an archive to"},
{"lineNum":"  267","line":"       be used in a polymorphic fashion, if necessary.  See the"},
{"lineNum":"  268","line":"       archive adapters for an example of this */"},
{"lineNum":"  269","line":"    class OutputArchiveBase"},
{"lineNum":"  270","line":"    {"},
{"lineNum":"  271","line":"      public:"},
{"lineNum":"  272","line":"        OutputArchiveBase() = default;"},
{"lineNum":"  273","line":"        OutputArchiveBase( OutputArchiveBase && ) CEREAL_NOEXCEPT {}"},
{"lineNum":"  274","line":"        OutputArchiveBase & operator=( OutputArchiveBase && ) CEREAL_NOEXCEPT { return *this; }"},
{"lineNum":"  275","line":"        virtual ~OutputArchiveBase() CEREAL_NOEXCEPT = default;"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"      private:"},
{"lineNum":"  278","line":"        virtual void rtti() {}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  279","line":"    };"},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"    class InputArchiveBase"},
{"lineNum":"  282","line":"    {"},
{"lineNum":"  283","line":"      public:"},
{"lineNum":"  284","line":"        InputArchiveBase() = default;"},
{"lineNum":"  285","line":"        InputArchiveBase( InputArchiveBase && ) CEREAL_NOEXCEPT {}"},
{"lineNum":"  286","line":"        InputArchiveBase & operator=( InputArchiveBase && ) CEREAL_NOEXCEPT { return *this; }"},
{"lineNum":"  287","line":"        virtual ~InputArchiveBase() CEREAL_NOEXCEPT = default;"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"      private:"},
{"lineNum":"  290","line":"        virtual void rtti() {}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  291","line":"    };"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"    // forward decls for polymorphic support"},
{"lineNum":"  294","line":"    template <class Archive, class T> struct polymorphic_serialization_support;"},
{"lineNum":"  295","line":"    struct adl_tag;"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"    // used during saving pointers"},
{"lineNum":"  298","line":"    static const uint32_t msb_32bit  = 0x80000000;"},
{"lineNum":"  299","line":"    static const int32_t msb2_32bit = 0x40000000;"},
{"lineNum":"  300","line":"  }"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"  // ######################################################################"},
{"lineNum":"  303","line":"  //! A wrapper around size metadata"},
{"lineNum":"  304","line":"  /*! This class provides a way for archives to have more flexibility over how"},
{"lineNum":"  305","line":"      they choose to serialize size metadata for containers.  For some archive"},
{"lineNum":"  306","line":"      types, the size may be implicitly encoded in the output (e.g. JSON) and"},
{"lineNum":"  307","line":"      not need an explicit entry.  Specializing serialize or load/save for"},
{"lineNum":"  308","line":"      your archive and SizeTags allows you to choose what happens."},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"      @internal */"},
{"lineNum":"  311","line":"  template <class T>"},
{"lineNum":"  312","line":"  class SizeTag"},
{"lineNum":"  313","line":"  {"},
{"lineNum":"  314","line":"    private:"},
{"lineNum":"  315","line":"      // Store a reference if passed an lvalue reference, otherwise"},
{"lineNum":"  316","line":"      // make a copy of the data"},
{"lineNum":"  317","line":"      using Type = typename std::conditional<std::is_lvalue_reference<T>::value,"},
{"lineNum":"  318","line":"                                             T,"},
{"lineNum":"  319","line":"                                             typename std::decay<T>::type>::type;"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"      SizeTag & operator=( SizeTag const & ) = delete;"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"    public:"},
{"lineNum":"  324","line":"      SizeTag( T && sz ) : size(std::forward<T>(sz)) {}"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"      Type size;"},
{"lineNum":"  327","line":"  };"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"  // ######################################################################"},
{"lineNum":"  330","line":"  //! A wrapper around a key and value for serializing data into maps."},
{"lineNum":"  331","line":"  /*! This class just provides a grouping of keys and values into a struct for"},
{"lineNum":"  332","line":"      human readable archives. For example, XML archives will use this wrapper"},
{"lineNum":"  333","line":"      to write maps like so:"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"      @code{.xml}"},
{"lineNum":"  336","line":"      <mymap>"},
{"lineNum":"  337","line":"        <item0>"},
{"lineNum":"  338","line":"          <key>MyFirstKey</key>"},
{"lineNum":"  339","line":"          <value>MyFirstValue</value>"},
{"lineNum":"  340","line":"        </item0>"},
{"lineNum":"  341","line":"        <item1>"},
{"lineNum":"  342","line":"          <key>MySecondKey</key>"},
{"lineNum":"  343","line":"          <value>MySecondValue</value>"},
{"lineNum":"  344","line":"        </item1>"},
{"lineNum":"  345","line":"      </mymap>"},
{"lineNum":"  346","line":"      @endcode"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"      \\sa make_map_item"},
{"lineNum":"  349","line":"      @internal */"},
{"lineNum":"  350","line":"  template <class Key, class Value>"},
{"lineNum":"  351","line":"  struct MapItem"},
{"lineNum":"  352","line":"  {"},
{"lineNum":"  353","line":"    using KeyType = typename std::conditional<"},
{"lineNum":"  354","line":"      std::is_lvalue_reference<Key>::value,"},
{"lineNum":"  355","line":"      Key,"},
{"lineNum":"  356","line":"      typename std::decay<Key>::type>::type;"},
{"lineNum":"  357","line":""},
{"lineNum":"  358","line":"    using ValueType = typename std::conditional<"},
{"lineNum":"  359","line":"      std::is_lvalue_reference<Value>::value,"},
{"lineNum":"  360","line":"      Value,"},
{"lineNum":"  361","line":"      typename std::decay<Value>::type>::type;"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"    //! Construct a MapItem from a key and a value"},
{"lineNum":"  364","line":"    /*! @internal */"},
{"lineNum":"  365","line":"    MapItem( Key && key_, Value && value_ ) : key(std::forward<Key>(key_)), value(std::forward<Value>(value_)) {}"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"    MapItem & operator=( MapItem const & ) = delete;"},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"    KeyType key;"},
{"lineNum":"  370","line":"    ValueType value;"},
{"lineNum":"  371","line":""},
{"lineNum":"  372","line":"    //! Serialize the MapItem with the NVPs \"key\" and \"value\""},
{"lineNum":"  373","line":"    template <class Archive> inline"},
{"lineNum":"  374","line":"    void CEREAL_SERIALIZE_FUNCTION_NAME(Archive & archive)"},
{"lineNum":"  375","line":"    {"},
{"lineNum":"  376","line":"      archive( make_nvp<Archive>(\"key\",   key),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  377","line":"               make_nvp<Archive>(\"value\", value) );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  378","line":"    }"},
{"lineNum":"  379","line":"  };"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"  //! Create a MapItem so that human readable archives will group keys and values together"},
{"lineNum":"  382","line":"  /*! @internal"},
{"lineNum":"  383","line":"      @relates MapItem */"},
{"lineNum":"  384","line":"  template <class KeyType, class ValueType> inline"},
{"lineNum":"  385","line":"  MapItem<KeyType, ValueType> make_map_item(KeyType && key, ValueType && value)"},
{"lineNum":"  386","line":"  {"},
{"lineNum":"  387","line":"    return {std::forward<KeyType>(key), std::forward<ValueType>(value)};"},
{"lineNum":"  388","line":"  }"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"  namespace detail"},
{"lineNum":"  391","line":"  {"},
{"lineNum":"  392","line":"    //! Tag for Version, which due to its anonymous namespace, becomes a different"},
{"lineNum":"  393","line":"    //! type in each translation unit"},
{"lineNum":"  394","line":"    /*! This allows CEREAL_CLASS_VERSION to be safely called in a header file */"},
{"lineNum":"  395","line":"    namespace{ struct version_binding_tag {}; }"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"    // ######################################################################"},
{"lineNum":"  398","line":"    //! Version information class"},
{"lineNum":"  399","line":"    /*! This is the base case for classes that have not been explicitly"},
{"lineNum":"  400","line":"        registered */"},
{"lineNum":"  401","line":"    template <class T, class BindingTag = version_binding_tag> struct Version"},
{"lineNum":"  402","line":"    {"},
{"lineNum":"  403","line":"      static const std::uint32_t version = 0;"},
{"lineNum":"  404","line":"      // we don\'t need to explicitly register these types since they"},
{"lineNum":"  405","line":"      // always get a version number of 0"},
{"lineNum":"  406","line":"    };"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"    //! Holds all registered version information"},
{"lineNum":"  409","line":"    struct Versions"},
{"lineNum":"  410","line":"    {"},
{"lineNum":"  411","line":"      std::unordered_map<std::size_t, std::uint32_t> mapping;"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"      std::uint32_t find( std::size_t hash, std::uint32_t version )"},
{"lineNum":"  414","line":"      {"},
{"lineNum":"  415","line":"        const auto result = mapping.emplace( hash, version );"},
{"lineNum":"  416","line":"        return result.first->second;"},
{"lineNum":"  417","line":"      }"},
{"lineNum":"  418","line":"    }; // struct Versions"},
{"lineNum":"  419","line":"  } // namespace detail"},
{"lineNum":"  420","line":"} // namespace cereal"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"#endif // CEREAL_DETAILS_HELPERS_HPP_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 7, "covered" : 0,};
var merged_data = [];
