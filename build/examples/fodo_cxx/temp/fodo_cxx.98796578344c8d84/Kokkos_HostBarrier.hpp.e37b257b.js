var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_HOST_BARRIER_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_HOST_BARRIER_HPP"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include <Kokkos_Macros.hpp>"},
{"lineNum":"   49","line":"#include <Kokkos_Atomic.hpp>"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"namespace Kokkos {"},
{"lineNum":"   52","line":"namespace Impl {"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"// class HostBarrier"},
{"lineNum":"   55","line":"//"},
{"lineNum":"   56","line":"// provides a static and member interface for a barrier shared between threads"},
{"lineNum":"   57","line":"// of execution."},
{"lineNum":"   58","line":"//"},
{"lineNum":"   59","line":"// *buffer* is a shared resource between the threads of execution"},
{"lineNum":"   60","line":"// *step* should be a stack variable associated with the current thread of"},
{"lineNum":"   61","line":"// execution *size* is the number of threads which share the barrier"},
{"lineNum":"   62","line":"//"},
{"lineNum":"   63","line":"// before calling any arrive type function the buffer and step must have been"},
{"lineNum":"   64","line":"// initialized to 0 and one of the following conditions must be true"},
{"lineNum":"   65","line":"//"},
{"lineNum":"   66","line":"// 1) step == 0 (i.e. first arrive call to HostBarrier),"},
{"lineNum":"   67","line":"// 2) try_wait has returned true for the current thread of execution,"},
{"lineNum":"   68","line":"// 3) a wait type function has returned for the current thread of execution, or"},
{"lineNum":"   69","line":"// 4) split_arrive returned true on the current thread of execution and it has"},
{"lineNum":"   70","line":"//    called split_release"},
{"lineNum":"   71","line":"//"},
{"lineNum":"   72","line":"// The purporse of the split functions is to allow the last thread to arrive"},
{"lineNum":"   73","line":"// an opportunity to perform some actions before releasing the waiting threads"},
{"lineNum":"   74","line":"//"},
{"lineNum":"   75","line":"// If all threads have arrived (and split_release has been call if using"},
{"lineNum":"   76","line":"// split_arrive) before a wait type call, the wait may return quickly"},
{"lineNum":"   77","line":"class HostBarrier {"},
{"lineNum":"   78","line":" public:"},
{"lineNum":"   79","line":"  using buffer_type                         = int;"},
{"lineNum":"   80","line":"  static constexpr int required_buffer_size = 128;"},
{"lineNum":"   81","line":"  static constexpr int required_buffer_length ="},
{"lineNum":"   82","line":"      required_buffer_size / sizeof(int);"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":" private:"},
{"lineNum":"   85","line":"  // fit the following 3 atomics within a 128 bytes while"},
{"lineNum":"   86","line":"  // keeping the arrive atomic at least 64 bytes away from"},
{"lineNum":"   87","line":"  // the wait atomic to reduce contention on the caches"},
{"lineNum":"   88","line":"  static constexpr int arrive_idx = 32 / sizeof(int);"},
{"lineNum":"   89","line":"  static constexpr int master_idx = 64 / sizeof(int);"},
{"lineNum":"   90","line":"  static constexpr int wait_idx   = 96 / sizeof(int);"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"  static constexpr int num_nops                   = 32;"},
{"lineNum":"   93","line":"  static constexpr int iterations_till_backoff    = 64;"},
{"lineNum":"   94","line":"  static constexpr int log2_iterations_till_yield = 4;"},
{"lineNum":"   95","line":"  static constexpr int log2_iterations_till_sleep = 6;"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":" public:"},
{"lineNum":"   98","line":"  // will return true if call is the last thread to arrive"},
{"lineNum":"   99","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  100","line":"  static bool split_arrive(int* buffer, const int size, int& step,"},
{"lineNum":"  101","line":"                           const bool master_wait = true) noexcept {"},
{"lineNum":"  102","line":"    if (size <= 1) return true;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"    ++step;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  105","line":"    Kokkos::memory_fence();"},
{"lineNum":"  106","line":"    const bool result ="},
{"lineNum":"  107","line":"        Kokkos::atomic_fetch_add(buffer + arrive_idx, 1) == size - 1;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    if (master_wait && result) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  110","line":"      Kokkos::atomic_fetch_add(buffer + master_idx, 1);"},
{"lineNum":"  111","line":"    }"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"    return result;"},
{"lineNum":"  114","line":"  }"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"  // release waiting threads"},
{"lineNum":"  117","line":"  // only the thread which received a return value of true from split_arrive"},
{"lineNum":"  118","line":"  // or the thread which calls split_master_wait may call split_release"},
{"lineNum":"  119","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  120","line":"  static void split_release(int* buffer, const int size, const int /*step*/"},
{"lineNum":"  121","line":"                            ) noexcept {"},
{"lineNum":"  122","line":"    if (size <= 1) return;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  123","line":"    Kokkos::memory_fence();"},
{"lineNum":"  124","line":"    Kokkos::atomic_fetch_sub(buffer + arrive_idx, size);"},
{"lineNum":"  125","line":"    Kokkos::atomic_fetch_add(buffer + wait_idx, 1);"},
{"lineNum":"  126","line":"  }"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"  // should only be called by the master thread, will allow the master thread to"},
{"lineNum":"  129","line":"  // resume after all threads have arrived"},
{"lineNum":"  130","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  131","line":"  static void split_master_wait(int* buffer, const int size, const int step,"},
{"lineNum":"  132","line":"                                const bool active_wait = true) noexcept {"},
{"lineNum":"  133","line":"    if (size <= 1) return;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  134","line":"    wait_until_equal(buffer + master_idx, step, active_wait);"},
{"lineNum":"  135","line":"  }"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"  // arrive, last thread automatically release waiting threads"},
{"lineNum":"  138","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  139","line":"  static void arrive(int* buffer, const int size, int& step) noexcept {"},
{"lineNum":"  140","line":"    if (size <= 1) return;"},
{"lineNum":"  141","line":"    if (split_arrive(buffer, size, step)) {"},
{"lineNum":"  142","line":"      split_release(buffer, size, step);"},
{"lineNum":"  143","line":"    }"},
{"lineNum":"  144","line":"  }"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"  // test if all threads have arrived"},
{"lineNum":"  147","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  148","line":"  static bool try_wait(int* buffer, const int size, const int step) noexcept {"},
{"lineNum":"  149","line":"    if (size <= 1) return true;"},
{"lineNum":"  150","line":"    return test_equal(buffer + wait_idx, step);"},
{"lineNum":"  151","line":"  }"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"  // wait for all threads to arrive"},
{"lineNum":"  154","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  155","line":"  static void wait(int* buffer, const int size, const int step,"},
{"lineNum":"  156","line":"                   bool active_wait = true) noexcept {"},
{"lineNum":"  157","line":"    if (size <= 1) return;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  158","line":"    wait_until_equal(buffer + wait_idx, step, active_wait);"},
{"lineNum":"  159","line":"  }"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":" public:"},
{"lineNum":"  162","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  163","line":"  bool split_arrive(const bool master_wait = true) const noexcept {"},
{"lineNum":"  164","line":"    return split_arrive(m_buffer, m_size, m_step, master_wait);"},
{"lineNum":"  165","line":"  }"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  168","line":"  void split_release() const noexcept {"},
{"lineNum":"  169","line":"    split_release(m_buffer, m_size, m_step);"},
{"lineNum":"  170","line":"  }"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  173","line":"  void split_master_wait(const bool active_wait = true) noexcept {"},
{"lineNum":"  174","line":"    split_master_wait(m_buffer, m_size, m_step, active_wait);"},
{"lineNum":"  175","line":"  }"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  178","line":"  void arrive() const noexcept { return arrive(m_buffer, m_size, m_step); }"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  181","line":"  bool try_wait() const noexcept { return try_wait(m_buffer, m_size, m_step); }"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  184","line":"  void wait() const noexcept { wait(m_buffer, m_size, m_step); }"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"  HostBarrier()              = default;"},
{"lineNum":"  187","line":"  HostBarrier(HostBarrier&&) = default;"},
{"lineNum":"  188","line":"  HostBarrier& operator=(HostBarrier&&) = default;"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  191","line":"  HostBarrier(int size, int* buffer)"},
{"lineNum":"  192","line":"      : m_size{size}, m_step{0u}, m_buffer{buffer} {}"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"  HostBarrier(const HostBarrier&) = delete;"},
{"lineNum":"  195","line":"  HostBarrier& operator=(const HostBarrier&) = delete;"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":" private:"},
{"lineNum":"  198","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  199","line":"  static bool test_equal(int* ptr, int v) noexcept {"},
{"lineNum":"  200","line":"    const bool result = Kokkos::atomic_fetch_add(ptr, 0) == v;","class":"lineNoCov","hits":"0","possible_hits":"42",},
{"lineNum":"  201","line":"    if (result) {","class":"lineNoCov","hits":"0","possible_hits":"43",},
{"lineNum":"  202","line":"      Kokkos::memory_fence();"},
{"lineNum":"  203","line":"    }"},
{"lineNum":"  204","line":"    return result;"},
{"lineNum":"  205","line":"  }"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  208","line":"  static void wait_until_equal(int* ptr, const int v,"},
{"lineNum":"  209","line":"                               bool active_wait = true) noexcept {"},
{"lineNum":"  210","line":"#if defined(KOKKOS_ACTIVE_EXECUTION_MEMORY_SPACE_HOST)"},
{"lineNum":"  211","line":"    bool result = test_equal(ptr, v);"},
{"lineNum":"  212","line":"    for (int i = 0; !result && i < iterations_till_backoff; ++i) {","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  213","line":"#if defined(KOKKOS_ENABLE_ASM)"},
{"lineNum":"  214","line":"#if defined(_WIN32)"},
{"lineNum":"  215","line":"      for (int j = 0; j < num_nops; ++j) {"},
{"lineNum":"  216","line":"        __asm__ __volatile__(\"nop\\n\");"},
{"lineNum":"  217","line":"      }"},
{"lineNum":"  218","line":"      __asm__ __volatile__(\"pause\\n\" ::: \"memory\");"},
{"lineNum":"  219","line":"#elif defined(__PPC64__)"},
{"lineNum":"  220","line":"      for (int j = 0; j < num_nops; ++j) {"},
{"lineNum":"  221","line":"        asm volatile(\"nop\\n\");"},
{"lineNum":"  222","line":"      }"},
{"lineNum":"  223","line":"      asm volatile(\"or 27, 27, 27\" ::: \"memory\");"},
{"lineNum":"  224","line":"#elif defined(__amd64) || defined(__amd64__) || defined(__x86_64) || \\"},
{"lineNum":"  225","line":"    defined(__x86_64__)"},
{"lineNum":"  226","line":"      for (int j = 0; j < num_nops; ++j) {"},
{"lineNum":"  227","line":"        asm volatile(\"nop\\n\");"},
{"lineNum":"  228","line":"      }"},
{"lineNum":"  229","line":"      asm volatile(\"pause\\n\" ::: \"memory\");"},
{"lineNum":"  230","line":"#endif"},
{"lineNum":"  231","line":"#endif"},
{"lineNum":"  232","line":"      result = test_equal(ptr, v);"},
{"lineNum":"  233","line":"    }"},
{"lineNum":"  234","line":"    if (!result) {"},
{"lineNum":"  235","line":"      impl_backoff_wait_until_equal(ptr, v, active_wait);"},
{"lineNum":"  236","line":"    }"},
{"lineNum":"  237","line":"#else"},
{"lineNum":"  238","line":"    (void)active_wait;"},
{"lineNum":"  239","line":"    while (!test_equal(ptr, v)) {"},
{"lineNum":"  240","line":"    }"},
{"lineNum":"  241","line":"#endif"},
{"lineNum":"  242","line":"  }"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"  static void impl_backoff_wait_until_equal(int* ptr, const int v,"},
{"lineNum":"  245","line":"                                            const bool active_wait) noexcept;"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":" private:"},
{"lineNum":"  248","line":"  int m_size{0};"},
{"lineNum":"  249","line":"  mutable int m_step{0};"},
{"lineNum":"  250","line":"  int* m_buffer{nullptr};"},
{"lineNum":"  251","line":"};"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"}  // namespace Impl"},
{"lineNum":"  254","line":"}  // namespace Kokkos"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"#endif  // KOKKOS_HOST_BARRIER_HPP"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 10, "covered" : 0,};
var merged_data = [];
