var data = {lines:[
{"lineNum":"    1","line":"/* Copyright (C) 2002-2020 Free Software Foundation, Inc."},
{"lineNum":"    2","line":"   This file is part of the GNU C Library."},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"   The GNU C Library is free software; you can redistribute it and/or"},
{"lineNum":"    5","line":"   modify it under the terms of the GNU Lesser General Public"},
{"lineNum":"    6","line":"   License as published by the Free Software Foundation; either"},
{"lineNum":"    7","line":"   version 2.1 of the License, or (at your option) any later version."},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"   The GNU C Library is distributed in the hope that it will be useful,"},
{"lineNum":"   10","line":"   but WITHOUT ANY WARRANTY; without even the implied warranty of"},
{"lineNum":"   11","line":"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU"},
{"lineNum":"   12","line":"   Lesser General Public License for more details."},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"   You should have received a copy of the GNU Lesser General Public"},
{"lineNum":"   15","line":"   License along with the GNU C Library; if not, see"},
{"lineNum":"   16","line":"   <https://www.gnu.org/licenses/>.  */"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"#ifndef _PTHREAD_H"},
{"lineNum":"   19","line":"#define _PTHREAD_H\t1"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"#include <features.h>"},
{"lineNum":"   22","line":"#include <sched.h>"},
{"lineNum":"   23","line":"#include <time.h>"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"#include <bits/endian.h>"},
{"lineNum":"   26","line":"#include <bits/pthreadtypes.h>"},
{"lineNum":"   27","line":"#include <bits/setjmp.h>"},
{"lineNum":"   28","line":"#include <bits/wordsize.h>"},
{"lineNum":"   29","line":"#include <bits/types/struct_timespec.h>"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"/* Detach state.  */"},
{"lineNum":"   33","line":"enum"},
{"lineNum":"   34","line":"{"},
{"lineNum":"   35","line":"  PTHREAD_CREATE_JOINABLE,"},
{"lineNum":"   36","line":"#define PTHREAD_CREATE_JOINABLE\tPTHREAD_CREATE_JOINABLE"},
{"lineNum":"   37","line":"  PTHREAD_CREATE_DETACHED"},
{"lineNum":"   38","line":"#define PTHREAD_CREATE_DETACHED\tPTHREAD_CREATE_DETACHED"},
{"lineNum":"   39","line":"};"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"/* Mutex types.  */"},
{"lineNum":"   43","line":"enum"},
{"lineNum":"   44","line":"{"},
{"lineNum":"   45","line":"  PTHREAD_MUTEX_TIMED_NP,"},
{"lineNum":"   46","line":"  PTHREAD_MUTEX_RECURSIVE_NP,"},
{"lineNum":"   47","line":"  PTHREAD_MUTEX_ERRORCHECK_NP,"},
{"lineNum":"   48","line":"  PTHREAD_MUTEX_ADAPTIVE_NP"},
{"lineNum":"   49","line":"#if defined __USE_UNIX98 || defined __USE_XOPEN2K8"},
{"lineNum":"   50","line":"  ,"},
{"lineNum":"   51","line":"  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,"},
{"lineNum":"   52","line":"  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,"},
{"lineNum":"   53","line":"  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,"},
{"lineNum":"   54","line":"  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL"},
{"lineNum":"   55","line":"#endif"},
{"lineNum":"   56","line":"#ifdef __USE_GNU"},
{"lineNum":"   57","line":"  /* For compatibility.  */"},
{"lineNum":"   58","line":"  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP"},
{"lineNum":"   59","line":"#endif"},
{"lineNum":"   60","line":"};"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":"   64","line":"/* Robust mutex or not flags.  */"},
{"lineNum":"   65","line":"enum"},
{"lineNum":"   66","line":"{"},
{"lineNum":"   67","line":"  PTHREAD_MUTEX_STALLED,"},
{"lineNum":"   68","line":"  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,"},
{"lineNum":"   69","line":"  PTHREAD_MUTEX_ROBUST,"},
{"lineNum":"   70","line":"  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST"},
{"lineNum":"   71","line":"};"},
{"lineNum":"   72","line":"#endif"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"#if defined __USE_POSIX199506 || defined __USE_UNIX98"},
{"lineNum":"   76","line":"/* Mutex protocols.  */"},
{"lineNum":"   77","line":"enum"},
{"lineNum":"   78","line":"{"},
{"lineNum":"   79","line":"  PTHREAD_PRIO_NONE,"},
{"lineNum":"   80","line":"  PTHREAD_PRIO_INHERIT,"},
{"lineNum":"   81","line":"  PTHREAD_PRIO_PROTECT"},
{"lineNum":"   82","line":"};"},
{"lineNum":"   83","line":"#endif"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"#define PTHREAD_MUTEX_INITIALIZER \\"},
{"lineNum":"   87","line":" { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_TIMED_NP) } }"},
{"lineNum":"   88","line":"#ifdef __USE_GNU"},
{"lineNum":"   89","line":"# define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \\"},
{"lineNum":"   90","line":" { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_RECURSIVE_NP) } }"},
{"lineNum":"   91","line":"# define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \\"},
{"lineNum":"   92","line":" { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ERRORCHECK_NP) } }"},
{"lineNum":"   93","line":"# define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \\"},
{"lineNum":"   94","line":" { {  __PTHREAD_MUTEX_INITIALIZER (PTHREAD_MUTEX_ADAPTIVE_NP) } }"},
{"lineNum":"   95","line":"#endif"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"/* Read-write lock types.  */"},
{"lineNum":"   99","line":"#if defined __USE_UNIX98 || defined __USE_XOPEN2K"},
{"lineNum":"  100","line":"enum"},
{"lineNum":"  101","line":"{"},
{"lineNum":"  102","line":"  PTHREAD_RWLOCK_PREFER_READER_NP,"},
{"lineNum":"  103","line":"  PTHREAD_RWLOCK_PREFER_WRITER_NP,"},
{"lineNum":"  104","line":"  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,"},
{"lineNum":"  105","line":"  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP"},
{"lineNum":"  106","line":"};"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"/* Read-write lock initializers.  */"},
{"lineNum":"  110","line":"# define PTHREAD_RWLOCK_INITIALIZER \\"},
{"lineNum":"  111","line":"  { { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_DEFAULT_NP) } }"},
{"lineNum":"  112","line":"# ifdef __USE_GNU"},
{"lineNum":"  113","line":"#  define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \\"},
{"lineNum":"  114","line":"  { { __PTHREAD_RWLOCK_INITIALIZER (PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP) } }"},
{"lineNum":"  115","line":"# endif"},
{"lineNum":"  116","line":"#endif  /* Unix98 or XOpen2K */"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"/* Scheduler inheritance.  */"},
{"lineNum":"  120","line":"enum"},
{"lineNum":"  121","line":"{"},
{"lineNum":"  122","line":"  PTHREAD_INHERIT_SCHED,"},
{"lineNum":"  123","line":"#define PTHREAD_INHERIT_SCHED   PTHREAD_INHERIT_SCHED"},
{"lineNum":"  124","line":"  PTHREAD_EXPLICIT_SCHED"},
{"lineNum":"  125","line":"#define PTHREAD_EXPLICIT_SCHED  PTHREAD_EXPLICIT_SCHED"},
{"lineNum":"  126","line":"};"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"/* Scope handling.  */"},
{"lineNum":"  130","line":"enum"},
{"lineNum":"  131","line":"{"},
{"lineNum":"  132","line":"  PTHREAD_SCOPE_SYSTEM,"},
{"lineNum":"  133","line":"#define PTHREAD_SCOPE_SYSTEM    PTHREAD_SCOPE_SYSTEM"},
{"lineNum":"  134","line":"  PTHREAD_SCOPE_PROCESS"},
{"lineNum":"  135","line":"#define PTHREAD_SCOPE_PROCESS   PTHREAD_SCOPE_PROCESS"},
{"lineNum":"  136","line":"};"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"/* Process shared or private flag.  */"},
{"lineNum":"  140","line":"enum"},
{"lineNum":"  141","line":"{"},
{"lineNum":"  142","line":"  PTHREAD_PROCESS_PRIVATE,"},
{"lineNum":"  143","line":"#define PTHREAD_PROCESS_PRIVATE PTHREAD_PROCESS_PRIVATE"},
{"lineNum":"  144","line":"  PTHREAD_PROCESS_SHARED"},
{"lineNum":"  145","line":"#define PTHREAD_PROCESS_SHARED  PTHREAD_PROCESS_SHARED"},
{"lineNum":"  146","line":"};"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"/* Conditional variable handling.  */"},
{"lineNum":"  151","line":"#define PTHREAD_COND_INITIALIZER { { {0}, {0}, {0, 0}, {0, 0}, 0, 0, {0, 0} } }"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"/* Cleanup buffers */"},
{"lineNum":"  155","line":"struct _pthread_cleanup_buffer"},
{"lineNum":"  156","line":"{"},
{"lineNum":"  157","line":"  void (*__routine) (void *);             /* Function to call.  */"},
{"lineNum":"  158","line":"  void *__arg;                            /* Its argument.  */"},
{"lineNum":"  159","line":"  int __canceltype;                       /* Saved cancellation type. */"},
{"lineNum":"  160","line":"  struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */"},
{"lineNum":"  161","line":"};"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"/* Cancellation */"},
{"lineNum":"  164","line":"enum"},
{"lineNum":"  165","line":"{"},
{"lineNum":"  166","line":"  PTHREAD_CANCEL_ENABLE,"},
{"lineNum":"  167","line":"#define PTHREAD_CANCEL_ENABLE   PTHREAD_CANCEL_ENABLE"},
{"lineNum":"  168","line":"  PTHREAD_CANCEL_DISABLE"},
{"lineNum":"  169","line":"#define PTHREAD_CANCEL_DISABLE  PTHREAD_CANCEL_DISABLE"},
{"lineNum":"  170","line":"};"},
{"lineNum":"  171","line":"enum"},
{"lineNum":"  172","line":"{"},
{"lineNum":"  173","line":"  PTHREAD_CANCEL_DEFERRED,"},
{"lineNum":"  174","line":"#define PTHREAD_CANCEL_DEFERRED\tPTHREAD_CANCEL_DEFERRED"},
{"lineNum":"  175","line":"  PTHREAD_CANCEL_ASYNCHRONOUS"},
{"lineNum":"  176","line":"#define PTHREAD_CANCEL_ASYNCHRONOUS\tPTHREAD_CANCEL_ASYNCHRONOUS"},
{"lineNum":"  177","line":"};"},
{"lineNum":"  178","line":"#define PTHREAD_CANCELED ((void *) -1)"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"/* Single execution handling.  */"},
{"lineNum":"  182","line":"#define PTHREAD_ONCE_INIT 0"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":"  186","line":"/* Value returned by \'pthread_barrier_wait\' for one of the threads after"},
{"lineNum":"  187","line":"   the required number of threads have called this function."},
{"lineNum":"  188","line":"   -1 is distinct from 0 and all errno constants */"},
{"lineNum":"  189","line":"# define PTHREAD_BARRIER_SERIAL_THREAD -1"},
{"lineNum":"  190","line":"#endif"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"__BEGIN_DECLS"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"/* Create a new thread, starting with execution of START-ROUTINE"},
{"lineNum":"  196","line":"   getting passed ARG.  Creation attributed come from ATTR.  The new"},
{"lineNum":"  197","line":"   handle is stored in *NEWTHREAD.  */"},
{"lineNum":"  198","line":"extern int pthread_create (pthread_t *__restrict __newthread,"},
{"lineNum":"  199","line":"\t\t\t   const pthread_attr_t *__restrict __attr,"},
{"lineNum":"  200","line":"\t\t\t   void *(*__start_routine) (void *),"},
{"lineNum":"  201","line":"\t\t\t   void *__restrict __arg) __THROWNL __nonnull ((1, 3));"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"/* Terminate calling thread."},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"   The registered cleanup handlers are called via exception handling"},
{"lineNum":"  206","line":"   so we cannot mark this function with __THROW.*/"},
{"lineNum":"  207","line":"extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"/* Make calling thread wait for termination of the thread TH.  The"},
{"lineNum":"  210","line":"   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN"},
{"lineNum":"  211","line":"   is not NULL."},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"   This function is a cancellation point and therefore not marked with"},
{"lineNum":"  214","line":"   __THROW.  */"},
{"lineNum":"  215","line":"extern int pthread_join (pthread_t __th, void **__thread_return);"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"#ifdef __USE_GNU"},
{"lineNum":"  218","line":"/* Check whether thread TH has terminated.  If yes return the status of"},
{"lineNum":"  219","line":"   the thread in *THREAD_RETURN, if THREAD_RETURN is not NULL.  */"},
{"lineNum":"  220","line":"extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __THROW;"},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"/* Make calling thread wait for termination of the thread TH, but only"},
{"lineNum":"  223","line":"   until TIMEOUT.  The exit status of the thread is stored in"},
{"lineNum":"  224","line":"   *THREAD_RETURN, if THREAD_RETURN is not NULL."},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"   This function is a cancellation point and therefore not marked with"},
{"lineNum":"  227","line":"   __THROW.  */"},
{"lineNum":"  228","line":"extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,"},
{"lineNum":"  229","line":"\t\t\t\t const struct timespec *__abstime);"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"/* Make calling thread wait for termination of the thread TH, but only"},
{"lineNum":"  232","line":"   until TIMEOUT measured against the clock specified by CLOCKID.  The"},
{"lineNum":"  233","line":"   exit status of the thread is stored in *THREAD_RETURN, if"},
{"lineNum":"  234","line":"   THREAD_RETURN is not NULL."},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"   This function is a cancellation point and therefore not marked with"},
{"lineNum":"  237","line":"   __THROW.  */"},
{"lineNum":"  238","line":"extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,"},
{"lineNum":"  239","line":"                                 clockid_t __clockid,"},
{"lineNum":"  240","line":"\t\t\t\t const struct timespec *__abstime);"},
{"lineNum":"  241","line":"#endif"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"/* Indicate that the thread TH is never to be joined with PTHREAD_JOIN."},
{"lineNum":"  244","line":"   The resources of TH will therefore be freed immediately when it"},
{"lineNum":"  245","line":"   terminates, instead of waiting for another thread to perform PTHREAD_JOIN"},
{"lineNum":"  246","line":"   on it.  */"},
{"lineNum":"  247","line":"extern int pthread_detach (pthread_t __th) __THROW;"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"/* Obtain the identifier of the current thread.  */"},
{"lineNum":"  251","line":"extern pthread_t pthread_self (void) __THROW __attribute__ ((__const__));"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"/* Compare two thread identifiers.  */"},
{"lineNum":"  254","line":"extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)"},
{"lineNum":"  255","line":"  __THROW __attribute__ ((__const__));"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"/* Thread attribute handling.  */"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"/* Initialize thread attribute *ATTR with default attributes"},
{"lineNum":"  261","line":"   (detachstate is PTHREAD_JOINABLE, scheduling policy is SCHED_OTHER,"},
{"lineNum":"  262","line":"    no user-provided stack).  */"},
{"lineNum":"  263","line":"extern int pthread_attr_init (pthread_attr_t *__attr) __THROW __nonnull ((1));"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"/* Destroy thread attribute *ATTR.  */"},
{"lineNum":"  266","line":"extern int pthread_attr_destroy (pthread_attr_t *__attr)"},
{"lineNum":"  267","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"/* Get detach state attribute.  */"},
{"lineNum":"  270","line":"extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,"},
{"lineNum":"  271","line":"\t\t\t\t\tint *__detachstate)"},
{"lineNum":"  272","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"/* Set detach state attribute.  */"},
{"lineNum":"  275","line":"extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,"},
{"lineNum":"  276","line":"\t\t\t\t\tint __detachstate)"},
{"lineNum":"  277","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"/* Get the size of the guard area created for stack overflow protection.  */"},
{"lineNum":"  281","line":"extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,"},
{"lineNum":"  282","line":"\t\t\t\t      size_t *__guardsize)"},
{"lineNum":"  283","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"/* Set the size of the guard area created for stack overflow protection.  */"},
{"lineNum":"  286","line":"extern int pthread_attr_setguardsize (pthread_attr_t *__attr,"},
{"lineNum":"  287","line":"\t\t\t\t      size_t __guardsize)"},
{"lineNum":"  288","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"/* Return in *PARAM the scheduling parameters of *ATTR.  */"},
{"lineNum":"  292","line":"extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,"},
{"lineNum":"  293","line":"\t\t\t\t       struct sched_param *__restrict __param)"},
{"lineNum":"  294","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"/* Set scheduling parameters (priority, etc) in *ATTR according to PARAM.  */"},
{"lineNum":"  297","line":"extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,"},
{"lineNum":"  298","line":"\t\t\t\t       const struct sched_param *__restrict"},
{"lineNum":"  299","line":"\t\t\t\t       __param) __THROW __nonnull ((1, 2));"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"/* Return in *POLICY the scheduling policy of *ATTR.  */"},
{"lineNum":"  302","line":"extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict"},
{"lineNum":"  303","line":"\t\t\t\t\t__attr, int *__restrict __policy)"},
{"lineNum":"  304","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"/* Set scheduling policy in *ATTR according to POLICY.  */"},
{"lineNum":"  307","line":"extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)"},
{"lineNum":"  308","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"/* Return in *INHERIT the scheduling inheritance mode of *ATTR.  */"},
{"lineNum":"  311","line":"extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict"},
{"lineNum":"  312","line":"\t\t\t\t\t __attr, int *__restrict __inherit)"},
{"lineNum":"  313","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"/* Set scheduling inheritance mode in *ATTR according to INHERIT.  */"},
{"lineNum":"  316","line":"extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,"},
{"lineNum":"  317","line":"\t\t\t\t\t int __inherit)"},
{"lineNum":"  318","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"/* Return in *SCOPE the scheduling contention scope of *ATTR.  */"},
{"lineNum":"  322","line":"extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,"},
{"lineNum":"  323","line":"\t\t\t\t  int *__restrict __scope)"},
{"lineNum":"  324","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"/* Set scheduling contention scope in *ATTR according to SCOPE.  */"},
{"lineNum":"  327","line":"extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)"},
{"lineNum":"  328","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"/* Return the previously set address for the stack.  */"},
{"lineNum":"  331","line":"extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict"},
{"lineNum":"  332","line":"\t\t\t\t      __attr, void **__restrict __stackaddr)"},
{"lineNum":"  333","line":"     __THROW __nonnull ((1, 2)) __attribute_deprecated__;"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"/* Set the starting address of the stack of the thread to be created."},
{"lineNum":"  336","line":"   Depending on whether the stack grows up or down the value must either"},
{"lineNum":"  337","line":"   be higher or lower than all the address in the memory block.  The"},
{"lineNum":"  338","line":"   minimal size of the block must be PTHREAD_STACK_MIN.  */"},
{"lineNum":"  339","line":"extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,"},
{"lineNum":"  340","line":"\t\t\t\t      void *__stackaddr)"},
{"lineNum":"  341","line":"     __THROW __nonnull ((1)) __attribute_deprecated__;"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"/* Return the currently used minimal stack size.  */"},
{"lineNum":"  344","line":"extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict"},
{"lineNum":"  345","line":"\t\t\t\t      __attr, size_t *__restrict __stacksize)"},
{"lineNum":"  346","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"/* Add information about the minimum stack size needed for the thread"},
{"lineNum":"  349","line":"   to be started.  This size must never be less than PTHREAD_STACK_MIN"},
{"lineNum":"  350","line":"   and must also not exceed the system limits.  */"},
{"lineNum":"  351","line":"extern int pthread_attr_setstacksize (pthread_attr_t *__attr,"},
{"lineNum":"  352","line":"\t\t\t\t      size_t __stacksize)"},
{"lineNum":"  353","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":"  356","line":"/* Return the previously set address for the stack.  */"},
{"lineNum":"  357","line":"extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,"},
{"lineNum":"  358","line":"\t\t\t\t  void **__restrict __stackaddr,"},
{"lineNum":"  359","line":"\t\t\t\t  size_t *__restrict __stacksize)"},
{"lineNum":"  360","line":"     __THROW __nonnull ((1, 2, 3));"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"/* The following two interfaces are intended to replace the last two.  They"},
{"lineNum":"  363","line":"   require setting the address as well as the size since only setting the"},
{"lineNum":"  364","line":"   address will make the implementation on some architectures impossible.  */"},
{"lineNum":"  365","line":"extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,"},
{"lineNum":"  366","line":"\t\t\t\t  size_t __stacksize) __THROW __nonnull ((1));"},
{"lineNum":"  367","line":"#endif"},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"#ifdef __USE_GNU"},
{"lineNum":"  370","line":"/* Thread created with attribute ATTR will be limited to run only on"},
{"lineNum":"  371","line":"   the processors represented in CPUSET.  */"},
{"lineNum":"  372","line":"extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,"},
{"lineNum":"  373","line":"\t\t\t\t\tsize_t __cpusetsize,"},
{"lineNum":"  374","line":"\t\t\t\t\tconst cpu_set_t *__cpuset)"},
{"lineNum":"  375","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"/* Get bit set in CPUSET representing the processors threads created with"},
{"lineNum":"  378","line":"   ATTR can run on.  */"},
{"lineNum":"  379","line":"extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,"},
{"lineNum":"  380","line":"\t\t\t\t\tsize_t __cpusetsize,"},
{"lineNum":"  381","line":"\t\t\t\t\tcpu_set_t *__cpuset)"},
{"lineNum":"  382","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"/* Get the default attributes used by pthread_create in this process.  */"},
{"lineNum":"  385","line":"extern int pthread_getattr_default_np (pthread_attr_t *__attr)"},
{"lineNum":"  386","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"/* Set the default attributes to be used by pthread_create in this"},
{"lineNum":"  389","line":"   process.  */"},
{"lineNum":"  390","line":"extern int pthread_setattr_default_np (const pthread_attr_t *__attr)"},
{"lineNum":"  391","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"/* Initialize thread attribute *ATTR with attributes corresponding to the"},
{"lineNum":"  394","line":"   already running thread TH.  It shall be called on uninitialized ATTR"},
{"lineNum":"  395","line":"   and destroyed with pthread_attr_destroy when no longer needed.  */"},
{"lineNum":"  396","line":"extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)"},
{"lineNum":"  397","line":"     __THROW __nonnull ((2));"},
{"lineNum":"  398","line":"#endif"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":""},
{"lineNum":"  401","line":"/* Functions for scheduling control.  */"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"/* Set the scheduling parameters for TARGET_THREAD according to POLICY"},
{"lineNum":"  404","line":"   and *PARAM.  */"},
{"lineNum":"  405","line":"extern int pthread_setschedparam (pthread_t __target_thread, int __policy,"},
{"lineNum":"  406","line":"\t\t\t\t  const struct sched_param *__param)"},
{"lineNum":"  407","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"/* Return in *POLICY and *PARAM the scheduling parameters for TARGET_THREAD. */"},
{"lineNum":"  410","line":"extern int pthread_getschedparam (pthread_t __target_thread,"},
{"lineNum":"  411","line":"\t\t\t\t  int *__restrict __policy,"},
{"lineNum":"  412","line":"\t\t\t\t  struct sched_param *__restrict __param)"},
{"lineNum":"  413","line":"     __THROW __nonnull ((2, 3));"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"/* Set the scheduling priority for TARGET_THREAD.  */"},
{"lineNum":"  416","line":"extern int pthread_setschedprio (pthread_t __target_thread, int __prio)"},
{"lineNum":"  417","line":"     __THROW;"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":""},
{"lineNum":"  420","line":"#ifdef __USE_GNU"},
{"lineNum":"  421","line":"/* Get thread name visible in the kernel and its interfaces.  */"},
{"lineNum":"  422","line":"extern int pthread_getname_np (pthread_t __target_thread, char *__buf,"},
{"lineNum":"  423","line":"\t\t\t       size_t __buflen)"},
{"lineNum":"  424","line":"     __THROW __nonnull ((2));"},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"/* Set thread name visible in the kernel and its interfaces.  */"},
{"lineNum":"  427","line":"extern int pthread_setname_np (pthread_t __target_thread, const char *__name)"},
{"lineNum":"  428","line":"     __THROW __nonnull ((2));"},
{"lineNum":"  429","line":"#endif"},
{"lineNum":"  430","line":""},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"#ifdef __USE_UNIX98"},
{"lineNum":"  433","line":"/* Determine level of concurrency.  */"},
{"lineNum":"  434","line":"extern int pthread_getconcurrency (void) __THROW;"},
{"lineNum":"  435","line":""},
{"lineNum":"  436","line":"/* Set new concurrency level to LEVEL.  */"},
{"lineNum":"  437","line":"extern int pthread_setconcurrency (int __level) __THROW;"},
{"lineNum":"  438","line":"#endif"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"#ifdef __USE_GNU"},
{"lineNum":"  441","line":"/* Yield the processor to another thread or process."},
{"lineNum":"  442","line":"   This function is similar to the POSIX `sched_yield\' function but"},
{"lineNum":"  443","line":"   might be differently implemented in the case of a m-on-n thread"},
{"lineNum":"  444","line":"   implementation.  */"},
{"lineNum":"  445","line":"extern int pthread_yield (void) __THROW;"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"/* Limit specified thread TH to run only on the processors represented"},
{"lineNum":"  449","line":"   in CPUSET.  */"},
{"lineNum":"  450","line":"extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,"},
{"lineNum":"  451","line":"\t\t\t\t   const cpu_set_t *__cpuset)"},
{"lineNum":"  452","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"/* Get bit set in CPUSET representing the processors TH can run on.  */"},
{"lineNum":"  455","line":"extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,"},
{"lineNum":"  456","line":"\t\t\t\t   cpu_set_t *__cpuset)"},
{"lineNum":"  457","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  458","line":"#endif"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":"/* Functions for handling initialization.  */"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"/* Guarantee that the initialization function INIT_ROUTINE will be called"},
{"lineNum":"  464","line":"   only once, even if pthread_once is executed several times with the"},
{"lineNum":"  465","line":"   same ONCE_CONTROL argument. ONCE_CONTROL must point to a static or"},
{"lineNum":"  466","line":"   extern variable initialized to PTHREAD_ONCE_INIT."},
{"lineNum":"  467","line":""},
{"lineNum":"  468","line":"   The initialization functions might throw exception which is why"},
{"lineNum":"  469","line":"   this function is not marked with __THROW.  */"},
{"lineNum":"  470","line":"extern int pthread_once (pthread_once_t *__once_control,"},
{"lineNum":"  471","line":"\t\t\t void (*__init_routine) (void)) __nonnull ((1, 2));"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":""},
{"lineNum":"  474","line":"/* Functions for handling cancellation."},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"   Note that these functions are explicitly not marked to not throw an"},
{"lineNum":"  477","line":"   exception in C++ code.  If cancellation is implemented by unwinding"},
{"lineNum":"  478","line":"   this is necessary to have the compiler generate the unwind information.  */"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"/* Set cancelability state of current thread to STATE, returning old"},
{"lineNum":"  481","line":"   state in *OLDSTATE if OLDSTATE is not NULL.  */"},
{"lineNum":"  482","line":"extern int pthread_setcancelstate (int __state, int *__oldstate);"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"/* Set cancellation state of current thread to TYPE, returning the old"},
{"lineNum":"  485","line":"   type in *OLDTYPE if OLDTYPE is not NULL.  */"},
{"lineNum":"  486","line":"extern int pthread_setcanceltype (int __type, int *__oldtype);"},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"/* Cancel THREAD immediately or at the next possibility.  */"},
{"lineNum":"  489","line":"extern int pthread_cancel (pthread_t __th);"},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"/* Test for pending cancellation for the current thread and terminate"},
{"lineNum":"  492","line":"   the thread as per pthread_exit(PTHREAD_CANCELED) if it has been"},
{"lineNum":"  493","line":"   cancelled.  */"},
{"lineNum":"  494","line":"extern void pthread_testcancel (void);"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"/* Cancellation handling with integration into exception handling.  */"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"typedef struct"},
{"lineNum":"  500","line":"{"},
{"lineNum":"  501","line":"  struct"},
{"lineNum":"  502","line":"  {"},
{"lineNum":"  503","line":"    __jmp_buf __cancel_jmp_buf;"},
{"lineNum":"  504","line":"    int __mask_was_saved;"},
{"lineNum":"  505","line":"  } __cancel_jmp_buf[1];"},
{"lineNum":"  506","line":"  void *__pad[4];"},
{"lineNum":"  507","line":"} __pthread_unwind_buf_t __attribute__ ((__aligned__));"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"/* No special attributes by default.  */"},
{"lineNum":"  510","line":"#ifndef __cleanup_fct_attribute"},
{"lineNum":"  511","line":"# define __cleanup_fct_attribute"},
{"lineNum":"  512","line":"#endif"},
{"lineNum":"  513","line":""},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"/* Structure to hold the cleanup handler information.  */"},
{"lineNum":"  516","line":"struct __pthread_cleanup_frame"},
{"lineNum":"  517","line":"{"},
{"lineNum":"  518","line":"  void (*__cancel_routine) (void *);"},
{"lineNum":"  519","line":"  void *__cancel_arg;"},
{"lineNum":"  520","line":"  int __do_it;"},
{"lineNum":"  521","line":"  int __cancel_type;"},
{"lineNum":"  522","line":"};"},
{"lineNum":"  523","line":""},
{"lineNum":"  524","line":"#if defined __GNUC__ && defined __EXCEPTIONS"},
{"lineNum":"  525","line":"# ifdef __cplusplus"},
{"lineNum":"  526","line":"/* Class to handle cancellation handler invocation.  */"},
{"lineNum":"  527","line":"class __pthread_cleanup_class"},
{"lineNum":"  528","line":"{"},
{"lineNum":"  529","line":"  void (*__cancel_routine) (void *);"},
{"lineNum":"  530","line":"  void *__cancel_arg;"},
{"lineNum":"  531","line":"  int __do_it;"},
{"lineNum":"  532","line":"  int __cancel_type;"},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":" public:"},
{"lineNum":"  535","line":"  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)"},
{"lineNum":"  536","line":"    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }"},
{"lineNum":"  537","line":"  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }"},
{"lineNum":"  538","line":"  void __setdoit (int __newval) { __do_it = __newval; }"},
{"lineNum":"  539","line":"  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,"},
{"lineNum":"  540","line":"\t\t\t\t\t   &__cancel_type); }"},
{"lineNum":"  541","line":"  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }"},
{"lineNum":"  542","line":"};"},
{"lineNum":"  543","line":""},
{"lineNum":"  544","line":"/* Install a cleanup handler: ROUTINE will be called with arguments ARG"},
{"lineNum":"  545","line":"   when the thread is canceled or calls pthread_exit.  ROUTINE will also"},
{"lineNum":"  546","line":"   be called with arguments ARG when the matching pthread_cleanup_pop"},
{"lineNum":"  547","line":"   is executed with non-zero EXECUTE argument."},
{"lineNum":"  548","line":""},
{"lineNum":"  549","line":"   pthread_cleanup_push and pthread_cleanup_pop are macros and must always"},
{"lineNum":"  550","line":"   be used in matching pairs at the same nesting level of braces.  */"},
{"lineNum":"  551","line":"#  define pthread_cleanup_push(routine, arg) \\"},
{"lineNum":"  552","line":"  do {\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  553","line":"    __pthread_cleanup_class __clframe (routine, arg)"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"/* Remove a cleanup handler installed by the matching pthread_cleanup_push."},
{"lineNum":"  556","line":"   If EXECUTE is non-zero, the handler function is called. */"},
{"lineNum":"  557","line":"#  define pthread_cleanup_pop(execute) \\"},
{"lineNum":"  558","line":"    __clframe.__setdoit (execute);\t\t\t\t\t      \\"},
{"lineNum":"  559","line":"  } while (0)"},
{"lineNum":"  560","line":""},
{"lineNum":"  561","line":"#  ifdef __USE_GNU"},
{"lineNum":"  562","line":"/* Install a cleanup handler as pthread_cleanup_push does, but also"},
{"lineNum":"  563","line":"   saves the current cancellation type and sets it to deferred"},
{"lineNum":"  564","line":"   cancellation.  */"},
{"lineNum":"  565","line":"#   define pthread_cleanup_push_defer_np(routine, arg) \\"},
{"lineNum":"  566","line":"  do {\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  567","line":"    __pthread_cleanup_class __clframe (routine, arg);\t\t\t      \\"},
{"lineNum":"  568","line":"    __clframe.__defer ()"},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"/* Remove a cleanup handler as pthread_cleanup_pop does, but also"},
{"lineNum":"  571","line":"   restores the cancellation type that was in effect when the matching"},
{"lineNum":"  572","line":"   pthread_cleanup_push_defer was called.  */"},
{"lineNum":"  573","line":"#   define pthread_cleanup_pop_restore_np(execute) \\"},
{"lineNum":"  574","line":"    __clframe.__restore ();\t\t\t\t\t\t      \\"},
{"lineNum":"  575","line":"    __clframe.__setdoit (execute);\t\t\t\t\t      \\"},
{"lineNum":"  576","line":"  } while (0)"},
{"lineNum":"  577","line":"#  endif"},
{"lineNum":"  578","line":"# else"},
{"lineNum":"  579","line":"/* Function called to call the cleanup handler.  As an extern inline"},
{"lineNum":"  580","line":"   function the compiler is free to decide inlining the change when"},
{"lineNum":"  581","line":"   needed or fall back on the copy which must exist somewhere"},
{"lineNum":"  582","line":"   else.  */"},
{"lineNum":"  583","line":"__extern_inline void"},
{"lineNum":"  584","line":"__pthread_cleanup_routine (struct __pthread_cleanup_frame *__frame)"},
{"lineNum":"  585","line":"{"},
{"lineNum":"  586","line":"  if (__frame->__do_it)"},
{"lineNum":"  587","line":"    __frame->__cancel_routine (__frame->__cancel_arg);"},
{"lineNum":"  588","line":"}"},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":"/* Install a cleanup handler: ROUTINE will be called with arguments ARG"},
{"lineNum":"  591","line":"   when the thread is canceled or calls pthread_exit.  ROUTINE will also"},
{"lineNum":"  592","line":"   be called with arguments ARG when the matching pthread_cleanup_pop"},
{"lineNum":"  593","line":"   is executed with non-zero EXECUTE argument."},
{"lineNum":"  594","line":""},
{"lineNum":"  595","line":"   pthread_cleanup_push and pthread_cleanup_pop are macros and must always"},
{"lineNum":"  596","line":"   be used in matching pairs at the same nesting level of braces.  */"},
{"lineNum":"  597","line":"#  define pthread_cleanup_push(routine, arg) \\"},
{"lineNum":"  598","line":"  do {\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  599","line":"    struct __pthread_cleanup_frame __clframe\t\t\t\t      \\"},
{"lineNum":"  600","line":"      __attribute__ ((__cleanup__ (__pthread_cleanup_routine)))\t\t      \\"},
{"lineNum":"  601","line":"      = { .__cancel_routine = (routine), .__cancel_arg = (arg),\t \t      \\"},
{"lineNum":"  602","line":"\t  .__do_it = 1 };"},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"/* Remove a cleanup handler installed by the matching pthread_cleanup_push."},
{"lineNum":"  605","line":"   If EXECUTE is non-zero, the handler function is called. */"},
{"lineNum":"  606","line":"#  define pthread_cleanup_pop(execute) \\"},
{"lineNum":"  607","line":"    __clframe.__do_it = (execute);\t\t\t\t\t      \\"},
{"lineNum":"  608","line":"  } while (0)"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"#  ifdef __USE_GNU"},
{"lineNum":"  611","line":"/* Install a cleanup handler as pthread_cleanup_push does, but also"},
{"lineNum":"  612","line":"   saves the current cancellation type and sets it to deferred"},
{"lineNum":"  613","line":"   cancellation.  */"},
{"lineNum":"  614","line":"#   define pthread_cleanup_push_defer_np(routine, arg) \\"},
{"lineNum":"  615","line":"  do {\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  616","line":"    struct __pthread_cleanup_frame __clframe\t\t\t\t      \\"},
{"lineNum":"  617","line":"      __attribute__ ((__cleanup__ (__pthread_cleanup_routine)))\t\t      \\"},
{"lineNum":"  618","line":"      = { .__cancel_routine = (routine), .__cancel_arg = (arg),\t\t      \\"},
{"lineNum":"  619","line":"\t  .__do_it = 1 };\t\t\t\t\t\t      \\"},
{"lineNum":"  620","line":"    (void) pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,\t\t      \\"},
{"lineNum":"  621","line":"\t\t\t\t  &__clframe.__cancel_type)"},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"/* Remove a cleanup handler as pthread_cleanup_pop does, but also"},
{"lineNum":"  624","line":"   restores the cancellation type that was in effect when the matching"},
{"lineNum":"  625","line":"   pthread_cleanup_push_defer was called.  */"},
{"lineNum":"  626","line":"#   define pthread_cleanup_pop_restore_np(execute) \\"},
{"lineNum":"  627","line":"    (void) pthread_setcanceltype (__clframe.__cancel_type, NULL);\t      \\"},
{"lineNum":"  628","line":"    __clframe.__do_it = (execute);\t\t\t\t\t      \\"},
{"lineNum":"  629","line":"  } while (0)"},
{"lineNum":"  630","line":"#  endif"},
{"lineNum":"  631","line":"# endif"},
{"lineNum":"  632","line":"#else"},
{"lineNum":"  633","line":"/* Install a cleanup handler: ROUTINE will be called with arguments ARG"},
{"lineNum":"  634","line":"   when the thread is canceled or calls pthread_exit.  ROUTINE will also"},
{"lineNum":"  635","line":"   be called with arguments ARG when the matching pthread_cleanup_pop"},
{"lineNum":"  636","line":"   is executed with non-zero EXECUTE argument."},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"   pthread_cleanup_push and pthread_cleanup_pop are macros and must always"},
{"lineNum":"  639","line":"   be used in matching pairs at the same nesting level of braces.  */"},
{"lineNum":"  640","line":"# define pthread_cleanup_push(routine, arg) \\"},
{"lineNum":"  641","line":"  do {\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  642","line":"    __pthread_unwind_buf_t __cancel_buf;\t\t\t\t      \\"},
{"lineNum":"  643","line":"    void (*__cancel_routine) (void *) = (routine);\t\t\t      \\"},
{"lineNum":"  644","line":"    void *__cancel_arg = (arg);\t\t\t\t\t\t      \\"},
{"lineNum":"  645","line":"    int __not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *)     \\"},
{"lineNum":"  646","line":"\t\t\t\t\t__cancel_buf.__cancel_jmp_buf, 0);    \\"},
{"lineNum":"  647","line":"    if (__glibc_unlikely (__not_first_call))\t\t\t\t      \\"},
{"lineNum":"  648","line":"      {\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  649","line":"\t__cancel_routine (__cancel_arg);\t\t\t\t      \\"},
{"lineNum":"  650","line":"\t__pthread_unwind_next (&__cancel_buf);\t\t\t\t      \\"},
{"lineNum":"  651","line":"\t/* NOTREACHED */\t\t\t\t\t\t      \\"},
{"lineNum":"  652","line":"      }\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  653","line":"\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  654","line":"    __pthread_register_cancel (&__cancel_buf);\t\t\t\t      \\"},
{"lineNum":"  655","line":"    do {"},
{"lineNum":"  656","line":"extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)"},
{"lineNum":"  657","line":"     __cleanup_fct_attribute;"},
{"lineNum":"  658","line":""},
{"lineNum":"  659","line":"/* Remove a cleanup handler installed by the matching pthread_cleanup_push."},
{"lineNum":"  660","line":"   If EXECUTE is non-zero, the handler function is called. */"},
{"lineNum":"  661","line":"# define pthread_cleanup_pop(execute) \\"},
{"lineNum":"  662","line":"      do { } while (0);/* Empty to allow label before pthread_cleanup_pop.  */\\"},
{"lineNum":"  663","line":"    } while (0);\t\t\t\t\t\t\t      \\"},
{"lineNum":"  664","line":"    __pthread_unregister_cancel (&__cancel_buf);\t\t\t      \\"},
{"lineNum":"  665","line":"    if (execute)\t\t\t\t\t\t\t      \\"},
{"lineNum":"  666","line":"      __cancel_routine (__cancel_arg);\t\t\t\t\t      \\"},
{"lineNum":"  667","line":"  } while (0)"},
{"lineNum":"  668","line":"extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)"},
{"lineNum":"  669","line":"  __cleanup_fct_attribute;"},
{"lineNum":"  670","line":""},
{"lineNum":"  671","line":"# ifdef __USE_GNU"},
{"lineNum":"  672","line":"/* Install a cleanup handler as pthread_cleanup_push does, but also"},
{"lineNum":"  673","line":"   saves the current cancellation type and sets it to deferred"},
{"lineNum":"  674","line":"   cancellation.  */"},
{"lineNum":"  675","line":"#  define pthread_cleanup_push_defer_np(routine, arg) \\"},
{"lineNum":"  676","line":"  do {\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  677","line":"    __pthread_unwind_buf_t __cancel_buf;\t\t\t\t      \\"},
{"lineNum":"  678","line":"    void (*__cancel_routine) (void *) = (routine);\t\t\t      \\"},
{"lineNum":"  679","line":"    void *__cancel_arg = (arg);\t\t\t\t\t\t      \\"},
{"lineNum":"  680","line":"    int __not_first_call = __sigsetjmp ((struct __jmp_buf_tag *) (void *)     \\"},
{"lineNum":"  681","line":"\t\t\t\t\t__cancel_buf.__cancel_jmp_buf, 0);    \\"},
{"lineNum":"  682","line":"    if (__glibc_unlikely (__not_first_call))\t\t\t\t      \\"},
{"lineNum":"  683","line":"      {\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  684","line":"\t__cancel_routine (__cancel_arg);\t\t\t\t      \\"},
{"lineNum":"  685","line":"\t__pthread_unwind_next (&__cancel_buf);\t\t\t\t      \\"},
{"lineNum":"  686","line":"\t/* NOTREACHED */\t\t\t\t\t\t      \\"},
{"lineNum":"  687","line":"      }\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  688","line":"\t\t\t\t\t\t\t\t\t      \\"},
{"lineNum":"  689","line":"    __pthread_register_cancel_defer (&__cancel_buf);\t\t\t      \\"},
{"lineNum":"  690","line":"    do {"},
{"lineNum":"  691","line":"extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)"},
{"lineNum":"  692","line":"     __cleanup_fct_attribute;"},
{"lineNum":"  693","line":""},
{"lineNum":"  694","line":"/* Remove a cleanup handler as pthread_cleanup_pop does, but also"},
{"lineNum":"  695","line":"   restores the cancellation type that was in effect when the matching"},
{"lineNum":"  696","line":"   pthread_cleanup_push_defer was called.  */"},
{"lineNum":"  697","line":"#  define pthread_cleanup_pop_restore_np(execute) \\"},
{"lineNum":"  698","line":"      do { } while (0);/* Empty to allow label before pthread_cleanup_pop.  */\\"},
{"lineNum":"  699","line":"    } while (0);\t\t\t\t\t\t\t      \\"},
{"lineNum":"  700","line":"    __pthread_unregister_cancel_restore (&__cancel_buf);\t\t      \\"},
{"lineNum":"  701","line":"    if (execute)\t\t\t\t\t\t\t      \\"},
{"lineNum":"  702","line":"      __cancel_routine (__cancel_arg);\t\t\t\t\t      \\"},
{"lineNum":"  703","line":"  } while (0)"},
{"lineNum":"  704","line":"extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)"},
{"lineNum":"  705","line":"  __cleanup_fct_attribute;"},
{"lineNum":"  706","line":"# endif"},
{"lineNum":"  707","line":""},
{"lineNum":"  708","line":"/* Internal interface to initiate cleanup.  */"},
{"lineNum":"  709","line":"extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)"},
{"lineNum":"  710","line":"     __cleanup_fct_attribute __attribute__ ((__noreturn__))"},
{"lineNum":"  711","line":"# ifndef SHARED"},
{"lineNum":"  712","line":"     __attribute__ ((__weak__))"},
{"lineNum":"  713","line":"# endif"},
{"lineNum":"  714","line":"     ;"},
{"lineNum":"  715","line":"#endif"},
{"lineNum":"  716","line":""},
{"lineNum":"  717","line":"/* Function used in the macros.  */"},
{"lineNum":"  718","line":"struct __jmp_buf_tag;"},
{"lineNum":"  719","line":"extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __THROWNL;"},
{"lineNum":"  720","line":""},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"/* Mutex handling.  */"},
{"lineNum":"  723","line":""},
{"lineNum":"  724","line":"/* Initialize a mutex.  */"},
{"lineNum":"  725","line":"extern int pthread_mutex_init (pthread_mutex_t *__mutex,"},
{"lineNum":"  726","line":"\t\t\t       const pthread_mutexattr_t *__mutexattr)"},
{"lineNum":"  727","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  728","line":""},
{"lineNum":"  729","line":"/* Destroy a mutex.  */"},
{"lineNum":"  730","line":"extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)"},
{"lineNum":"  731","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  732","line":""},
{"lineNum":"  733","line":"/* Try locking a mutex.  */"},
{"lineNum":"  734","line":"extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)"},
{"lineNum":"  735","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  736","line":""},
{"lineNum":"  737","line":"/* Lock a mutex.  */"},
{"lineNum":"  738","line":"extern int pthread_mutex_lock (pthread_mutex_t *__mutex)"},
{"lineNum":"  739","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  740","line":""},
{"lineNum":"  741","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":"  742","line":"/* Wait until lock becomes available, or specified time passes. */"},
{"lineNum":"  743","line":"extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,"},
{"lineNum":"  744","line":"\t\t\t\t    const struct timespec *__restrict"},
{"lineNum":"  745","line":"\t\t\t\t    __abstime) __THROWNL __nonnull ((1, 2));"},
{"lineNum":"  746","line":"#endif"},
{"lineNum":"  747","line":""},
{"lineNum":"  748","line":"#ifdef __USE_GNU"},
{"lineNum":"  749","line":"extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,"},
{"lineNum":"  750","line":"\t\t\t\t    clockid_t __clockid,"},
{"lineNum":"  751","line":"\t\t\t\t    const struct timespec *__restrict"},
{"lineNum":"  752","line":"\t\t\t\t    __abstime) __THROWNL __nonnull ((1, 3));"},
{"lineNum":"  753","line":"#endif"},
{"lineNum":"  754","line":""},
{"lineNum":"  755","line":"/* Unlock a mutex.  */"},
{"lineNum":"  756","line":"extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)"},
{"lineNum":"  757","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":""},
{"lineNum":"  760","line":"/* Get the priority ceiling of MUTEX.  */"},
{"lineNum":"  761","line":"extern int pthread_mutex_getprioceiling (const pthread_mutex_t *"},
{"lineNum":"  762","line":"\t\t\t\t\t __restrict __mutex,"},
{"lineNum":"  763","line":"\t\t\t\t\t int *__restrict __prioceiling)"},
{"lineNum":"  764","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"/* Set the priority ceiling of MUTEX to PRIOCEILING, return old"},
{"lineNum":"  767","line":"   priority ceiling value in *OLD_CEILING.  */"},
{"lineNum":"  768","line":"extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,"},
{"lineNum":"  769","line":"\t\t\t\t\t int __prioceiling,"},
{"lineNum":"  770","line":"\t\t\t\t\t int *__restrict __old_ceiling)"},
{"lineNum":"  771","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  772","line":""},
{"lineNum":"  773","line":""},
{"lineNum":"  774","line":"#ifdef __USE_XOPEN2K8"},
{"lineNum":"  775","line":"/* Declare the state protected by MUTEX as consistent.  */"},
{"lineNum":"  776","line":"extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)"},
{"lineNum":"  777","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  778","line":"# ifdef __USE_GNU"},
{"lineNum":"  779","line":"extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)"},
{"lineNum":"  780","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  781","line":"# endif"},
{"lineNum":"  782","line":"#endif"},
{"lineNum":"  783","line":""},
{"lineNum":"  784","line":""},
{"lineNum":"  785","line":"/* Functions for handling mutex attributes.  */"},
{"lineNum":"  786","line":""},
{"lineNum":"  787","line":"/* Initialize mutex attribute object ATTR with default attributes"},
{"lineNum":"  788","line":"   (kind is PTHREAD_MUTEX_TIMED_NP).  */"},
{"lineNum":"  789","line":"extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)"},
{"lineNum":"  790","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  791","line":""},
{"lineNum":"  792","line":"/* Destroy mutex attribute object ATTR.  */"},
{"lineNum":"  793","line":"extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)"},
{"lineNum":"  794","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  795","line":""},
{"lineNum":"  796","line":"/* Get the process-shared flag of the mutex attribute ATTR.  */"},
{"lineNum":"  797","line":"extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *"},
{"lineNum":"  798","line":"\t\t\t\t\t __restrict __attr,"},
{"lineNum":"  799","line":"\t\t\t\t\t int *__restrict __pshared)"},
{"lineNum":"  800","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  801","line":""},
{"lineNum":"  802","line":"/* Set the process-shared flag of the mutex attribute ATTR.  */"},
{"lineNum":"  803","line":"extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,"},
{"lineNum":"  804","line":"\t\t\t\t\t int __pshared)"},
{"lineNum":"  805","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  806","line":""},
{"lineNum":"  807","line":"#if defined __USE_UNIX98 || defined __USE_XOPEN2K8"},
{"lineNum":"  808","line":"/* Return in *KIND the mutex kind attribute in *ATTR.  */"},
{"lineNum":"  809","line":"extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict"},
{"lineNum":"  810","line":"\t\t\t\t      __attr, int *__restrict __kind)"},
{"lineNum":"  811","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"/* Set the mutex kind attribute in *ATTR to KIND (either PTHREAD_MUTEX_NORMAL,"},
{"lineNum":"  814","line":"   PTHREAD_MUTEX_RECURSIVE, PTHREAD_MUTEX_ERRORCHECK, or"},
{"lineNum":"  815","line":"   PTHREAD_MUTEX_DEFAULT).  */"},
{"lineNum":"  816","line":"extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)"},
{"lineNum":"  817","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  818","line":"#endif"},
{"lineNum":"  819","line":""},
{"lineNum":"  820","line":"/* Return in *PROTOCOL the mutex protocol attribute in *ATTR.  */"},
{"lineNum":"  821","line":"extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *"},
{"lineNum":"  822","line":"\t\t\t\t\t  __restrict __attr,"},
{"lineNum":"  823","line":"\t\t\t\t\t  int *__restrict __protocol)"},
{"lineNum":"  824","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  825","line":""},
{"lineNum":"  826","line":"/* Set the mutex protocol attribute in *ATTR to PROTOCOL (either"},
{"lineNum":"  827","line":"   PTHREAD_PRIO_NONE, PTHREAD_PRIO_INHERIT, or PTHREAD_PRIO_PROTECT).  */"},
{"lineNum":"  828","line":"extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,"},
{"lineNum":"  829","line":"\t\t\t\t\t  int __protocol)"},
{"lineNum":"  830","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  831","line":""},
{"lineNum":"  832","line":"/* Return in *PRIOCEILING the mutex prioceiling attribute in *ATTR.  */"},
{"lineNum":"  833","line":"extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *"},
{"lineNum":"  834","line":"\t\t\t\t\t     __restrict __attr,"},
{"lineNum":"  835","line":"\t\t\t\t\t     int *__restrict __prioceiling)"},
{"lineNum":"  836","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"/* Set the mutex prioceiling attribute in *ATTR to PRIOCEILING.  */"},
{"lineNum":"  839","line":"extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,"},
{"lineNum":"  840","line":"\t\t\t\t\t     int __prioceiling)"},
{"lineNum":"  841","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  842","line":""},
{"lineNum":"  843","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":"  844","line":"/* Get the robustness flag of the mutex attribute ATTR.  */"},
{"lineNum":"  845","line":"extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,"},
{"lineNum":"  846","line":"\t\t\t\t\tint *__robustness)"},
{"lineNum":"  847","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  848","line":"# ifdef __USE_GNU"},
{"lineNum":"  849","line":"extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,"},
{"lineNum":"  850","line":"\t\t\t\t\t   int *__robustness)"},
{"lineNum":"  851","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  852","line":"# endif"},
{"lineNum":"  853","line":""},
{"lineNum":"  854","line":"/* Set the robustness flag of the mutex attribute ATTR.  */"},
{"lineNum":"  855","line":"extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,"},
{"lineNum":"  856","line":"\t\t\t\t\tint __robustness)"},
{"lineNum":"  857","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  858","line":"# ifdef __USE_GNU"},
{"lineNum":"  859","line":"extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,"},
{"lineNum":"  860","line":"\t\t\t\t\t   int __robustness)"},
{"lineNum":"  861","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  862","line":"# endif"},
{"lineNum":"  863","line":"#endif"},
{"lineNum":"  864","line":""},
{"lineNum":"  865","line":""},
{"lineNum":"  866","line":"#if defined __USE_UNIX98 || defined __USE_XOPEN2K"},
{"lineNum":"  867","line":"/* Functions for handling read-write locks.  */"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"/* Initialize read-write lock RWLOCK using attributes ATTR, or use"},
{"lineNum":"  870","line":"   the default values if later is NULL.  */"},
{"lineNum":"  871","line":"extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,"},
{"lineNum":"  872","line":"\t\t\t\tconst pthread_rwlockattr_t *__restrict"},
{"lineNum":"  873","line":"\t\t\t\t__attr) __THROW __nonnull ((1));"},
{"lineNum":"  874","line":""},
{"lineNum":"  875","line":"/* Destroy read-write lock RWLOCK.  */"},
{"lineNum":"  876","line":"extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)"},
{"lineNum":"  877","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"/* Acquire read lock for RWLOCK.  */"},
{"lineNum":"  880","line":"extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)"},
{"lineNum":"  881","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  882","line":""},
{"lineNum":"  883","line":"/* Try to acquire read lock for RWLOCK.  */"},
{"lineNum":"  884","line":"extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)"},
{"lineNum":"  885","line":"  __THROWNL __nonnull ((1));"},
{"lineNum":"  886","line":""},
{"lineNum":"  887","line":"# ifdef __USE_XOPEN2K"},
{"lineNum":"  888","line":"/* Try to acquire read lock for RWLOCK or return after specfied time.  */"},
{"lineNum":"  889","line":"extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,"},
{"lineNum":"  890","line":"\t\t\t\t       const struct timespec *__restrict"},
{"lineNum":"  891","line":"\t\t\t\t       __abstime) __THROWNL __nonnull ((1, 2));"},
{"lineNum":"  892","line":"# endif"},
{"lineNum":"  893","line":""},
{"lineNum":"  894","line":"# ifdef __USE_GNU"},
{"lineNum":"  895","line":"extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,"},
{"lineNum":"  896","line":"\t\t\t\t       clockid_t __clockid,"},
{"lineNum":"  897","line":"\t\t\t\t       const struct timespec *__restrict"},
{"lineNum":"  898","line":"\t\t\t\t       __abstime) __THROWNL __nonnull ((1, 3));"},
{"lineNum":"  899","line":"# endif"},
{"lineNum":"  900","line":""},
{"lineNum":"  901","line":"/* Acquire write lock for RWLOCK.  */"},
{"lineNum":"  902","line":"extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)"},
{"lineNum":"  903","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  904","line":""},
{"lineNum":"  905","line":"/* Try to acquire write lock for RWLOCK.  */"},
{"lineNum":"  906","line":"extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)"},
{"lineNum":"  907","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  908","line":""},
{"lineNum":"  909","line":"# ifdef __USE_XOPEN2K"},
{"lineNum":"  910","line":"/* Try to acquire write lock for RWLOCK or return after specfied time.  */"},
{"lineNum":"  911","line":"extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,"},
{"lineNum":"  912","line":"\t\t\t\t       const struct timespec *__restrict"},
{"lineNum":"  913","line":"\t\t\t\t       __abstime) __THROWNL __nonnull ((1, 2));"},
{"lineNum":"  914","line":"# endif"},
{"lineNum":"  915","line":""},
{"lineNum":"  916","line":"# ifdef __USE_GNU"},
{"lineNum":"  917","line":"extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,"},
{"lineNum":"  918","line":"\t\t\t\t       clockid_t __clockid,"},
{"lineNum":"  919","line":"\t\t\t\t       const struct timespec *__restrict"},
{"lineNum":"  920","line":"\t\t\t\t       __abstime) __THROWNL __nonnull ((1, 3));"},
{"lineNum":"  921","line":"# endif"},
{"lineNum":"  922","line":""},
{"lineNum":"  923","line":"/* Unlock RWLOCK.  */"},
{"lineNum":"  924","line":"extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)"},
{"lineNum":"  925","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  926","line":""},
{"lineNum":"  927","line":""},
{"lineNum":"  928","line":"/* Functions for handling read-write lock attributes.  */"},
{"lineNum":"  929","line":""},
{"lineNum":"  930","line":"/* Initialize attribute object ATTR with default values.  */"},
{"lineNum":"  931","line":"extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)"},
{"lineNum":"  932","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  933","line":""},
{"lineNum":"  934","line":"/* Destroy attribute object ATTR.  */"},
{"lineNum":"  935","line":"extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)"},
{"lineNum":"  936","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  937","line":""},
{"lineNum":"  938","line":"/* Return current setting of process-shared attribute of ATTR in PSHARED.  */"},
{"lineNum":"  939","line":"extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *"},
{"lineNum":"  940","line":"\t\t\t\t\t  __restrict __attr,"},
{"lineNum":"  941","line":"\t\t\t\t\t  int *__restrict __pshared)"},
{"lineNum":"  942","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  943","line":""},
{"lineNum":"  944","line":"/* Set process-shared attribute of ATTR to PSHARED.  */"},
{"lineNum":"  945","line":"extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,"},
{"lineNum":"  946","line":"\t\t\t\t\t  int __pshared)"},
{"lineNum":"  947","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  948","line":""},
{"lineNum":"  949","line":"/* Return current setting of reader/writer preference.  */"},
{"lineNum":"  950","line":"extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *"},
{"lineNum":"  951","line":"\t\t\t\t\t  __restrict __attr,"},
{"lineNum":"  952","line":"\t\t\t\t\t  int *__restrict __pref)"},
{"lineNum":"  953","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  954","line":""},
{"lineNum":"  955","line":"/* Set reader/write preference.  */"},
{"lineNum":"  956","line":"extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,"},
{"lineNum":"  957","line":"\t\t\t\t\t  int __pref) __THROW __nonnull ((1));"},
{"lineNum":"  958","line":"#endif"},
{"lineNum":"  959","line":""},
{"lineNum":"  960","line":""},
{"lineNum":"  961","line":"/* Functions for handling conditional variables.  */"},
{"lineNum":"  962","line":""},
{"lineNum":"  963","line":"/* Initialize condition variable COND using attributes ATTR, or use"},
{"lineNum":"  964","line":"   the default values if later is NULL.  */"},
{"lineNum":"  965","line":"extern int pthread_cond_init (pthread_cond_t *__restrict __cond,"},
{"lineNum":"  966","line":"\t\t\t      const pthread_condattr_t *__restrict __cond_attr)"},
{"lineNum":"  967","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  968","line":""},
{"lineNum":"  969","line":"/* Destroy condition variable COND.  */"},
{"lineNum":"  970","line":"extern int pthread_cond_destroy (pthread_cond_t *__cond)"},
{"lineNum":"  971","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  972","line":""},
{"lineNum":"  973","line":"/* Wake up one thread waiting for condition variable COND.  */"},
{"lineNum":"  974","line":"extern int pthread_cond_signal (pthread_cond_t *__cond)"},
{"lineNum":"  975","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  976","line":""},
{"lineNum":"  977","line":"/* Wake up all threads waiting for condition variables COND.  */"},
{"lineNum":"  978","line":"extern int pthread_cond_broadcast (pthread_cond_t *__cond)"},
{"lineNum":"  979","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":"  980","line":""},
{"lineNum":"  981","line":"/* Wait for condition variable COND to be signaled or broadcast."},
{"lineNum":"  982","line":"   MUTEX is assumed to be locked before."},
{"lineNum":"  983","line":""},
{"lineNum":"  984","line":"   This function is a cancellation point and therefore not marked with"},
{"lineNum":"  985","line":"   __THROW.  */"},
{"lineNum":"  986","line":"extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,"},
{"lineNum":"  987","line":"\t\t\t      pthread_mutex_t *__restrict __mutex)"},
{"lineNum":"  988","line":"     __nonnull ((1, 2));"},
{"lineNum":"  989","line":""},
{"lineNum":"  990","line":"/* Wait for condition variable COND to be signaled or broadcast until"},
{"lineNum":"  991","line":"   ABSTIME.  MUTEX is assumed to be locked before.  ABSTIME is an"},
{"lineNum":"  992","line":"   absolute time specification; zero is the beginning of the epoch"},
{"lineNum":"  993","line":"   (00:00:00 GMT, January 1, 1970)."},
{"lineNum":"  994","line":""},
{"lineNum":"  995","line":"   This function is a cancellation point and therefore not marked with"},
{"lineNum":"  996","line":"   __THROW.  */"},
{"lineNum":"  997","line":"extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,"},
{"lineNum":"  998","line":"\t\t\t\t   pthread_mutex_t *__restrict __mutex,"},
{"lineNum":"  999","line":"\t\t\t\t   const struct timespec *__restrict __abstime)"},
{"lineNum":" 1000","line":"     __nonnull ((1, 2, 3));"},
{"lineNum":" 1001","line":""},
{"lineNum":" 1002","line":"# ifdef __USE_GNU"},
{"lineNum":" 1003","line":"/* Wait for condition variable COND to be signaled or broadcast until"},
{"lineNum":" 1004","line":"   ABSTIME measured by the specified clock. MUTEX is assumed to be"},
{"lineNum":" 1005","line":"   locked before. CLOCK is the clock to use. ABSTIME is an absolute"},
{"lineNum":" 1006","line":"   time specification against CLOCK\'s epoch."},
{"lineNum":" 1007","line":""},
{"lineNum":" 1008","line":"   This function is a cancellation point and therefore not marked with"},
{"lineNum":" 1009","line":"   __THROW. */"},
{"lineNum":" 1010","line":"extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,"},
{"lineNum":" 1011","line":"\t\t\t\t   pthread_mutex_t *__restrict __mutex,"},
{"lineNum":" 1012","line":"\t\t\t\t   __clockid_t __clock_id,"},
{"lineNum":" 1013","line":"\t\t\t\t   const struct timespec *__restrict __abstime)"},
{"lineNum":" 1014","line":"     __nonnull ((1, 2, 4));"},
{"lineNum":" 1015","line":"# endif"},
{"lineNum":" 1016","line":""},
{"lineNum":" 1017","line":"/* Functions for handling condition variable attributes.  */"},
{"lineNum":" 1018","line":""},
{"lineNum":" 1019","line":"/* Initialize condition variable attribute ATTR.  */"},
{"lineNum":" 1020","line":"extern int pthread_condattr_init (pthread_condattr_t *__attr)"},
{"lineNum":" 1021","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1022","line":""},
{"lineNum":" 1023","line":"/* Destroy condition variable attribute ATTR.  */"},
{"lineNum":" 1024","line":"extern int pthread_condattr_destroy (pthread_condattr_t *__attr)"},
{"lineNum":" 1025","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1026","line":""},
{"lineNum":" 1027","line":"/* Get the process-shared flag of the condition variable attribute ATTR.  */"},
{"lineNum":" 1028","line":"extern int pthread_condattr_getpshared (const pthread_condattr_t *"},
{"lineNum":" 1029","line":"\t\t\t\t\t__restrict __attr,"},
{"lineNum":" 1030","line":"\t\t\t\t\tint *__restrict __pshared)"},
{"lineNum":" 1031","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":" 1032","line":""},
{"lineNum":" 1033","line":"/* Set the process-shared flag of the condition variable attribute ATTR.  */"},
{"lineNum":" 1034","line":"extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,"},
{"lineNum":" 1035","line":"\t\t\t\t\tint __pshared) __THROW __nonnull ((1));"},
{"lineNum":" 1036","line":""},
{"lineNum":" 1037","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":" 1038","line":"/* Get the clock selected for the condition variable attribute ATTR.  */"},
{"lineNum":" 1039","line":"extern int pthread_condattr_getclock (const pthread_condattr_t *"},
{"lineNum":" 1040","line":"\t\t\t\t      __restrict __attr,"},
{"lineNum":" 1041","line":"\t\t\t\t      __clockid_t *__restrict __clock_id)"},
{"lineNum":" 1042","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":" 1043","line":""},
{"lineNum":" 1044","line":"/* Set the clock selected for the condition variable attribute ATTR.  */"},
{"lineNum":" 1045","line":"extern int pthread_condattr_setclock (pthread_condattr_t *__attr,"},
{"lineNum":" 1046","line":"\t\t\t\t      __clockid_t __clock_id)"},
{"lineNum":" 1047","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1048","line":"#endif"},
{"lineNum":" 1049","line":""},
{"lineNum":" 1050","line":""},
{"lineNum":" 1051","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":" 1052","line":"/* Functions to handle spinlocks.  */"},
{"lineNum":" 1053","line":""},
{"lineNum":" 1054","line":"/* Initialize the spinlock LOCK.  If PSHARED is nonzero the spinlock can"},
{"lineNum":" 1055","line":"   be shared between different processes.  */"},
{"lineNum":" 1056","line":"extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)"},
{"lineNum":" 1057","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1058","line":""},
{"lineNum":" 1059","line":"/* Destroy the spinlock LOCK.  */"},
{"lineNum":" 1060","line":"extern int pthread_spin_destroy (pthread_spinlock_t *__lock)"},
{"lineNum":" 1061","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1062","line":""},
{"lineNum":" 1063","line":"/* Wait until spinlock LOCK is retrieved.  */"},
{"lineNum":" 1064","line":"extern int pthread_spin_lock (pthread_spinlock_t *__lock)"},
{"lineNum":" 1065","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":" 1066","line":""},
{"lineNum":" 1067","line":"/* Try to lock spinlock LOCK.  */"},
{"lineNum":" 1068","line":"extern int pthread_spin_trylock (pthread_spinlock_t *__lock)"},
{"lineNum":" 1069","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":" 1070","line":""},
{"lineNum":" 1071","line":"/* Release spinlock LOCK.  */"},
{"lineNum":" 1072","line":"extern int pthread_spin_unlock (pthread_spinlock_t *__lock)"},
{"lineNum":" 1073","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":" 1074","line":""},
{"lineNum":" 1075","line":""},
{"lineNum":" 1076","line":"/* Functions to handle barriers.  */"},
{"lineNum":" 1077","line":""},
{"lineNum":" 1078","line":"/* Initialize BARRIER with the attributes in ATTR.  The barrier is"},
{"lineNum":" 1079","line":"   opened when COUNT waiters arrived.  */"},
{"lineNum":" 1080","line":"extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,"},
{"lineNum":" 1081","line":"\t\t\t\t const pthread_barrierattr_t *__restrict"},
{"lineNum":" 1082","line":"\t\t\t\t __attr, unsigned int __count)"},
{"lineNum":" 1083","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1084","line":""},
{"lineNum":" 1085","line":"/* Destroy a previously dynamically initialized barrier BARRIER.  */"},
{"lineNum":" 1086","line":"extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)"},
{"lineNum":" 1087","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1088","line":""},
{"lineNum":" 1089","line":"/* Wait on barrier BARRIER.  */"},
{"lineNum":" 1090","line":"extern int pthread_barrier_wait (pthread_barrier_t *__barrier)"},
{"lineNum":" 1091","line":"     __THROWNL __nonnull ((1));"},
{"lineNum":" 1092","line":""},
{"lineNum":" 1093","line":""},
{"lineNum":" 1094","line":"/* Initialize barrier attribute ATTR.  */"},
{"lineNum":" 1095","line":"extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)"},
{"lineNum":" 1096","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1097","line":""},
{"lineNum":" 1098","line":"/* Destroy previously dynamically initialized barrier attribute ATTR.  */"},
{"lineNum":" 1099","line":"extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)"},
{"lineNum":" 1100","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1101","line":""},
{"lineNum":" 1102","line":"/* Get the process-shared flag of the barrier attribute ATTR.  */"},
{"lineNum":" 1103","line":"extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *"},
{"lineNum":" 1104","line":"\t\t\t\t\t   __restrict __attr,"},
{"lineNum":" 1105","line":"\t\t\t\t\t   int *__restrict __pshared)"},
{"lineNum":" 1106","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":" 1107","line":""},
{"lineNum":" 1108","line":"/* Set the process-shared flag of the barrier attribute ATTR.  */"},
{"lineNum":" 1109","line":"extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,"},
{"lineNum":" 1110","line":"\t\t\t\t\t   int __pshared)"},
{"lineNum":" 1111","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1112","line":"#endif"},
{"lineNum":" 1113","line":""},
{"lineNum":" 1114","line":""},
{"lineNum":" 1115","line":"/* Functions for handling thread-specific data.  */"},
{"lineNum":" 1116","line":""},
{"lineNum":" 1117","line":"/* Create a key value identifying a location in the thread-specific"},
{"lineNum":" 1118","line":"   data area.  Each thread maintains a distinct thread-specific data"},
{"lineNum":" 1119","line":"   area.  DESTR_FUNCTION, if non-NULL, is called with the value"},
{"lineNum":" 1120","line":"   associated to that key when the key is destroyed."},
{"lineNum":" 1121","line":"   DESTR_FUNCTION is not called if the value associated is NULL when"},
{"lineNum":" 1122","line":"   the key is destroyed.  */"},
{"lineNum":" 1123","line":"extern int pthread_key_create (pthread_key_t *__key,"},
{"lineNum":" 1124","line":"\t\t\t       void (*__destr_function) (void *))"},
{"lineNum":" 1125","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1126","line":""},
{"lineNum":" 1127","line":"/* Destroy KEY.  */"},
{"lineNum":" 1128","line":"extern int pthread_key_delete (pthread_key_t __key) __THROW;"},
{"lineNum":" 1129","line":""},
{"lineNum":" 1130","line":"/* Return current value of the thread-specific data slot identified by KEY.  */"},
{"lineNum":" 1131","line":"extern void *pthread_getspecific (pthread_key_t __key) __THROW;"},
{"lineNum":" 1132","line":""},
{"lineNum":" 1133","line":"/* Store POINTER in the thread-specific data slot identified by KEY. */"},
{"lineNum":" 1134","line":"extern int pthread_setspecific (pthread_key_t __key,"},
{"lineNum":" 1135","line":"\t\t\t\tconst void *__pointer) __THROW ;"},
{"lineNum":" 1136","line":""},
{"lineNum":" 1137","line":""},
{"lineNum":" 1138","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":" 1139","line":"/* Get ID of CPU-time clock for thread THREAD_ID.  */"},
{"lineNum":" 1140","line":"extern int pthread_getcpuclockid (pthread_t __thread_id,"},
{"lineNum":" 1141","line":"\t\t\t\t  __clockid_t *__clock_id)"},
{"lineNum":" 1142","line":"     __THROW __nonnull ((2));"},
{"lineNum":" 1143","line":"#endif"},
{"lineNum":" 1144","line":""},
{"lineNum":" 1145","line":""},
{"lineNum":" 1146","line":"/* Install handlers to be called when a new process is created with FORK."},
{"lineNum":" 1147","line":"   The PREPARE handler is called in the parent process just before performing"},
{"lineNum":" 1148","line":"   FORK. The PARENT handler is called in the parent process just after FORK."},
{"lineNum":" 1149","line":"   The CHILD handler is called in the child process.  Each of the three"},
{"lineNum":" 1150","line":"   handlers can be NULL, meaning that no handler needs to be called at that"},
{"lineNum":" 1151","line":"   point."},
{"lineNum":" 1152","line":"   PTHREAD_ATFORK can be called several times, in which case the PREPARE"},
{"lineNum":" 1153","line":"   handlers are called in LIFO order (last added with PTHREAD_ATFORK,"},
{"lineNum":" 1154","line":"   first called before FORK), and the PARENT and CHILD handlers are called"},
{"lineNum":" 1155","line":"   in FIFO (first added, first called).  */"},
{"lineNum":" 1156","line":""},
{"lineNum":" 1157","line":"extern int pthread_atfork (void (*__prepare) (void),"},
{"lineNum":" 1158","line":"\t\t\t   void (*__parent) (void),"},
{"lineNum":" 1159","line":"\t\t\t   void (*__child) (void)) __THROW;"},
{"lineNum":" 1160","line":""},
{"lineNum":" 1161","line":""},
{"lineNum":" 1162","line":"#ifdef __USE_EXTERN_INLINES"},
{"lineNum":" 1163","line":"/* Optimizations.  */"},
{"lineNum":" 1164","line":"__extern_inline int"},
{"lineNum":" 1165","line":"__NTH (pthread_equal (pthread_t __thread1, pthread_t __thread2))"},
{"lineNum":" 1166","line":"{","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1167","line":"  return __thread1 == __thread2;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1168","line":"}"},
{"lineNum":" 1169","line":"#endif"},
{"lineNum":" 1170","line":""},
{"lineNum":" 1171","line":"__END_DECLS"},
{"lineNum":" 1172","line":""},
{"lineNum":" 1173","line":"#endif\t/* pthread.h */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-14 19:20:37", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
