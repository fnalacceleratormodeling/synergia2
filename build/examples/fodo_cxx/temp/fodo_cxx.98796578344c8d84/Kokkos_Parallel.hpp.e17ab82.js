var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"/// \\file Kokkos_Parallel.hpp"},
{"lineNum":"   46","line":"/// \\brief Declaration of parallel operators"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#ifndef KOKKOS_PARALLEL_HPP"},
{"lineNum":"   49","line":"#define KOKKOS_PARALLEL_HPP"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"#include <cstddef>"},
{"lineNum":"   52","line":"#include <Kokkos_Core_fwd.hpp>"},
{"lineNum":"   53","line":"#include <Kokkos_View.hpp>"},
{"lineNum":"   54","line":"#include <Kokkos_ExecPolicy.hpp>"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"#include <impl/Kokkos_Tools.hpp>"},
{"lineNum":"   57","line":"#include <type_traits>"},
{"lineNum":"   58","line":"#include <typeinfo>"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"#include <impl/Kokkos_Tags.hpp>"},
{"lineNum":"   61","line":"#include <impl/Kokkos_Traits.hpp>"},
{"lineNum":"   62","line":"#include <impl/Kokkos_FunctorAnalysis.hpp>"},
{"lineNum":"   63","line":"#include <impl/Kokkos_FunctorAdapter.hpp>"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"#ifdef KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES"},
{"lineNum":"   66","line":"#include <iostream>"},
{"lineNum":"   67","line":"#endif"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   70","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"namespace Kokkos {"},
{"lineNum":"   73","line":"namespace Impl {"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"template <class T, class = void>"},
{"lineNum":"   76","line":"struct is_detected_execution_space : std::false_type {"},
{"lineNum":"   77","line":"  using type = not_a_type;"},
{"lineNum":"   78","line":"};"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"template <class T>"},
{"lineNum":"   81","line":"struct is_detected_execution_space<T, void_t<typename T::execution_space>>"},
{"lineNum":"   82","line":"    : std::true_type {"},
{"lineNum":"   83","line":"  using type = typename T::execution_space;"},
{"lineNum":"   84","line":"};"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"template <class T>"},
{"lineNum":"   87","line":"using detected_execution_space_t ="},
{"lineNum":"   88","line":"    typename is_detected_execution_space<T>::type;"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"template <class T, class = void>"},
{"lineNum":"   91","line":"struct is_detected_device_type : std::false_type {"},
{"lineNum":"   92","line":"  using type = not_a_type;"},
{"lineNum":"   93","line":"};"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"template <class T>"},
{"lineNum":"   96","line":"struct is_detected_device_type<T, void_t<typename T::device_type>>"},
{"lineNum":"   97","line":"    : std::true_type {"},
{"lineNum":"   98","line":"  using type = typename T::device_type;"},
{"lineNum":"   99","line":"};"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"template <class T>"},
{"lineNum":"  102","line":"using detected_device_type_t = typename is_detected_device_type<T>::type;"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  105","line":"/** \\brief  Given a Functor and Execution Policy query an execution space."},
{"lineNum":"  106","line":" *"},
{"lineNum":"  107","line":" *  if       the Policy has an execution space use that"},
{"lineNum":"  108","line":" *  else if  the Functor has an execution_space use that"},
{"lineNum":"  109","line":" *  else if  the Functor has a device_type use that for backward compatibility"},
{"lineNum":"  110","line":" *  else     use the default"},
{"lineNum":"  111","line":" */"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"template <class Functor, class Policy>"},
{"lineNum":"  114","line":"struct FunctorPolicyExecutionSpace {"},
{"lineNum":"  115","line":"  using execution_space = std::conditional_t<"},
{"lineNum":"  116","line":"      is_detected_execution_space<Policy>::value,"},
{"lineNum":"  117","line":"      detected_execution_space_t<Policy>,"},
{"lineNum":"  118","line":"      std::conditional_t<"},
{"lineNum":"  119","line":"          is_detected_execution_space<Functor>::value,"},
{"lineNum":"  120","line":"          detected_execution_space_t<Functor>,"},
{"lineNum":"  121","line":"          std::conditional_t<"},
{"lineNum":"  122","line":"              is_detected_device_type<Functor>::value,"},
{"lineNum":"  123","line":"              detected_execution_space_t<detected_device_type_t<Functor>>,"},
{"lineNum":"  124","line":"              Kokkos::DefaultExecutionSpace>>>;"},
{"lineNum":"  125","line":"};"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"}  // namespace Impl"},
{"lineNum":"  128","line":"}  // namespace Kokkos"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  131","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"namespace Kokkos {"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"/** \\brief Execute \\c functor in parallel according to the execution \\c policy."},
{"lineNum":"  136","line":" *"},
{"lineNum":"  137","line":" * A \"functor\" is a class containing the function to execute in parallel,"},
{"lineNum":"  138","line":" * data needed for that execution, and an optional \\c execution_space"},
{"lineNum":"  139","line":" * alias.  Here is an example functor for parallel_for:"},
{"lineNum":"  140","line":" *"},
{"lineNum":"  141","line":" * \\code"},
{"lineNum":"  142","line":" *  class FunctorType {"},
{"lineNum":"  143","line":" *  public:"},
{"lineNum":"  144","line":" *    using execution_space = ...;"},
{"lineNum":"  145","line":" *    void operator() ( WorkType iwork ) const ;"},
{"lineNum":"  146","line":" *  };"},
{"lineNum":"  147","line":" * \\endcode"},
{"lineNum":"  148","line":" *"},
{"lineNum":"  149","line":" * In the above example, \\c WorkType is any integer type for which a"},
{"lineNum":"  150","line":" * valid conversion from \\c size_t to \\c IntType exists.  Its"},
{"lineNum":"  151","line":" * <tt>operator()</tt> method defines the operation to parallelize,"},
{"lineNum":"  152","line":" * over the range of integer indices <tt>iwork=[0,work_count-1]</tt>."},
{"lineNum":"  153","line":" * This compares to a single iteration \\c iwork of a \\c for loop."},
{"lineNum":"  154","line":" * If \\c execution_space is not defined DefaultExecutionSpace will be used."},
{"lineNum":"  155","line":" */"},
{"lineNum":"  156","line":"template <class ExecPolicy, class FunctorType>"},
{"lineNum":"  157","line":"inline void parallel_for("},
{"lineNum":"  158","line":"    const ExecPolicy& policy, const FunctorType& functor,"},
{"lineNum":"  159","line":"    const std::string& str = \"\","},
{"lineNum":"  160","line":"    typename std::enable_if<"},
{"lineNum":"  161","line":"        Kokkos::Impl::is_execution_policy<ExecPolicy>::value>::type* ="},
{"lineNum":"  162","line":"        nullptr) {","class":"lineNoCov","hits":"0","possible_hits":"67",},
{"lineNum":"  163","line":"  uint64_t kpID = 0;","class":"lineNoCov","hits":"0","possible_hits":"74",},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"  ExecPolicy inner_policy = policy;","class":"lineNoCov","hits":"0","possible_hits":"75",},
{"lineNum":"  166","line":"  Kokkos::Tools::Impl::begin_parallel_for(inner_policy, functor, str, kpID);","class":"lineNoCov","hits":"0","possible_hits":"70",},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"  Kokkos::Impl::shared_allocation_tracking_disable();"},
{"lineNum":"  169","line":"  Impl::ParallelFor<FunctorType, ExecPolicy> closure(functor, inner_policy);","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  170","line":"  Kokkos::Impl::shared_allocation_tracking_enable();"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  closure.execute();","class":"lineNoCov","hits":"0","possible_hits":"54",},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"  Kokkos::Tools::Impl::end_parallel_for(inner_policy, functor, str, kpID);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  175","line":"}","class":"lineNoCov","hits":"0","possible_hits":"68",},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"template <class FunctorType>"},
{"lineNum":"  178","line":"inline void parallel_for(const size_t work_count, const FunctorType& functor,"},
{"lineNum":"  179","line":"                         const std::string& str = \"\") {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  180","line":"  using execution_space ="},
{"lineNum":"  181","line":"      typename Impl::FunctorPolicyExecutionSpace<FunctorType,"},
{"lineNum":"  182","line":"                                                 void>::execution_space;"},
{"lineNum":"  183","line":"  using policy = RangePolicy<execution_space>;"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"  uint64_t kpID = 0;","class":"lineNoCov","hits":"0","possible_hits":"39",},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"  policy execution_policy = policy(0, work_count);","class":"lineNoCov","hits":"0","possible_hits":"39",},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"  Kokkos::Tools::Impl::begin_parallel_for(execution_policy, functor, str, kpID);","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"  Kokkos::Impl::shared_allocation_tracking_disable();"},
{"lineNum":"  192","line":"  Impl::ParallelFor<FunctorType, policy> closure(functor, execution_policy);"},
{"lineNum":"  193","line":"  Kokkos::Impl::shared_allocation_tracking_enable();"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"  closure.execute();","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"  Kokkos::Tools::Impl::end_parallel_for(execution_policy, functor, str, kpID);"},
{"lineNum":"  198","line":"}","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"template <class ExecPolicy, class FunctorType>"},
{"lineNum":"  201","line":"inline void parallel_for(const std::string& str, const ExecPolicy& policy,"},
{"lineNum":"  202","line":"                         const FunctorType& functor) {"},
{"lineNum":"  203","line":"#if KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES"},
{"lineNum":"  204","line":"  Kokkos::fence();"},
{"lineNum":"  205","line":"  std::cout << \"KOKKOS_DEBUG Start parallel_for kernel: \" << str << std::endl;"},
{"lineNum":"  206","line":"#endif"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"  ::Kokkos::parallel_for(policy, functor, str);","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"#if KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES"},
{"lineNum":"  211","line":"  Kokkos::fence();"},
{"lineNum":"  212","line":"  std::cout << \"KOKKOS_DEBUG End   parallel_for kernel: \" << str << std::endl;"},
{"lineNum":"  213","line":"#endif"},
{"lineNum":"  214","line":"  (void)str;"},
{"lineNum":"  215","line":"}"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"}  // namespace Kokkos"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"#include <Kokkos_Parallel_Reduce.hpp>"},
{"lineNum":"  220","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  221","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"namespace Kokkos {"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"/// \\fn parallel_scan"},
{"lineNum":"  226","line":"/// \\tparam ExecutionPolicy The execution policy type."},
{"lineNum":"  227","line":"/// \\tparam FunctorType     The scan functor type."},
{"lineNum":"  228","line":"///"},
{"lineNum":"  229","line":"/// \\param policy  [in] The execution policy."},
{"lineNum":"  230","line":"/// \\param functor [in] The scan functor."},
{"lineNum":"  231","line":"///"},
{"lineNum":"  232","line":"/// This function implements a parallel scan pattern.  The scan can"},
{"lineNum":"  233","line":"/// be either inclusive or exclusive, depending on how you implement"},
{"lineNum":"  234","line":"/// the scan functor."},
{"lineNum":"  235","line":"///"},
{"lineNum":"  236","line":"/// A scan functor looks almost exactly like a reduce functor, except"},
{"lineNum":"  237","line":"/// that its operator() takes a third \\c bool argument, \\c final_pass,"},
{"lineNum":"  238","line":"/// which indicates whether this is the last pass of the scan"},
{"lineNum":"  239","line":"/// operation.  We will show below how to use the \\c final_pass"},
{"lineNum":"  240","line":"/// argument to control whether the scan is inclusive or exclusive."},
{"lineNum":"  241","line":"///"},
{"lineNum":"  242","line":"/// Here is the minimum required interface of a scan functor for a POD"},
{"lineNum":"  243","line":"/// (plain old data) value type \\c PodType.  That is, the result is a"},
{"lineNum":"  244","line":"/// View of zero or more PodType.  It is also possible for the result"},
{"lineNum":"  245","line":"/// to be an array of (same-sized) arrays of PodType, but we do not"},
{"lineNum":"  246","line":"/// show the required interface for that here."},
{"lineNum":"  247","line":"/// \\code"},
{"lineNum":"  248","line":"/// template< class ExecPolicy , class FunctorType >"},
{"lineNum":"  249","line":"/// class ScanFunctor {"},
{"lineNum":"  250","line":"/// public:"},
{"lineNum":"  251","line":"///   // The Kokkos device type"},
{"lineNum":"  252","line":"///   using execution_space = ...;"},
{"lineNum":"  253","line":"///   // Type of an entry of the array containing the result;"},
{"lineNum":"  254","line":"///   // also the type of each of the entries combined using"},
{"lineNum":"  255","line":"///   // operator() or join()."},
{"lineNum":"  256","line":"///   using value_type = PodType;"},
{"lineNum":"  257","line":"///"},
{"lineNum":"  258","line":"///   void operator () (const ExecPolicy::member_type & i, value_type& update,"},
{"lineNum":"  259","line":"///   const bool final_pass) const; void init (value_type& update) const; void"},
{"lineNum":"  260","line":"///   join (volatile value_type& update, volatile const value_type& input) const"},
{"lineNum":"  261","line":"/// };"},
{"lineNum":"  262","line":"/// \\endcode"},
{"lineNum":"  263","line":"///"},
{"lineNum":"  264","line":"/// Here is an example of a functor which computes an inclusive plus-scan"},
{"lineNum":"  265","line":"/// of an array of \\c int, in place.  If given an array [1, 2, 3, 4], this"},
{"lineNum":"  266","line":"/// scan will overwrite that array with [1, 3, 6, 10]."},
{"lineNum":"  267","line":"///"},
{"lineNum":"  268","line":"/// \\code"},
{"lineNum":"  269","line":"/// template<class SpaceType>"},
{"lineNum":"  270","line":"/// class InclScanFunctor {"},
{"lineNum":"  271","line":"/// public:"},
{"lineNum":"  272","line":"///   using execution_space = SpaceType;"},
{"lineNum":"  273","line":"///   using value_type = int;"},
{"lineNum":"  274","line":"///   using size_type = typename SpaceType::size_type;"},
{"lineNum":"  275","line":"///"},
{"lineNum":"  276","line":"///   InclScanFunctor( Kokkos::View<value_type*, execution_space> x"},
{"lineNum":"  277","line":"///                  , Kokkos::View<value_type*, execution_space> y ) : m_x(x),"},
{"lineNum":"  278","line":"///                  m_y(y) {}"},
{"lineNum":"  279","line":"///"},
{"lineNum":"  280","line":"///   void operator () (const size_type i, value_type& update, const bool"},
{"lineNum":"  281","line":"///   final_pass) const {"},
{"lineNum":"  282","line":"///     update += m_x(i);"},
{"lineNum":"  283","line":"///     if (final_pass) {"},
{"lineNum":"  284","line":"///       m_y(i) = update;"},
{"lineNum":"  285","line":"///     }"},
{"lineNum":"  286","line":"///   }"},
{"lineNum":"  287","line":"///   void init (value_type& update) const {"},
{"lineNum":"  288","line":"///     update = 0;"},
{"lineNum":"  289","line":"///   }"},
{"lineNum":"  290","line":"///   void join (volatile value_type& update, volatile const value_type& input)"},
{"lineNum":"  291","line":"///   const {"},
{"lineNum":"  292","line":"///     update += input;"},
{"lineNum":"  293","line":"///   }"},
{"lineNum":"  294","line":"///"},
{"lineNum":"  295","line":"/// private:"},
{"lineNum":"  296","line":"///   Kokkos::View<value_type*, execution_space> m_x;"},
{"lineNum":"  297","line":"///   Kokkos::View<value_type*, execution_space> m_y;"},
{"lineNum":"  298","line":"/// };"},
{"lineNum":"  299","line":"/// \\endcode"},
{"lineNum":"  300","line":"///"},
{"lineNum":"  301","line":"/// Here is an example of a functor which computes an <i>exclusive</i>"},
{"lineNum":"  302","line":"/// scan of an array of \\c int, in place.  In operator(), note both"},
{"lineNum":"  303","line":"/// that the final_pass test and the update have switched places, and"},
{"lineNum":"  304","line":"/// the use of a temporary.  If given an array [1, 2, 3, 4], this scan"},
{"lineNum":"  305","line":"/// will overwrite that array with [0, 1, 3, 6]."},
{"lineNum":"  306","line":"///"},
{"lineNum":"  307","line":"/// \\code"},
{"lineNum":"  308","line":"/// template<class SpaceType>"},
{"lineNum":"  309","line":"/// class ExclScanFunctor {"},
{"lineNum":"  310","line":"/// public:"},
{"lineNum":"  311","line":"///   using execution_space = SpaceType;"},
{"lineNum":"  312","line":"///   using value_type = int;"},
{"lineNum":"  313","line":"///   using size_type = typename SpaceType::size_type;"},
{"lineNum":"  314","line":"///"},
{"lineNum":"  315","line":"///   ExclScanFunctor (Kokkos::View<value_type*, execution_space> x) : x_ (x) {}"},
{"lineNum":"  316","line":"///"},
{"lineNum":"  317","line":"///   void operator () (const size_type i, value_type& update, const bool"},
{"lineNum":"  318","line":"///   final_pass) const {"},
{"lineNum":"  319","line":"///     const value_type x_i = x_(i);"},
{"lineNum":"  320","line":"///     if (final_pass) {"},
{"lineNum":"  321","line":"///       x_(i) = update;"},
{"lineNum":"  322","line":"///     }"},
{"lineNum":"  323","line":"///     update += x_i;"},
{"lineNum":"  324","line":"///   }"},
{"lineNum":"  325","line":"///   void init (value_type& update) const {"},
{"lineNum":"  326","line":"///     update = 0;"},
{"lineNum":"  327","line":"///   }"},
{"lineNum":"  328","line":"///   void join (volatile value_type& update, volatile const value_type& input)"},
{"lineNum":"  329","line":"///   const {"},
{"lineNum":"  330","line":"///     update += input;"},
{"lineNum":"  331","line":"///   }"},
{"lineNum":"  332","line":"///"},
{"lineNum":"  333","line":"/// private:"},
{"lineNum":"  334","line":"///   Kokkos::View<value_type*, execution_space> x_;"},
{"lineNum":"  335","line":"/// };"},
{"lineNum":"  336","line":"/// \\endcode"},
{"lineNum":"  337","line":"///"},
{"lineNum":"  338","line":"/// Here is an example of a functor which builds on the above"},
{"lineNum":"  339","line":"/// exclusive scan example, to compute an offsets array from a"},
{"lineNum":"  340","line":"/// population count array, in place.  We assume that the pop count"},
{"lineNum":"  341","line":"/// array has an extra entry at the end to store the final count.  If"},
{"lineNum":"  342","line":"/// given an array [1, 2, 3, 4, 0], this scan will overwrite that"},
{"lineNum":"  343","line":"/// array with [0, 1, 3, 6, 10]."},
{"lineNum":"  344","line":"///"},
{"lineNum":"  345","line":"/// \\code"},
{"lineNum":"  346","line":"/// template<class SpaceType>"},
{"lineNum":"  347","line":"/// class OffsetScanFunctor {"},
{"lineNum":"  348","line":"/// public:"},
{"lineNum":"  349","line":"///   using execution_space = SpaceType;"},
{"lineNum":"  350","line":"///   using value_type = int;"},
{"lineNum":"  351","line":"///   using size_type = typename SpaceType::size_type;"},
{"lineNum":"  352","line":"///"},
{"lineNum":"  353","line":"///   // lastIndex_ is the last valid index (zero-based) of x."},
{"lineNum":"  354","line":"///   // If x has length zero, then lastIndex_ won\'t be used anyway."},
{"lineNum":"  355","line":"///   OffsetScanFunctor( Kokkos::View<value_type*, execution_space> x"},
{"lineNum":"  356","line":"///                    , Kokkos::View<value_type*, execution_space> y )"},
{"lineNum":"  357","line":"///      : m_x(x), m_y(y), last_index_ (x.dimension_0 () == 0 ? 0 :"},
{"lineNum":"  358","line":"///      x.dimension_0 () - 1)"},
{"lineNum":"  359","line":"///   {}"},
{"lineNum":"  360","line":"///"},
{"lineNum":"  361","line":"///   void operator () (const size_type i, int& update, const bool final_pass)"},
{"lineNum":"  362","line":"///   const {"},
{"lineNum":"  363","line":"///     if (final_pass) {"},
{"lineNum":"  364","line":"///       m_y(i) = update;"},
{"lineNum":"  365","line":"///     }"},
{"lineNum":"  366","line":"///     update += m_x(i);"},
{"lineNum":"  367","line":"///     // The last entry of m_y gets the final sum."},
{"lineNum":"  368","line":"///     if (final_pass && i == last_index_) {"},
{"lineNum":"  369","line":"///       m_y(i+1) = update;"},
{"lineNum":"  370","line":"// i/     }"},
{"lineNum":"  371","line":"///   }"},
{"lineNum":"  372","line":"///   void init (value_type& update) const {"},
{"lineNum":"  373","line":"///     update = 0;"},
{"lineNum":"  374","line":"///   }"},
{"lineNum":"  375","line":"///   void join (volatile value_type& update, volatile const value_type& input)"},
{"lineNum":"  376","line":"///   const {"},
{"lineNum":"  377","line":"///     update += input;"},
{"lineNum":"  378","line":"///   }"},
{"lineNum":"  379","line":"///"},
{"lineNum":"  380","line":"/// private:"},
{"lineNum":"  381","line":"///   Kokkos::View<value_type*, execution_space> m_x;"},
{"lineNum":"  382","line":"///   Kokkos::View<value_type*, execution_space> m_y;"},
{"lineNum":"  383","line":"///   const size_type last_index_;"},
{"lineNum":"  384","line":"/// };"},
{"lineNum":"  385","line":"/// \\endcode"},
{"lineNum":"  386","line":"///"},
{"lineNum":"  387","line":"template <class ExecutionPolicy, class FunctorType>"},
{"lineNum":"  388","line":"inline void parallel_scan("},
{"lineNum":"  389","line":"    const ExecutionPolicy& policy, const FunctorType& functor,"},
{"lineNum":"  390","line":"    const std::string& str = \"\","},
{"lineNum":"  391","line":"    typename std::enable_if<"},
{"lineNum":"  392","line":"        Kokkos::Impl::is_execution_policy<ExecutionPolicy>::value>::type* ="},
{"lineNum":"  393","line":"        nullptr) {"},
{"lineNum":"  394","line":"  uint64_t kpID                = 0;"},
{"lineNum":"  395","line":"  ExecutionPolicy inner_policy = policy;"},
{"lineNum":"  396","line":"  Kokkos::Tools::Impl::begin_parallel_scan(inner_policy, functor, str, kpID);"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"  Kokkos::Impl::shared_allocation_tracking_disable();"},
{"lineNum":"  399","line":"  Impl::ParallelScan<FunctorType, ExecutionPolicy> closure(functor,"},
{"lineNum":"  400","line":"                                                           inner_policy);"},
{"lineNum":"  401","line":"  Kokkos::Impl::shared_allocation_tracking_enable();"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"  closure.execute();"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"  Kokkos::Tools::Impl::end_parallel_scan(inner_policy, functor, str, kpID);"},
{"lineNum":"  406","line":"}"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"template <class FunctorType>"},
{"lineNum":"  409","line":"inline void parallel_scan(const size_t work_count, const FunctorType& functor,"},
{"lineNum":"  410","line":"                          const std::string& str = \"\") {"},
{"lineNum":"  411","line":"  using execution_space ="},
{"lineNum":"  412","line":"      typename Kokkos::Impl::FunctorPolicyExecutionSpace<FunctorType,"},
{"lineNum":"  413","line":"                                                         void>::execution_space;"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"  using policy = Kokkos::RangePolicy<execution_space>;"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"  uint64_t kpID = 0;"},
{"lineNum":"  418","line":"  policy execution_policy(0, work_count);"},
{"lineNum":"  419","line":"  Kokkos::Tools::Impl::begin_parallel_scan(execution_policy, functor, str,"},
{"lineNum":"  420","line":"                                           kpID);"},
{"lineNum":"  421","line":"  Kokkos::Impl::shared_allocation_tracking_disable();"},
{"lineNum":"  422","line":"  Impl::ParallelScan<FunctorType, policy> closure(functor, execution_policy);"},
{"lineNum":"  423","line":"  Kokkos::Impl::shared_allocation_tracking_enable();"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"  closure.execute();"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"  Kokkos::Tools::Impl::end_parallel_scan(execution_policy, functor, str, kpID);"},
{"lineNum":"  428","line":"}"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"template <class ExecutionPolicy, class FunctorType>"},
{"lineNum":"  431","line":"inline void parallel_scan(const std::string& str, const ExecutionPolicy& policy,"},
{"lineNum":"  432","line":"                          const FunctorType& functor) {"},
{"lineNum":"  433","line":"#if KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES"},
{"lineNum":"  434","line":"  Kokkos::fence();"},
{"lineNum":"  435","line":"  std::cout << \"KOKKOS_DEBUG Start parallel_scan kernel: \" << str << std::endl;"},
{"lineNum":"  436","line":"#endif"},
{"lineNum":"  437","line":""},
{"lineNum":"  438","line":"  ::Kokkos::parallel_scan(policy, functor, str);"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"#if KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES"},
{"lineNum":"  441","line":"  Kokkos::fence();"},
{"lineNum":"  442","line":"  std::cout << \"KOKKOS_DEBUG End parallel_scan kernel: \" << str << std::endl;"},
{"lineNum":"  443","line":"#endif"},
{"lineNum":"  444","line":"  (void)str;"},
{"lineNum":"  445","line":"}"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"template <class ExecutionPolicy, class FunctorType, class ReturnType>"},
{"lineNum":"  448","line":"inline void parallel_scan("},
{"lineNum":"  449","line":"    const ExecutionPolicy& policy, const FunctorType& functor,"},
{"lineNum":"  450","line":"    ReturnType& return_value, const std::string& str = \"\","},
{"lineNum":"  451","line":"    typename std::enable_if<"},
{"lineNum":"  452","line":"        Kokkos::Impl::is_execution_policy<ExecutionPolicy>::value>::type* ="},
{"lineNum":"  453","line":"        nullptr) {"},
{"lineNum":"  454","line":"  uint64_t kpID                = 0;"},
{"lineNum":"  455","line":"  ExecutionPolicy inner_policy = policy;"},
{"lineNum":"  456","line":"  Kokkos::Tools::Impl::begin_parallel_scan(inner_policy, functor, str, kpID);"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"  Kokkos::Impl::shared_allocation_tracking_disable();"},
{"lineNum":"  459","line":"  Impl::ParallelScanWithTotal<FunctorType, ExecutionPolicy, ReturnType> closure("},
{"lineNum":"  460","line":"      functor, inner_policy, return_value);"},
{"lineNum":"  461","line":"  Kokkos::Impl::shared_allocation_tracking_enable();"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"  closure.execute();"},
{"lineNum":"  464","line":""},
{"lineNum":"  465","line":"  Kokkos::Tools::Impl::end_parallel_scan(inner_policy, functor, str, kpID);"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"  policy.space().fence();"},
{"lineNum":"  468","line":"}"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"template <class FunctorType, class ReturnType>"},
{"lineNum":"  471","line":"inline void parallel_scan(const size_t work_count, const FunctorType& functor,"},
{"lineNum":"  472","line":"                          ReturnType& return_value,"},
{"lineNum":"  473","line":"                          const std::string& str = \"\") {"},
{"lineNum":"  474","line":"  using execution_space ="},
{"lineNum":"  475","line":"      typename Kokkos::Impl::FunctorPolicyExecutionSpace<FunctorType,"},
{"lineNum":"  476","line":"                                                         void>::execution_space;"},
{"lineNum":"  477","line":""},
{"lineNum":"  478","line":"  using policy = Kokkos::RangePolicy<execution_space>;"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"  policy execution_policy(0, work_count);"},
{"lineNum":"  481","line":"  uint64_t kpID = 0;"},
{"lineNum":"  482","line":"  Kokkos::Tools::Impl::begin_parallel_scan(execution_policy, functor, str,"},
{"lineNum":"  483","line":"                                           kpID);"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"  Kokkos::Impl::shared_allocation_tracking_disable();"},
{"lineNum":"  486","line":"  Impl::ParallelScanWithTotal<FunctorType, policy, ReturnType> closure("},
{"lineNum":"  487","line":"      functor, execution_policy, return_value);"},
{"lineNum":"  488","line":"  Kokkos::Impl::shared_allocation_tracking_enable();"},
{"lineNum":"  489","line":""},
{"lineNum":"  490","line":"  closure.execute();"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"  Kokkos::Tools::Impl::end_parallel_scan(execution_policy, functor, str, kpID);"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"  execution_space().fence();"},
{"lineNum":"  495","line":"}"},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"template <class ExecutionPolicy, class FunctorType, class ReturnType>"},
{"lineNum":"  498","line":"inline void parallel_scan(const std::string& str, const ExecutionPolicy& policy,"},
{"lineNum":"  499","line":"                          const FunctorType& functor,"},
{"lineNum":"  500","line":"                          ReturnType& return_value) {"},
{"lineNum":"  501","line":"#if KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES"},
{"lineNum":"  502","line":"  Kokkos::fence();"},
{"lineNum":"  503","line":"  std::cout << \"KOKKOS_DEBUG Start parallel_scan kernel: \" << str << std::endl;"},
{"lineNum":"  504","line":"#endif"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"  ::Kokkos::parallel_scan(policy, functor, return_value, str);"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"#if KOKKOS_ENABLE_DEBUG_PRINT_KERNEL_NAMES"},
{"lineNum":"  509","line":"  Kokkos::fence();"},
{"lineNum":"  510","line":"  std::cout << \"KOKKOS_DEBUG End parallel_scan kernel: \" << str << std::endl;"},
{"lineNum":"  511","line":"#endif"},
{"lineNum":"  512","line":"  (void)str;"},
{"lineNum":"  513","line":"}"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"}  // namespace Kokkos"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  518","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"namespace Kokkos {"},
{"lineNum":"  521","line":"namespace Impl {"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"template <class FunctorType,"},
{"lineNum":"  524","line":"          bool HasTeamShmemSize ="},
{"lineNum":"  525","line":"              has_member_team_shmem_size<FunctorType>::value,"},
{"lineNum":"  526","line":"          bool HasShmemSize = has_member_shmem_size<FunctorType>::value>"},
{"lineNum":"  527","line":"struct FunctorTeamShmemSize {"},
{"lineNum":"  528","line":"  KOKKOS_INLINE_FUNCTION static size_t value(const FunctorType&, int) {"},
{"lineNum":"  529","line":"    return 0;"},
{"lineNum":"  530","line":"  }"},
{"lineNum":"  531","line":"};"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"template <class FunctorType>"},
{"lineNum":"  534","line":"struct FunctorTeamShmemSize<FunctorType, true, false> {"},
{"lineNum":"  535","line":"  static inline size_t value(const FunctorType& f, int team_size) {"},
{"lineNum":"  536","line":"    return f.team_shmem_size(team_size);"},
{"lineNum":"  537","line":"  }"},
{"lineNum":"  538","line":"};"},
{"lineNum":"  539","line":""},
{"lineNum":"  540","line":"template <class FunctorType>"},
{"lineNum":"  541","line":"struct FunctorTeamShmemSize<FunctorType, false, true> {"},
{"lineNum":"  542","line":"  static inline size_t value(const FunctorType& f, int team_size) {"},
{"lineNum":"  543","line":"    return f.shmem_size(team_size);"},
{"lineNum":"  544","line":"  }"},
{"lineNum":"  545","line":"};"},
{"lineNum":"  546","line":"template <class FunctorType>"},
{"lineNum":"  547","line":"struct FunctorTeamShmemSize<FunctorType, true, true> {"},
{"lineNum":"  548","line":"  static inline size_t value(const FunctorType& /*f*/, int /*team_size*/) {"},
{"lineNum":"  549","line":"    Kokkos::abort("},
{"lineNum":"  550","line":"        \"Functor with both team_shmem_size and shmem_size defined is \""},
{"lineNum":"  551","line":"        \"not allowed\");"},
{"lineNum":"  552","line":"    return 0;"},
{"lineNum":"  553","line":"  }"},
{"lineNum":"  554","line":"};"},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"}  // namespace Impl"},
{"lineNum":"  557","line":"}  // namespace Kokkos"},
{"lineNum":"  558","line":""},
{"lineNum":"  559","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  560","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"#endif /* KOKKOS_PARALLEL_HPP */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 15, "covered" : 0,};
var merged_data = [];
