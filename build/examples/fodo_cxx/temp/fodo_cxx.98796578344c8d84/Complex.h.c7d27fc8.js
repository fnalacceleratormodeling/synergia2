var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_COMPLEX_SSE_H"},
{"lineNum":"   11","line":"#define EIGEN_COMPLEX_SSE_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"../../InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"//---------- float ----------"},
{"lineNum":"   20","line":"struct Packet2cf"},
{"lineNum":"   21","line":"{"},
{"lineNum":"   22","line":"  EIGEN_STRONG_INLINE Packet2cf() {}"},
{"lineNum":"   23","line":"  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}"},
{"lineNum":"   24","line":"  Packet4f v;"},
{"lineNum":"   25","line":"};"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"// Use the packet_traits defined in AVX/PacketMath.h instead if we\'re going"},
{"lineNum":"   28","line":"// to leverage AVX instructions."},
{"lineNum":"   29","line":"#ifndef EIGEN_VECTORIZE_AVX"},
{"lineNum":"   30","line":"template<> struct packet_traits<std::complex<float> >  : default_packet_traits"},
{"lineNum":"   31","line":"{"},
{"lineNum":"   32","line":"  typedef Packet2cf type;"},
{"lineNum":"   33","line":"  typedef Packet2cf half;"},
{"lineNum":"   34","line":"  enum {"},
{"lineNum":"   35","line":"    Vectorizable = 1,"},
{"lineNum":"   36","line":"    AlignedOnScalar = 1,"},
{"lineNum":"   37","line":"    size = 2,"},
{"lineNum":"   38","line":"    HasHalfPacket = 0,"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"    HasAdd    = 1,"},
{"lineNum":"   41","line":"    HasSub    = 1,"},
{"lineNum":"   42","line":"    HasMul    = 1,"},
{"lineNum":"   43","line":"    HasDiv    = 1,"},
{"lineNum":"   44","line":"    HasNegate = 1,"},
{"lineNum":"   45","line":"    HasSqrt   = 1,"},
{"lineNum":"   46","line":"    HasAbs    = 0,"},
{"lineNum":"   47","line":"    HasAbs2   = 0,"},
{"lineNum":"   48","line":"    HasMin    = 0,"},
{"lineNum":"   49","line":"    HasMax    = 0,"},
{"lineNum":"   50","line":"    HasSetLinear = 0,"},
{"lineNum":"   51","line":"    HasBlend  = 1"},
{"lineNum":"   52","line":"  };"},
{"lineNum":"   53","line":"};"},
{"lineNum":"   54","line":"#endif"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"template<> struct unpacket_traits<Packet2cf> {"},
{"lineNum":"   57","line":"  typedef std::complex<float> type;"},
{"lineNum":"   58","line":"  typedef Packet2cf half;"},
{"lineNum":"   59","line":"  typedef Packet4f as_real;"},
{"lineNum":"   60","line":"  enum {"},
{"lineNum":"   61","line":"    size=2,"},
{"lineNum":"   62","line":"    alignment=Aligned16,"},
{"lineNum":"   63","line":"    vectorizable=true,"},
{"lineNum":"   64","line":"    masked_load_available=false,"},
{"lineNum":"   65","line":"    masked_store_available=false"},
{"lineNum":"   66","line":"  };"},
{"lineNum":"   67","line":"};"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }"},
{"lineNum":"   70","line":"template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)"},
{"lineNum":"   73","line":"{"},
{"lineNum":"   74","line":"  const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x80000000,0x80000000,0x80000000));"},
{"lineNum":"   75","line":"  return Packet2cf(_mm_xor_ps(a.v,mask));"},
{"lineNum":"   76","line":"}"},
{"lineNum":"   77","line":"template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)"},
{"lineNum":"   78","line":"{"},
{"lineNum":"   79","line":"  const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x00000000,0x80000000,0x00000000,0x80000000));"},
{"lineNum":"   80","line":"  return Packet2cf(_mm_xor_ps(a.v,mask));"},
{"lineNum":"   81","line":"}"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)"},
{"lineNum":"   84","line":"{"},
{"lineNum":"   85","line":"  #ifdef EIGEN_VECTORIZE_SSE3"},
{"lineNum":"   86","line":"  return Packet2cf(_mm_addsub_ps(_mm_mul_ps(_mm_moveldup_ps(a.v), b.v),"},
{"lineNum":"   87","line":"                                 _mm_mul_ps(_mm_movehdup_ps(a.v),"},
{"lineNum":"   88","line":"                                            vec4f_swizzle1(b.v, 1, 0, 3, 2))));"},
{"lineNum":"   89","line":"//   return Packet2cf(_mm_addsub_ps(_mm_mul_ps(vec4f_swizzle1(a.v, 0, 0, 2, 2), b.v),"},
{"lineNum":"   90","line":"//                                  _mm_mul_ps(vec4f_swizzle1(a.v, 1, 1, 3, 3),"},
{"lineNum":"   91","line":"//                                             vec4f_swizzle1(b.v, 1, 0, 3, 2))));"},
{"lineNum":"   92","line":"  #else"},
{"lineNum":"   93","line":"  const __m128 mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x00000000,0x80000000,0x00000000));"},
{"lineNum":"   94","line":"  return Packet2cf(_mm_add_ps(_mm_mul_ps(vec4f_swizzle1(a.v, 0, 0, 2, 2), b.v),"},
{"lineNum":"   95","line":"                              _mm_xor_ps(_mm_mul_ps(vec4f_swizzle1(a.v, 1, 1, 3, 3),"},
{"lineNum":"   96","line":"                                                    vec4f_swizzle1(b.v, 1, 0, 3, 2)), mask)));"},
{"lineNum":"   97","line":"  #endif"},
{"lineNum":"   98","line":"}"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"template<> EIGEN_STRONG_INLINE Packet2cf ptrue  <Packet2cf>(const Packet2cf& a) { return Packet2cf(ptrue(Packet4f(a.v))); }"},
{"lineNum":"  101","line":"template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }"},
{"lineNum":"  102","line":"template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }"},
{"lineNum":"  103","line":"template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }"},
{"lineNum":"  104","line":"template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(b.v,a.v)); }"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&numext::real_ref(*from))); }"},
{"lineNum":"  107","line":"template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&numext::real_ref(*from))); }"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)"},
{"lineNum":"  110","line":"{"},
{"lineNum":"  111","line":"  const float re = std::real(from);"},
{"lineNum":"  112","line":"  const float im = std::imag(from);"},
{"lineNum":"  113","line":"  return Packet2cf(_mm_set_ps(im, re, im, re));"},
{"lineNum":"  114","line":"}"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&numext::real_ref(*to), Packet4f(from.v)); }"},
{"lineNum":"  119","line":"template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&numext::real_ref(*to), Packet4f(from.v)); }"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"template<> EIGEN_DEVICE_FUNC inline Packet2cf pgather<std::complex<float>, Packet2cf>(const std::complex<float>* from, Index stride)"},
{"lineNum":"  123","line":"{"},
{"lineNum":"  124","line":"  return Packet2cf(_mm_set_ps(std::imag(from[1*stride]), std::real(from[1*stride]),"},
{"lineNum":"  125","line":"                              std::imag(from[0*stride]), std::real(from[0*stride])));"},
{"lineNum":"  126","line":"}"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"template<> EIGEN_DEVICE_FUNC inline void pscatter<std::complex<float>, Packet2cf>(std::complex<float>* to, const Packet2cf& from, Index stride)"},
{"lineNum":"  129","line":"{"},
{"lineNum":"  130","line":"  to[stride*0] = std::complex<float>(_mm_cvtss_f32(_mm_shuffle_ps(from.v, from.v, 0)),"},
{"lineNum":"  131","line":"                                     _mm_cvtss_f32(_mm_shuffle_ps(from.v, from.v, 1)));"},
{"lineNum":"  132","line":"  to[stride*1] = std::complex<float>(_mm_cvtss_f32(_mm_shuffle_ps(from.v, from.v, 2)),"},
{"lineNum":"  133","line":"                                     _mm_cvtss_f32(_mm_shuffle_ps(from.v, from.v, 3)));"},
{"lineNum":"  134","line":"}"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)"},
{"lineNum":"  139","line":"{"},
{"lineNum":"  140","line":"  #if EIGEN_GNUC_AT_MOST(4,3)"},
{"lineNum":"  141","line":"  // Workaround gcc 4.2 ICE - this is not performance wise ideal, but who cares..."},
{"lineNum":"  142","line":"  // This workaround also fix invalid code generation with gcc 4.3"},
{"lineNum":"  143","line":"  EIGEN_ALIGN16 std::complex<float> res[2];"},
{"lineNum":"  144","line":"  _mm_store_ps((float*)res, a.v);"},
{"lineNum":"  145","line":"  return res[0];"},
{"lineNum":"  146","line":"  #else"},
{"lineNum":"  147","line":"  std::complex<float> res;"},
{"lineNum":"  148","line":"  _mm_storel_pi((__m64*)&res, a.v);"},
{"lineNum":"  149","line":"  return res;"},
{"lineNum":"  150","line":"  #endif"},
{"lineNum":"  151","line":"}"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(Packet2d(_mm_castps_pd(a.v))))); }"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)"},
{"lineNum":"  156","line":"{"},
{"lineNum":"  157","line":"  return pfirst(Packet2cf(_mm_add_ps(a.v, _mm_movehl_ps(a.v,a.v))));"},
{"lineNum":"  158","line":"}"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)"},
{"lineNum":"  161","line":"{"},
{"lineNum":"  162","line":"  return pfirst(pmul(a, Packet2cf(_mm_movehl_ps(a.v,a.v))));"},
{"lineNum":"  163","line":"}"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"EIGEN_STRONG_INLINE Packet2cf pcplxflip/* <Packet2cf> */(const Packet2cf& x)"},
{"lineNum":"  166","line":"{"},
{"lineNum":"  167","line":"  return Packet2cf(vec4f_swizzle1(x.v, 1, 0, 3, 2));"},
{"lineNum":"  168","line":"}"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet2cf,Packet4f)"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)"},
{"lineNum":"  173","line":"{"},
{"lineNum":"  174","line":"  return pdiv_complex(a, b);"},
{"lineNum":"  175","line":"}"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"//---------- double ----------"},
{"lineNum":"  178","line":"struct Packet1cd"},
{"lineNum":"  179","line":"{"},
{"lineNum":"  180","line":"  EIGEN_STRONG_INLINE Packet1cd() {}"},
{"lineNum":"  181","line":"  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}"},
{"lineNum":"  182","line":"  Packet2d v;"},
{"lineNum":"  183","line":"};"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"// Use the packet_traits defined in AVX/PacketMath.h instead if we\'re going"},
{"lineNum":"  186","line":"// to leverage AVX instructions."},
{"lineNum":"  187","line":"#ifndef EIGEN_VECTORIZE_AVX"},
{"lineNum":"  188","line":"template<> struct packet_traits<std::complex<double> >  : default_packet_traits"},
{"lineNum":"  189","line":"{"},
{"lineNum":"  190","line":"  typedef Packet1cd type;"},
{"lineNum":"  191","line":"  typedef Packet1cd half;"},
{"lineNum":"  192","line":"  enum {"},
{"lineNum":"  193","line":"    Vectorizable = 1,"},
{"lineNum":"  194","line":"    AlignedOnScalar = 0,"},
{"lineNum":"  195","line":"    size = 1,"},
{"lineNum":"  196","line":"    HasHalfPacket = 0,"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"    HasAdd    = 1,"},
{"lineNum":"  199","line":"    HasSub    = 1,"},
{"lineNum":"  200","line":"    HasMul    = 1,"},
{"lineNum":"  201","line":"    HasDiv    = 1,"},
{"lineNum":"  202","line":"    HasNegate = 1,"},
{"lineNum":"  203","line":"    HasSqrt   = 1,"},
{"lineNum":"  204","line":"    HasAbs    = 0,"},
{"lineNum":"  205","line":"    HasAbs2   = 0,"},
{"lineNum":"  206","line":"    HasMin    = 0,"},
{"lineNum":"  207","line":"    HasMax    = 0,"},
{"lineNum":"  208","line":"    HasSetLinear = 0"},
{"lineNum":"  209","line":"  };"},
{"lineNum":"  210","line":"};"},
{"lineNum":"  211","line":"#endif"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"template<> struct unpacket_traits<Packet1cd> {"},
{"lineNum":"  214","line":"  typedef std::complex<double> type;"},
{"lineNum":"  215","line":"  typedef Packet1cd half;"},
{"lineNum":"  216","line":"  typedef Packet2d as_real;"},
{"lineNum":"  217","line":"  enum {"},
{"lineNum":"  218","line":"    size=1,"},
{"lineNum":"  219","line":"    alignment=Aligned16,"},
{"lineNum":"  220","line":"    vectorizable=true,"},
{"lineNum":"  221","line":"    masked_load_available=false,"},
{"lineNum":"  222","line":"    masked_store_available=false"},
{"lineNum":"  223","line":"  };"},
{"lineNum":"  224","line":"};"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  227","line":"template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }"},
{"lineNum":"  228","line":"template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(Packet2d(a.v))); }"},
{"lineNum":"  229","line":"template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)"},
{"lineNum":"  230","line":"{"},
{"lineNum":"  231","line":"  const __m128d mask = _mm_castsi128_pd(_mm_set_epi32(0x80000000,0x0,0x0,0x0));"},
{"lineNum":"  232","line":"  return Packet1cd(_mm_xor_pd(a.v,mask));"},
{"lineNum":"  233","line":"}"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)"},
{"lineNum":"  236","line":"{"},
{"lineNum":"  237","line":"  #ifdef EIGEN_VECTORIZE_SSE3"},
{"lineNum":"  238","line":"  return Packet1cd(_mm_addsub_pd(_mm_mul_pd(_mm_movedup_pd(a.v), b.v),"},
{"lineNum":"  239","line":"                                 _mm_mul_pd(vec2d_swizzle1(a.v, 1, 1),"},
{"lineNum":"  240","line":"                                            vec2d_swizzle1(b.v, 1, 0))));"},
{"lineNum":"  241","line":"  #else"},
{"lineNum":"  242","line":"  const __m128d mask = _mm_castsi128_pd(_mm_set_epi32(0x0,0x0,0x80000000,0x0));"},
{"lineNum":"  243","line":"  return Packet1cd(_mm_add_pd(_mm_mul_pd(vec2d_swizzle1(a.v, 0, 0), b.v),","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  244","line":"                              _mm_xor_pd(_mm_mul_pd(vec2d_swizzle1(a.v, 1, 1),","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  245","line":"                                                    vec2d_swizzle1(b.v, 1, 0)), mask)));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  246","line":"  #endif"},
{"lineNum":"  247","line":"}"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"template<> EIGEN_STRONG_INLINE Packet1cd ptrue  <Packet1cd>(const Packet1cd& a) { return Packet1cd(ptrue(Packet2d(a.v))); }"},
{"lineNum":"  250","line":"template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }"},
{"lineNum":"  251","line":"template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }"},
{"lineNum":"  252","line":"template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }"},
{"lineNum":"  253","line":"template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(b.v,a.v)); }"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"// FIXME force unaligned load, this is a temporary fix"},
{"lineNum":"  256","line":"template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)"},
{"lineNum":"  257","line":"{ EIGEN_DEBUG_ALIGNED_LOAD return Packet1cd(pload<Packet2d>((const double*)from)); }"},
{"lineNum":"  258","line":"template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)"},
{"lineNum":"  259","line":"{ EIGEN_DEBUG_UNALIGNED_LOAD return Packet1cd(ploadu<Packet2d>((const double*)from)); }"},
{"lineNum":"  260","line":"template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)"},
{"lineNum":"  261","line":"{ /* here we really have to use unaligned loads :( */ return ploadu<Packet1cd>(&from); }"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"// FIXME force unaligned store, this is a temporary fix"},
{"lineNum":"  266","line":"template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, Packet2d(from.v)); }"},
{"lineNum":"  267","line":"template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, Packet2d(from.v)); }"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }"},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)"},
{"lineNum":"  272","line":"{"},
{"lineNum":"  273","line":"  EIGEN_ALIGN16 double res[2];"},
{"lineNum":"  274","line":"  _mm_store_pd(res, a.v);"},
{"lineNum":"  275","line":"  return std::complex<double>(res[0],res[1]);"},
{"lineNum":"  276","line":"}"},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)"},
{"lineNum":"  281","line":"{"},
{"lineNum":"  282","line":"  return pfirst(a);"},
{"lineNum":"  283","line":"}"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)"},
{"lineNum":"  286","line":"{"},
{"lineNum":"  287","line":"  return pfirst(a);"},
{"lineNum":"  288","line":"}"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"EIGEN_MAKE_CONJ_HELPER_CPLX_REAL(Packet1cd,Packet2d)"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)"},
{"lineNum":"  293","line":"{"},
{"lineNum":"  294","line":"  return pdiv_complex(a, b);"},
{"lineNum":"  295","line":"}"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"EIGEN_STRONG_INLINE Packet1cd pcplxflip/* <Packet1cd> */(const Packet1cd& x)"},
{"lineNum":"  298","line":"{"},
{"lineNum":"  299","line":"  return Packet1cd(preverse(Packet2d(x.v)));"},
{"lineNum":"  300","line":"}"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"EIGEN_DEVICE_FUNC inline void"},
{"lineNum":"  303","line":"ptranspose(PacketBlock<Packet2cf,2>& kernel) {"},
{"lineNum":"  304","line":"  __m128d w1 = _mm_castps_pd(kernel.packet[0].v);"},
{"lineNum":"  305","line":"  __m128d w2 = _mm_castps_pd(kernel.packet[1].v);"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"  __m128 tmp = _mm_castpd_ps(_mm_unpackhi_pd(w1, w2));"},
{"lineNum":"  308","line":"  kernel.packet[0].v = _mm_castpd_ps(_mm_unpacklo_pd(w1, w2));"},
{"lineNum":"  309","line":"  kernel.packet[1].v = tmp;"},
{"lineNum":"  310","line":"}"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"template<> EIGEN_STRONG_INLINE Packet2cf pcmp_eq(const Packet2cf& a, const Packet2cf& b)"},
{"lineNum":"  313","line":"{"},
{"lineNum":"  314","line":"  __m128 eq = _mm_cmpeq_ps(a.v, b.v);"},
{"lineNum":"  315","line":"  return Packet2cf(pand<Packet4f>(eq, vec4f_swizzle1(eq, 1, 0, 3, 2)));"},
{"lineNum":"  316","line":"}"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"template<> EIGEN_STRONG_INLINE Packet1cd pcmp_eq(const Packet1cd& a, const Packet1cd& b)"},
{"lineNum":"  319","line":"{"},
{"lineNum":"  320","line":"  __m128d eq = _mm_cmpeq_pd(a.v, b.v);"},
{"lineNum":"  321","line":"  return Packet1cd(pand<Packet2d>(eq, vec2d_swizzle1(eq, 1, 0)));"},
{"lineNum":"  322","line":"}"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"template<>  EIGEN_STRONG_INLINE Packet2cf pblend(const Selector<2>& ifPacket, const Packet2cf& thenPacket, const Packet2cf& elsePacket) {"},
{"lineNum":"  325","line":"  __m128d result = pblend<Packet2d>(ifPacket, _mm_castps_pd(thenPacket.v), _mm_castps_pd(elsePacket.v));"},
{"lineNum":"  326","line":"  return Packet2cf(_mm_castpd_ps(result));"},
{"lineNum":"  327","line":"}"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"template<> EIGEN_STRONG_INLINE Packet1cd psqrt<Packet1cd>(const Packet1cd& a) {"},
{"lineNum":"  330","line":"  return psqrt_complex<Packet1cd>(a);"},
{"lineNum":"  331","line":"}"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"template<> EIGEN_STRONG_INLINE Packet2cf psqrt<Packet2cf>(const Packet2cf& a) {"},
{"lineNum":"  334","line":"  return psqrt_complex<Packet2cf>(a);"},
{"lineNum":"  335","line":"}"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"} // end namespace internal"},
{"lineNum":"  338","line":"} // end namespace Eigen"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"#endif // EIGEN_COMPLEX_SSE_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
