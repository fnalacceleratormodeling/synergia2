var data = {lines:[
{"lineNum":"    1","line":"//@HEADER"},
{"lineNum":"    2","line":"// ************************************************************************"},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    5","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    6","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    7","line":"//"},
{"lineNum":"    8","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"    9","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   10","line":"//"},
{"lineNum":"   11","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   12","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   13","line":"// met:"},
{"lineNum":"   14","line":"//"},
{"lineNum":"   15","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   16","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   17","line":"//"},
{"lineNum":"   18","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   19","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   20","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   21","line":"//"},
{"lineNum":"   22","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   23","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   24","line":"// this software without specific prior written permission."},
{"lineNum":"   25","line":"//"},
{"lineNum":"   26","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   27","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   28","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   29","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   30","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   31","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   32","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   33","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   34","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   35","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   36","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   37","line":"//"},
{"lineNum":"   38","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   39","line":"//"},
{"lineNum":"   40","line":"// ************************************************************************"},
{"lineNum":"   41","line":"//@HEADER"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"/// \\file Kokkos_Pair.hpp"},
{"lineNum":"   44","line":"/// \\brief Declaration and definition of Kokkos::pair."},
{"lineNum":"   45","line":"///"},
{"lineNum":"   46","line":"/// This header file declares and defines Kokkos::pair and its related"},
{"lineNum":"   47","line":"/// nonmember functions."},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"#ifndef KOKKOS_PAIR_HPP"},
{"lineNum":"   50","line":"#define KOKKOS_PAIR_HPP"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"#include <Kokkos_Macros.hpp>"},
{"lineNum":"   53","line":"#include <utility>"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"namespace Kokkos {"},
{"lineNum":"   56","line":"/// \\struct pair"},
{"lineNum":"   57","line":"/// \\brief Replacement for std::pair that works on CUDA devices."},
{"lineNum":"   58","line":"///"},
{"lineNum":"   59","line":"/// The instance methods of std::pair, including its constructors, are"},
{"lineNum":"   60","line":"/// not marked as <tt>__device__</tt> functions.  Thus, they cannot be"},
{"lineNum":"   61","line":"/// called on a CUDA device, such as an NVIDIA GPU.  This struct"},
{"lineNum":"   62","line":"/// implements the same interface as std::pair, but can be used on a"},
{"lineNum":"   63","line":"/// CUDA device as well as on the host."},
{"lineNum":"   64","line":"template <class T1, class T2>"},
{"lineNum":"   65","line":"struct pair {"},
{"lineNum":"   66","line":"  //! The first template parameter of this class."},
{"lineNum":"   67","line":"  using first_type = T1;"},
{"lineNum":"   68","line":"  //! The second template parameter of this class."},
{"lineNum":"   69","line":"  using second_type = T2;"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"  //! The first element of the pair."},
{"lineNum":"   72","line":"  first_type first;"},
{"lineNum":"   73","line":"  //! The second element of the pair."},
{"lineNum":"   74","line":"  second_type second;"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"  /// \\brief Default constructor."},
{"lineNum":"   77","line":"  ///"},
{"lineNum":"   78","line":"  /// This calls the default constructors of T1 and T2.  It won\'t"},
{"lineNum":"   79","line":"  /// compile if those default constructors are not defined and"},
{"lineNum":"   80","line":"  /// public."},
{"lineNum":"   81","line":"  KOKKOS_DEFAULTED_FUNCTION constexpr pair() = default;"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"  /// \\brief Constructor that takes both elements of the pair."},
{"lineNum":"   84","line":"  ///"},
{"lineNum":"   85","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"   86","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"   87","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(first_type const& f,"},
{"lineNum":"   88","line":"                                             second_type const& s)"},
{"lineNum":"   89","line":"      : first(f), second(s) {}","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"  /// \\brief Copy constructor."},
{"lineNum":"   92","line":"  ///"},
{"lineNum":"   93","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"   94","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"   95","line":"  template <class U, class V>"},
{"lineNum":"   96","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(const pair<U, V>& p)"},
{"lineNum":"   97","line":"      : first(p.first), second(p.second) {}"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"  /// \\brief Copy constructor."},
{"lineNum":"  100","line":"  ///"},
{"lineNum":"  101","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"  102","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"  103","line":"  template <class U, class V>"},
{"lineNum":"  104","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(const volatile pair<U, V>& p)"},
{"lineNum":"  105","line":"      : first(p.first), second(p.second) {}","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"  /// \\brief Assignment operator."},
{"lineNum":"  108","line":"  ///"},
{"lineNum":"  109","line":"  /// This calls the assignment operators of T1 and T2.  It won\'t"},
{"lineNum":"  110","line":"  /// compile if the assignment operators are not defined and public."},
{"lineNum":"  111","line":"  template <class U, class V>"},
{"lineNum":"  112","line":"  KOKKOS_FORCEINLINE_FUNCTION pair<T1, T2>& operator=(const pair<U, V>& p) {"},
{"lineNum":"  113","line":"    first  = p.first;"},
{"lineNum":"  114","line":"    second = p.second;"},
{"lineNum":"  115","line":"    return *this;"},
{"lineNum":"  116","line":"  }"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"  /// \\brief Assignment operator, for volatile <tt>*this</tt>."},
{"lineNum":"  119","line":"  ///"},
{"lineNum":"  120","line":"  /// \\param p [in] Input; right-hand side of the assignment."},
{"lineNum":"  121","line":"  ///"},
{"lineNum":"  122","line":"  /// This calls the assignment operators of T1 and T2.  It will not"},
{"lineNum":"  123","line":"  /// compile if the assignment operators are not defined and public."},
{"lineNum":"  124","line":"  ///"},
{"lineNum":"  125","line":"  /// This operator returns \\c void instead of <tt>volatile pair<T1,"},
{"lineNum":"  126","line":"  /// T2>& </tt>.  See Kokkos Issue #177 for the explanation.  In"},
{"lineNum":"  127","line":"  /// practice, this means that you should not chain assignments with"},
{"lineNum":"  128","line":"  /// volatile lvalues."},
{"lineNum":"  129","line":"  template <class U, class V>"},
{"lineNum":"  130","line":"  KOKKOS_FORCEINLINE_FUNCTION void operator=("},
{"lineNum":"  131","line":"      const volatile pair<U, V>& p) volatile {"},
{"lineNum":"  132","line":"    first  = p.first;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  133","line":"    second = p.second;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  134","line":"    // We deliberately do not return anything here.  See explanation"},
{"lineNum":"  135","line":"    // in public documentation above."},
{"lineNum":"  136","line":"  }"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"  // from std::pair<U,V>"},
{"lineNum":"  139","line":"  template <class U, class V>"},
{"lineNum":"  140","line":"  pair(const std::pair<U, V>& p) : first(p.first), second(p.second) {}"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"  /// \\brief Return the std::pair version of this object."},
{"lineNum":"  143","line":"  ///"},
{"lineNum":"  144","line":"  /// This is <i>not</i> a device function; you may not call it on a"},
{"lineNum":"  145","line":"  /// CUDA device.  It is meant to be called on the host, if the user"},
{"lineNum":"  146","line":"  /// wants an std::pair instead of a Kokkos::pair."},
{"lineNum":"  147","line":"  ///"},
{"lineNum":"  148","line":"  /// \\note This is not a conversion operator, since defining a"},
{"lineNum":"  149","line":"  ///   conversion operator made the relational operators have"},
{"lineNum":"  150","line":"  ///   ambiguous definitions."},
{"lineNum":"  151","line":"  std::pair<T1, T2> to_std_pair() const {"},
{"lineNum":"  152","line":"    return std::make_pair(first, second);"},
{"lineNum":"  153","line":"  }"},
{"lineNum":"  154","line":"};"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"template <class T1, class T2>"},
{"lineNum":"  157","line":"struct pair<T1&, T2&> {"},
{"lineNum":"  158","line":"  //! The first template parameter of this class."},
{"lineNum":"  159","line":"  using first_type = T1&;"},
{"lineNum":"  160","line":"  //! The second template parameter of this class."},
{"lineNum":"  161","line":"  using second_type = T2&;"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"  //! The first element of the pair."},
{"lineNum":"  164","line":"  first_type first;"},
{"lineNum":"  165","line":"  //! The second element of the pair."},
{"lineNum":"  166","line":"  second_type second;"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"  /// \\brief Constructor that takes both elements of the pair."},
{"lineNum":"  169","line":"  ///"},
{"lineNum":"  170","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"  171","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"  172","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(first_type f, second_type s)"},
{"lineNum":"  173","line":"      : first(f), second(s) {}"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"  /// \\brief Copy constructor."},
{"lineNum":"  176","line":"  ///"},
{"lineNum":"  177","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"  178","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"  179","line":"  template <class U, class V>"},
{"lineNum":"  180","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(const pair<U, V>& p)"},
{"lineNum":"  181","line":"      : first(p.first), second(p.second) {}"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"  // from std::pair<U,V>"},
{"lineNum":"  184","line":"  template <class U, class V>"},
{"lineNum":"  185","line":"  pair(const std::pair<U, V>& p) : first(p.first), second(p.second) {}"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"  /// \\brief Assignment operator."},
{"lineNum":"  188","line":"  ///"},
{"lineNum":"  189","line":"  /// This calls the assignment operators of T1 and T2.  It won\'t"},
{"lineNum":"  190","line":"  /// compile if the assignment operators are not defined and public."},
{"lineNum":"  191","line":"  template <class U, class V>"},
{"lineNum":"  192","line":"  KOKKOS_FORCEINLINE_FUNCTION pair<first_type, second_type>& operator=("},
{"lineNum":"  193","line":"      const pair<U, V>& p) {"},
{"lineNum":"  194","line":"    first  = p.first;"},
{"lineNum":"  195","line":"    second = p.second;"},
{"lineNum":"  196","line":"    return *this;"},
{"lineNum":"  197","line":"  }"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"  /// \\brief Return the std::pair version of this object."},
{"lineNum":"  200","line":"  ///"},
{"lineNum":"  201","line":"  /// This is <i>not</i> a device function; you may not call it on a"},
{"lineNum":"  202","line":"  /// CUDA device.  It is meant to be called on the host, if the user"},
{"lineNum":"  203","line":"  /// wants an std::pair instead of a Kokkos::pair."},
{"lineNum":"  204","line":"  ///"},
{"lineNum":"  205","line":"  /// \\note This is not a conversion operator, since defining a"},
{"lineNum":"  206","line":"  ///   conversion operator made the relational operators have"},
{"lineNum":"  207","line":"  ///   ambiguous definitions."},
{"lineNum":"  208","line":"  std::pair<T1, T2> to_std_pair() const {"},
{"lineNum":"  209","line":"    return std::make_pair(first, second);"},
{"lineNum":"  210","line":"  }"},
{"lineNum":"  211","line":"};"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"template <class T1, class T2>"},
{"lineNum":"  214","line":"struct pair<T1, T2&> {"},
{"lineNum":"  215","line":"  //! The first template parameter of this class."},
{"lineNum":"  216","line":"  using first_type = T1;"},
{"lineNum":"  217","line":"  //! The second template parameter of this class."},
{"lineNum":"  218","line":"  using second_type = T2&;"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"  //! The first element of the pair."},
{"lineNum":"  221","line":"  first_type first;"},
{"lineNum":"  222","line":"  //! The second element of the pair."},
{"lineNum":"  223","line":"  second_type second;"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"  /// \\brief Constructor that takes both elements of the pair."},
{"lineNum":"  226","line":"  ///"},
{"lineNum":"  227","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"  228","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"  229","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(first_type const& f, second_type s)"},
{"lineNum":"  230","line":"      : first(f), second(s) {}"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"  /// \\brief Copy constructor."},
{"lineNum":"  233","line":"  ///"},
{"lineNum":"  234","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"  235","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"  236","line":"  template <class U, class V>"},
{"lineNum":"  237","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(const pair<U, V>& p)"},
{"lineNum":"  238","line":"      : first(p.first), second(p.second) {}"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"  // from std::pair<U,V>"},
{"lineNum":"  241","line":"  template <class U, class V>"},
{"lineNum":"  242","line":"  pair(const std::pair<U, V>& p) : first(p.first), second(p.second) {}"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"  /// \\brief Assignment operator."},
{"lineNum":"  245","line":"  ///"},
{"lineNum":"  246","line":"  /// This calls the assignment operators of T1 and T2.  It won\'t"},
{"lineNum":"  247","line":"  /// compile if the assignment operators are not defined and public."},
{"lineNum":"  248","line":"  template <class U, class V>"},
{"lineNum":"  249","line":"  KOKKOS_FORCEINLINE_FUNCTION pair<first_type, second_type>& operator=("},
{"lineNum":"  250","line":"      const pair<U, V>& p) {"},
{"lineNum":"  251","line":"    first  = p.first;"},
{"lineNum":"  252","line":"    second = p.second;"},
{"lineNum":"  253","line":"    return *this;"},
{"lineNum":"  254","line":"  }"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"  /// \\brief Return the std::pair version of this object."},
{"lineNum":"  257","line":"  ///"},
{"lineNum":"  258","line":"  /// This is <i>not</i> a device function; you may not call it on a"},
{"lineNum":"  259","line":"  /// CUDA device.  It is meant to be called on the host, if the user"},
{"lineNum":"  260","line":"  /// wants an std::pair instead of a Kokkos::pair."},
{"lineNum":"  261","line":"  ///"},
{"lineNum":"  262","line":"  /// \\note This is not a conversion operator, since defining a"},
{"lineNum":"  263","line":"  ///   conversion operator made the relational operators have"},
{"lineNum":"  264","line":"  ///   ambiguous definitions."},
{"lineNum":"  265","line":"  std::pair<T1, T2> to_std_pair() const {"},
{"lineNum":"  266","line":"    return std::make_pair(first, second);"},
{"lineNum":"  267","line":"  }"},
{"lineNum":"  268","line":"};"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"template <class T1, class T2>"},
{"lineNum":"  271","line":"struct pair<T1&, T2> {"},
{"lineNum":"  272","line":"  //! The first template parameter of this class."},
{"lineNum":"  273","line":"  using first_type = T1&;"},
{"lineNum":"  274","line":"  //! The second template parameter of this class."},
{"lineNum":"  275","line":"  using second_type = T2;"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"  //! The first element of the pair."},
{"lineNum":"  278","line":"  first_type first;"},
{"lineNum":"  279","line":"  //! The second element of the pair."},
{"lineNum":"  280","line":"  second_type second;"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"  /// \\brief Constructor that takes both elements of the pair."},
{"lineNum":"  283","line":"  ///"},
{"lineNum":"  284","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"  285","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"  286","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(first_type f, second_type const& s)"},
{"lineNum":"  287","line":"      : first(f), second(s) {}"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"  /// \\brief Copy constructor."},
{"lineNum":"  290","line":"  ///"},
{"lineNum":"  291","line":"  /// This calls the copy constructors of T1 and T2.  It won\'t compile"},
{"lineNum":"  292","line":"  /// if those copy constructors are not defined and public."},
{"lineNum":"  293","line":"  template <class U, class V>"},
{"lineNum":"  294","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(const pair<U, V>& p)"},
{"lineNum":"  295","line":"      : first(p.first), second(p.second) {}"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"  // from std::pair<U,V>"},
{"lineNum":"  298","line":"  template <class U, class V>"},
{"lineNum":"  299","line":"  pair(const std::pair<U, V>& p) : first(p.first), second(p.second) {}"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"  /// \\brief Assignment operator."},
{"lineNum":"  302","line":"  ///"},
{"lineNum":"  303","line":"  /// This calls the assignment operators of T1 and T2.  It won\'t"},
{"lineNum":"  304","line":"  /// compile if the assignment operators are not defined and public."},
{"lineNum":"  305","line":"  template <class U, class V>"},
{"lineNum":"  306","line":"  KOKKOS_FORCEINLINE_FUNCTION pair<first_type, second_type>& operator=("},
{"lineNum":"  307","line":"      const pair<U, V>& p) {"},
{"lineNum":"  308","line":"    first  = p.first;"},
{"lineNum":"  309","line":"    second = p.second;"},
{"lineNum":"  310","line":"    return *this;"},
{"lineNum":"  311","line":"  }"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"  /// \\brief Return the std::pair version of this object."},
{"lineNum":"  314","line":"  ///"},
{"lineNum":"  315","line":"  /// This is <i>not</i> a device function; you may not call it on a"},
{"lineNum":"  316","line":"  /// CUDA device.  It is meant to be called on the host, if the user"},
{"lineNum":"  317","line":"  /// wants an std::pair instead of a Kokkos::pair."},
{"lineNum":"  318","line":"  ///"},
{"lineNum":"  319","line":"  /// \\note This is not a conversion operator, since defining a"},
{"lineNum":"  320","line":"  ///   conversion operator made the relational operators have"},
{"lineNum":"  321","line":"  ///   ambiguous definitions."},
{"lineNum":"  322","line":"  std::pair<T1, T2> to_std_pair() const {"},
{"lineNum":"  323","line":"    return std::make_pair(first, second);"},
{"lineNum":"  324","line":"  }"},
{"lineNum":"  325","line":"};"},
{"lineNum":"  326","line":""},
{"lineNum":"  327","line":"//! Equality operator for Kokkos::pair."},
{"lineNum":"  328","line":"template <class T1, class T2>"},
{"lineNum":"  329","line":"KOKKOS_FORCEINLINE_FUNCTION bool operator==(const pair<T1, T2>& lhs,"},
{"lineNum":"  330","line":"                                            const pair<T1, T2>& rhs) {"},
{"lineNum":"  331","line":"  return lhs.first == rhs.first && lhs.second == rhs.second;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  332","line":"}"},
{"lineNum":"  333","line":""},
{"lineNum":"  334","line":"//! Inequality operator for Kokkos::pair."},
{"lineNum":"  335","line":"template <class T1, class T2>"},
{"lineNum":"  336","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator!=(const pair<T1, T2>& lhs,"},
{"lineNum":"  337","line":"                                                      const pair<T1, T2>& rhs) {"},
{"lineNum":"  338","line":"  return !(lhs == rhs);"},
{"lineNum":"  339","line":"}"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"//! Less-than operator for Kokkos::pair."},
{"lineNum":"  342","line":"template <class T1, class T2>"},
{"lineNum":"  343","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator<(const pair<T1, T2>& lhs,"},
{"lineNum":"  344","line":"                                                     const pair<T1, T2>& rhs) {"},
{"lineNum":"  345","line":"  return lhs.first < rhs.first ||"},
{"lineNum":"  346","line":"         (!(rhs.first < lhs.first) && lhs.second < rhs.second);"},
{"lineNum":"  347","line":"}"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"//! Less-than-or-equal-to operator for Kokkos::pair."},
{"lineNum":"  350","line":"template <class T1, class T2>"},
{"lineNum":"  351","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator<=(const pair<T1, T2>& lhs,"},
{"lineNum":"  352","line":"                                                      const pair<T1, T2>& rhs) {"},
{"lineNum":"  353","line":"  return !(rhs < lhs);"},
{"lineNum":"  354","line":"}"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"//! Greater-than operator for Kokkos::pair."},
{"lineNum":"  357","line":"template <class T1, class T2>"},
{"lineNum":"  358","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator>(const pair<T1, T2>& lhs,"},
{"lineNum":"  359","line":"                                                     const pair<T1, T2>& rhs) {"},
{"lineNum":"  360","line":"  return rhs < lhs;"},
{"lineNum":"  361","line":"}"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"//! Greater-than-or-equal-to operator for Kokkos::pair."},
{"lineNum":"  364","line":"template <class T1, class T2>"},
{"lineNum":"  365","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator>=(const pair<T1, T2>& lhs,"},
{"lineNum":"  366","line":"                                                      const pair<T1, T2>& rhs) {"},
{"lineNum":"  367","line":"  return !(lhs < rhs);"},
{"lineNum":"  368","line":"}"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"/// \\brief Return a new pair."},
{"lineNum":"  371","line":"///"},
{"lineNum":"  372","line":"/// This is a \"nonmember constructor\" for Kokkos::pair.  It works just"},
{"lineNum":"  373","line":"/// like std::make_pair."},
{"lineNum":"  374","line":"template <class T1, class T2>"},
{"lineNum":"  375","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr pair<T1, T2> make_pair(T1 x, T2 y) {"},
{"lineNum":"  376","line":"  return (pair<T1, T2>(x, y));"},
{"lineNum":"  377","line":"}"},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"/// \\brief Return a pair of references to the input arguments."},
{"lineNum":"  380","line":"///"},
{"lineNum":"  381","line":"/// This compares to std::tie (new in C++11).  You can use it to"},
{"lineNum":"  382","line":"/// assign to two variables at once, from the result of a function"},
{"lineNum":"  383","line":"/// that returns a pair.  For example (<tt>__device__</tt> and"},
{"lineNum":"  384","line":"/// <tt>__host__</tt> attributes omitted for brevity):"},
{"lineNum":"  385","line":"/// \\code"},
{"lineNum":"  386","line":"/// // Declaration of the function to call."},
{"lineNum":"  387","line":"/// // First return value: operation count."},
{"lineNum":"  388","line":"/// // Second return value: whether all operations succeeded."},
{"lineNum":"  389","line":"/// Kokkos::pair<int, bool> someFunction ();"},
{"lineNum":"  390","line":"///"},
{"lineNum":"  391","line":"/// // Code that uses Kokkos::tie."},
{"lineNum":"  392","line":"/// int myFunction () {"},
{"lineNum":"  393","line":"///   int count = 0;"},
{"lineNum":"  394","line":"///   bool success = false;"},
{"lineNum":"  395","line":"///"},
{"lineNum":"  396","line":"///   // This assigns to both count and success."},
{"lineNum":"  397","line":"///   Kokkos::tie (count, success) = someFunction ();"},
{"lineNum":"  398","line":"///"},
{"lineNum":"  399","line":"///   if (! success) {"},
{"lineNum":"  400","line":"///     // ... Some operation failed;"},
{"lineNum":"  401","line":"///     //     take corrective action ..."},
{"lineNum":"  402","line":"///   }"},
{"lineNum":"  403","line":"///   return count;"},
{"lineNum":"  404","line":"/// }"},
{"lineNum":"  405","line":"/// \\endcode"},
{"lineNum":"  406","line":"///"},
{"lineNum":"  407","line":"/// The line that uses tie() could have been written like this:"},
{"lineNum":"  408","line":"/// \\code"},
{"lineNum":"  409","line":"///   Kokkos::pair<int, bool> result = someFunction ();"},
{"lineNum":"  410","line":"///   count = result.first;"},
{"lineNum":"  411","line":"///   success = result.second;"},
{"lineNum":"  412","line":"/// \\endcode"},
{"lineNum":"  413","line":"///"},
{"lineNum":"  414","line":"/// Using tie() saves two lines of code and avoids a copy of each"},
{"lineNum":"  415","line":"/// element of the pair.  The latter could be significant if one or"},
{"lineNum":"  416","line":"/// both elements of the pair are more substantial objects than \\c int"},
{"lineNum":"  417","line":"/// or \\c bool."},
{"lineNum":"  418","line":"template <class T1, class T2>"},
{"lineNum":"  419","line":"KOKKOS_FORCEINLINE_FUNCTION pair<T1&, T2&> tie(T1& x, T2& y) {"},
{"lineNum":"  420","line":"  return (pair<T1&, T2&>(x, y));"},
{"lineNum":"  421","line":"}"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"//"},
{"lineNum":"  424","line":"// Specialization of Kokkos::pair for a \\c void second argument.  This"},
{"lineNum":"  425","line":"// is not actually a \"pair\"; it only contains one element, the first."},
{"lineNum":"  426","line":"//"},
{"lineNum":"  427","line":"template <class T1>"},
{"lineNum":"  428","line":"struct pair<T1, void> {"},
{"lineNum":"  429","line":"  using first_type  = T1;"},
{"lineNum":"  430","line":"  using second_type = void;"},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"  first_type first;"},
{"lineNum":"  433","line":"  enum { second = 0 };"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"  KOKKOS_DEFAULTED_FUNCTION constexpr pair() = default;"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(const first_type& f) : first(f) {}"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(const first_type& f, int)"},
{"lineNum":"  440","line":"      : first(f) {}"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"  template <class U>"},
{"lineNum":"  443","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr pair(const pair<U, void>& p)"},
{"lineNum":"  444","line":"      : first(p.first) {}"},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":"  template <class U>"},
{"lineNum":"  447","line":"  KOKKOS_FORCEINLINE_FUNCTION pair<T1, void>& operator=("},
{"lineNum":"  448","line":"      const pair<U, void>& p) {"},
{"lineNum":"  449","line":"    first = p.first;"},
{"lineNum":"  450","line":"    return *this;"},
{"lineNum":"  451","line":"  }"},
{"lineNum":"  452","line":"};"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"//"},
{"lineNum":"  455","line":"// Specialization of relational operators for Kokkos::pair<T1,void>."},
{"lineNum":"  456","line":"//"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"template <class T1>"},
{"lineNum":"  459","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator==("},
{"lineNum":"  460","line":"    const pair<T1, void>& lhs, const pair<T1, void>& rhs) {"},
{"lineNum":"  461","line":"  return lhs.first == rhs.first;"},
{"lineNum":"  462","line":"}"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"template <class T1>"},
{"lineNum":"  465","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator!=("},
{"lineNum":"  466","line":"    const pair<T1, void>& lhs, const pair<T1, void>& rhs) {"},
{"lineNum":"  467","line":"  return !(lhs == rhs);"},
{"lineNum":"  468","line":"}"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"template <class T1>"},
{"lineNum":"  471","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator<("},
{"lineNum":"  472","line":"    const pair<T1, void>& lhs, const pair<T1, void>& rhs) {"},
{"lineNum":"  473","line":"  return lhs.first < rhs.first;"},
{"lineNum":"  474","line":"}"},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"template <class T1>"},
{"lineNum":"  477","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator<=("},
{"lineNum":"  478","line":"    const pair<T1, void>& lhs, const pair<T1, void>& rhs) {"},
{"lineNum":"  479","line":"  return !(rhs < lhs);"},
{"lineNum":"  480","line":"}"},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"template <class T1>"},
{"lineNum":"  483","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator>("},
{"lineNum":"  484","line":"    const pair<T1, void>& lhs, const pair<T1, void>& rhs) {"},
{"lineNum":"  485","line":"  return rhs < lhs;"},
{"lineNum":"  486","line":"}"},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"template <class T1>"},
{"lineNum":"  489","line":"KOKKOS_FORCEINLINE_FUNCTION constexpr bool operator>=("},
{"lineNum":"  490","line":"    const pair<T1, void>& lhs, const pair<T1, void>& rhs) {"},
{"lineNum":"  491","line":"  return !(lhs < rhs);"},
{"lineNum":"  492","line":"}"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"namespace Impl {"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"template <class T>"},
{"lineNum":"  497","line":"struct is_pair_like : std::false_type {};"},
{"lineNum":"  498","line":"template <class T, class U>"},
{"lineNum":"  499","line":"struct is_pair_like<Kokkos::pair<T, U>> : std::true_type {};"},
{"lineNum":"  500","line":"template <class T, class U>"},
{"lineNum":"  501","line":"struct is_pair_like<std::pair<T, U>> : std::true_type {};"},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"}  // end namespace Impl"},
{"lineNum":"  504","line":""},
{"lineNum":"  505","line":"}  // namespace Kokkos"},
{"lineNum":"  506","line":""},
{"lineNum":"  507","line":"#endif  // KOKKOS_PAIR_HPP"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 5, "covered" : 0,};
var merged_data = [];
