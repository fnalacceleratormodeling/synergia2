var data = {lines:[
{"lineNum":"    1","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"    2","line":"/// \\file expr.hpp"},
{"lineNum":"    3","line":"/// Contains definition of expr\\<\\> class template."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//  Copyright 2008 Eric Niebler. Distributed under the Boost"},
{"lineNum":"    6","line":"//  Software License, Version 1.0. (See accompanying file"},
{"lineNum":"    7","line":"//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"#ifndef BOOST_PROTO_EXPR_HPP_EAN_04_01_2005"},
{"lineNum":"   10","line":"#define BOOST_PROTO_EXPR_HPP_EAN_04_01_2005"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"#include <boost/preprocessor/cat.hpp>"},
{"lineNum":"   13","line":"#include <boost/preprocessor/arithmetic/dec.hpp>"},
{"lineNum":"   14","line":"#include <boost/preprocessor/selection/max.hpp>"},
{"lineNum":"   15","line":"#include <boost/preprocessor/iteration/iterate.hpp>"},
{"lineNum":"   16","line":"#include <boost/preprocessor/facilities/intercept.hpp>"},
{"lineNum":"   17","line":"#include <boost/preprocessor/repetition/repeat.hpp>"},
{"lineNum":"   18","line":"#include <boost/preprocessor/repetition/repeat_from_to.hpp>"},
{"lineNum":"   19","line":"#include <boost/preprocessor/repetition/enum_trailing.hpp>"},
{"lineNum":"   20","line":"#include <boost/preprocessor/repetition/enum_params.hpp>"},
{"lineNum":"   21","line":"#include <boost/preprocessor/repetition/enum_binary_params.hpp>"},
{"lineNum":"   22","line":"#include <boost/preprocessor/repetition/enum_trailing_params.hpp>"},
{"lineNum":"   23","line":"#include <boost/preprocessor/repetition/enum_trailing_binary_params.hpp>"},
{"lineNum":"   24","line":"#include <boost/utility/addressof.hpp>"},
{"lineNum":"   25","line":"#include <boost/proto/proto_fwd.hpp>"},
{"lineNum":"   26","line":"#include <boost/proto/args.hpp>"},
{"lineNum":"   27","line":"#include <boost/proto/traits.hpp>"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"#if defined(_MSC_VER)"},
{"lineNum":"   30","line":"# pragma warning(push)"},
{"lineNum":"   31","line":"# pragma warning(disable : 4510) // default constructor could not be generated"},
{"lineNum":"   32","line":"# pragma warning(disable : 4512) // assignment operator could not be generated"},
{"lineNum":"   33","line":"# pragma warning(disable : 4610) // user defined constructor required"},
{"lineNum":"   34","line":"# pragma warning(disable : 4714) // function \'xxx\' marked as __forceinline not inlined"},
{"lineNum":"   35","line":"#endif"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"namespace boost { namespace proto"},
{"lineNum":"   38","line":"{"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"    namespace detail"},
{"lineNum":"   41","line":"    {"},
{"lineNum":"   42","line":"        struct not_a_valid_type"},
{"lineNum":"   43","line":"        {"},
{"lineNum":"   44","line":"        private:"},
{"lineNum":"   45","line":"            not_a_valid_type()"},
{"lineNum":"   46","line":"            {}"},
{"lineNum":"   47","line":"        };"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"        template<typename Tag, typename Arg>"},
{"lineNum":"   50","line":"        struct address_of_hack"},
{"lineNum":"   51","line":"        {"},
{"lineNum":"   52","line":"            typedef not_a_valid_type type;"},
{"lineNum":"   53","line":"        };"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"        template<typename Expr>"},
{"lineNum":"   56","line":"        struct address_of_hack<proto::tag::address_of, Expr &>"},
{"lineNum":"   57","line":"        {"},
{"lineNum":"   58","line":"            typedef Expr *type;"},
{"lineNum":"   59","line":"        };"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"        template<typename T, typename Expr, typename Arg0>"},
{"lineNum":"   62","line":"        BOOST_FORCEINLINE"},
{"lineNum":"   63","line":"        Expr make_terminal(T &t, Expr *, proto::term<Arg0> *)"},
{"lineNum":"   64","line":"        {"},
{"lineNum":"   65","line":"            Expr that = {t};","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   66","line":"            return that;"},
{"lineNum":"   67","line":"        }"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"        template<typename T, typename Expr, typename Arg0, std::size_t N>"},
{"lineNum":"   70","line":"        BOOST_FORCEINLINE"},
{"lineNum":"   71","line":"        Expr make_terminal(T (&t)[N], Expr *, proto::term<Arg0[N]> *)"},
{"lineNum":"   72","line":"        {"},
{"lineNum":"   73","line":"            Expr that;"},
{"lineNum":"   74","line":"            for(std::size_t i = 0; i < N; ++i)"},
{"lineNum":"   75","line":"            {"},
{"lineNum":"   76","line":"                that.child0[i] = t[i];"},
{"lineNum":"   77","line":"            }"},
{"lineNum":"   78","line":"            return that;"},
{"lineNum":"   79","line":"        }"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"        template<typename T, typename Expr, typename Arg0, std::size_t N>"},
{"lineNum":"   82","line":"        BOOST_FORCEINLINE"},
{"lineNum":"   83","line":"        Expr make_terminal(T const(&t)[N], Expr *, proto::term<Arg0[N]> *)"},
{"lineNum":"   84","line":"        {"},
{"lineNum":"   85","line":"            Expr that;"},
{"lineNum":"   86","line":"            for(std::size_t i = 0; i < N; ++i)"},
{"lineNum":"   87","line":"            {"},
{"lineNum":"   88","line":"                that.child0[i] = t[i];"},
{"lineNum":"   89","line":"            }"},
{"lineNum":"   90","line":"            return that;"},
{"lineNum":"   91","line":"        }"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"        // Work-around for:"},
{"lineNum":"   94","line":"        // https://connect.microsoft.com/VisualStudio/feedback/details/765449/codegen-stack-corruption-using-runtime-checks-when-aggregate-initializing-struct"},
{"lineNum":"   95","line":"    #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1700))"},
{"lineNum":"   96","line":"        template<typename T, typename Expr, typename C, typename U>"},
{"lineNum":"   97","line":"        BOOST_FORCEINLINE"},
{"lineNum":"   98","line":"        Expr make_terminal(T &t, Expr *, proto::term<U C::*> *)"},
{"lineNum":"   99","line":"        {"},
{"lineNum":"  100","line":"            Expr that;"},
{"lineNum":"  101","line":"            that.child0 = t;"},
{"lineNum":"  102","line":"            return that;"},
{"lineNum":"  103","line":"        }"},
{"lineNum":"  104","line":"    #endif"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"        template<typename T, typename U>"},
{"lineNum":"  107","line":"        struct same_cv"},
{"lineNum":"  108","line":"        {"},
{"lineNum":"  109","line":"            typedef U type;"},
{"lineNum":"  110","line":"        };"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"        template<typename T, typename U>"},
{"lineNum":"  113","line":"        struct same_cv<T const, U>"},
{"lineNum":"  114","line":"        {"},
{"lineNum":"  115","line":"            typedef U const type;"},
{"lineNum":"  116","line":"        };"},
{"lineNum":"  117","line":"    }"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    namespace result_of"},
{"lineNum":"  120","line":"    {"},
{"lineNum":"  121","line":"        /// \\brief A helper metafunction for computing the"},
{"lineNum":"  122","line":"        /// return type of \\c proto::expr\\<\\>::operator()."},
{"lineNum":"  123","line":"        template<typename Sig, typename This, typename Domain>"},
{"lineNum":"  124","line":"        struct funop;"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"        #include <boost/proto/detail/funop.hpp>"},
{"lineNum":"  127","line":"    }"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    namespace exprns_"},
{"lineNum":"  130","line":"    {"},
{"lineNum":"  131","line":"        // This is where the basic_expr specializations are"},
{"lineNum":"  132","line":"        // actually defined:"},
{"lineNum":"  133","line":"        #include <boost/proto/detail/basic_expr.hpp>"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"        // This is where the expr specialization are"},
{"lineNum":"  136","line":"        // actually defined:"},
{"lineNum":"  137","line":"        #include <boost/proto/detail/expr.hpp>"},
{"lineNum":"  138","line":"    }"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"    /// \\brief Lets you inherit the interface of an expression"},
{"lineNum":"  141","line":"    /// while hiding from Proto the fact that the type is a Proto"},
{"lineNum":"  142","line":"    /// expression."},
{"lineNum":"  143","line":"    template<typename Expr>"},
{"lineNum":"  144","line":"    struct unexpr"},
{"lineNum":"  145","line":"      : Expr"},
{"lineNum":"  146","line":"    {"},
{"lineNum":"  147","line":"        BOOST_PROTO_UNEXPR()"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"        BOOST_FORCEINLINE"},
{"lineNum":"  150","line":"        explicit unexpr(Expr const &e)"},
{"lineNum":"  151","line":"          : Expr(e)"},
{"lineNum":"  152","line":"        {}"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"        using Expr::operator =;"},
{"lineNum":"  155","line":"    };"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"}}"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"#if defined(_MSC_VER)"},
{"lineNum":"  160","line":"# pragma warning(pop)"},
{"lineNum":"  161","line":"#endif"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"#endif // BOOST_PROTO_EXPR_HPP_EAN_04_01_2005"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
