var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2014 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_CWISE_UNARY_OP_H"},
{"lineNum":"   12","line":"#define EIGEN_CWISE_UNARY_OP_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":"template<typename UnaryOp, typename XprType>"},
{"lineNum":"   20","line":"struct traits<CwiseUnaryOp<UnaryOp, XprType> >"},
{"lineNum":"   21","line":" : traits<XprType>"},
{"lineNum":"   22","line":"{"},
{"lineNum":"   23","line":"  typedef typename result_of<"},
{"lineNum":"   24","line":"                     UnaryOp(const typename XprType::Scalar&)"},
{"lineNum":"   25","line":"                   >::type Scalar;"},
{"lineNum":"   26","line":"  typedef typename XprType::Nested XprTypeNested;"},
{"lineNum":"   27","line":"  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;"},
{"lineNum":"   28","line":"  enum {"},
{"lineNum":"   29","line":"    Flags = _XprTypeNested::Flags & RowMajorBit"},
{"lineNum":"   30","line":"  };"},
{"lineNum":"   31","line":"};"},
{"lineNum":"   32","line":"}"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"template<typename UnaryOp, typename XprType, typename StorageKind>"},
{"lineNum":"   35","line":"class CwiseUnaryOpImpl;"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"/** \\class CwiseUnaryOp"},
{"lineNum":"   38","line":"  * \\ingroup Core_Module"},
{"lineNum":"   39","line":"  *"},
{"lineNum":"   40","line":"  * \\brief Generic expression where a coefficient-wise unary operator is applied to an expression"},
{"lineNum":"   41","line":"  *"},
{"lineNum":"   42","line":"  * \\tparam UnaryOp template functor implementing the operator"},
{"lineNum":"   43","line":"  * \\tparam XprType the type of the expression to which we are applying the unary operator"},
{"lineNum":"   44","line":"  *"},
{"lineNum":"   45","line":"  * This class represents an expression where a unary operator is applied to an expression."},
{"lineNum":"   46","line":"  * It is the return type of all operations taking exactly 1 input expression, regardless of the"},
{"lineNum":"   47","line":"  * presence of other inputs such as scalars. For example, the operator* in the expression 3*matrix"},
{"lineNum":"   48","line":"  * is considered unary, because only the right-hand side is an expression, and its"},
{"lineNum":"   49","line":"  * return type is a specialization of CwiseUnaryOp."},
{"lineNum":"   50","line":"  *"},
{"lineNum":"   51","line":"  * Most of the time, this is the only way that it is used, so you typically don\'t have to name"},
{"lineNum":"   52","line":"  * CwiseUnaryOp types explicitly."},
{"lineNum":"   53","line":"  *"},
{"lineNum":"   54","line":"  * \\sa MatrixBase::unaryExpr(const CustomUnaryOp &) const, class CwiseBinaryOp, class CwiseNullaryOp"},
{"lineNum":"   55","line":"  */"},
{"lineNum":"   56","line":"template<typename UnaryOp, typename XprType>"},
{"lineNum":"   57","line":"class CwiseUnaryOp : public CwiseUnaryOpImpl<UnaryOp, XprType, typename internal::traits<XprType>::StorageKind>, internal::no_assignment_operator"},
{"lineNum":"   58","line":"{"},
{"lineNum":"   59","line":"  public:"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;"},
{"lineNum":"   62","line":"    EIGEN_GENERIC_PUBLIC_INTERFACE(CwiseUnaryOp)"},
{"lineNum":"   63","line":"    typedef typename internal::ref_selector<XprType>::type XprTypeNested;"},
{"lineNum":"   64","line":"    typedef typename internal::remove_all<XprType>::type NestedExpression;"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"   67","line":"    explicit CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())"},
{"lineNum":"   68","line":"      : m_xpr(xpr), m_functor(func) {}"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"   71","line":"    Index rows() const EIGEN_NOEXCEPT { return m_xpr.rows(); }"},
{"lineNum":"   72","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"   73","line":"    Index cols() const EIGEN_NOEXCEPT { return m_xpr.cols(); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"    /** \\returns the functor representing the unary operation */"},
{"lineNum":"   76","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"   77","line":"    const UnaryOp& functor() const { return m_functor; }"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"    /** \\returns the nested expression */"},
{"lineNum":"   80","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"   81","line":"    const typename internal::remove_all<XprTypeNested>::type&"},
{"lineNum":"   82","line":"    nestedExpression() const { return m_xpr; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"    /** \\returns the nested expression */"},
{"lineNum":"   85","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"   86","line":"    typename internal::remove_all<XprTypeNested>::type&"},
{"lineNum":"   87","line":"    nestedExpression() { return m_xpr; }"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"  protected:"},
{"lineNum":"   90","line":"    XprTypeNested m_xpr;"},
{"lineNum":"   91","line":"    const UnaryOp m_functor;"},
{"lineNum":"   92","line":"};"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"// Generic API dispatcher"},
{"lineNum":"   95","line":"template<typename UnaryOp, typename XprType, typename StorageKind>"},
{"lineNum":"   96","line":"class CwiseUnaryOpImpl"},
{"lineNum":"   97","line":"  : public internal::generic_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type"},
{"lineNum":"   98","line":"{"},
{"lineNum":"   99","line":"public:"},
{"lineNum":"  100","line":"  typedef typename internal::generic_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;"},
{"lineNum":"  101","line":"};"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"} // end namespace Eigen"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"#endif // EIGEN_CWISE_UNARY_OP_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
