var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_DENSESTORAGEBASE_H"},
{"lineNum":"   12","line":"#define EIGEN_DENSESTORAGEBASE_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#if defined(EIGEN_INITIALIZE_MATRICES_BY_ZERO)"},
{"lineNum":"   15","line":"# define EIGEN_INITIALIZE_COEFFS"},
{"lineNum":"   16","line":"# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(Index i=0;i<base().size();++i) coeffRef(i)=Scalar(0);"},
{"lineNum":"   17","line":"#elif defined(EIGEN_INITIALIZE_MATRICES_BY_NAN)"},
{"lineNum":"   18","line":"# define EIGEN_INITIALIZE_COEFFS"},
{"lineNum":"   19","line":"# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED for(Index i=0;i<base().size();++i) coeffRef(i)=std::numeric_limits<Scalar>::quiet_NaN();"},
{"lineNum":"   20","line":"#else"},
{"lineNum":"   21","line":"# undef EIGEN_INITIALIZE_COEFFS"},
{"lineNum":"   22","line":"# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED"},
{"lineNum":"   23","line":"#endif"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"namespace Eigen {"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"namespace internal {"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {"},
{"lineNum":"   32","line":"  template<typename Index>"},
{"lineNum":"   33","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   34","line":"  static EIGEN_ALWAYS_INLINE void run(Index, Index)"},
{"lineNum":"   35","line":"  {"},
{"lineNum":"   36","line":"  }"},
{"lineNum":"   37","line":"};"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"template<> struct check_rows_cols_for_overflow<Dynamic> {"},
{"lineNum":"   40","line":"  template<typename Index>"},
{"lineNum":"   41","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   42","line":"  static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)"},
{"lineNum":"   43","line":"  {"},
{"lineNum":"   44","line":"    // http://hg.mozilla.org/mozilla-central/file/6c8a909977d3/xpcom/ds/CheckedInt.h#l242"},
{"lineNum":"   45","line":"    // we assume Index is signed"},
{"lineNum":"   46","line":"    Index max_index = (std::size_t(1) << (8 * sizeof(Index) - 1)) - 1; // assume Index is signed"},
{"lineNum":"   47","line":"    bool error = (rows == 0 || cols == 0) ? false","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"   48","line":"               : (rows > max_index / cols);","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"   49","line":"    if (error)","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"   50","line":"      throw_std_bad_alloc();"},
{"lineNum":"   51","line":"  }"},
{"lineNum":"   52","line":"};"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"template <typename Derived,"},
{"lineNum":"   55","line":"          typename OtherDerived = Derived,"},
{"lineNum":"   56","line":"          bool IsVector = bool(Derived::IsVectorAtCompileTime) && bool(OtherDerived::IsVectorAtCompileTime)>"},
{"lineNum":"   57","line":"struct conservative_resize_like_impl;"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers> struct matrix_swap_impl;"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"} // end namespace internal"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"#ifdef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"   64","line":"namespace doxygen {"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"// This is a workaround to doxygen not being able to understand the inheritance logic"},
{"lineNum":"   67","line":"// when it is hidden by the dense_xpr_base helper struct."},
{"lineNum":"   68","line":"// Moreover, doxygen fails to include members that are not documented in the declaration body of"},
{"lineNum":"   69","line":"// MatrixBase if we inherits MatrixBase<Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_> >,"},
{"lineNum":"   70","line":"// this is why we simply inherits MatrixBase, though this does not make sense."},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"/** This class is just a workaround for Doxygen and it does not not actually exist. */"},
{"lineNum":"   73","line":"template<typename Derived> struct dense_xpr_base_dispatcher;"},
{"lineNum":"   74","line":"/** This class is just a workaround for Doxygen and it does not not actually exist. */"},
{"lineNum":"   75","line":"template<typename Scalar_, int Rows_, int Cols_, int Options_, int MaxRows_, int MaxCols_>"},
{"lineNum":"   76","line":"struct dense_xpr_base_dispatcher<Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_> >"},
{"lineNum":"   77","line":"    : public MatrixBase {};"},
{"lineNum":"   78","line":"/** This class is just a workaround for Doxygen and it does not not actually exist. */"},
{"lineNum":"   79","line":"template<typename Scalar_, int Rows_, int Cols_, int Options_, int MaxRows_, int MaxCols_>"},
{"lineNum":"   80","line":"struct dense_xpr_base_dispatcher<Array<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_> >"},
{"lineNum":"   81","line":"    : public ArrayBase {};"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"} // namespace doxygen"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"/** \\class PlainObjectBase"},
{"lineNum":"   86","line":"  * \\ingroup Core_Module"},
{"lineNum":"   87","line":"  * \\brief %Dense storage base class for matrices and arrays."},
{"lineNum":"   88","line":"  *"},
{"lineNum":"   89","line":"  * This class can be extended with the help of the plugin mechanism described on the page"},
{"lineNum":"   90","line":"  * \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_PLAINOBJECTBASE_PLUGIN."},
{"lineNum":"   91","line":"  *"},
{"lineNum":"   92","line":"  * \\tparam Derived is the derived type, e.g., a Matrix or Array"},
{"lineNum":"   93","line":"  *"},
{"lineNum":"   94","line":"  * \\sa \\ref TopicClassHierarchy"},
{"lineNum":"   95","line":"  */"},
{"lineNum":"   96","line":"template<typename Derived>"},
{"lineNum":"   97","line":"class PlainObjectBase : public doxygen::dense_xpr_base_dispatcher<Derived>"},
{"lineNum":"   98","line":"#else"},
{"lineNum":"   99","line":"template<typename Derived>"},
{"lineNum":"  100","line":"class PlainObjectBase : public internal::dense_xpr_base<Derived>::type"},
{"lineNum":"  101","line":"#endif"},
{"lineNum":"  102","line":"{"},
{"lineNum":"  103","line":"  public:"},
{"lineNum":"  104","line":"    enum { Options = internal::traits<Derived>::Options };"},
{"lineNum":"  105","line":"    typedef typename internal::dense_xpr_base<Derived>::type Base;"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"    typedef typename internal::traits<Derived>::StorageKind StorageKind;"},
{"lineNum":"  108","line":"    typedef typename internal::traits<Derived>::Scalar Scalar;"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"    typedef typename internal::packet_traits<Scalar>::type PacketScalar;"},
{"lineNum":"  111","line":"    typedef typename NumTraits<Scalar>::Real RealScalar;"},
{"lineNum":"  112","line":"    typedef Derived DenseType;"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"    using Base::RowsAtCompileTime;"},
{"lineNum":"  115","line":"    using Base::ColsAtCompileTime;"},
{"lineNum":"  116","line":"    using Base::SizeAtCompileTime;"},
{"lineNum":"  117","line":"    using Base::MaxRowsAtCompileTime;"},
{"lineNum":"  118","line":"    using Base::MaxColsAtCompileTime;"},
{"lineNum":"  119","line":"    using Base::MaxSizeAtCompileTime;"},
{"lineNum":"  120","line":"    using Base::IsVectorAtCompileTime;"},
{"lineNum":"  121","line":"    using Base::Flags;"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"    typedef Eigen::Map<Derived, Unaligned>  MapType;"},
{"lineNum":"  124","line":"    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;"},
{"lineNum":"  125","line":"    typedef Eigen::Map<Derived, AlignedMax> AlignedMapType;"},
{"lineNum":"  126","line":"    typedef const Eigen::Map<const Derived, AlignedMax> ConstAlignedMapType;"},
{"lineNum":"  127","line":"    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };"},
{"lineNum":"  128","line":"    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };"},
{"lineNum":"  129","line":"    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, AlignedMax, StrideType> type; };"},
{"lineNum":"  130","line":"    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, AlignedMax, StrideType> type; };"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"  protected:"},
{"lineNum":"  133","line":"    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"  public:"},
{"lineNum":"  136","line":"    enum { NeedsToAlign = (SizeAtCompileTime != Dynamic) && (internal::traits<Derived>::Alignment>0) };"},
{"lineNum":"  137","line":"    EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"    EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1, (int(Options)&RowMajor)==RowMajor), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  140","line":"    EIGEN_STATIC_ASSERT(EIGEN_IMPLIES(MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1, (int(Options)&RowMajor)==0), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  141","line":"    EIGEN_STATIC_ASSERT((RowsAtCompileTime == Dynamic) || (RowsAtCompileTime >= 0), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  142","line":"    EIGEN_STATIC_ASSERT((ColsAtCompileTime == Dynamic) || (ColsAtCompileTime >= 0), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  143","line":"    EIGEN_STATIC_ASSERT((MaxRowsAtCompileTime == Dynamic) || (MaxRowsAtCompileTime >= 0), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  144","line":"    EIGEN_STATIC_ASSERT((MaxColsAtCompileTime == Dynamic) || (MaxColsAtCompileTime >= 0), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  145","line":"    EIGEN_STATIC_ASSERT((MaxRowsAtCompileTime == RowsAtCompileTime || RowsAtCompileTime==Dynamic), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  146","line":"    EIGEN_STATIC_ASSERT((MaxColsAtCompileTime == ColsAtCompileTime || ColsAtCompileTime==Dynamic), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  147","line":"    EIGEN_STATIC_ASSERT(((Options & (DontAlign|RowMajor)) == Options), INVALID_MATRIX_TEMPLATE_PARAMETERS)"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  150","line":"    Base& base() { return *static_cast<Base*>(this); }"},
{"lineNum":"  151","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  152","line":"    const Base& base() const { return *static_cast<const Base*>(this); }"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  155","line":"    Index rows() const EIGEN_NOEXCEPT { return m_storage.rows(); }"},
{"lineNum":"  156","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  157","line":"    Index cols() const EIGEN_NOEXCEPT { return m_storage.cols(); }"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index,Index) const"},
{"lineNum":"  160","line":"      * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts."},
{"lineNum":"  161","line":"      *"},
{"lineNum":"  162","line":"      * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */"},
{"lineNum":"  163","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  164","line":"    EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const"},
{"lineNum":"  165","line":"    {"},
{"lineNum":"  166","line":"      if(Flags & RowMajorBit)"},
{"lineNum":"  167","line":"        return m_storage.data()[colId + rowId * m_storage.cols()];","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  168","line":"      else // column-major"},
{"lineNum":"  169","line":"        return m_storage.data()[rowId + colId * m_storage.rows()];","class":"lineNoCov","hits":"0","possible_hits":"37",},
{"lineNum":"  170","line":"    }"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"    /** This is an overloaded version of DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const"},
{"lineNum":"  173","line":"      * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts."},
{"lineNum":"  174","line":"      *"},
{"lineNum":"  175","line":"      * See DenseCoeffsBase<Derived,ReadOnlyAccessors>::coeff(Index) const for details. */"},
{"lineNum":"  176","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  177","line":"    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const"},
{"lineNum":"  178","line":"    {"},
{"lineNum":"  179","line":"      return m_storage.data()[index];","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  180","line":"    }"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"    /** This is an overloaded version of DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index,Index) const"},
{"lineNum":"  183","line":"      * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts."},
{"lineNum":"  184","line":"      *"},
{"lineNum":"  185","line":"      * See DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index,Index) const for details. */"},
{"lineNum":"  186","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  187","line":"    EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)"},
{"lineNum":"  188","line":"    {"},
{"lineNum":"  189","line":"      if(Flags & RowMajorBit)"},
{"lineNum":"  190","line":"        return m_storage.data()[colId + rowId * m_storage.cols()];","class":"lineNoCov","hits":"0","possible_hits":"51",},
{"lineNum":"  191","line":"      else // column-major"},
{"lineNum":"  192","line":"        return m_storage.data()[rowId + colId * m_storage.rows()];","class":"lineNoCov","hits":"0","possible_hits":"31",},
{"lineNum":"  193","line":"    }"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"    /** This is an overloaded version of DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index) const"},
{"lineNum":"  196","line":"      * provided to by-pass the creation of an evaluator of the expression, thus saving compilation efforts."},
{"lineNum":"  197","line":"      *"},
{"lineNum":"  198","line":"      * See DenseCoeffsBase<Derived,WriteAccessors>::coeffRef(Index) const for details. */"},
{"lineNum":"  199","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  200","line":"    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)"},
{"lineNum":"  201","line":"    {"},
{"lineNum":"  202","line":"      return m_storage.data()[index];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  203","line":"    }"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"    /** This is the const version of coeffRef(Index,Index) which is thus synonym of coeff(Index,Index)."},
{"lineNum":"  206","line":"      * It is provided for convenience. */"},
{"lineNum":"  207","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  208","line":"    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const"},
{"lineNum":"  209","line":"    {"},
{"lineNum":"  210","line":"      if(Flags & RowMajorBit)"},
{"lineNum":"  211","line":"        return m_storage.data()[colId + rowId * m_storage.cols()];","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  212","line":"      else // column-major"},
{"lineNum":"  213","line":"        return m_storage.data()[rowId + colId * m_storage.rows()];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  214","line":"    }"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"    /** This is the const version of coeffRef(Index) which is thus synonym of coeff(Index)."},
{"lineNum":"  217","line":"      * It is provided for convenience. */"},
{"lineNum":"  218","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  219","line":"    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const"},
{"lineNum":"  220","line":"    {"},
{"lineNum":"  221","line":"      return m_storage.data()[index];"},
{"lineNum":"  222","line":"    }"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"    /** \\internal */"},
{"lineNum":"  225","line":"    template<int LoadMode>"},
{"lineNum":"  226","line":"    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const"},
{"lineNum":"  227","line":"    {"},
{"lineNum":"  228","line":"      return internal::ploadt<PacketScalar, LoadMode>"},
{"lineNum":"  229","line":"               (m_storage.data() + (Flags & RowMajorBit"},
{"lineNum":"  230","line":"                                   ? colId + rowId * m_storage.cols()"},
{"lineNum":"  231","line":"                                   : rowId + colId * m_storage.rows()));"},
{"lineNum":"  232","line":"    }"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"    /** \\internal */"},
{"lineNum":"  235","line":"    template<int LoadMode>"},
{"lineNum":"  236","line":"    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const"},
{"lineNum":"  237","line":"    {"},
{"lineNum":"  238","line":"      return internal::ploadt<PacketScalar, LoadMode>(m_storage.data() + index);"},
{"lineNum":"  239","line":"    }"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"    /** \\internal */"},
{"lineNum":"  242","line":"    template<int StoreMode>"},
{"lineNum":"  243","line":"    EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)"},
{"lineNum":"  244","line":"    {"},
{"lineNum":"  245","line":"      internal::pstoret<Scalar, PacketScalar, StoreMode>"},
{"lineNum":"  246","line":"              (m_storage.data() + (Flags & RowMajorBit"},
{"lineNum":"  247","line":"                                   ? colId + rowId * m_storage.cols()"},
{"lineNum":"  248","line":"                                   : rowId + colId * m_storage.rows()), val);"},
{"lineNum":"  249","line":"    }"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"    /** \\internal */"},
{"lineNum":"  252","line":"    template<int StoreMode>"},
{"lineNum":"  253","line":"    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)"},
{"lineNum":"  254","line":"    {"},
{"lineNum":"  255","line":"      internal::pstoret<Scalar, PacketScalar, StoreMode>(m_storage.data() + index, val);"},
{"lineNum":"  256","line":"    }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"    /** \\returns a const pointer to the data array of this matrix */"},
{"lineNum":"  259","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar *data() const"},
{"lineNum":"  260","line":"    { return m_storage.data(); }"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"    /** \\returns a pointer to the data array of this matrix */"},
{"lineNum":"  263","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar *data()"},
{"lineNum":"  264","line":"    { return m_storage.data(); }"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"    /** Resizes \\c *this to a \\a rows x \\a cols matrix."},
{"lineNum":"  267","line":"      *"},
{"lineNum":"  268","line":"      * This method is intended for dynamic-size matrices, although it is legal to call it on any"},
{"lineNum":"  269","line":"      * matrix as long as fixed dimensions are left unchanged. If you only want to change the number"},
{"lineNum":"  270","line":"      * of rows and/or of columns, you can use resize(NoChange_t, Index), resize(Index, NoChange_t)."},
{"lineNum":"  271","line":"      *"},
{"lineNum":"  272","line":"      * If the current number of coefficients of \\c *this exactly matches the"},
{"lineNum":"  273","line":"      * product \\a rows * \\a cols, then no memory allocation is performed and"},
{"lineNum":"  274","line":"      * the current values are left unchanged. In all other cases, including"},
{"lineNum":"  275","line":"      * shrinking, the data is reallocated and all previous values are lost."},
{"lineNum":"  276","line":"      *"},
{"lineNum":"  277","line":"      * Example: \\include Matrix_resize_int_int.cpp"},
{"lineNum":"  278","line":"      * Output: \\verbinclude Matrix_resize_int_int.out"},
{"lineNum":"  279","line":"      *"},
{"lineNum":"  280","line":"      * \\sa resize(Index) for vectors, resize(NoChange_t, Index), resize(Index, NoChange_t)"},
{"lineNum":"  281","line":"      */"},
{"lineNum":"  282","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  283","line":"    EIGEN_STRONG_INLINE void resize(Index rows, Index cols)"},
{"lineNum":"  284","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  285","line":"      eigen_assert(EIGEN_IMPLIES(RowsAtCompileTime!=Dynamic,rows==RowsAtCompileTime)"},
{"lineNum":"  286","line":"                   && EIGEN_IMPLIES(ColsAtCompileTime!=Dynamic,cols==ColsAtCompileTime)"},
{"lineNum":"  287","line":"                   && EIGEN_IMPLIES(RowsAtCompileTime==Dynamic && MaxRowsAtCompileTime!=Dynamic,rows<=MaxRowsAtCompileTime)"},
{"lineNum":"  288","line":"                   && EIGEN_IMPLIES(ColsAtCompileTime==Dynamic && MaxColsAtCompileTime!=Dynamic,cols<=MaxColsAtCompileTime)"},
{"lineNum":"  289","line":"                   && rows>=0 && cols>=0 && \"Invalid sizes when resizing a matrix or array.\");"},
{"lineNum":"  290","line":"      internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(rows, cols);"},
{"lineNum":"  291","line":"      #ifdef EIGEN_INITIALIZE_COEFFS"},
{"lineNum":"  292","line":"        Index size = rows*cols;"},
{"lineNum":"  293","line":"        bool size_changed = size != this->size();"},
{"lineNum":"  294","line":"        m_storage.resize(size, rows, cols);"},
{"lineNum":"  295","line":"        if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED"},
{"lineNum":"  296","line":"      #else"},
{"lineNum":"  297","line":"        m_storage.resize(rows*cols, rows, cols);","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  298","line":"      #endif"},
{"lineNum":"  299","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"    /** Resizes \\c *this to a vector of length \\a size"},
{"lineNum":"  302","line":"      *"},
{"lineNum":"  303","line":"      * \\only_for_vectors. This method does not work for"},
{"lineNum":"  304","line":"      * partially dynamic matrices when the static dimension is anything other"},
{"lineNum":"  305","line":"      * than 1. For example it will not work with Matrix<double, 2, Dynamic>."},
{"lineNum":"  306","line":"      *"},
{"lineNum":"  307","line":"      * Example: \\include Matrix_resize_int.cpp"},
{"lineNum":"  308","line":"      * Output: \\verbinclude Matrix_resize_int.out"},
{"lineNum":"  309","line":"      *"},
{"lineNum":"  310","line":"      * \\sa resize(Index,Index), resize(NoChange_t, Index), resize(Index, NoChange_t)"},
{"lineNum":"  311","line":"      */"},
{"lineNum":"  312","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  313","line":"    inline void resize(Index size)"},
{"lineNum":"  314","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  315","line":"      EIGEN_STATIC_ASSERT_VECTOR_ONLY(PlainObjectBase)"},
{"lineNum":"  316","line":"      eigen_assert(((SizeAtCompileTime == Dynamic && (MaxSizeAtCompileTime==Dynamic || size<=MaxSizeAtCompileTime)) || SizeAtCompileTime == size) && size>=0);"},
{"lineNum":"  317","line":"      #ifdef EIGEN_INITIALIZE_COEFFS"},
{"lineNum":"  318","line":"        bool size_changed = size != this->size();"},
{"lineNum":"  319","line":"      #endif"},
{"lineNum":"  320","line":"      if(RowsAtCompileTime == 1)"},
{"lineNum":"  321","line":"        m_storage.resize(size, 1, size);"},
{"lineNum":"  322","line":"      else"},
{"lineNum":"  323","line":"        m_storage.resize(size, size, 1);"},
{"lineNum":"  324","line":"      #ifdef EIGEN_INITIALIZE_COEFFS"},
{"lineNum":"  325","line":"        if(size_changed) EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED"},
{"lineNum":"  326","line":"      #endif"},
{"lineNum":"  327","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"    /** Resizes the matrix, changing only the number of columns. For the parameter of type NoChange_t, just pass the special value \\c NoChange"},
{"lineNum":"  330","line":"      * as in the example below."},
{"lineNum":"  331","line":"      *"},
{"lineNum":"  332","line":"      * Example: \\include Matrix_resize_NoChange_int.cpp"},
{"lineNum":"  333","line":"      * Output: \\verbinclude Matrix_resize_NoChange_int.out"},
{"lineNum":"  334","line":"      *"},
{"lineNum":"  335","line":"      * \\sa resize(Index,Index)"},
{"lineNum":"  336","line":"      */"},
{"lineNum":"  337","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  338","line":"    inline void resize(NoChange_t, Index cols)"},
{"lineNum":"  339","line":"    {"},
{"lineNum":"  340","line":"      resize(rows(), cols);"},
{"lineNum":"  341","line":"    }"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"    /** Resizes the matrix, changing only the number of rows. For the parameter of type NoChange_t, just pass the special value \\c NoChange"},
{"lineNum":"  344","line":"      * as in the example below."},
{"lineNum":"  345","line":"      *"},
{"lineNum":"  346","line":"      * Example: \\include Matrix_resize_int_NoChange.cpp"},
{"lineNum":"  347","line":"      * Output: \\verbinclude Matrix_resize_int_NoChange.out"},
{"lineNum":"  348","line":"      *"},
{"lineNum":"  349","line":"      * \\sa resize(Index,Index)"},
{"lineNum":"  350","line":"      */"},
{"lineNum":"  351","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  352","line":"    inline void resize(Index rows, NoChange_t)"},
{"lineNum":"  353","line":"    {"},
{"lineNum":"  354","line":"      resize(rows, cols());"},
{"lineNum":"  355","line":"    }"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"    /** Resizes \\c *this to have the same dimensions as \\a other."},
{"lineNum":"  358","line":"      * Takes care of doing all the checking that\'s needed."},
{"lineNum":"  359","line":"      *"},
{"lineNum":"  360","line":"      * Note that copying a row-vector into a vector (and conversely) is allowed."},
{"lineNum":"  361","line":"      * The resizing, if any, is then done in the appropriate way so that row-vectors"},
{"lineNum":"  362","line":"      * remain row-vectors and vectors remain vectors."},
{"lineNum":"  363","line":"      */"},
{"lineNum":"  364","line":"    template<typename OtherDerived>"},
{"lineNum":"  365","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  366","line":"    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)"},
{"lineNum":"  367","line":"    {"},
{"lineNum":"  368","line":"      const OtherDerived& other = _other.derived();"},
{"lineNum":"  369","line":"      internal::check_rows_cols_for_overflow<MaxSizeAtCompileTime>::run(other.rows(), other.cols());"},
{"lineNum":"  370","line":"      const Index othersize = other.rows()*other.cols();"},
{"lineNum":"  371","line":"      if(RowsAtCompileTime == 1)"},
{"lineNum":"  372","line":"      {"},
{"lineNum":"  373","line":"        eigen_assert(other.rows() == 1 || other.cols() == 1);"},
{"lineNum":"  374","line":"        resize(1, othersize);"},
{"lineNum":"  375","line":"      }"},
{"lineNum":"  376","line":"      else if(ColsAtCompileTime == 1)"},
{"lineNum":"  377","line":"      {"},
{"lineNum":"  378","line":"        eigen_assert(other.rows() == 1 || other.cols() == 1);"},
{"lineNum":"  379","line":"        resize(othersize, 1);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  380","line":"      }"},
{"lineNum":"  381","line":"      else resize(other.rows(), other.cols());","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  382","line":"    }"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"    /** Resizes the matrix to \\a rows x \\a cols while leaving old values untouched."},
{"lineNum":"  385","line":"      *"},
{"lineNum":"  386","line":"      * The method is intended for matrices of dynamic size. If you only want to change the number"},
{"lineNum":"  387","line":"      * of rows and/or of columns, you can use conservativeResize(NoChange_t, Index) or"},
{"lineNum":"  388","line":"      * conservativeResize(Index, NoChange_t)."},
{"lineNum":"  389","line":"      *"},
{"lineNum":"  390","line":"      * Matrices are resized relative to the top-left element. In case values need to be"},
{"lineNum":"  391","line":"      * appended to the matrix they will be uninitialized."},
{"lineNum":"  392","line":"      */"},
{"lineNum":"  393","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  394","line":"    EIGEN_STRONG_INLINE void conservativeResize(Index rows, Index cols)"},
{"lineNum":"  395","line":"    {"},
{"lineNum":"  396","line":"      internal::conservative_resize_like_impl<Derived>::run(*this, rows, cols);"},
{"lineNum":"  397","line":"    }"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"    /** Resizes the matrix to \\a rows x \\a cols while leaving old values untouched."},
{"lineNum":"  400","line":"      *"},
{"lineNum":"  401","line":"      * As opposed to conservativeResize(Index rows, Index cols), this version leaves"},
{"lineNum":"  402","line":"      * the number of columns unchanged."},
{"lineNum":"  403","line":"      *"},
{"lineNum":"  404","line":"      * In case the matrix is growing, new rows will be uninitialized."},
{"lineNum":"  405","line":"      */"},
{"lineNum":"  406","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  407","line":"    EIGEN_STRONG_INLINE void conservativeResize(Index rows, NoChange_t)"},
{"lineNum":"  408","line":"    {"},
{"lineNum":"  409","line":"      // Note: see the comment in conservativeResize(Index,Index)"},
{"lineNum":"  410","line":"      conservativeResize(rows, cols());"},
{"lineNum":"  411","line":"    }"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"    /** Resizes the matrix to \\a rows x \\a cols while leaving old values untouched."},
{"lineNum":"  414","line":"      *"},
{"lineNum":"  415","line":"      * As opposed to conservativeResize(Index rows, Index cols), this version leaves"},
{"lineNum":"  416","line":"      * the number of rows unchanged."},
{"lineNum":"  417","line":"      *"},
{"lineNum":"  418","line":"      * In case the matrix is growing, new columns will be uninitialized."},
{"lineNum":"  419","line":"      */"},
{"lineNum":"  420","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  421","line":"    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index cols)"},
{"lineNum":"  422","line":"    {"},
{"lineNum":"  423","line":"      // Note: see the comment in conservativeResize(Index,Index)"},
{"lineNum":"  424","line":"      conservativeResize(rows(), cols);"},
{"lineNum":"  425","line":"    }"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"    /** Resizes the vector to \\a size while retaining old values."},
{"lineNum":"  428","line":"      *"},
{"lineNum":"  429","line":"      * \\only_for_vectors. This method does not work for"},
{"lineNum":"  430","line":"      * partially dynamic matrices when the static dimension is anything other"},
{"lineNum":"  431","line":"      * than 1. For example it will not work with Matrix<double, 2, Dynamic>."},
{"lineNum":"  432","line":"      *"},
{"lineNum":"  433","line":"      * When values are appended, they will be uninitialized."},
{"lineNum":"  434","line":"      */"},
{"lineNum":"  435","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  436","line":"    EIGEN_STRONG_INLINE void conservativeResize(Index size)"},
{"lineNum":"  437","line":"    {"},
{"lineNum":"  438","line":"      internal::conservative_resize_like_impl<Derived>::run(*this, size);"},
{"lineNum":"  439","line":"    }"},
{"lineNum":"  440","line":""},
{"lineNum":"  441","line":"    /** Resizes the matrix to \\a rows x \\a cols of \\c other, while leaving old values untouched."},
{"lineNum":"  442","line":"      *"},
{"lineNum":"  443","line":"      * The method is intended for matrices of dynamic size. If you only want to change the number"},
{"lineNum":"  444","line":"      * of rows and/or of columns, you can use conservativeResize(NoChange_t, Index) or"},
{"lineNum":"  445","line":"      * conservativeResize(Index, NoChange_t)."},
{"lineNum":"  446","line":"      *"},
{"lineNum":"  447","line":"      * Matrices are resized relative to the top-left element. In case values need to be"},
{"lineNum":"  448","line":"      * appended to the matrix they will copied from \\c other."},
{"lineNum":"  449","line":"      */"},
{"lineNum":"  450","line":"    template<typename OtherDerived>"},
{"lineNum":"  451","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  452","line":"    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)"},
{"lineNum":"  453","line":"    {"},
{"lineNum":"  454","line":"      internal::conservative_resize_like_impl<Derived,OtherDerived>::run(*this, other);"},
{"lineNum":"  455","line":"    }"},
{"lineNum":"  456","line":""},
{"lineNum":"  457","line":"    /** This is a special case of the templated operator=. Its purpose is to"},
{"lineNum":"  458","line":"      * prevent a default operator= from hiding the templated operator=."},
{"lineNum":"  459","line":"      */"},
{"lineNum":"  460","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  461","line":"    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)"},
{"lineNum":"  462","line":"    {"},
{"lineNum":"  463","line":"      return _set(other);"},
{"lineNum":"  464","line":"    }"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"    /** \\sa MatrixBase::lazyAssign() */"},
{"lineNum":"  467","line":"    template<typename OtherDerived>"},
{"lineNum":"  468","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  469","line":"    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)"},
{"lineNum":"  470","line":"    {"},
{"lineNum":"  471","line":"      _resize_to_match(other);"},
{"lineNum":"  472","line":"      return Base::lazyAssign(other.derived());"},
{"lineNum":"  473","line":"    }"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"    template<typename OtherDerived>"},
{"lineNum":"  476","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  477","line":"    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)"},
{"lineNum":"  478","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  479","line":"      resize(func.rows(), func.cols());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  480","line":"      return Base::operator=(func);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  481","line":"    }"},
{"lineNum":"  482","line":""},
{"lineNum":"  483","line":"    // Prevent user from trying to instantiate PlainObjectBase objects"},
{"lineNum":"  484","line":"    // by making all its constructor protected. See bug 1074."},
{"lineNum":"  485","line":"  protected:"},
{"lineNum":"  486","line":""},
{"lineNum":"  487","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  488","line":"    EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()"},
{"lineNum":"  489","line":"    {"},
{"lineNum":"  490","line":"//       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED"},
{"lineNum":"  491","line":"    }"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"#ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  494","line":"    // FIXME is it still needed ?"},
{"lineNum":"  495","line":"    /** \\internal */"},
{"lineNum":"  496","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  497","line":"    explicit PlainObjectBase(internal::constructor_without_unaligned_array_assert)"},
{"lineNum":"  498","line":"      : m_storage(internal::constructor_without_unaligned_array_assert())"},
{"lineNum":"  499","line":"    {"},
{"lineNum":"  500","line":"      // EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED"},
{"lineNum":"  501","line":"    }"},
{"lineNum":"  502","line":"#endif"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"#if EIGEN_HAS_RVALUE_REFERENCES"},
{"lineNum":"  505","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  506","line":"    PlainObjectBase(PlainObjectBase&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  507","line":"      : m_storage( std::move(other.m_storage) )"},
{"lineNum":"  508","line":"    {"},
{"lineNum":"  509","line":"    }"},
{"lineNum":"  510","line":""},
{"lineNum":"  511","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  512","line":"    PlainObjectBase& operator=(PlainObjectBase&& other) EIGEN_NOEXCEPT"},
{"lineNum":"  513","line":"    {"},
{"lineNum":"  514","line":"      m_storage = std::move(other.m_storage);"},
{"lineNum":"  515","line":"      return *this;"},
{"lineNum":"  516","line":"    }"},
{"lineNum":"  517","line":"#endif"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"    /** Copy constructor */"},
{"lineNum":"  520","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  521","line":"    EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)"},
{"lineNum":"  522","line":"      : Base(), m_storage(other.m_storage) { }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  523","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  524","line":"    EIGEN_STRONG_INLINE PlainObjectBase(Index size, Index rows, Index cols)"},
{"lineNum":"  525","line":"      : m_storage(size, rows, cols)"},
{"lineNum":"  526","line":"    {"},
{"lineNum":"  527","line":"//       EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED"},
{"lineNum":"  528","line":"    }"},
{"lineNum":"  529","line":""},
{"lineNum":"  530","line":"    #if EIGEN_HAS_CXX11"},
{"lineNum":"  531","line":"    /** \\brief Construct a row of column vector with fixed size from an arbitrary number of coefficients. \\cpp11"},
{"lineNum":"  532","line":"      *"},
{"lineNum":"  533","line":"      * \\only_for_vectors"},
{"lineNum":"  534","line":"      *"},
{"lineNum":"  535","line":"      * This constructor is for 1D array or vectors with more than 4 coefficients."},
{"lineNum":"  536","line":"      * There exists C++98 analogue constructors for fixed-size array/vector having 1, 2, 3, or 4 coefficients."},
{"lineNum":"  537","line":"      *"},
{"lineNum":"  538","line":"      * \\warning To construct a column (resp. row) vector of fixed length, the number of values passed to this"},
{"lineNum":"  539","line":"      * constructor must match the the fixed number of rows (resp. columns) of \\c *this."},
{"lineNum":"  540","line":"      */"},
{"lineNum":"  541","line":"    template <typename... ArgTypes>"},
{"lineNum":"  542","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  543","line":"    PlainObjectBase(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const ArgTypes&... args)"},
{"lineNum":"  544","line":"      : m_storage()"},
{"lineNum":"  545","line":"    {"},
{"lineNum":"  546","line":"      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, sizeof...(args) + 4);"},
{"lineNum":"  547","line":"      m_storage.data()[0] = a0;"},
{"lineNum":"  548","line":"      m_storage.data()[1] = a1;"},
{"lineNum":"  549","line":"      m_storage.data()[2] = a2;"},
{"lineNum":"  550","line":"      m_storage.data()[3] = a3;"},
{"lineNum":"  551","line":"      Index i = 4;"},
{"lineNum":"  552","line":"      auto x = {(m_storage.data()[i++] = args, 0)...};"},
{"lineNum":"  553","line":"      static_cast<void>(x);"},
{"lineNum":"  554","line":"    }"},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"    /** \\brief Constructs a Matrix or Array and initializes it by elements given by an initializer list of initializer"},
{"lineNum":"  557","line":"      * lists \\cpp11"},
{"lineNum":"  558","line":"      */"},
{"lineNum":"  559","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  560","line":"    explicit EIGEN_STRONG_INLINE PlainObjectBase(const std::initializer_list<std::initializer_list<Scalar>>& list)"},
{"lineNum":"  561","line":"      : m_storage()"},
{"lineNum":"  562","line":"    {"},
{"lineNum":"  563","line":"      size_t list_size = 0;"},
{"lineNum":"  564","line":"      if (list.begin() != list.end()) {"},
{"lineNum":"  565","line":"        list_size = list.begin()->size();"},
{"lineNum":"  566","line":"      }"},
{"lineNum":"  567","line":""},
{"lineNum":"  568","line":"      // This is to allow syntax like VectorXi {{1, 2, 3, 4}}"},
{"lineNum":"  569","line":"      if (ColsAtCompileTime == 1 && list.size() == 1) {"},
{"lineNum":"  570","line":"        eigen_assert(list_size == static_cast<size_t>(RowsAtCompileTime) || RowsAtCompileTime == Dynamic);"},
{"lineNum":"  571","line":"        resize(list_size, ColsAtCompileTime);"},
{"lineNum":"  572","line":"        std::copy(list.begin()->begin(), list.begin()->end(), m_storage.data());"},
{"lineNum":"  573","line":"      } else {"},
{"lineNum":"  574","line":"        eigen_assert(list.size() == static_cast<size_t>(RowsAtCompileTime) || RowsAtCompileTime == Dynamic);"},
{"lineNum":"  575","line":"        eigen_assert(list_size == static_cast<size_t>(ColsAtCompileTime) || ColsAtCompileTime == Dynamic);"},
{"lineNum":"  576","line":"        resize(list.size(), list_size);"},
{"lineNum":"  577","line":""},
{"lineNum":"  578","line":"        Index row_index = 0;"},
{"lineNum":"  579","line":"        for (const std::initializer_list<Scalar>& row : list) {"},
{"lineNum":"  580","line":"          eigen_assert(list_size == row.size());"},
{"lineNum":"  581","line":"          Index col_index = 0;"},
{"lineNum":"  582","line":"          for (const Scalar& e : row) {"},
{"lineNum":"  583","line":"            coeffRef(row_index, col_index) = e;"},
{"lineNum":"  584","line":"            ++col_index;"},
{"lineNum":"  585","line":"          }"},
{"lineNum":"  586","line":"          ++row_index;"},
{"lineNum":"  587","line":"        }"},
{"lineNum":"  588","line":"      }"},
{"lineNum":"  589","line":"    }"},
{"lineNum":"  590","line":"    #endif  // end EIGEN_HAS_CXX11"},
{"lineNum":"  591","line":""},
{"lineNum":"  592","line":"    /** \\sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */"},
{"lineNum":"  593","line":"    template<typename OtherDerived>"},
{"lineNum":"  594","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  595","line":"    EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)"},
{"lineNum":"  596","line":"      : m_storage()"},
{"lineNum":"  597","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  598","line":"      resizeLike(other);"},
{"lineNum":"  599","line":"      _set_noalias(other);"},
{"lineNum":"  600","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"    /** \\sa PlainObjectBase::operator=(const EigenBase<OtherDerived>&) */"},
{"lineNum":"  603","line":"    template<typename OtherDerived>"},
{"lineNum":"  604","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  605","line":"    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)"},
{"lineNum":"  606","line":"      : m_storage()"},
{"lineNum":"  607","line":"    {"},
{"lineNum":"  608","line":"      resizeLike(other);"},
{"lineNum":"  609","line":"      *this = other.derived();"},
{"lineNum":"  610","line":"    }"},
{"lineNum":"  611","line":"    /** \\brief Copy constructor with in-place evaluation */"},
{"lineNum":"  612","line":"    template<typename OtherDerived>"},
{"lineNum":"  613","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  614","line":"    EIGEN_STRONG_INLINE PlainObjectBase(const ReturnByValue<OtherDerived>& other)"},
{"lineNum":"  615","line":"    {"},
{"lineNum":"  616","line":"      // FIXME this does not automatically transpose vectors if necessary"},
{"lineNum":"  617","line":"      resize(other.rows(), other.cols());"},
{"lineNum":"  618","line":"      other.evalTo(this->derived());"},
{"lineNum":"  619","line":"    }"},
{"lineNum":"  620","line":""},
{"lineNum":"  621","line":"  public:"},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"    /** \\brief Copies the generic expression \\a other into *this."},
{"lineNum":"  624","line":"      * \\copydetails DenseBase::operator=(const EigenBase<OtherDerived> &other)"},
{"lineNum":"  625","line":"      */"},
{"lineNum":"  626","line":"    template<typename OtherDerived>"},
{"lineNum":"  627","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  628","line":"    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)"},
{"lineNum":"  629","line":"    {"},
{"lineNum":"  630","line":"      _resize_to_match(other);"},
{"lineNum":"  631","line":"      Base::operator=(other.derived());"},
{"lineNum":"  632","line":"      return this->derived();"},
{"lineNum":"  633","line":"    }"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"    /** \\name Map"},
{"lineNum":"  636","line":"      * These are convenience functions returning Map objects. The Map() static functions return unaligned Map objects,"},
{"lineNum":"  637","line":"      * while the AlignedMap() functions return aligned Map objects and thus should be called only with 16-byte-aligned"},
{"lineNum":"  638","line":"      * \\a data pointers."},
{"lineNum":"  639","line":"      *"},
{"lineNum":"  640","line":"      * Here is an example using strides:"},
{"lineNum":"  641","line":"      * \\include Matrix_Map_stride.cpp"},
{"lineNum":"  642","line":"      * Output: \\verbinclude Matrix_Map_stride.out"},
{"lineNum":"  643","line":"      *"},
{"lineNum":"  644","line":"      * \\see class Map"},
{"lineNum":"  645","line":"      */"},
{"lineNum":"  646","line":"    //@{"},
{"lineNum":"  647","line":"    static inline ConstMapType Map(const Scalar* data)"},
{"lineNum":"  648","line":"    { return ConstMapType(data); }"},
{"lineNum":"  649","line":"    static inline MapType Map(Scalar* data)"},
{"lineNum":"  650","line":"    { return MapType(data); }"},
{"lineNum":"  651","line":"    static inline ConstMapType Map(const Scalar* data, Index size)"},
{"lineNum":"  652","line":"    { return ConstMapType(data, size); }"},
{"lineNum":"  653","line":"    static inline MapType Map(Scalar* data, Index size)"},
{"lineNum":"  654","line":"    { return MapType(data, size); }"},
{"lineNum":"  655","line":"    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)"},
{"lineNum":"  656","line":"    { return ConstMapType(data, rows, cols); }"},
{"lineNum":"  657","line":"    static inline MapType Map(Scalar* data, Index rows, Index cols)"},
{"lineNum":"  658","line":"    { return MapType(data, rows, cols); }"},
{"lineNum":"  659","line":""},
{"lineNum":"  660","line":"    static inline ConstAlignedMapType MapAligned(const Scalar* data)"},
{"lineNum":"  661","line":"    { return ConstAlignedMapType(data); }"},
{"lineNum":"  662","line":"    static inline AlignedMapType MapAligned(Scalar* data)"},
{"lineNum":"  663","line":"    { return AlignedMapType(data); }"},
{"lineNum":"  664","line":"    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)"},
{"lineNum":"  665","line":"    { return ConstAlignedMapType(data, size); }"},
{"lineNum":"  666","line":"    static inline AlignedMapType MapAligned(Scalar* data, Index size)"},
{"lineNum":"  667","line":"    { return AlignedMapType(data, size); }"},
{"lineNum":"  668","line":"    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)"},
{"lineNum":"  669","line":"    { return ConstAlignedMapType(data, rows, cols); }"},
{"lineNum":"  670","line":"    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)"},
{"lineNum":"  671","line":"    { return AlignedMapType(data, rows, cols); }"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"    template<int Outer, int Inner>"},
{"lineNum":"  674","line":"    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  675","line":"    { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, stride); }"},
{"lineNum":"  676","line":"    template<int Outer, int Inner>"},
{"lineNum":"  677","line":"    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  678","line":"    { return typename StridedMapType<Stride<Outer, Inner> >::type(data, stride); }"},
{"lineNum":"  679","line":"    template<int Outer, int Inner>"},
{"lineNum":"  680","line":"    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  681","line":"    { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, size, stride); }"},
{"lineNum":"  682","line":"    template<int Outer, int Inner>"},
{"lineNum":"  683","line":"    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  684","line":"    { return typename StridedMapType<Stride<Outer, Inner> >::type(data, size, stride); }"},
{"lineNum":"  685","line":"    template<int Outer, int Inner>"},
{"lineNum":"  686","line":"    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  687","line":"    { return typename StridedConstMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }"},
{"lineNum":"  688","line":"    template<int Outer, int Inner>"},
{"lineNum":"  689","line":"    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  690","line":"    { return typename StridedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"    template<int Outer, int Inner>"},
{"lineNum":"  693","line":"    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  694","line":"    { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, stride); }"},
{"lineNum":"  695","line":"    template<int Outer, int Inner>"},
{"lineNum":"  696","line":"    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  697","line":"    { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, stride); }"},
{"lineNum":"  698","line":"    template<int Outer, int Inner>"},
{"lineNum":"  699","line":"    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  700","line":"    { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, size, stride); }"},
{"lineNum":"  701","line":"    template<int Outer, int Inner>"},
{"lineNum":"  702","line":"    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  703","line":"    { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, size, stride); }"},
{"lineNum":"  704","line":"    template<int Outer, int Inner>"},
{"lineNum":"  705","line":"    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  706","line":"    { return typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }"},
{"lineNum":"  707","line":"    template<int Outer, int Inner>"},
{"lineNum":"  708","line":"    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)"},
{"lineNum":"  709","line":"    { return typename StridedAlignedMapType<Stride<Outer, Inner> >::type(data, rows, cols, stride); }"},
{"lineNum":"  710","line":"    //@}"},
{"lineNum":"  711","line":""},
{"lineNum":"  712","line":"    using Base::setConstant;"},
{"lineNum":"  713","line":"    EIGEN_DEVICE_FUNC Derived& setConstant(Index size, const Scalar& val);"},
{"lineNum":"  714","line":"    EIGEN_DEVICE_FUNC Derived& setConstant(Index rows, Index cols, const Scalar& val);"},
{"lineNum":"  715","line":"    EIGEN_DEVICE_FUNC Derived& setConstant(NoChange_t, Index cols, const Scalar& val);"},
{"lineNum":"  716","line":"    EIGEN_DEVICE_FUNC Derived& setConstant(Index rows, NoChange_t, const Scalar& val);"},
{"lineNum":"  717","line":""},
{"lineNum":"  718","line":"    using Base::setZero;"},
{"lineNum":"  719","line":"    EIGEN_DEVICE_FUNC Derived& setZero(Index size);"},
{"lineNum":"  720","line":"    EIGEN_DEVICE_FUNC Derived& setZero(Index rows, Index cols);"},
{"lineNum":"  721","line":"    EIGEN_DEVICE_FUNC Derived& setZero(NoChange_t, Index cols);"},
{"lineNum":"  722","line":"    EIGEN_DEVICE_FUNC Derived& setZero(Index rows, NoChange_t);"},
{"lineNum":"  723","line":""},
{"lineNum":"  724","line":"    using Base::setOnes;"},
{"lineNum":"  725","line":"    EIGEN_DEVICE_FUNC Derived& setOnes(Index size);"},
{"lineNum":"  726","line":"    EIGEN_DEVICE_FUNC Derived& setOnes(Index rows, Index cols);"},
{"lineNum":"  727","line":"    EIGEN_DEVICE_FUNC Derived& setOnes(NoChange_t, Index cols);"},
{"lineNum":"  728","line":"    EIGEN_DEVICE_FUNC Derived& setOnes(Index rows, NoChange_t);"},
{"lineNum":"  729","line":""},
{"lineNum":"  730","line":"    using Base::setRandom;"},
{"lineNum":"  731","line":"    Derived& setRandom(Index size);"},
{"lineNum":"  732","line":"    Derived& setRandom(Index rows, Index cols);"},
{"lineNum":"  733","line":"    Derived& setRandom(NoChange_t, Index cols);"},
{"lineNum":"  734","line":"    Derived& setRandom(Index rows, NoChange_t);"},
{"lineNum":"  735","line":""},
{"lineNum":"  736","line":"    #ifdef EIGEN_PLAINOBJECTBASE_PLUGIN"},
{"lineNum":"  737","line":"    #include EIGEN_PLAINOBJECTBASE_PLUGIN"},
{"lineNum":"  738","line":"    #endif"},
{"lineNum":"  739","line":""},
{"lineNum":"  740","line":"  protected:"},
{"lineNum":"  741","line":"    /** \\internal Resizes *this in preparation for assigning \\a other to it."},
{"lineNum":"  742","line":"      * Takes care of doing all the checking that\'s needed."},
{"lineNum":"  743","line":"      *"},
{"lineNum":"  744","line":"      * Note that copying a row-vector into a vector (and conversely) is allowed."},
{"lineNum":"  745","line":"      * The resizing, if any, is then done in the appropriate way so that row-vectors"},
{"lineNum":"  746","line":"      * remain row-vectors and vectors remain vectors."},
{"lineNum":"  747","line":"      */"},
{"lineNum":"  748","line":"    template<typename OtherDerived>"},
{"lineNum":"  749","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  750","line":"    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)"},
{"lineNum":"  751","line":"    {"},
{"lineNum":"  752","line":"      #ifdef EIGEN_NO_AUTOMATIC_RESIZING"},
{"lineNum":"  753","line":"      eigen_assert((this->size()==0 || (IsVectorAtCompileTime ? (this->size() == other.size())"},
{"lineNum":"  754","line":"                 : (rows() == other.rows() && cols() == other.cols())))"},
{"lineNum":"  755","line":"        && \"Size mismatch. Automatic resizing is disabled because EIGEN_NO_AUTOMATIC_RESIZING is defined\");"},
{"lineNum":"  756","line":"      EIGEN_ONLY_USED_FOR_DEBUG(other);"},
{"lineNum":"  757","line":"      #else"},
{"lineNum":"  758","line":"      resizeLike(other);"},
{"lineNum":"  759","line":"      #endif"},
{"lineNum":"  760","line":"    }"},
{"lineNum":"  761","line":""},
{"lineNum":"  762","line":"    /**"},
{"lineNum":"  763","line":"      * \\brief Copies the value of the expression \\a other into \\c *this with automatic resizing."},
{"lineNum":"  764","line":"      *"},
{"lineNum":"  765","line":"      * *this might be resized to match the dimensions of \\a other. If *this was a null matrix (not already initialized),"},
{"lineNum":"  766","line":"      * it will be initialized."},
{"lineNum":"  767","line":"      *"},
{"lineNum":"  768","line":"      * Note that copying a row-vector into a vector (and conversely) is allowed."},
{"lineNum":"  769","line":"      * The resizing, if any, is then done in the appropriate way so that row-vectors"},
{"lineNum":"  770","line":"      * remain row-vectors and vectors remain vectors."},
{"lineNum":"  771","line":"      *"},
{"lineNum":"  772","line":"      * \\sa operator=(const MatrixBase<OtherDerived>&), _set_noalias()"},
{"lineNum":"  773","line":"      *"},
{"lineNum":"  774","line":"      * \\internal"},
{"lineNum":"  775","line":"      */"},
{"lineNum":"  776","line":"    // aliasing is dealt once in internal::call_assignment"},
{"lineNum":"  777","line":"    // so at this stage we have to assume aliasing... and resising has to be done later."},
{"lineNum":"  778","line":"    template<typename OtherDerived>"},
{"lineNum":"  779","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  780","line":"    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)"},
{"lineNum":"  781","line":"    {"},
{"lineNum":"  782","line":"      internal::call_assignment(this->derived(), other.derived());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  783","line":"      return this->derived();"},
{"lineNum":"  784","line":"    }"},
{"lineNum":"  785","line":""},
{"lineNum":"  786","line":"    /** \\internal Like _set() but additionally makes the assumption that no aliasing effect can happen (which"},
{"lineNum":"  787","line":"      * is the case when creating a new matrix) so one can enforce lazy evaluation."},
{"lineNum":"  788","line":"      *"},
{"lineNum":"  789","line":"      * \\sa operator=(const MatrixBase<OtherDerived>&), _set()"},
{"lineNum":"  790","line":"      */"},
{"lineNum":"  791","line":"    template<typename OtherDerived>"},
{"lineNum":"  792","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  793","line":"    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)"},
{"lineNum":"  794","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  795","line":"      // I don\'t think we need this resize call since the lazyAssign will anyways resize"},
{"lineNum":"  796","line":"      // and lazyAssign will be called by the assign selector."},
{"lineNum":"  797","line":"      //_resize_to_match(other);"},
{"lineNum":"  798","line":"      // the \'false\' below means to enforce lazy evaluation. We don\'t use lazyAssign() because"},
{"lineNum":"  799","line":"      // it wouldn\'t allow to copy a row-vector into a column-vector."},
{"lineNum":"  800","line":"      internal::call_assignment_no_alias(this->derived(), other.derived(), internal::assign_op<Scalar,typename OtherDerived::Scalar>());"},
{"lineNum":"  801","line":"      return this->derived();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  802","line":"    }"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"    template<typename T0, typename T1>"},
{"lineNum":"  805","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  806","line":"    EIGEN_STRONG_INLINE void _init2(Index rows, Index cols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)"},
{"lineNum":"  807","line":"    {"},
{"lineNum":"  808","line":"      const bool t0_is_integer_alike = internal::is_valid_index_type<T0>::value;"},
{"lineNum":"  809","line":"      const bool t1_is_integer_alike = internal::is_valid_index_type<T1>::value;"},
{"lineNum":"  810","line":"      EIGEN_STATIC_ASSERT(t0_is_integer_alike &&"},
{"lineNum":"  811","line":"                          t1_is_integer_alike,"},
{"lineNum":"  812","line":"                          FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)"},
{"lineNum":"  813","line":"      resize(rows,cols);","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  814","line":"    }"},
{"lineNum":"  815","line":""},
{"lineNum":"  816","line":"    template<typename T0, typename T1>"},
{"lineNum":"  817","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  818","line":"    EIGEN_STRONG_INLINE void _init2(const T0& val0, const T1& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)"},
{"lineNum":"  819","line":"    {"},
{"lineNum":"  820","line":"      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2)"},
{"lineNum":"  821","line":"      m_storage.data()[0] = Scalar(val0);"},
{"lineNum":"  822","line":"      m_storage.data()[1] = Scalar(val1);"},
{"lineNum":"  823","line":"    }"},
{"lineNum":"  824","line":""},
{"lineNum":"  825","line":"    template<typename T0, typename T1>"},
{"lineNum":"  826","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  827","line":"    EIGEN_STRONG_INLINE void _init2(const Index& val0, const Index& val1,"},
{"lineNum":"  828","line":"                                    typename internal::enable_if<    (!internal::is_same<Index,Scalar>::value)"},
{"lineNum":"  829","line":"                                                                  && (internal::is_same<T0,Index>::value)"},
{"lineNum":"  830","line":"                                                                  && (internal::is_same<T1,Index>::value)"},
{"lineNum":"  831","line":"                                                                  && Base::SizeAtCompileTime==2,T1>::type* = 0)"},
{"lineNum":"  832","line":"    {"},
{"lineNum":"  833","line":"      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 2)"},
{"lineNum":"  834","line":"      m_storage.data()[0] = Scalar(val0);"},
{"lineNum":"  835","line":"      m_storage.data()[1] = Scalar(val1);"},
{"lineNum":"  836","line":"    }"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"    // The argument is convertible to the Index type and we either have a non 1x1 Matrix, or a dynamic-sized Array,"},
{"lineNum":"  839","line":"    // then the argument is meant to be the size of the object."},
{"lineNum":"  840","line":"    template<typename T>"},
{"lineNum":"  841","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  842","line":"    EIGEN_STRONG_INLINE void _init1(Index size, typename internal::enable_if<    (Base::SizeAtCompileTime!=1 || !internal::is_convertible<T, Scalar>::value)"},
{"lineNum":"  843","line":"                                                                              && ((!internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value || Base::SizeAtCompileTime==Dynamic)),T>::type* = 0)"},
{"lineNum":"  844","line":"    {"},
{"lineNum":"  845","line":"      // NOTE MSVC 2008 complains if we directly put bool(NumTraits<T>::IsInteger) as the EIGEN_STATIC_ASSERT argument."},
{"lineNum":"  846","line":"      const bool is_integer_alike = internal::is_valid_index_type<T>::value;"},
{"lineNum":"  847","line":"      EIGEN_UNUSED_VARIABLE(is_integer_alike);"},
{"lineNum":"  848","line":"      EIGEN_STATIC_ASSERT(is_integer_alike,"},
{"lineNum":"  849","line":"                          FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED)"},
{"lineNum":"  850","line":"      resize(size);","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  851","line":"    }"},
{"lineNum":"  852","line":""},
{"lineNum":"  853","line":"    // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coefficient (case where scalar type can be implicitly converted)"},
{"lineNum":"  854","line":"    template<typename T>"},
{"lineNum":"  855","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  856","line":"    EIGEN_STRONG_INLINE void _init1(const Scalar& val0, typename internal::enable_if<Base::SizeAtCompileTime==1 && internal::is_convertible<T, Scalar>::value,T>::type* = 0)"},
{"lineNum":"  857","line":"    {"},
{"lineNum":"  858","line":"      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1)"},
{"lineNum":"  859","line":"      m_storage.data()[0] = val0;"},
{"lineNum":"  860","line":"    }"},
{"lineNum":"  861","line":""},
{"lineNum":"  862","line":"    // We have a 1x1 matrix/array => the argument is interpreted as the value of the unique coefficient (case where scalar type match the index type)"},
{"lineNum":"  863","line":"    template<typename T>"},
{"lineNum":"  864","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  865","line":"    EIGEN_STRONG_INLINE void _init1(const Index& val0,"},
{"lineNum":"  866","line":"                                    typename internal::enable_if<    (!internal::is_same<Index,Scalar>::value)"},
{"lineNum":"  867","line":"                                                                  && (internal::is_same<Index,T>::value)"},
{"lineNum":"  868","line":"                                                                  && Base::SizeAtCompileTime==1"},
{"lineNum":"  869","line":"                                                                  && internal::is_convertible<T, Scalar>::value,T*>::type* = 0)"},
{"lineNum":"  870","line":"    {"},
{"lineNum":"  871","line":"      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(PlainObjectBase, 1)"},
{"lineNum":"  872","line":"      m_storage.data()[0] = Scalar(val0);"},
{"lineNum":"  873","line":"    }"},
{"lineNum":"  874","line":""},
{"lineNum":"  875","line":"    // Initialize a fixed size matrix from a pointer to raw data"},
{"lineNum":"  876","line":"    template<typename T>"},
{"lineNum":"  877","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  878","line":"    EIGEN_STRONG_INLINE void _init1(const Scalar* data){"},
{"lineNum":"  879","line":"      this->_set_noalias(ConstMapType(data));"},
{"lineNum":"  880","line":"    }"},
{"lineNum":"  881","line":""},
{"lineNum":"  882","line":"    // Initialize an arbitrary matrix from a dense expression"},
{"lineNum":"  883","line":"    template<typename T, typename OtherDerived>"},
{"lineNum":"  884","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  885","line":"    EIGEN_STRONG_INLINE void _init1(const DenseBase<OtherDerived>& other){"},
{"lineNum":"  886","line":"      this->_set_noalias(other);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  887","line":"    }"},
{"lineNum":"  888","line":""},
{"lineNum":"  889","line":"    // Initialize an arbitrary matrix from an object convertible to the Derived type."},
{"lineNum":"  890","line":"    template<typename T>"},
{"lineNum":"  891","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  892","line":"    EIGEN_STRONG_INLINE void _init1(const Derived& other){"},
{"lineNum":"  893","line":"      this->_set_noalias(other);"},
{"lineNum":"  894","line":"    }"},
{"lineNum":"  895","line":""},
{"lineNum":"  896","line":"    // Initialize an arbitrary matrix from a generic Eigen expression"},
{"lineNum":"  897","line":"    template<typename T, typename OtherDerived>"},
{"lineNum":"  898","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  899","line":"    EIGEN_STRONG_INLINE void _init1(const EigenBase<OtherDerived>& other){"},
{"lineNum":"  900","line":"      this->derived() = other;"},
{"lineNum":"  901","line":"    }"},
{"lineNum":"  902","line":""},
{"lineNum":"  903","line":"    template<typename T, typename OtherDerived>"},
{"lineNum":"  904","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  905","line":"    EIGEN_STRONG_INLINE void _init1(const ReturnByValue<OtherDerived>& other)"},
{"lineNum":"  906","line":"    {"},
{"lineNum":"  907","line":"      resize(other.rows(), other.cols());"},
{"lineNum":"  908","line":"      other.evalTo(this->derived());"},
{"lineNum":"  909","line":"    }"},
{"lineNum":"  910","line":""},
{"lineNum":"  911","line":"    template<typename T, typename OtherDerived, int ColsAtCompileTime>"},
{"lineNum":"  912","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  913","line":"    EIGEN_STRONG_INLINE void _init1(const RotationBase<OtherDerived,ColsAtCompileTime>& r)"},
{"lineNum":"  914","line":"    {"},
{"lineNum":"  915","line":"      this->derived() = r;"},
{"lineNum":"  916","line":"    }"},
{"lineNum":"  917","line":""},
{"lineNum":"  918","line":"    // For fixed-size Array<Scalar,...>"},
{"lineNum":"  919","line":"    template<typename T>"},
{"lineNum":"  920","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  921","line":"    EIGEN_STRONG_INLINE void _init1(const Scalar& val0,"},
{"lineNum":"  922","line":"                                    typename internal::enable_if<    Base::SizeAtCompileTime!=Dynamic"},
{"lineNum":"  923","line":"                                                                  && Base::SizeAtCompileTime!=1"},
{"lineNum":"  924","line":"                                                                  && internal::is_convertible<T, Scalar>::value"},
{"lineNum":"  925","line":"                                                                  && internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value,T>::type* = 0)"},
{"lineNum":"  926","line":"    {"},
{"lineNum":"  927","line":"      Base::setConstant(val0);"},
{"lineNum":"  928","line":"    }"},
{"lineNum":"  929","line":""},
{"lineNum":"  930","line":"    // For fixed-size Array<Index,...>"},
{"lineNum":"  931","line":"    template<typename T>"},
{"lineNum":"  932","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  933","line":"    EIGEN_STRONG_INLINE void _init1(const Index& val0,"},
{"lineNum":"  934","line":"                                    typename internal::enable_if<    (!internal::is_same<Index,Scalar>::value)"},
{"lineNum":"  935","line":"                                                                  && (internal::is_same<Index,T>::value)"},
{"lineNum":"  936","line":"                                                                  && Base::SizeAtCompileTime!=Dynamic"},
{"lineNum":"  937","line":"                                                                  && Base::SizeAtCompileTime!=1"},
{"lineNum":"  938","line":"                                                                  && internal::is_convertible<T, Scalar>::value"},
{"lineNum":"  939","line":"                                                                  && internal::is_same<typename internal::traits<Derived>::XprKind,ArrayXpr>::value,T*>::type* = 0)"},
{"lineNum":"  940","line":"    {"},
{"lineNum":"  941","line":"      Base::setConstant(val0);"},
{"lineNum":"  942","line":"    }"},
{"lineNum":"  943","line":""},
{"lineNum":"  944","line":"    template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>"},
{"lineNum":"  945","line":"    friend struct internal::matrix_swap_impl;"},
{"lineNum":"  946","line":""},
{"lineNum":"  947","line":"  public:"},
{"lineNum":"  948","line":""},
{"lineNum":"  949","line":"#ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  950","line":"    /** \\internal"},
{"lineNum":"  951","line":"      * \\brief Override DenseBase::swap() since for dynamic-sized matrices"},
{"lineNum":"  952","line":"      * of same type it is enough to swap the data pointers."},
{"lineNum":"  953","line":"      */"},
{"lineNum":"  954","line":"    template<typename OtherDerived>"},
{"lineNum":"  955","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  956","line":"    void swap(DenseBase<OtherDerived> & other)"},
{"lineNum":"  957","line":"    {"},
{"lineNum":"  958","line":"      enum { SwapPointers = internal::is_same<Derived, OtherDerived>::value && Base::SizeAtCompileTime==Dynamic };"},
{"lineNum":"  959","line":"      internal::matrix_swap_impl<Derived, OtherDerived, bool(SwapPointers)>::run(this->derived(), other.derived());"},
{"lineNum":"  960","line":"    }"},
{"lineNum":"  961","line":""},
{"lineNum":"  962","line":"    /** \\internal"},
{"lineNum":"  963","line":"      * \\brief const version forwarded to DenseBase::swap"},
{"lineNum":"  964","line":"      */"},
{"lineNum":"  965","line":"    template<typename OtherDerived>"},
{"lineNum":"  966","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  967","line":"    void swap(DenseBase<OtherDerived> const & other)"},
{"lineNum":"  968","line":"    { Base::swap(other.derived()); }"},
{"lineNum":"  969","line":""},
{"lineNum":"  970","line":"    enum { IsPlainObjectBase = 1 };"},
{"lineNum":"  971","line":"#endif"},
{"lineNum":"  972","line":"  public:"},
{"lineNum":"  973","line":"    // These apparently need to be down here for nvcc+icc to prevent duplicate"},
{"lineNum":"  974","line":"    // Map symbol."},
{"lineNum":"  975","line":"    template<typename PlainObjectType, int MapOptions, typename StrideType> friend class Eigen::Map;"},
{"lineNum":"  976","line":"    friend class Eigen::Map<Derived, Unaligned>;"},
{"lineNum":"  977","line":"    friend class Eigen::Map<const Derived, Unaligned>;"},
{"lineNum":"  978","line":"#if EIGEN_MAX_ALIGN_BYTES>0"},
{"lineNum":"  979","line":"    // for EIGEN_MAX_ALIGN_BYTES==0, AlignedMax==Unaligned, and many compilers generate warnings for friend-ing a class twice."},
{"lineNum":"  980","line":"    friend class Eigen::Map<Derived, AlignedMax>;"},
{"lineNum":"  981","line":"    friend class Eigen::Map<const Derived, AlignedMax>;"},
{"lineNum":"  982","line":"#endif"},
{"lineNum":"  983","line":"};"},
{"lineNum":"  984","line":""},
{"lineNum":"  985","line":"namespace internal {"},
{"lineNum":"  986","line":""},
{"lineNum":"  987","line":"template <typename Derived, typename OtherDerived, bool IsVector>"},
{"lineNum":"  988","line":"struct conservative_resize_like_impl"},
{"lineNum":"  989","line":"{"},
{"lineNum":"  990","line":"  #if EIGEN_HAS_TYPE_TRAITS"},
{"lineNum":"  991","line":"  static const bool IsRelocatable = std::is_trivially_copyable<typename Derived::Scalar>::value;"},
{"lineNum":"  992","line":"  #else"},
{"lineNum":"  993","line":"  static const bool IsRelocatable = !NumTraits<typename Derived::Scalar>::RequireInitialization;"},
{"lineNum":"  994","line":"  #endif"},
{"lineNum":"  995","line":"  static void run(DenseBase<Derived>& _this, Index rows, Index cols)"},
{"lineNum":"  996","line":"  {"},
{"lineNum":"  997","line":"    if (_this.rows() == rows && _this.cols() == cols) return;"},
{"lineNum":"  998","line":"    EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(Derived)"},
{"lineNum":"  999","line":""},
{"lineNum":" 1000","line":"    if ( IsRelocatable"},
{"lineNum":" 1001","line":"          && (( Derived::IsRowMajor && _this.cols() == cols) ||  // row-major and we change only the number of rows"},
{"lineNum":" 1002","line":"              (!Derived::IsRowMajor && _this.rows() == rows) ))  // column-major and we change only the number of columns"},
{"lineNum":" 1003","line":"    {"},
{"lineNum":" 1004","line":"      internal::check_rows_cols_for_overflow<Derived::MaxSizeAtCompileTime>::run(rows, cols);"},
{"lineNum":" 1005","line":"      _this.derived().m_storage.conservativeResize(rows*cols,rows,cols);"},
{"lineNum":" 1006","line":"    }"},
{"lineNum":" 1007","line":"    else"},
{"lineNum":" 1008","line":"    {"},
{"lineNum":" 1009","line":"      // The storage order does not allow us to use reallocation."},
{"lineNum":" 1010","line":"      Derived tmp(rows,cols);"},
{"lineNum":" 1011","line":"      const Index common_rows = numext::mini(rows, _this.rows());"},
{"lineNum":" 1012","line":"      const Index common_cols = numext::mini(cols, _this.cols());"},
{"lineNum":" 1013","line":"      tmp.block(0,0,common_rows,common_cols) = _this.block(0,0,common_rows,common_cols);"},
{"lineNum":" 1014","line":"      _this.derived().swap(tmp);"},
{"lineNum":" 1015","line":"    }"},
{"lineNum":" 1016","line":"  }"},
{"lineNum":" 1017","line":""},
{"lineNum":" 1018","line":"  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)"},
{"lineNum":" 1019","line":"  {"},
{"lineNum":" 1020","line":"    if (_this.rows() == other.rows() && _this.cols() == other.cols()) return;"},
{"lineNum":" 1021","line":""},
{"lineNum":" 1022","line":"    // Note: Here is space for improvement. Basically, for conservativeResize(Index,Index),"},
{"lineNum":" 1023","line":"    // neither RowsAtCompileTime or ColsAtCompileTime must be Dynamic. If only one of the"},
{"lineNum":" 1024","line":"    // dimensions is dynamic, one could use either conservativeResize(Index rows, NoChange_t) or"},
{"lineNum":" 1025","line":"    // conservativeResize(NoChange_t, Index cols). For these methods new static asserts like"},
{"lineNum":" 1026","line":"    // EIGEN_STATIC_ASSERT_DYNAMIC_ROWS and EIGEN_STATIC_ASSERT_DYNAMIC_COLS would be good."},
{"lineNum":" 1027","line":"    EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(Derived)"},
{"lineNum":" 1028","line":"    EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(OtherDerived)"},
{"lineNum":" 1029","line":""},
{"lineNum":" 1030","line":"    if ( IsRelocatable &&"},
{"lineNum":" 1031","line":"          (( Derived::IsRowMajor && _this.cols() == other.cols()) ||  // row-major and we change only the number of rows"},
{"lineNum":" 1032","line":"           (!Derived::IsRowMajor && _this.rows() == other.rows()) ))  // column-major and we change only the number of columns"},
{"lineNum":" 1033","line":"    {"},
{"lineNum":" 1034","line":"      const Index new_rows = other.rows() - _this.rows();"},
{"lineNum":" 1035","line":"      const Index new_cols = other.cols() - _this.cols();"},
{"lineNum":" 1036","line":"      _this.derived().m_storage.conservativeResize(other.size(),other.rows(),other.cols());"},
{"lineNum":" 1037","line":"      if (new_rows>0)"},
{"lineNum":" 1038","line":"        _this.bottomRightCorner(new_rows, other.cols()) = other.bottomRows(new_rows);"},
{"lineNum":" 1039","line":"      else if (new_cols>0)"},
{"lineNum":" 1040","line":"        _this.bottomRightCorner(other.rows(), new_cols) = other.rightCols(new_cols);"},
{"lineNum":" 1041","line":"    }"},
{"lineNum":" 1042","line":"    else"},
{"lineNum":" 1043","line":"    {"},
{"lineNum":" 1044","line":"      // The storage order does not allow us to use reallocation."},
{"lineNum":" 1045","line":"      Derived tmp(other);"},
{"lineNum":" 1046","line":"      const Index common_rows = numext::mini(tmp.rows(), _this.rows());"},
{"lineNum":" 1047","line":"      const Index common_cols = numext::mini(tmp.cols(), _this.cols());"},
{"lineNum":" 1048","line":"      tmp.block(0,0,common_rows,common_cols) = _this.block(0,0,common_rows,common_cols);"},
{"lineNum":" 1049","line":"      _this.derived().swap(tmp);"},
{"lineNum":" 1050","line":"    }"},
{"lineNum":" 1051","line":"  }"},
{"lineNum":" 1052","line":"};"},
{"lineNum":" 1053","line":""},
{"lineNum":" 1054","line":"// Here, the specialization for vectors inherits from the general matrix case"},
{"lineNum":" 1055","line":"// to allow calling .conservativeResize(rows,cols) on vectors."},
{"lineNum":" 1056","line":"template <typename Derived, typename OtherDerived>"},
{"lineNum":" 1057","line":"struct conservative_resize_like_impl<Derived,OtherDerived,true>"},
{"lineNum":" 1058","line":"  : conservative_resize_like_impl<Derived,OtherDerived,false>"},
{"lineNum":" 1059","line":"{"},
{"lineNum":" 1060","line":"  typedef conservative_resize_like_impl<Derived,OtherDerived,false> Base;"},
{"lineNum":" 1061","line":"  using Base::run;"},
{"lineNum":" 1062","line":"  using Base::IsRelocatable;"},
{"lineNum":" 1063","line":""},
{"lineNum":" 1064","line":"  static void run(DenseBase<Derived>& _this, Index size)"},
{"lineNum":" 1065","line":"  {"},
{"lineNum":" 1066","line":"    const Index new_rows = Derived::RowsAtCompileTime==1 ? 1 : size;"},
{"lineNum":" 1067","line":"    const Index new_cols = Derived::RowsAtCompileTime==1 ? size : 1;"},
{"lineNum":" 1068","line":"    if(IsRelocatable)"},
{"lineNum":" 1069","line":"      _this.derived().m_storage.conservativeResize(size,new_rows,new_cols);"},
{"lineNum":" 1070","line":"    else"},
{"lineNum":" 1071","line":"      Base::run(_this.derived(), new_rows, new_cols);"},
{"lineNum":" 1072","line":"  }"},
{"lineNum":" 1073","line":""},
{"lineNum":" 1074","line":"  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)"},
{"lineNum":" 1075","line":"  {"},
{"lineNum":" 1076","line":"    if (_this.rows() == other.rows() && _this.cols() == other.cols()) return;"},
{"lineNum":" 1077","line":""},
{"lineNum":" 1078","line":"    const Index num_new_elements = other.size() - _this.size();"},
{"lineNum":" 1079","line":""},
{"lineNum":" 1080","line":"    const Index new_rows = Derived::RowsAtCompileTime==1 ? 1 : other.rows();"},
{"lineNum":" 1081","line":"    const Index new_cols = Derived::RowsAtCompileTime==1 ? other.cols() : 1;"},
{"lineNum":" 1082","line":"    if(IsRelocatable)"},
{"lineNum":" 1083","line":"      _this.derived().m_storage.conservativeResize(other.size(),new_rows,new_cols);"},
{"lineNum":" 1084","line":"    else"},
{"lineNum":" 1085","line":"      Base::run(_this.derived(), new_rows, new_cols);"},
{"lineNum":" 1086","line":""},
{"lineNum":" 1087","line":"    if (num_new_elements > 0)"},
{"lineNum":" 1088","line":"      _this.tail(num_new_elements) = other.tail(num_new_elements);"},
{"lineNum":" 1089","line":"  }"},
{"lineNum":" 1090","line":"};"},
{"lineNum":" 1091","line":""},
{"lineNum":" 1092","line":"template<typename MatrixTypeA, typename MatrixTypeB, bool SwapPointers>"},
{"lineNum":" 1093","line":"struct matrix_swap_impl"},
{"lineNum":" 1094","line":"{"},
{"lineNum":" 1095","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":" 1096","line":"  static EIGEN_STRONG_INLINE void run(MatrixTypeA& a, MatrixTypeB& b)"},
{"lineNum":" 1097","line":"  {"},
{"lineNum":" 1098","line":"    a.base().swap(b);"},
{"lineNum":" 1099","line":"  }"},
{"lineNum":" 1100","line":"};"},
{"lineNum":" 1101","line":""},
{"lineNum":" 1102","line":"template<typename MatrixTypeA, typename MatrixTypeB>"},
{"lineNum":" 1103","line":"struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>"},
{"lineNum":" 1104","line":"{"},
{"lineNum":" 1105","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":" 1106","line":"  static inline void run(MatrixTypeA& a, MatrixTypeB& b)"},
{"lineNum":" 1107","line":"  {"},
{"lineNum":" 1108","line":"    static_cast<typename MatrixTypeA::Base&>(a).m_storage.swap(static_cast<typename MatrixTypeB::Base&>(b).m_storage);"},
{"lineNum":" 1109","line":"  }"},
{"lineNum":" 1110","line":"};"},
{"lineNum":" 1111","line":""},
{"lineNum":" 1112","line":"} // end namespace internal"},
{"lineNum":" 1113","line":""},
{"lineNum":" 1114","line":"} // end namespace Eigen"},
{"lineNum":" 1115","line":""},
{"lineNum":" 1116","line":"#endif // EIGEN_DENSESTORAGEBASE_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 30, "covered" : 0,};
var merged_data = [];
