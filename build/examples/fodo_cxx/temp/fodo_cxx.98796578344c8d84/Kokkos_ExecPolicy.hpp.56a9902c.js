var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_EXECPOLICY_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_EXECPOLICY_HPP"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include <Kokkos_Core_fwd.hpp>"},
{"lineNum":"   49","line":"#include <impl/Kokkos_Traits.hpp>"},
{"lineNum":"   50","line":"#include <impl/Kokkos_Error.hpp>"},
{"lineNum":"   51","line":"#include <impl/Kokkos_Tags.hpp>"},
{"lineNum":"   52","line":"#include <impl/Kokkos_AnalyzePolicy.hpp>"},
{"lineNum":"   53","line":"#include <Kokkos_Concepts.hpp>"},
{"lineNum":"   54","line":"#include <typeinfo>"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"namespace Kokkos {"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"struct ParallelForTag {};"},
{"lineNum":"   61","line":"struct ParallelScanTag {};"},
{"lineNum":"   62","line":"struct ParallelReduceTag {};"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"struct ChunkSize {"},
{"lineNum":"   65","line":"  int value;"},
{"lineNum":"   66","line":"  ChunkSize(int value_) : value(value_) {}"},
{"lineNum":"   67","line":"};"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"/** \\brief  Execution policy for work over a range of an integral type."},
{"lineNum":"   70","line":" *"},
{"lineNum":"   71","line":" * Valid template argument options:"},
{"lineNum":"   72","line":" *"},
{"lineNum":"   73","line":" *  With a specified execution space:"},
{"lineNum":"   74","line":" *    < ExecSpace , WorkTag , { IntConst | IntType } >"},
{"lineNum":"   75","line":" *    < ExecSpace , WorkTag , void >"},
{"lineNum":"   76","line":" *    < ExecSpace , { IntConst | IntType } , void >"},
{"lineNum":"   77","line":" *    < ExecSpace , void , void >"},
{"lineNum":"   78","line":" *"},
{"lineNum":"   79","line":" *  With the default execution space:"},
{"lineNum":"   80","line":" *    < WorkTag , { IntConst | IntType } , void >"},
{"lineNum":"   81","line":" *    < WorkTag , void , void >"},
{"lineNum":"   82","line":" *    < { IntConst | IntType } , void , void >"},
{"lineNum":"   83","line":" *    < void , void , void >"},
{"lineNum":"   84","line":" *"},
{"lineNum":"   85","line":" *  IntType  is a fundamental integral type"},
{"lineNum":"   86","line":" *  IntConst is an Impl::integral_constant< IntType , Blocking >"},
{"lineNum":"   87","line":" *"},
{"lineNum":"   88","line":" *  Blocking is the granularity of partitioning the range among threads."},
{"lineNum":"   89","line":" */"},
{"lineNum":"   90","line":"template <class... Properties>"},
{"lineNum":"   91","line":"class RangePolicy : public Impl::PolicyTraits<Properties...> {"},
{"lineNum":"   92","line":" public:"},
{"lineNum":"   93","line":"  using traits = Impl::PolicyTraits<Properties...>;"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":" private:"},
{"lineNum":"   96","line":"  typename traits::execution_space m_space;"},
{"lineNum":"   97","line":"  typename traits::index_type m_begin;"},
{"lineNum":"   98","line":"  typename traits::index_type m_end;"},
{"lineNum":"   99","line":"  typename traits::index_type m_granularity;"},
{"lineNum":"  100","line":"  typename traits::index_type m_granularity_mask;"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"  template <class... OtherProperties>"},
{"lineNum":"  103","line":"  friend class RangePolicy;"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":" public:"},
{"lineNum":"  106","line":"  //! Tag this class as an execution policy"},
{"lineNum":"  107","line":"  using execution_policy = RangePolicy<Properties...>;"},
{"lineNum":"  108","line":"  using member_type      = typename traits::index_type;"},
{"lineNum":"  109","line":"  using index_type       = typename traits::index_type;"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"  KOKKOS_INLINE_FUNCTION const typename traits::execution_space& space() const {"},
{"lineNum":"  112","line":"    return m_space;"},
{"lineNum":"  113","line":"  }"},
{"lineNum":"  114","line":"  KOKKOS_INLINE_FUNCTION member_type begin() const { return m_begin; }","class":"lineNoCov","hits":"0","possible_hits":"133",},
{"lineNum":"  115","line":"  KOKKOS_INLINE_FUNCTION member_type end() const { return m_end; }","class":"lineNoCov","hits":"0","possible_hits":"335",},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"  // TODO: find a better workaround for Clangs weird instantiation order"},
{"lineNum":"  118","line":"  // This thing is here because of an instantiation error, where the RangePolicy"},
{"lineNum":"  119","line":"  // is inserted into FunctorValue Traits, which tries decltype on the operator."},
{"lineNum":"  120","line":"  // It tries to do this even though the first argument of parallel for clearly"},
{"lineNum":"  121","line":"  // doesn\'t match."},
{"lineNum":"  122","line":"  void operator()(const int&) const {}"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"  template <class... OtherProperties>"},
{"lineNum":"  125","line":"  RangePolicy(const RangePolicy<OtherProperties...>& p)"},
{"lineNum":"  126","line":"      : traits(p),  // base class may contain data such as desired occupancy"},
{"lineNum":"  127","line":"        m_space(p.m_space),"},
{"lineNum":"  128","line":"        m_begin(p.m_begin),"},
{"lineNum":"  129","line":"        m_end(p.m_end),"},
{"lineNum":"  130","line":"        m_granularity(p.m_granularity),"},
{"lineNum":"  131","line":"        m_granularity_mask(p.m_granularity_mask) {}"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"  inline RangePolicy()"},
{"lineNum":"  134","line":"      : m_space(),"},
{"lineNum":"  135","line":"        m_begin(0),"},
{"lineNum":"  136","line":"        m_end(0),"},
{"lineNum":"  137","line":"        m_granularity(0),"},
{"lineNum":"  138","line":"        m_granularity_mask(0) {}"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"  /** \\brief  Total range */"},
{"lineNum":"  141","line":"  inline RangePolicy(const typename traits::execution_space& work_space,"},
{"lineNum":"  142","line":"                     const member_type work_begin, const member_type work_end)"},
{"lineNum":"  143","line":"      : m_space(work_space),"},
{"lineNum":"  144","line":"        m_begin(work_begin < work_end ? work_begin : 0),","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  145","line":"        m_end(work_begin < work_end ? work_end : 0),","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  146","line":"        m_granularity(0),","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  147","line":"        m_granularity_mask(0) {","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  148","line":"    set_auto_chunk_size();","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  149","line":"  }"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"  /** \\brief  Total range */"},
{"lineNum":"  152","line":"  inline RangePolicy(const member_type work_begin, const member_type work_end)"},
{"lineNum":"  153","line":"      : RangePolicy(typename traits::execution_space(), work_begin, work_end) {","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  154","line":"    set_auto_chunk_size();","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  155","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"  /** \\brief  Total range */"},
{"lineNum":"  158","line":"  template <class... Args>"},
{"lineNum":"  159","line":"  inline RangePolicy(const typename traits::execution_space& work_space,"},
{"lineNum":"  160","line":"                     const member_type work_begin, const member_type work_end,"},
{"lineNum":"  161","line":"                     Args... args)"},
{"lineNum":"  162","line":"      : m_space(work_space),"},
{"lineNum":"  163","line":"        m_begin(work_begin < work_end ? work_begin : 0),"},
{"lineNum":"  164","line":"        m_end(work_begin < work_end ? work_end : 0),"},
{"lineNum":"  165","line":"        m_granularity(0),"},
{"lineNum":"  166","line":"        m_granularity_mask(0) {"},
{"lineNum":"  167","line":"    set_auto_chunk_size();"},
{"lineNum":"  168","line":"    set(args...);"},
{"lineNum":"  169","line":"  }"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"  /** \\brief  Total range */"},
{"lineNum":"  172","line":"  template <class... Args>"},
{"lineNum":"  173","line":"  inline RangePolicy(const member_type work_begin, const member_type work_end,"},
{"lineNum":"  174","line":"                     Args... args)"},
{"lineNum":"  175","line":"      : RangePolicy(typename traits::execution_space(), work_begin, work_end) {"},
{"lineNum":"  176","line":"    set_auto_chunk_size();"},
{"lineNum":"  177","line":"    set(args...);"},
{"lineNum":"  178","line":"  }"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":" private:"},
{"lineNum":"  181","line":"  inline void set() {}"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":" public:"},
{"lineNum":"  184","line":"  template <class... Args>"},
{"lineNum":"  185","line":"  inline void set(Args...) {"},
{"lineNum":"  186","line":"    static_assert("},
{"lineNum":"  187","line":"        0 == sizeof...(Args),"},
{"lineNum":"  188","line":"        \"Kokkos::RangePolicy: unhandled constructor arguments encountered.\");"},
{"lineNum":"  189","line":"  }"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"  template <class... Args>"},
{"lineNum":"  192","line":"  inline void set(const ChunkSize& chunksize, Args... args) {"},
{"lineNum":"  193","line":"    m_granularity      = chunksize.value;"},
{"lineNum":"  194","line":"    m_granularity_mask = m_granularity - 1;"},
{"lineNum":"  195","line":"    set(args...);"},
{"lineNum":"  196","line":"  }"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":" public:"},
{"lineNum":"  199","line":"  /** \\brief return chunk_size */"},
{"lineNum":"  200","line":"  inline member_type chunk_size() const { return m_granularity; }","class":"lineNoCov","hits":"0","possible_hits":"197",},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"  /** \\brief set chunk_size to a discrete value*/"},
{"lineNum":"  203","line":"  inline RangePolicy set_chunk_size(int chunk_size_) const {"},
{"lineNum":"  204","line":"    RangePolicy p        = *this;","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  205","line":"    p.m_granularity      = chunk_size_;","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  206","line":"    p.m_granularity_mask = p.m_granularity - 1;"},
{"lineNum":"  207","line":"    return p;"},
{"lineNum":"  208","line":"  }"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":" private:"},
{"lineNum":"  211","line":"  /** \\brief finalize chunk_size if it was set to AUTO*/"},
{"lineNum":"  212","line":"  inline void set_auto_chunk_size() {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  213","line":"    int64_t concurrency ="},
{"lineNum":"  214","line":"        static_cast<int64_t>(traits::execution_space::concurrency());","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  215","line":"    if (concurrency == 0) concurrency = 1;","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    if (m_granularity > 0) {","class":"lineNoCov","hits":"0","possible_hits":"31",},
{"lineNum":"  218","line":"      if (!Impl::is_integral_power_of_two(m_granularity))","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  219","line":"        Kokkos::abort(\"RangePolicy blocking granularity must be power of two\");","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  220","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"    int64_t new_chunk_size = 1;"},
{"lineNum":"  223","line":"    while (new_chunk_size * 100 * concurrency <","class":"lineNoCov","hits":"0","possible_hits":"76",},
{"lineNum":"  224","line":"           static_cast<int64_t>(m_end - m_begin))","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  225","line":"      new_chunk_size *= 2;","class":"lineNoCov","hits":"0","possible_hits":"38",},
{"lineNum":"  226","line":"    if (new_chunk_size < 128) {","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  227","line":"      new_chunk_size = 1;"},
{"lineNum":"  228","line":"      while ((new_chunk_size * 40 * concurrency <","class":"lineNoCov","hits":"0","possible_hits":"77",},
{"lineNum":"  229","line":"              static_cast<int64_t>(m_end - m_begin)) &&","class":"lineNoCov","hits":"0","possible_hits":"48",},
{"lineNum":"  230","line":"             (new_chunk_size < 128))","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  231","line":"        new_chunk_size *= 2;","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  232","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  233","line":"    m_granularity      = new_chunk_size;","class":"lineNoCov","hits":"0","possible_hits":"34",},
{"lineNum":"  234","line":"    m_granularity_mask = m_granularity - 1;","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  235","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":" public:"},
{"lineNum":"  238","line":"  /** \\brief  Subrange for a partition\'s rank and size."},
{"lineNum":"  239","line":"   *"},
{"lineNum":"  240","line":"   *  Typically used to partition a range over a group of threads."},
{"lineNum":"  241","line":"   */"},
{"lineNum":"  242","line":"  struct WorkRange {"},
{"lineNum":"  243","line":"    using work_tag    = typename RangePolicy<Properties...>::work_tag;"},
{"lineNum":"  244","line":"    using member_type = typename RangePolicy<Properties...>::member_type;"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"    KOKKOS_INLINE_FUNCTION member_type begin() const { return m_begin; }"},
{"lineNum":"  247","line":"    KOKKOS_INLINE_FUNCTION member_type end() const { return m_end; }"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"    /** \\brief  Subrange for a partition\'s rank and size."},
{"lineNum":"  250","line":"     *"},
{"lineNum":"  251","line":"     *  Typically used to partition a range over a group of threads."},
{"lineNum":"  252","line":"     */"},
{"lineNum":"  253","line":"    KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  254","line":"    WorkRange(const RangePolicy& range, const int part_rank,"},
{"lineNum":"  255","line":"              const int part_size)"},
{"lineNum":"  256","line":"        : m_begin(0), m_end(0) {"},
{"lineNum":"  257","line":"      if (part_size) {"},
{"lineNum":"  258","line":"        // Split evenly among partitions, then round up to the granularity."},
{"lineNum":"  259","line":"        const member_type work_part ="},
{"lineNum":"  260","line":"            ((((range.end() - range.begin()) + (part_size - 1)) / part_size) +"},
{"lineNum":"  261","line":"             range.m_granularity_mask) &"},
{"lineNum":"  262","line":"            ~member_type(range.m_granularity_mask);"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"        m_begin = range.begin() + work_part * part_rank;"},
{"lineNum":"  265","line":"        m_end   = m_begin + work_part;"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"        if (range.end() < m_begin) m_begin = range.end();"},
{"lineNum":"  268","line":"        if (range.end() < m_end) m_end = range.end();"},
{"lineNum":"  269","line":"      }"},
{"lineNum":"  270","line":"    }"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"   private:"},
{"lineNum":"  273","line":"    member_type m_begin;"},
{"lineNum":"  274","line":"    member_type m_end;"},
{"lineNum":"  275","line":"    WorkRange();"},
{"lineNum":"  276","line":"    WorkRange& operator=(const WorkRange&);"},
{"lineNum":"  277","line":"  };"},
{"lineNum":"  278","line":"};"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"}  // namespace Kokkos"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  283","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"namespace Kokkos {"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"namespace Impl {"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"template <class ExecSpace, class... Properties>"},
{"lineNum":"  290","line":"class TeamPolicyInternal : public Impl::PolicyTraits<Properties...> {"},
{"lineNum":"  291","line":" private:"},
{"lineNum":"  292","line":"  using traits = Impl::PolicyTraits<Properties...>;"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":" public:"},
{"lineNum":"  295","line":"  using index_type = typename traits::index_type;"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"  //----------------------------------------"},
{"lineNum":"  298","line":"  /** \\brief  Query maximum team size for a given functor."},
{"lineNum":"  299","line":"   *"},
{"lineNum":"  300","line":"   *  This size takes into account execution space concurrency limitations and"},
{"lineNum":"  301","line":"   *  scratch memory space limitations for reductions, team reduce/scan, and"},
{"lineNum":"  302","line":"   *  team shared memory."},
{"lineNum":"  303","line":"   *"},
{"lineNum":"  304","line":"   *  This function only works for single-operator functors."},
{"lineNum":"  305","line":"   *  With multi-operator functors it cannot be determined"},
{"lineNum":"  306","line":"   *  which operator will be called."},
{"lineNum":"  307","line":"   */"},
{"lineNum":"  308","line":"  template <class FunctorType>"},
{"lineNum":"  309","line":"  static int team_size_max(const FunctorType&);"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"  /** \\brief  Query recommended team size for a given functor."},
{"lineNum":"  312","line":"   *"},
{"lineNum":"  313","line":"   *  This size takes into account execution space concurrency limitations and"},
{"lineNum":"  314","line":"   *  scratch memory space limitations for reductions, team reduce/scan, and"},
{"lineNum":"  315","line":"   *  team shared memory."},
{"lineNum":"  316","line":"   *"},
{"lineNum":"  317","line":"   *  This function only works for single-operator functors."},
{"lineNum":"  318","line":"   *  With multi-operator functors it cannot be determined"},
{"lineNum":"  319","line":"   *  which operator will be called."},
{"lineNum":"  320","line":"   */"},
{"lineNum":"  321","line":"  template <class FunctorType>"},
{"lineNum":"  322","line":"  static int team_size_recommended(const FunctorType&);"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"  template <class FunctorType>"},
{"lineNum":"  325","line":"  static int team_size_recommended(const FunctorType&, const int&);"},
{"lineNum":"  326","line":""},
{"lineNum":"  327","line":"  template <class FunctorType>"},
{"lineNum":"  328","line":"  int team_size_recommended(const FunctorType& functor,"},
{"lineNum":"  329","line":"                            const int vector_length);"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"  //----------------------------------------"},
{"lineNum":"  332","line":"  /** \\brief  Construct policy with the given instance of the execution space */"},
{"lineNum":"  333","line":"  TeamPolicyInternal(const typename traits::execution_space&,"},
{"lineNum":"  334","line":"                     int league_size_request, int team_size_request,"},
{"lineNum":"  335","line":"                     int vector_length_request = 1);"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"  TeamPolicyInternal(const typename traits::execution_space&,"},
{"lineNum":"  338","line":"                     int league_size_request, const Kokkos::AUTO_t&,"},
{"lineNum":"  339","line":"                     int vector_length_request = 1);"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"  /** \\brief  Construct policy with the default instance of the execution space"},
{"lineNum":"  342","line":"   */"},
{"lineNum":"  343","line":"  TeamPolicyInternal(int league_size_request, int team_size_request,"},
{"lineNum":"  344","line":"                     int vector_length_request = 1);"},
{"lineNum":"  345","line":""},
{"lineNum":"  346","line":"  TeamPolicyInternal(int league_size_request, const Kokkos::AUTO_t&,"},
{"lineNum":"  347","line":"                     int vector_length_request = 1);"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"  /*  TeamPolicyInternal( int league_size_request , int team_size_request );"},
{"lineNum":"  350","line":""},
{"lineNum":"  351","line":"    TeamPolicyInternal( int league_size_request , const Kokkos::AUTO_t & );*/"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"  /** \\brief  The actual league size (number of teams) of the policy."},
{"lineNum":"  354","line":"   *"},
{"lineNum":"  355","line":"   *  This may be smaller than the requested league size due to limitations"},
{"lineNum":"  356","line":"   *  of the execution space."},
{"lineNum":"  357","line":"   */"},
{"lineNum":"  358","line":"  KOKKOS_INLINE_FUNCTION int league_size() const;"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"  /** \\brief  The actual team size (number of threads per team) of the policy."},
{"lineNum":"  361","line":"   *"},
{"lineNum":"  362","line":"   *  This may be smaller than the requested team size due to limitations"},
{"lineNum":"  363","line":"   *  of the execution space."},
{"lineNum":"  364","line":"   */"},
{"lineNum":"  365","line":"  KOKKOS_INLINE_FUNCTION int team_size() const;"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"  /** \\brief Whether the policy has an automatically determined team size"},
{"lineNum":"  368","line":"   */"},
{"lineNum":"  369","line":"  inline bool impl_auto_team_size() const;"},
{"lineNum":"  370","line":"  /** \\brief Whether the policy has an automatically determined vector length"},
{"lineNum":"  371","line":"   */"},
{"lineNum":"  372","line":"  inline bool impl_auto_vector_length() const;"},
{"lineNum":"  373","line":""},
{"lineNum":"  374","line":"  static int vector_length_max();"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"  KOKKOS_INLINE_FUNCTION int impl_vector_length() const;"},
{"lineNum":"  377","line":""},
{"lineNum":"  378","line":"  inline typename traits::index_type chunk_size() const;"},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":"  inline TeamPolicyInternal& set_chunk_size(int chunk_size);"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"  /** \\brief  Parallel execution of a functor calls the functor once with"},
{"lineNum":"  383","line":"   *          each member of the execution policy."},
{"lineNum":"  384","line":"   */"},
{"lineNum":"  385","line":"  struct member_type {"},
{"lineNum":"  386","line":"    /** \\brief  Handle to the currently executing team shared scratch memory */"},
{"lineNum":"  387","line":"    KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  388","line":"    typename traits::execution_space::scratch_memory_space team_shmem() const;"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"    /** \\brief  Rank of this team within the league of teams */"},
{"lineNum":"  391","line":"    KOKKOS_INLINE_FUNCTION int league_rank() const;"},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"    /** \\brief  Number of teams in the league */"},
{"lineNum":"  394","line":"    KOKKOS_INLINE_FUNCTION int league_size() const;"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"    /** \\brief  Rank of this thread within this team */"},
{"lineNum":"  397","line":"    KOKKOS_INLINE_FUNCTION int team_rank() const;"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"    /** \\brief  Number of threads in this team */"},
{"lineNum":"  400","line":"    KOKKOS_INLINE_FUNCTION int team_size() const;"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"    /** \\brief  Barrier among the threads of this team */"},
{"lineNum":"  403","line":"    KOKKOS_INLINE_FUNCTION void team_barrier() const;"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"    /** \\brief  Intra-team reduction. Returns join of all values of the team"},
{"lineNum":"  406","line":"     * members. */"},
{"lineNum":"  407","line":"    template <class JoinOp>"},
{"lineNum":"  408","line":"    KOKKOS_INLINE_FUNCTION typename JoinOp::value_type team_reduce("},
{"lineNum":"  409","line":"        const typename JoinOp::value_type, const JoinOp&) const;"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"    /** \\brief  Intra-team exclusive prefix sum with team_rank() ordering."},
{"lineNum":"  412","line":"     *"},
{"lineNum":"  413","line":"     *  The highest rank thread can compute the reduction total as"},
{"lineNum":"  414","line":"     *    reduction_total = dev.team_scan( value ) + value ;"},
{"lineNum":"  415","line":"     */"},
{"lineNum":"  416","line":"    template <typename Type>"},
{"lineNum":"  417","line":"    KOKKOS_INLINE_FUNCTION Type team_scan(const Type& value) const;"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"    /** \\brief  Intra-team exclusive prefix sum with team_rank() ordering"},
{"lineNum":"  420","line":"     *          with intra-team non-deterministic ordering accumulation."},
{"lineNum":"  421","line":"     *"},
{"lineNum":"  422","line":"     *  The global inter-team accumulation value will, at the end of the"},
{"lineNum":"  423","line":"     *  league\'s parallel execution, be the scan\'s total."},
{"lineNum":"  424","line":"     *  Parallel execution ordering of the league\'s teams is non-deterministic."},
{"lineNum":"  425","line":"     *  As such the base value for each team\'s scan operation is similarly"},
{"lineNum":"  426","line":"     *  non-deterministic."},
{"lineNum":"  427","line":"     */"},
{"lineNum":"  428","line":"    template <typename Type>"},
{"lineNum":"  429","line":"    KOKKOS_INLINE_FUNCTION Type team_scan(const Type& value,"},
{"lineNum":"  430","line":"                                          Type* const global_accum) const;"},
{"lineNum":"  431","line":"  };"},
{"lineNum":"  432","line":"};"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"struct PerTeamValue {"},
{"lineNum":"  435","line":"  int value;"},
{"lineNum":"  436","line":"  PerTeamValue(int arg);"},
{"lineNum":"  437","line":"};"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"struct PerThreadValue {"},
{"lineNum":"  440","line":"  int value;"},
{"lineNum":"  441","line":"  PerThreadValue(int arg);"},
{"lineNum":"  442","line":"};"},
{"lineNum":"  443","line":""},
{"lineNum":"  444","line":"template <class iType, class... Args>"},
{"lineNum":"  445","line":"struct ExtractVectorLength {"},
{"lineNum":"  446","line":"  static inline iType value("},
{"lineNum":"  447","line":"      typename std::enable_if<std::is_integral<iType>::value, iType>::type val,"},
{"lineNum":"  448","line":"      Args...) {"},
{"lineNum":"  449","line":"    return val;"},
{"lineNum":"  450","line":"  }"},
{"lineNum":"  451","line":"  static inline"},
{"lineNum":"  452","line":"      typename std::enable_if<!std::is_integral<iType>::value, int>::type"},
{"lineNum":"  453","line":"      value("},
{"lineNum":"  454","line":"          typename std::enable_if<!std::is_integral<iType>::value, iType>::type,"},
{"lineNum":"  455","line":"          Args...) {"},
{"lineNum":"  456","line":"    return 1;"},
{"lineNum":"  457","line":"  }"},
{"lineNum":"  458","line":"};"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"template <class iType, class... Args>"},
{"lineNum":"  461","line":"inline typename std::enable_if<std::is_integral<iType>::value, iType>::type"},
{"lineNum":"  462","line":"extract_vector_length(iType val, Args...) {"},
{"lineNum":"  463","line":"  return val;"},
{"lineNum":"  464","line":"}"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"template <class iType, class... Args>"},
{"lineNum":"  467","line":"inline typename std::enable_if<!std::is_integral<iType>::value, int>::type"},
{"lineNum":"  468","line":"extract_vector_length(iType, Args...) {"},
{"lineNum":"  469","line":"  return 1;"},
{"lineNum":"  470","line":"}"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"}  // namespace Impl"},
{"lineNum":"  473","line":""},
{"lineNum":"  474","line":"Impl::PerTeamValue PerTeam(const int& arg);"},
{"lineNum":"  475","line":"Impl::PerThreadValue PerThread(const int& arg);"},
{"lineNum":"  476","line":""},
{"lineNum":"  477","line":"struct ScratchRequest {"},
{"lineNum":"  478","line":"  int level;"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"  int per_team;"},
{"lineNum":"  481","line":"  int per_thread;"},
{"lineNum":"  482","line":""},
{"lineNum":"  483","line":"  inline ScratchRequest(const int& level_,"},
{"lineNum":"  484","line":"                        const Impl::PerTeamValue& team_value) {"},
{"lineNum":"  485","line":"    level      = level_;"},
{"lineNum":"  486","line":"    per_team   = team_value.value;"},
{"lineNum":"  487","line":"    per_thread = 0;"},
{"lineNum":"  488","line":"  }"},
{"lineNum":"  489","line":""},
{"lineNum":"  490","line":"  inline ScratchRequest(const int& level_,"},
{"lineNum":"  491","line":"                        const Impl::PerThreadValue& thread_value) {"},
{"lineNum":"  492","line":"    level      = level_;"},
{"lineNum":"  493","line":"    per_team   = 0;"},
{"lineNum":"  494","line":"    per_thread = thread_value.value;"},
{"lineNum":"  495","line":"  }"},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"  inline ScratchRequest(const int& level_, const Impl::PerTeamValue& team_value,"},
{"lineNum":"  498","line":"                        const Impl::PerThreadValue& thread_value) {"},
{"lineNum":"  499","line":"    level      = level_;"},
{"lineNum":"  500","line":"    per_team   = team_value.value;"},
{"lineNum":"  501","line":"    per_thread = thread_value.value;"},
{"lineNum":"  502","line":"  }"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"  inline ScratchRequest(const int& level_,"},
{"lineNum":"  505","line":"                        const Impl::PerThreadValue& thread_value,"},
{"lineNum":"  506","line":"                        const Impl::PerTeamValue& team_value) {"},
{"lineNum":"  507","line":"    level      = level_;"},
{"lineNum":"  508","line":"    per_team   = team_value.value;"},
{"lineNum":"  509","line":"    per_thread = thread_value.value;"},
{"lineNum":"  510","line":"  }"},
{"lineNum":"  511","line":"};"},
{"lineNum":"  512","line":""},
{"lineNum":"  513","line":"// Throws a runtime exception if level is not `0` or `1`"},
{"lineNum":"  514","line":"void team_policy_check_valid_storage_level_argument(int level);"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"/** \\brief  Execution policy for parallel work over a league of teams of"},
{"lineNum":"  517","line":" * threads."},
{"lineNum":"  518","line":" *"},
{"lineNum":"  519","line":" *  The work functor is called for each thread of each team such that"},
{"lineNum":"  520","line":" *  the team\'s member threads are guaranteed to be concurrent."},
{"lineNum":"  521","line":" *"},
{"lineNum":"  522","line":" *  The team\'s threads have access to team shared scratch memory and"},
{"lineNum":"  523","line":" *  team collective operations."},
{"lineNum":"  524","line":" *"},
{"lineNum":"  525","line":" *  If the WorkTag is non-void then the first calling argument of the"},
{"lineNum":"  526","line":" *  work functor\'s parentheses operator is \'const WorkTag &\'."},
{"lineNum":"  527","line":" *  This allows a functor to have multiple work member functions."},
{"lineNum":"  528","line":" *"},
{"lineNum":"  529","line":" *  Order of template arguments does not matter, since the implementation"},
{"lineNum":"  530","line":" *  uses variadic templates. Each and any of the template arguments can"},
{"lineNum":"  531","line":" *  be omitted."},
{"lineNum":"  532","line":" *"},
{"lineNum":"  533","line":" *  Possible Template arguments and their default values:"},
{"lineNum":"  534","line":" *    ExecutionSpace (DefaultExecutionSpace): where to execute code. Must be"},
{"lineNum":"  535","line":" * enabled. WorkTag (none): Tag which is used as the first argument for the"},
{"lineNum":"  536","line":" * functor operator. Schedule<Type> (Schedule<Static>): Scheduling Policy"},
{"lineNum":"  537","line":" * (Dynamic, or Static). IndexType<Type> (IndexType<ExecutionSpace::size_type>:"},
{"lineNum":"  538","line":" * Integer Index type used to iterate over the Index space."},
{"lineNum":"  539","line":" *    LaunchBounds<unsigned,unsigned> Launch Bounds for CUDA compilation,"},
{"lineNum":"  540","line":" *    default of LaunchBounds<0,0> indicates no launch bounds specified."},
{"lineNum":"  541","line":" */"},
{"lineNum":"  542","line":"template <class... Properties>"},
{"lineNum":"  543","line":"class TeamPolicy"},
{"lineNum":"  544","line":"    : public Impl::TeamPolicyInternal<"},
{"lineNum":"  545","line":"          typename Impl::PolicyTraits<Properties...>::execution_space,"},
{"lineNum":"  546","line":"          Properties...> {"},
{"lineNum":"  547","line":"  using internal_policy = Impl::TeamPolicyInternal<"},
{"lineNum":"  548","line":"      typename Impl::PolicyTraits<Properties...>::execution_space,"},
{"lineNum":"  549","line":"      Properties...>;"},
{"lineNum":"  550","line":""},
{"lineNum":"  551","line":"  template <class... OtherProperties>"},
{"lineNum":"  552","line":"  friend class TeamPolicy;"},
{"lineNum":"  553","line":""},
{"lineNum":"  554","line":" public:"},
{"lineNum":"  555","line":"  using traits = Impl::PolicyTraits<Properties...>;"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"  using execution_policy = TeamPolicy<Properties...>;"},
{"lineNum":"  558","line":""},
{"lineNum":"  559","line":"  TeamPolicy() : internal_policy(0, AUTO) {}"},
{"lineNum":"  560","line":""},
{"lineNum":"  561","line":"  /** \\brief  Construct policy with the given instance of the execution space */"},
{"lineNum":"  562","line":"  TeamPolicy(const typename traits::execution_space& space_,"},
{"lineNum":"  563","line":"             int league_size_request, int team_size_request,"},
{"lineNum":"  564","line":"             int vector_length_request = 1)"},
{"lineNum":"  565","line":"      : internal_policy(space_, league_size_request, team_size_request,"},
{"lineNum":"  566","line":"                        vector_length_request) {}"},
{"lineNum":"  567","line":""},
{"lineNum":"  568","line":"  TeamPolicy(const typename traits::execution_space& space_,"},
{"lineNum":"  569","line":"             int league_size_request, const Kokkos::AUTO_t&,"},
{"lineNum":"  570","line":"             int vector_length_request = 1)"},
{"lineNum":"  571","line":"      : internal_policy(space_, league_size_request, Kokkos::AUTO(),"},
{"lineNum":"  572","line":"                        vector_length_request) {}"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"  TeamPolicy(const typename traits::execution_space& space_,"},
{"lineNum":"  575","line":"             int league_size_request, const Kokkos::AUTO_t&,"},
{"lineNum":"  576","line":"             const Kokkos::AUTO_t&)"},
{"lineNum":"  577","line":"      : internal_policy(space_, league_size_request, Kokkos::AUTO(),"},
{"lineNum":"  578","line":"                        Kokkos::AUTO()) {}"},
{"lineNum":"  579","line":"  TeamPolicy(const typename traits::execution_space& space_,"},
{"lineNum":"  580","line":"             int league_size_request, const int team_size_request,"},
{"lineNum":"  581","line":"             const Kokkos::AUTO_t&)"},
{"lineNum":"  582","line":"      : internal_policy(space_, league_size_request, team_size_request,"},
{"lineNum":"  583","line":"                        Kokkos::AUTO()) {}"},
{"lineNum":"  584","line":"  /** \\brief  Construct policy with the default instance of the execution space"},
{"lineNum":"  585","line":"   */"},
{"lineNum":"  586","line":"  TeamPolicy(int league_size_request, int team_size_request,"},
{"lineNum":"  587","line":"             int vector_length_request = 1)"},
{"lineNum":"  588","line":"      : internal_policy(league_size_request, team_size_request,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  589","line":"                        vector_length_request) {}"},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"  TeamPolicy(int league_size_request, const Kokkos::AUTO_t&,"},
{"lineNum":"  592","line":"             int vector_length_request = 1)"},
{"lineNum":"  593","line":"      : internal_policy(league_size_request, Kokkos::AUTO(),"},
{"lineNum":"  594","line":"                        vector_length_request) {}"},
{"lineNum":"  595","line":""},
{"lineNum":"  596","line":"  TeamPolicy(int league_size_request, const Kokkos::AUTO_t&,"},
{"lineNum":"  597","line":"             const Kokkos::AUTO_t&)"},
{"lineNum":"  598","line":"      : internal_policy(league_size_request, Kokkos::AUTO(), Kokkos::AUTO()) {}"},
{"lineNum":"  599","line":"  TeamPolicy(int league_size_request, const int team_size_request,"},
{"lineNum":"  600","line":"             const Kokkos::AUTO_t&)"},
{"lineNum":"  601","line":"      : internal_policy(league_size_request, team_size_request,"},
{"lineNum":"  602","line":"                        Kokkos::AUTO()) {}"},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"  template <class... OtherProperties>"},
{"lineNum":"  605","line":"  TeamPolicy(const TeamPolicy<OtherProperties...> p) : internal_policy(p) {"},
{"lineNum":"  606","line":"    // Cannot call converting constructor in the member initializer list because"},
{"lineNum":"  607","line":"    // it is not a direct base."},
{"lineNum":"  608","line":"    internal_policy::traits::operator=(p);"},
{"lineNum":"  609","line":"  }"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":" private:"},
{"lineNum":"  612","line":"  TeamPolicy(const internal_policy& p) : internal_policy(p) {}"},
{"lineNum":"  613","line":""},
{"lineNum":"  614","line":" public:"},
{"lineNum":"  615","line":"  inline TeamPolicy& set_chunk_size(int chunk) {"},
{"lineNum":"  616","line":"    static_assert(std::is_same<decltype(internal_policy::set_chunk_size(chunk)),"},
{"lineNum":"  617","line":"                               internal_policy&>::value,"},
{"lineNum":"  618","line":"                  \"internal set_chunk_size should return a reference\");"},
{"lineNum":"  619","line":"    return static_cast<TeamPolicy&>(internal_policy::set_chunk_size(chunk));"},
{"lineNum":"  620","line":"  }"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"  inline TeamPolicy& set_scratch_size(const int& level,"},
{"lineNum":"  623","line":"                                      const Impl::PerTeamValue& per_team) {"},
{"lineNum":"  624","line":"    static_assert(std::is_same<decltype(internal_policy::set_scratch_size("},
{"lineNum":"  625","line":"                                   level, per_team)),"},
{"lineNum":"  626","line":"                               internal_policy&>::value,"},
{"lineNum":"  627","line":"                  \"internal set_chunk_size should return a reference\");"},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"    team_policy_check_valid_storage_level_argument(level);"},
{"lineNum":"  630","line":"    return static_cast<TeamPolicy&>("},
{"lineNum":"  631","line":"        internal_policy::set_scratch_size(level, per_team));"},
{"lineNum":"  632","line":"  }"},
{"lineNum":"  633","line":"  inline TeamPolicy& set_scratch_size(const int& level,"},
{"lineNum":"  634","line":"                                      const Impl::PerThreadValue& per_thread) {"},
{"lineNum":"  635","line":"    team_policy_check_valid_storage_level_argument(level);"},
{"lineNum":"  636","line":"    return static_cast<TeamPolicy&>("},
{"lineNum":"  637","line":"        internal_policy::set_scratch_size(level, per_thread));"},
{"lineNum":"  638","line":"  }"},
{"lineNum":"  639","line":"  inline TeamPolicy& set_scratch_size(const int& level,"},
{"lineNum":"  640","line":"                                      const Impl::PerTeamValue& per_team,"},
{"lineNum":"  641","line":"                                      const Impl::PerThreadValue& per_thread) {"},
{"lineNum":"  642","line":"    team_policy_check_valid_storage_level_argument(level);"},
{"lineNum":"  643","line":"    return static_cast<TeamPolicy&>("},
{"lineNum":"  644","line":"        internal_policy::set_scratch_size(level, per_team, per_thread));"},
{"lineNum":"  645","line":"  }"},
{"lineNum":"  646","line":"  inline TeamPolicy& set_scratch_size(const int& level,"},
{"lineNum":"  647","line":"                                      const Impl::PerThreadValue& per_thread,"},
{"lineNum":"  648","line":"                                      const Impl::PerTeamValue& per_team) {"},
{"lineNum":"  649","line":"    team_policy_check_valid_storage_level_argument(level);"},
{"lineNum":"  650","line":"    return static_cast<TeamPolicy&>("},
{"lineNum":"  651","line":"        internal_policy::set_scratch_size(level, per_team, per_thread));"},
{"lineNum":"  652","line":"  }"},
{"lineNum":"  653","line":"};"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"namespace Impl {"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"template <typename iType, class TeamMemberType>"},
{"lineNum":"  658","line":"struct TeamThreadRangeBoundariesStruct {"},
{"lineNum":"  659","line":" private:"},
{"lineNum":"  660","line":"  KOKKOS_INLINE_FUNCTION static iType ibegin(const iType& arg_begin,"},
{"lineNum":"  661","line":"                                             const iType& arg_end,"},
{"lineNum":"  662","line":"                                             const iType& arg_rank,"},
{"lineNum":"  663","line":"                                             const iType& arg_size) {"},
{"lineNum":"  664","line":"    return arg_begin +"},
{"lineNum":"  665","line":"           ((arg_end - arg_begin + arg_size - 1) / arg_size) * arg_rank;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  666","line":"  }"},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"  KOKKOS_INLINE_FUNCTION static iType iend(const iType& arg_begin,"},
{"lineNum":"  669","line":"                                           const iType& arg_end,"},
{"lineNum":"  670","line":"                                           const iType& arg_rank,"},
{"lineNum":"  671","line":"                                           const iType& arg_size) {"},
{"lineNum":"  672","line":"    const iType end_ ="},
{"lineNum":"  673","line":"        arg_begin +"},
{"lineNum":"  674","line":"        ((arg_end - arg_begin + arg_size - 1) / arg_size) * (arg_rank + 1);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  675","line":"    return end_ < arg_end ? end_ : arg_end;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  676","line":"  }"},
{"lineNum":"  677","line":""},
{"lineNum":"  678","line":" public:"},
{"lineNum":"  679","line":"  using index_type = iType;"},
{"lineNum":"  680","line":"  const iType start;"},
{"lineNum":"  681","line":"  const iType end;"},
{"lineNum":"  682","line":"  enum { increment = 1 };"},
{"lineNum":"  683","line":"  const TeamMemberType& thread;"},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  686","line":"  TeamThreadRangeBoundariesStruct(const TeamMemberType& arg_thread,"},
{"lineNum":"  687","line":"                                  const iType& arg_end)"},
{"lineNum":"  688","line":"      : start("},
{"lineNum":"  689","line":"            ibegin(0, arg_end, arg_thread.team_rank(), arg_thread.team_size())),"},
{"lineNum":"  690","line":"        end(iend(0, arg_end, arg_thread.team_rank(), arg_thread.team_size())),"},
{"lineNum":"  691","line":"        thread(arg_thread) {}"},
{"lineNum":"  692","line":""},
{"lineNum":"  693","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  694","line":"  TeamThreadRangeBoundariesStruct(const TeamMemberType& arg_thread,"},
{"lineNum":"  695","line":"                                  const iType& arg_begin, const iType& arg_end)"},
{"lineNum":"  696","line":"      : start(ibegin(arg_begin, arg_end, arg_thread.team_rank(),"},
{"lineNum":"  697","line":"                     arg_thread.team_size())),"},
{"lineNum":"  698","line":"        end(iend(arg_begin, arg_end, arg_thread.team_rank(),"},
{"lineNum":"  699","line":"                 arg_thread.team_size())),"},
{"lineNum":"  700","line":"        thread(arg_thread) {}"},
{"lineNum":"  701","line":"};"},
{"lineNum":"  702","line":""},
{"lineNum":"  703","line":"template <typename iType, class TeamMemberType>"},
{"lineNum":"  704","line":"struct TeamVectorRangeBoundariesStruct {"},
{"lineNum":"  705","line":" private:"},
{"lineNum":"  706","line":"  KOKKOS_INLINE_FUNCTION static iType ibegin(const iType& arg_begin,"},
{"lineNum":"  707","line":"                                             const iType& arg_end,"},
{"lineNum":"  708","line":"                                             const iType& arg_rank,"},
{"lineNum":"  709","line":"                                             const iType& arg_size) {"},
{"lineNum":"  710","line":"    return arg_begin +"},
{"lineNum":"  711","line":"           ((arg_end - arg_begin + arg_size - 1) / arg_size) * arg_rank;"},
{"lineNum":"  712","line":"  }"},
{"lineNum":"  713","line":""},
{"lineNum":"  714","line":"  KOKKOS_INLINE_FUNCTION static iType iend(const iType& arg_begin,"},
{"lineNum":"  715","line":"                                           const iType& arg_end,"},
{"lineNum":"  716","line":"                                           const iType& arg_rank,"},
{"lineNum":"  717","line":"                                           const iType& arg_size) {"},
{"lineNum":"  718","line":"    const iType end_ ="},
{"lineNum":"  719","line":"        arg_begin +"},
{"lineNum":"  720","line":"        ((arg_end - arg_begin + arg_size - 1) / arg_size) * (arg_rank + 1);"},
{"lineNum":"  721","line":"    return end_ < arg_end ? end_ : arg_end;"},
{"lineNum":"  722","line":"  }"},
{"lineNum":"  723","line":""},
{"lineNum":"  724","line":" public:"},
{"lineNum":"  725","line":"  using index_type = iType;"},
{"lineNum":"  726","line":"  const iType start;"},
{"lineNum":"  727","line":"  const iType end;"},
{"lineNum":"  728","line":"  enum { increment = 1 };"},
{"lineNum":"  729","line":"  const TeamMemberType& thread;"},
{"lineNum":"  730","line":""},
{"lineNum":"  731","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  732","line":"  TeamVectorRangeBoundariesStruct(const TeamMemberType& arg_thread,"},
{"lineNum":"  733","line":"                                  const iType& arg_end)"},
{"lineNum":"  734","line":"      : start("},
{"lineNum":"  735","line":"            ibegin(0, arg_end, arg_thread.team_rank(), arg_thread.team_size())),"},
{"lineNum":"  736","line":"        end(iend(0, arg_end, arg_thread.team_rank(), arg_thread.team_size())),"},
{"lineNum":"  737","line":"        thread(arg_thread) {}"},
{"lineNum":"  738","line":""},
{"lineNum":"  739","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  740","line":"  TeamVectorRangeBoundariesStruct(const TeamMemberType& arg_thread,"},
{"lineNum":"  741","line":"                                  const iType& arg_begin, const iType& arg_end)"},
{"lineNum":"  742","line":"      : start(ibegin(arg_begin, arg_end, arg_thread.team_rank(),"},
{"lineNum":"  743","line":"                     arg_thread.team_size())),"},
{"lineNum":"  744","line":"        end(iend(arg_begin, arg_end, arg_thread.team_rank(),"},
{"lineNum":"  745","line":"                 arg_thread.team_size())),"},
{"lineNum":"  746","line":"        thread(arg_thread) {}"},
{"lineNum":"  747","line":"};"},
{"lineNum":"  748","line":""},
{"lineNum":"  749","line":"template <typename iType, class TeamMemberType>"},
{"lineNum":"  750","line":"struct ThreadVectorRangeBoundariesStruct {"},
{"lineNum":"  751","line":"  using index_type = iType;"},
{"lineNum":"  752","line":"  const index_type start;"},
{"lineNum":"  753","line":"  const index_type end;"},
{"lineNum":"  754","line":"  enum { increment = 1 };"},
{"lineNum":"  755","line":""},
{"lineNum":"  756","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  757","line":"  constexpr ThreadVectorRangeBoundariesStruct(const TeamMemberType,"},
{"lineNum":"  758","line":"                                              const index_type& count) noexcept"},
{"lineNum":"  759","line":"      : start(static_cast<index_type>(0)), end(count) {}"},
{"lineNum":"  760","line":""},
{"lineNum":"  761","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  762","line":"  constexpr ThreadVectorRangeBoundariesStruct(const index_type& count) noexcept"},
{"lineNum":"  763","line":"      : start(static_cast<index_type>(0)), end(count) {}"},
{"lineNum":"  764","line":""},
{"lineNum":"  765","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  766","line":"  constexpr ThreadVectorRangeBoundariesStruct("},
{"lineNum":"  767","line":"      const TeamMemberType, const index_type& arg_begin,"},
{"lineNum":"  768","line":"      const index_type& arg_end) noexcept"},
{"lineNum":"  769","line":"      : start(static_cast<index_type>(arg_begin)), end(arg_end) {}"},
{"lineNum":"  770","line":""},
{"lineNum":"  771","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  772","line":"  constexpr ThreadVectorRangeBoundariesStruct("},
{"lineNum":"  773","line":"      const index_type& arg_begin, const index_type& arg_end) noexcept"},
{"lineNum":"  774","line":"      : start(static_cast<index_type>(arg_begin)), end(arg_end) {}"},
{"lineNum":"  775","line":"};"},
{"lineNum":"  776","line":""},
{"lineNum":"  777","line":"template <class TeamMemberType>"},
{"lineNum":"  778","line":"struct ThreadSingleStruct {"},
{"lineNum":"  779","line":"  const TeamMemberType& team_member;"},
{"lineNum":"  780","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  781","line":"  ThreadSingleStruct(const TeamMemberType& team_member_)"},
{"lineNum":"  782","line":"      : team_member(team_member_) {}"},
{"lineNum":"  783","line":"};"},
{"lineNum":"  784","line":""},
{"lineNum":"  785","line":"template <class TeamMemberType>"},
{"lineNum":"  786","line":"struct VectorSingleStruct {"},
{"lineNum":"  787","line":"  const TeamMemberType& team_member;"},
{"lineNum":"  788","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  789","line":"  VectorSingleStruct(const TeamMemberType& team_member_)"},
{"lineNum":"  790","line":"      : team_member(team_member_) {}"},
{"lineNum":"  791","line":"};"},
{"lineNum":"  792","line":""},
{"lineNum":"  793","line":"}  // namespace Impl"},
{"lineNum":"  794","line":""},
{"lineNum":"  795","line":"/** \\brief  Execution policy for parallel work over a threads within a team."},
{"lineNum":"  796","line":" *"},
{"lineNum":"  797","line":" *  The range is split over all threads in a team. The Mapping scheme depends on"},
{"lineNum":"  798","line":" * the architecture. This policy is used together with a parallel pattern as a"},
{"lineNum":"  799","line":" * nested layer within a kernel launched with the TeamPolicy. This variant"},
{"lineNum":"  800","line":" * expects a single count. So the range is (0,count]."},
{"lineNum":"  801","line":" */"},
{"lineNum":"  802","line":"template <typename iType, class TeamMemberType, class _never_use_this_overload>"},
{"lineNum":"  803","line":"KOKKOS_INLINE_FUNCTION_DELETED"},
{"lineNum":"  804","line":"    Impl::TeamThreadRangeBoundariesStruct<iType, TeamMemberType>"},
{"lineNum":"  805","line":"    TeamThreadRange(const TeamMemberType&, const iType& count) = delete;"},
{"lineNum":"  806","line":""},
{"lineNum":"  807","line":"/** \\brief  Execution policy for parallel work over a threads within a team."},
{"lineNum":"  808","line":" *"},
{"lineNum":"  809","line":" *  The range is split over all threads in a team. The Mapping scheme depends on"},
{"lineNum":"  810","line":" * the architecture. This policy is used together with a parallel pattern as a"},
{"lineNum":"  811","line":" * nested layer within a kernel launched with the TeamPolicy. This variant"},
{"lineNum":"  812","line":" * expects a begin and end. So the range is (begin,end]."},
{"lineNum":"  813","line":" */"},
{"lineNum":"  814","line":"template <typename iType1, typename iType2, class TeamMemberType,"},
{"lineNum":"  815","line":"          class _never_use_this_overload>"},
{"lineNum":"  816","line":"KOKKOS_INLINE_FUNCTION_DELETED Impl::TeamThreadRangeBoundariesStruct<"},
{"lineNum":"  817","line":"    typename std::common_type<iType1, iType2>::type, TeamMemberType>"},
{"lineNum":"  818","line":"TeamThreadRange(const TeamMemberType&, const iType1& begin,"},
{"lineNum":"  819","line":"                const iType2& end) = delete;"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"/** \\brief  Execution policy for parallel work over a threads within a team."},
{"lineNum":"  822","line":" *"},
{"lineNum":"  823","line":" *  The range is split over all threads in a team. The Mapping scheme depends on"},
{"lineNum":"  824","line":" * the architecture. This policy is used together with a parallel pattern as a"},
{"lineNum":"  825","line":" * nested layer within a kernel launched with the TeamPolicy. This variant"},
{"lineNum":"  826","line":" * expects a single count. So the range is (0,count]."},
{"lineNum":"  827","line":" */"},
{"lineNum":"  828","line":"template <typename iType, class TeamMemberType, class _never_use_this_overload>"},
{"lineNum":"  829","line":"KOKKOS_INLINE_FUNCTION_DELETED"},
{"lineNum":"  830","line":"    Impl::TeamThreadRangeBoundariesStruct<iType, TeamMemberType>"},
{"lineNum":"  831","line":"    TeamVectorRange(const TeamMemberType&, const iType& count) = delete;"},
{"lineNum":"  832","line":""},
{"lineNum":"  833","line":"/** \\brief  Execution policy for parallel work over a threads within a team."},
{"lineNum":"  834","line":" *"},
{"lineNum":"  835","line":" *  The range is split over all threads in a team. The Mapping scheme depends on"},
{"lineNum":"  836","line":" * the architecture. This policy is used together with a parallel pattern as a"},
{"lineNum":"  837","line":" * nested layer within a kernel launched with the TeamPolicy. This variant"},
{"lineNum":"  838","line":" * expects a begin and end. So the range is (begin,end]."},
{"lineNum":"  839","line":" */"},
{"lineNum":"  840","line":"template <typename iType1, typename iType2, class TeamMemberType,"},
{"lineNum":"  841","line":"          class _never_use_this_overload>"},
{"lineNum":"  842","line":"KOKKOS_INLINE_FUNCTION_DELETED Impl::TeamThreadRangeBoundariesStruct<"},
{"lineNum":"  843","line":"    typename std::common_type<iType1, iType2>::type, TeamMemberType>"},
{"lineNum":"  844","line":"TeamVectorRange(const TeamMemberType&, const iType1& begin,"},
{"lineNum":"  845","line":"                const iType2& end) = delete;"},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"/** \\brief  Execution policy for a vector parallel loop."},
{"lineNum":"  848","line":" *"},
{"lineNum":"  849","line":" *  The range is split over all vector lanes in a thread. The Mapping scheme"},
{"lineNum":"  850","line":" * depends on the architecture. This policy is used together with a parallel"},
{"lineNum":"  851","line":" * pattern as a nested layer within a kernel launched with the TeamPolicy. This"},
{"lineNum":"  852","line":" * variant expects a single count. So the range is (0,count]."},
{"lineNum":"  853","line":" */"},
{"lineNum":"  854","line":"template <typename iType, class TeamMemberType, class _never_use_this_overload>"},
{"lineNum":"  855","line":"KOKKOS_INLINE_FUNCTION_DELETED"},
{"lineNum":"  856","line":"    Impl::ThreadVectorRangeBoundariesStruct<iType, TeamMemberType>"},
{"lineNum":"  857","line":"    ThreadVectorRange(const TeamMemberType&, const iType& count) = delete;"},
{"lineNum":"  858","line":""},
{"lineNum":"  859","line":"template <typename iType1, typename iType2, class TeamMemberType,"},
{"lineNum":"  860","line":"          class _never_use_this_overload>"},
{"lineNum":"  861","line":"KOKKOS_INLINE_FUNCTION_DELETED Impl::ThreadVectorRangeBoundariesStruct<"},
{"lineNum":"  862","line":"    typename std::common_type<iType1, iType2>::type, TeamMemberType>"},
{"lineNum":"  863","line":"ThreadVectorRange(const TeamMemberType&, const iType1& arg_begin,"},
{"lineNum":"  864","line":"                  const iType2& arg_end) = delete;"},
{"lineNum":"  865","line":""},
{"lineNum":"  866","line":"namespace Impl {"},
{"lineNum":"  867","line":""},
{"lineNum":"  868","line":"template <typename FunctorType, typename TagType,"},
{"lineNum":"  869","line":"          bool HasTag = !std::is_same<TagType, void>::value>"},
{"lineNum":"  870","line":"struct ParallelConstructName;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  871","line":""},
{"lineNum":"  872","line":"template <typename FunctorType, typename TagType>"},
{"lineNum":"  873","line":"struct ParallelConstructName<FunctorType, TagType, true> {"},
{"lineNum":"  874","line":"  ParallelConstructName(std::string const& label) : label_ref(label) {"},
{"lineNum":"  875","line":"    if (label.empty()) {"},
{"lineNum":"  876","line":"      default_name = std::string(typeid(FunctorType).name()) + \"/\" +"},
{"lineNum":"  877","line":"                     typeid(TagType).name();"},
{"lineNum":"  878","line":"    }"},
{"lineNum":"  879","line":"  }"},
{"lineNum":"  880","line":"  std::string const& get() {"},
{"lineNum":"  881","line":"    return (label_ref.empty()) ? default_name : label_ref;"},
{"lineNum":"  882","line":"  }"},
{"lineNum":"  883","line":"  std::string const& label_ref;"},
{"lineNum":"  884","line":"  std::string default_name;"},
{"lineNum":"  885","line":"};"},
{"lineNum":"  886","line":""},
{"lineNum":"  887","line":"template <typename FunctorType, typename TagType>"},
{"lineNum":"  888","line":"struct ParallelConstructName<FunctorType, TagType, false> {"},
{"lineNum":"  889","line":"  ParallelConstructName(std::string const& label) : label_ref(label) {","class":"lineNoCov","hits":"0","possible_hits":"131",},
{"lineNum":"  890","line":"    if (label.empty()) {","class":"lineNoCov","hits":"0","possible_hits":"129",},
{"lineNum":"  891","line":"      default_name = std::string(typeid(FunctorType).name());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  892","line":"    }"},
{"lineNum":"  893","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  894","line":"  std::string const& get() {"},
{"lineNum":"  895","line":"    return (label_ref.empty()) ? default_name : label_ref;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  896","line":"  }"},
{"lineNum":"  897","line":"  std::string const& label_ref;"},
{"lineNum":"  898","line":"  std::string default_name;"},
{"lineNum":"  899","line":"};"},
{"lineNum":"  900","line":""},
{"lineNum":"  901","line":"}  // namespace Impl"},
{"lineNum":"  902","line":""},
{"lineNum":"  903","line":"}  // namespace Kokkos"},
{"lineNum":"  904","line":""},
{"lineNum":"  905","line":"namespace Kokkos {"},
{"lineNum":"  906","line":""},
{"lineNum":"  907","line":"namespace Impl {"},
{"lineNum":"  908","line":""},
{"lineNum":"  909","line":"template <class PatternTag, class... Args>"},
{"lineNum":"  910","line":"struct PatternImplSpecializationFromTag;"},
{"lineNum":"  911","line":""},
{"lineNum":"  912","line":"template <class... Args>"},
{"lineNum":"  913","line":"struct PatternImplSpecializationFromTag<Kokkos::ParallelForTag, Args...>"},
{"lineNum":"  914","line":"    : identity<ParallelFor<Args...>> {};"},
{"lineNum":"  915","line":""},
{"lineNum":"  916","line":"template <class... Args>"},
{"lineNum":"  917","line":"struct PatternImplSpecializationFromTag<Kokkos::ParallelReduceTag, Args...>"},
{"lineNum":"  918","line":"    : identity<ParallelReduce<Args...>> {};"},
{"lineNum":"  919","line":""},
{"lineNum":"  920","line":"template <class... Args>"},
{"lineNum":"  921","line":"struct PatternImplSpecializationFromTag<Kokkos::ParallelScanTag, Args...>"},
{"lineNum":"  922","line":"    : identity<ParallelScan<Args...>> {};"},
{"lineNum":"  923","line":""},
{"lineNum":"  924","line":"template <class PatternImpl>"},
{"lineNum":"  925","line":"struct PatternTagFromImplSpecialization;"},
{"lineNum":"  926","line":""},
{"lineNum":"  927","line":"template <class... Args>"},
{"lineNum":"  928","line":"struct PatternTagFromImplSpecialization<ParallelFor<Args...>>"},
{"lineNum":"  929","line":"    : identity<ParallelForTag> {};"},
{"lineNum":"  930","line":""},
{"lineNum":"  931","line":"template <class... Args>"},
{"lineNum":"  932","line":"struct PatternTagFromImplSpecialization<ParallelReduce<Args...>>"},
{"lineNum":"  933","line":"    : identity<ParallelReduceTag> {};"},
{"lineNum":"  934","line":""},
{"lineNum":"  935","line":"template <class... Args>"},
{"lineNum":"  936","line":"struct PatternTagFromImplSpecialization<ParallelScan<Args...>>"},
{"lineNum":"  937","line":"    : identity<ParallelScanTag> {};"},
{"lineNum":"  938","line":""},
{"lineNum":"  939","line":"}  // end namespace Impl"},
{"lineNum":"  940","line":""},
{"lineNum":"  941","line":"}  // namespace Kokkos"},
{"lineNum":"  942","line":"#endif /* #define KOKKOS_EXECPOLICY_HPP */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 42, "covered" : 0,};
var merged_data = [];
