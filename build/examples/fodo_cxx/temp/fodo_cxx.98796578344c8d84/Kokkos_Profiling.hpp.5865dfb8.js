var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_IMPL_KOKKOS_PROFILING_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_IMPL_KOKKOS_PROFILING_HPP"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include <Kokkos_Core_fwd.hpp>"},
{"lineNum":"   49","line":"#include <Kokkos_ExecPolicy.hpp>"},
{"lineNum":"   50","line":"#include <Kokkos_Macros.hpp>"},
{"lineNum":"   51","line":"#include <Kokkos_Tuners.hpp>"},
{"lineNum":"   52","line":"#include <impl/Kokkos_Profiling_Interface.hpp>"},
{"lineNum":"   53","line":"#include <map>"},
{"lineNum":"   54","line":"#include <string>"},
{"lineNum":"   55","line":"#include <type_traits>"},
{"lineNum":"   56","line":"namespace Kokkos {"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"// forward declaration"},
{"lineNum":"   59","line":"bool tune_internals() noexcept;"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"namespace Tools {"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"bool profileLibraryLoaded();"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"void beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,"},
{"lineNum":"   66","line":"                      uint64_t* kernelID);"},
{"lineNum":"   67","line":"void endParallelFor(const uint64_t kernelID);"},
{"lineNum":"   68","line":"void beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,"},
{"lineNum":"   69","line":"                       uint64_t* kernelID);"},
{"lineNum":"   70","line":"void endParallelScan(const uint64_t kernelID);"},
{"lineNum":"   71","line":"void beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,"},
{"lineNum":"   72","line":"                         uint64_t* kernelID);"},
{"lineNum":"   73","line":"void endParallelReduce(const uint64_t kernelID);"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"void pushRegion(const std::string& kName);"},
{"lineNum":"   76","line":"void popRegion();"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"void createProfileSection(const std::string& sectionName, uint32_t* secID);"},
{"lineNum":"   79","line":"void startSection(const uint32_t secID);"},
{"lineNum":"   80","line":"void stopSection(const uint32_t secID);"},
{"lineNum":"   81","line":"void destroyProfileSection(const uint32_t secID);"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"void markEvent(const std::string& evName);"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"void allocateData(const SpaceHandle space, const std::string label,"},
{"lineNum":"   86","line":"                  const void* ptr, const uint64_t size);"},
{"lineNum":"   87","line":"void deallocateData(const SpaceHandle space, const std::string label,"},
{"lineNum":"   88","line":"                    const void* ptr, const uint64_t size);"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"void beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,"},
{"lineNum":"   91","line":"                   const void* dst_ptr, const SpaceHandle src_space,"},
{"lineNum":"   92","line":"                   const std::string src_label, const void* src_ptr,"},
{"lineNum":"   93","line":"                   const uint64_t size);"},
{"lineNum":"   94","line":"void endDeepCopy();"},
{"lineNum":"   95","line":"void beginFence(const std::string name, const uint32_t deviceId,"},
{"lineNum":"   96","line":"                uint64_t* handle);"},
{"lineNum":"   97","line":"void endFence(const uint64_t handle);"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"/**"},
{"lineNum":"  100","line":" * syncDualView declares to the tool that a given DualView"},
{"lineNum":"  101","line":" * has been synced."},
{"lineNum":"  102","line":" *"},
{"lineNum":"  103","line":" * Arguments:"},
{"lineNum":"  104","line":" *"},
{"lineNum":"  105","line":" * label:     name of the View within the DualView"},
{"lineNum":"  106","line":" * ptr:       that View\'s data ptr"},
{"lineNum":"  107","line":" * to_device: true if the data is being synchronized to the device"},
{"lineNum":"  108","line":" * \t\tfalse otherwise"},
{"lineNum":"  109","line":" */"},
{"lineNum":"  110","line":"void syncDualView(const std::string& label, const void* const ptr,"},
{"lineNum":"  111","line":"                  bool to_device);"},
{"lineNum":"  112","line":"/**"},
{"lineNum":"  113","line":" * modifyDualView declares to the tool that a given DualView"},
{"lineNum":"  114","line":" * has been modified. Note: this means that somebody *called*"},
{"lineNum":"  115","line":" * modify on the DualView, this doesn\'t get called any time"},
{"lineNum":"  116","line":" * somebody touches the data"},
{"lineNum":"  117","line":" *"},
{"lineNum":"  118","line":" * Arguments:"},
{"lineNum":"  119","line":" *"},
{"lineNum":"  120","line":" * label:     name of the View within the DualView"},
{"lineNum":"  121","line":" * ptr:       that View\'s data ptr"},
{"lineNum":"  122","line":" * on_device: true if the data is being modified on the device"},
{"lineNum":"  123","line":" * \t\tfalse otherwise"},
{"lineNum":"  124","line":" */"},
{"lineNum":"  125","line":"void modifyDualView(const std::string& label, const void* const ptr,"},
{"lineNum":"  126","line":"                    bool on_device);"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"void declareMetadata(const std::string& key, const std::string& value);"},
{"lineNum":"  129","line":"void initialize(const std::string& = {});"},
{"lineNum":"  130","line":"void finalize();"},
{"lineNum":"  131","line":"bool printHelp(const std::string&);"},
{"lineNum":"  132","line":"void parseArgs(const std::string&);"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"Kokkos_Profiling_SpaceHandle make_space_handle(const char* space_name);"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"namespace Experimental {"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"void set_init_callback(initFunction callback);"},
{"lineNum":"  139","line":"void set_finalize_callback(finalizeFunction callback);"},
{"lineNum":"  140","line":"void set_parse_args_callback(parseArgsFunction callback);"},
{"lineNum":"  141","line":"void set_print_help_callback(printHelpFunction callback);"},
{"lineNum":"  142","line":"void set_begin_parallel_for_callback(beginFunction callback);"},
{"lineNum":"  143","line":"void set_end_parallel_for_callback(endFunction callback);"},
{"lineNum":"  144","line":"void set_begin_parallel_reduce_callback(beginFunction callback);"},
{"lineNum":"  145","line":"void set_end_parallel_reduce_callback(endFunction callback);"},
{"lineNum":"  146","line":"void set_begin_parallel_scan_callback(beginFunction callback);"},
{"lineNum":"  147","line":"void set_end_parallel_scan_callback(endFunction callback);"},
{"lineNum":"  148","line":"void set_push_region_callback(pushFunction callback);"},
{"lineNum":"  149","line":"void set_pop_region_callback(popFunction callback);"},
{"lineNum":"  150","line":"void set_allocate_data_callback(allocateDataFunction callback);"},
{"lineNum":"  151","line":"void set_deallocate_data_callback(deallocateDataFunction callback);"},
{"lineNum":"  152","line":"void set_create_profile_section_callback(createProfileSectionFunction callback);"},
{"lineNum":"  153","line":"void set_start_profile_section_callback(startProfileSectionFunction callback);"},
{"lineNum":"  154","line":"void set_stop_profile_section_callback(stopProfileSectionFunction callback);"},
{"lineNum":"  155","line":"void set_destroy_profile_section_callback("},
{"lineNum":"  156","line":"    destroyProfileSectionFunction callback);"},
{"lineNum":"  157","line":"void set_profile_event_callback(profileEventFunction callback);"},
{"lineNum":"  158","line":"void set_begin_deep_copy_callback(beginDeepCopyFunction callback);"},
{"lineNum":"  159","line":"void set_end_deep_copy_callback(endDeepCopyFunction callback);"},
{"lineNum":"  160","line":"void set_begin_fence_callback(beginFenceFunction callback);"},
{"lineNum":"  161","line":"void set_end_fence_callback(endFenceFunction callback);"},
{"lineNum":"  162","line":"void set_dual_view_sync_callback(dualViewSyncFunction callback);"},
{"lineNum":"  163","line":"void set_dual_view_modify_callback(dualViewModifyFunction callback);"},
{"lineNum":"  164","line":"void set_declare_metadata_callback(declareMetadataFunction callback);"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"void set_declare_output_type_callback(outputTypeDeclarationFunction callback);"},
{"lineNum":"  167","line":"void set_declare_input_type_callback(inputTypeDeclarationFunction callback);"},
{"lineNum":"  168","line":"void set_request_output_values_callback(requestValueFunction callback);"},
{"lineNum":"  169","line":"void set_declare_optimization_goal_callback("},
{"lineNum":"  170","line":"    optimizationGoalDeclarationFunction callback);"},
{"lineNum":"  171","line":"void set_end_context_callback(contextEndFunction callback);"},
{"lineNum":"  172","line":"void set_begin_context_callback(contextBeginFunction callback);"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"void pause_tools();"},
{"lineNum":"  175","line":"void resume_tools();"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"EventSet get_callbacks();"},
{"lineNum":"  178","line":"void set_callbacks(EventSet new_events);"},
{"lineNum":"  179","line":"}  // namespace Experimental"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"namespace Experimental {"},
{"lineNum":"  182","line":"// forward declarations"},
{"lineNum":"  183","line":"size_t get_new_context_id();"},
{"lineNum":"  184","line":"size_t get_current_context_id();"},
{"lineNum":"  185","line":"}  // namespace Experimental"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"namespace Impl {"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"static std::map<std::string, Kokkos::Tools::Experimental::TeamSizeTuner>"},
{"lineNum":"  190","line":"    team_tuners;","class":"lineCov","hits":"1","order":"705","possible_hits":"1",},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"template <int Rank>"},
{"lineNum":"  193","line":"using MDRangeTuningMap ="},
{"lineNum":"  194","line":"    std::map<std::string, Kokkos::Tools::Experimental::MDRangeTuner<Rank>>;"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"template <int Rank>"},
{"lineNum":"  197","line":"static MDRangeTuningMap<Rank> mdrange_tuners;"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"// For any policies without a tuning implementation, with a reducer"},
{"lineNum":"  200","line":"template <class ReducerType, class ExecPolicy, class Functor, typename TagType>"},
{"lineNum":"  201","line":"void tune_policy(const size_t, const std::string&, ExecPolicy&, const Functor&,"},
{"lineNum":"  202","line":"                 TagType) {}"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"// For any policies without a tuning implementation, without a reducer"},
{"lineNum":"  205","line":"template <class ExecPolicy, class Functor, typename TagType>"},
{"lineNum":"  206","line":"void tune_policy(const size_t, const std::string&, ExecPolicy&, const Functor&,"},
{"lineNum":"  207","line":"                 const TagType&) {}"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"/**"},
{"lineNum":"  210","line":" * Tuning for parallel_fors and parallel_scans is a fairly simple process."},
{"lineNum":"  211","line":" *"},
{"lineNum":"  212","line":" * Tuning for a parallel_reduce turns out to be a little more complicated."},
{"lineNum":"  213","line":" *"},
{"lineNum":"  214","line":" * If you\'re tuning a reducer, it might be a complex or a simple reducer"},
{"lineNum":"  215","line":" * (an example of simple would be one where the join is just \"+\"."},
{"lineNum":"  216","line":" *"},
{"lineNum":"  217","line":" * Unfortunately these two paths are very different in terms of which classes"},
{"lineNum":"  218","line":" * get instantiated. Thankfully, all of this complexity is encoded in the"},
{"lineNum":"  219","line":" * ReducerType. If it\'s a \"simple\" reducer, this will be Kokkos::InvalidType,"},
{"lineNum":"  220","line":" * otherwise it\'ll be something else."},
{"lineNum":"  221","line":" *"},
{"lineNum":"  222","line":" * If the type is complex, for the code to be generally right you _must_"},
{"lineNum":"  223","line":" * pass an instance of that ReducerType to functions that determine"},
{"lineNum":"  224","line":" * eligible team sizes. If the type is simple, you can\'t construct one,"},
{"lineNum":"  225","line":" * you use the simpler 2-arg formulation of team_size_recommended/max."},
{"lineNum":"  226","line":" */"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"namespace Impl {"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"struct SimpleTeamSizeCalculator {"},
{"lineNum":"  231","line":"  template <typename Policy, typename Functor, typename Tag>"},
{"lineNum":"  232","line":"  int get_max_team_size(const Policy& policy, const Functor& functor,"},
{"lineNum":"  233","line":"                        const Tag tag) {"},
{"lineNum":"  234","line":"    auto max = policy.team_size_max(functor, tag);"},
{"lineNum":"  235","line":"    return max;"},
{"lineNum":"  236","line":"  }"},
{"lineNum":"  237","line":"  template <typename Policy, typename Functor, typename Tag>"},
{"lineNum":"  238","line":"  int get_recommended_team_size(const Policy& policy, const Functor& functor,"},
{"lineNum":"  239","line":"                                const Tag tag) {"},
{"lineNum":"  240","line":"    auto max = policy.team_size_recommended(functor, tag);"},
{"lineNum":"  241","line":"    return max;"},
{"lineNum":"  242","line":"  }"},
{"lineNum":"  243","line":"  template <typename Policy, typename Functor>"},
{"lineNum":"  244","line":"  int get_mdrange_max_tile_size_product(const Policy& policy,"},
{"lineNum":"  245","line":"                                        const Functor& functor,"},
{"lineNum":"  246","line":"                                        const Kokkos::ParallelForTag&) {"},
{"lineNum":"  247","line":"    using exec_space = typename Policy::execution_space;"},
{"lineNum":"  248","line":"    using driver     = Kokkos::Impl::ParallelFor<Functor, Policy, exec_space>;"},
{"lineNum":"  249","line":"    return driver::max_tile_size_product(policy, functor);"},
{"lineNum":"  250","line":"  }"},
{"lineNum":"  251","line":"  template <typename Policy, typename Functor>"},
{"lineNum":"  252","line":"  int get_mdrange_max_tile_size_product(const Policy& policy,"},
{"lineNum":"  253","line":"                                        const Functor& functor,"},
{"lineNum":"  254","line":"                                        const Kokkos::ParallelReduceTag&) {"},
{"lineNum":"  255","line":"    using exec_space = typename Policy::execution_space;"},
{"lineNum":"  256","line":"    using driver ="},
{"lineNum":"  257","line":"        Kokkos::Impl::ParallelReduce<Functor, Policy, Kokkos::InvalidType,"},
{"lineNum":"  258","line":"                                     exec_space>;"},
{"lineNum":"  259","line":"    return driver::max_tile_size_product(policy, functor);"},
{"lineNum":"  260","line":"  }"},
{"lineNum":"  261","line":"};"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"// when we have a complex reducer, we need to pass an"},
{"lineNum":"  264","line":"// instance to team_size_recommended/max. Reducers"},
{"lineNum":"  265","line":"// aren\'t default constructible, but they are"},
{"lineNum":"  266","line":"// constructible from a reference to an"},
{"lineNum":"  267","line":"// instance of their value_type so we construct"},
{"lineNum":"  268","line":"// a value_type and temporary reducer here"},
{"lineNum":"  269","line":"template <typename ReducerType>"},
{"lineNum":"  270","line":"struct ComplexReducerSizeCalculator {"},
{"lineNum":"  271","line":"  template <typename Policy, typename Functor, typename Tag>"},
{"lineNum":"  272","line":"  int get_max_team_size(const Policy& policy, const Functor& functor,"},
{"lineNum":"  273","line":"                        const Tag tag) {"},
{"lineNum":"  274","line":"    using value_type = typename ReducerType::value_type;"},
{"lineNum":"  275","line":"    value_type value;"},
{"lineNum":"  276","line":"    ReducerType reducer_example = ReducerType(value);"},
{"lineNum":"  277","line":"    return policy.team_size_max(functor, reducer_example, tag);"},
{"lineNum":"  278","line":"  }"},
{"lineNum":"  279","line":"  template <typename Policy, typename Functor, typename Tag>"},
{"lineNum":"  280","line":"  int get_recommended_team_size(const Policy& policy, const Functor& functor,"},
{"lineNum":"  281","line":"                                const Tag tag) {"},
{"lineNum":"  282","line":"    using value_type = typename ReducerType::value_type;"},
{"lineNum":"  283","line":"    value_type value;"},
{"lineNum":"  284","line":"    ReducerType reducer_example = ReducerType(value);"},
{"lineNum":"  285","line":"    return policy.team_size_recommended(functor, reducer_example, tag);"},
{"lineNum":"  286","line":"  }"},
{"lineNum":"  287","line":"  template <typename Policy, typename Functor>"},
{"lineNum":"  288","line":"  int get_mdrange_max_tile_size_product(const Policy& policy,"},
{"lineNum":"  289","line":"                                        const Functor& functor,"},
{"lineNum":"  290","line":"                                        const Kokkos::ParallelReduceTag&) {"},
{"lineNum":"  291","line":"    using exec_space = typename Policy::execution_space;"},
{"lineNum":"  292","line":"    using driver ="},
{"lineNum":"  293","line":"        Kokkos::Impl::ParallelReduce<Functor, Policy, ReducerType, exec_space>;"},
{"lineNum":"  294","line":"    return driver::max_tile_size_product(policy, functor);"},
{"lineNum":"  295","line":"  }"},
{"lineNum":"  296","line":"};"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"}  // namespace Impl"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"template <class Tuner, class Functor, class TagType,"},
{"lineNum":"  301","line":"          class TuningPermissionFunctor, class Map, class Policy>"},
{"lineNum":"  302","line":"void generic_tune_policy(const std::string& label_in, Map& map, Policy& policy,"},
{"lineNum":"  303","line":"                         const Functor& functor, const TagType& tag,"},
{"lineNum":"  304","line":"                         const TuningPermissionFunctor& should_tune) {"},
{"lineNum":"  305","line":"  if (should_tune(policy)) {"},
{"lineNum":"  306","line":"    std::string label = label_in;"},
{"lineNum":"  307","line":"    if (label_in.empty()) {"},
{"lineNum":"  308","line":"      using policy_type ="},
{"lineNum":"  309","line":"          typename std::remove_reference<decltype(policy)>::type;"},
{"lineNum":"  310","line":"      using work_tag = typename policy_type::work_tag;"},
{"lineNum":"  311","line":"      Kokkos::Impl::ParallelConstructName<Functor, work_tag> name(label);"},
{"lineNum":"  312","line":"      label = name.get();"},
{"lineNum":"  313","line":"    }"},
{"lineNum":"  314","line":"    auto tuner_iter = [&]() {"},
{"lineNum":"  315","line":"      auto my_tuner = map.find(label);"},
{"lineNum":"  316","line":"      if (my_tuner == map.end()) {"},
{"lineNum":"  317","line":"        return (map.emplace(label, Tuner(label, policy, functor, tag,"},
{"lineNum":"  318","line":"                                         Impl::SimpleTeamSizeCalculator{}))"},
{"lineNum":"  319","line":"                    .first);"},
{"lineNum":"  320","line":"      }"},
{"lineNum":"  321","line":"      return my_tuner;"},
{"lineNum":"  322","line":"    }();"},
{"lineNum":"  323","line":"    tuner_iter->second.tune(policy);"},
{"lineNum":"  324","line":"  }"},
{"lineNum":"  325","line":"}"},
{"lineNum":"  326","line":"template <class Tuner, class ReducerType, class Functor, class TagType,"},
{"lineNum":"  327","line":"          class TuningPermissionFunctor, class Map, class Policy>"},
{"lineNum":"  328","line":"void generic_tune_policy(const std::string& label_in, Map& map, Policy& policy,"},
{"lineNum":"  329","line":"                         const Functor& functor, const TagType& tag,"},
{"lineNum":"  330","line":"                         const TuningPermissionFunctor& should_tune) {"},
{"lineNum":"  331","line":"  if (should_tune(policy)) {"},
{"lineNum":"  332","line":"    std::string label = label_in;"},
{"lineNum":"  333","line":"    if (label_in.empty()) {"},
{"lineNum":"  334","line":"      using policy_type ="},
{"lineNum":"  335","line":"          typename std::remove_reference<decltype(policy)>::type;"},
{"lineNum":"  336","line":"      using work_tag = typename policy_type::work_tag;"},
{"lineNum":"  337","line":"      Kokkos::Impl::ParallelConstructName<Functor, work_tag> name(label);"},
{"lineNum":"  338","line":"      label = name.get();"},
{"lineNum":"  339","line":"    }"},
{"lineNum":"  340","line":"    auto tuner_iter = [&]() {"},
{"lineNum":"  341","line":"      auto my_tuner = map.find(label);"},
{"lineNum":"  342","line":"      if (my_tuner == map.end()) {"},
{"lineNum":"  343","line":"        return (map.emplace("},
{"lineNum":"  344","line":"                       label,"},
{"lineNum":"  345","line":"                       Tuner(label, policy, functor, tag,"},
{"lineNum":"  346","line":"                             Impl::ComplexReducerSizeCalculator<ReducerType>{}))"},
{"lineNum":"  347","line":"                    .first);"},
{"lineNum":"  348","line":"      }"},
{"lineNum":"  349","line":"      return my_tuner;"},
{"lineNum":"  350","line":"    }();"},
{"lineNum":"  351","line":"    tuner_iter->second.tune(policy);"},
{"lineNum":"  352","line":"  }"},
{"lineNum":"  353","line":"}"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"// tune a TeamPolicy, without reducer"},
{"lineNum":"  356","line":"template <class Functor, class TagType, class... Properties>"},
{"lineNum":"  357","line":"void tune_policy(const size_t /**tuning_context*/, const std::string& label_in,"},
{"lineNum":"  358","line":"                 Kokkos::TeamPolicy<Properties...>& policy,"},
{"lineNum":"  359","line":"                 const Functor& functor, const TagType& tag) {"},
{"lineNum":"  360","line":"  generic_tune_policy<Experimental::TeamSizeTuner>("},
{"lineNum":"  361","line":"      label_in, team_tuners, policy, functor, tag,"},
{"lineNum":"  362","line":"      [](const Kokkos::TeamPolicy<Properties...>& candidate_policy) {"},
{"lineNum":"  363","line":"        return (candidate_policy.impl_auto_team_size() ||"},
{"lineNum":"  364","line":"                candidate_policy.impl_auto_vector_length());"},
{"lineNum":"  365","line":"      });"},
{"lineNum":"  366","line":"}"},
{"lineNum":"  367","line":""},
{"lineNum":"  368","line":"// tune a TeamPolicy, with reducer"},
{"lineNum":"  369","line":"template <class ReducerType, class Functor, class TagType, class... Properties>"},
{"lineNum":"  370","line":"void tune_policy(const size_t /**tuning_context*/, const std::string& label_in,"},
{"lineNum":"  371","line":"                 Kokkos::TeamPolicy<Properties...>& policy,"},
{"lineNum":"  372","line":"                 const Functor& functor, const TagType& tag) {"},
{"lineNum":"  373","line":"  generic_tune_policy<Experimental::TeamSizeTuner, ReducerType>("},
{"lineNum":"  374","line":"      label_in, team_tuners, policy, functor, tag,"},
{"lineNum":"  375","line":"      [](const Kokkos::TeamPolicy<Properties...>& candidate_policy) {"},
{"lineNum":"  376","line":"        return (candidate_policy.impl_auto_team_size() ||"},
{"lineNum":"  377","line":"                candidate_policy.impl_auto_vector_length());"},
{"lineNum":"  378","line":"      });"},
{"lineNum":"  379","line":"}"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"// tune a MDRangePolicy, without reducer"},
{"lineNum":"  382","line":"template <class Functor, class TagType, class... Properties>"},
{"lineNum":"  383","line":"void tune_policy(const size_t /**tuning_context*/, const std::string& label_in,"},
{"lineNum":"  384","line":"                 Kokkos::MDRangePolicy<Properties...>& policy,"},
{"lineNum":"  385","line":"                 const Functor& functor, const TagType& tag) {"},
{"lineNum":"  386","line":"  using Policy              = Kokkos::MDRangePolicy<Properties...>;"},
{"lineNum":"  387","line":"  static constexpr int rank = Policy::rank;"},
{"lineNum":"  388","line":"  generic_tune_policy<Experimental::MDRangeTuner<rank>>("},
{"lineNum":"  389","line":"      label_in, mdrange_tuners<rank>, policy, functor, tag,"},
{"lineNum":"  390","line":"      [](const Policy& candidate_policy) {"},
{"lineNum":"  391","line":"        return candidate_policy.impl_tune_tile_size();"},
{"lineNum":"  392","line":"      });"},
{"lineNum":"  393","line":"}"},
{"lineNum":"  394","line":""},
{"lineNum":"  395","line":"// tune a MDRangePolicy, with reducer"},
{"lineNum":"  396","line":"template <class ReducerType, class Functor, class TagType, class... Properties>"},
{"lineNum":"  397","line":"void tune_policy(const size_t /**tuning_context*/, const std::string& label_in,"},
{"lineNum":"  398","line":"                 Kokkos::MDRangePolicy<Properties...>& policy,"},
{"lineNum":"  399","line":"                 const Functor& functor, const TagType& tag) {"},
{"lineNum":"  400","line":"  using Policy              = Kokkos::MDRangePolicy<Properties...>;"},
{"lineNum":"  401","line":"  static constexpr int rank = Policy::rank;"},
{"lineNum":"  402","line":"  generic_tune_policy<Experimental::MDRangeTuner<rank>, ReducerType>("},
{"lineNum":"  403","line":"      label_in, mdrange_tuners<rank>, policy, functor, tag,"},
{"lineNum":"  404","line":"      [](const Policy& candidate_policy) {"},
{"lineNum":"  405","line":"        return candidate_policy.impl_tune_tile_size();"},
{"lineNum":"  406","line":"      });"},
{"lineNum":"  407","line":"}"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"template <class ReducerType>"},
{"lineNum":"  410","line":"struct ReductionSwitcher {"},
{"lineNum":"  411","line":"  template <class Functor, class TagType, class ExecPolicy>"},
{"lineNum":"  412","line":"  static void tune(const size_t tuning_context, const std::string& label,"},
{"lineNum":"  413","line":"                   ExecPolicy& policy, const Functor& functor,"},
{"lineNum":"  414","line":"                   const TagType& tag) {"},
{"lineNum":"  415","line":"    if (Kokkos::tune_internals()) {"},
{"lineNum":"  416","line":"      tune_policy<ReducerType>(tuning_context, label, policy, functor, tag);"},
{"lineNum":"  417","line":"    }"},
{"lineNum":"  418","line":"  }"},
{"lineNum":"  419","line":"};"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"template <>"},
{"lineNum":"  422","line":"struct ReductionSwitcher<Kokkos::InvalidType> {"},
{"lineNum":"  423","line":"  template <class Functor, class TagType, class ExecPolicy>"},
{"lineNum":"  424","line":"  static void tune(const size_t tuning_context, const std::string& label,"},
{"lineNum":"  425","line":"                   ExecPolicy& policy, const Functor& functor,"},
{"lineNum":"  426","line":"                   const TagType& tag) {"},
{"lineNum":"  427","line":"    if (Kokkos::tune_internals()) {"},
{"lineNum":"  428","line":"      tune_policy(tuning_context, label, policy, functor, tag);"},
{"lineNum":"  429","line":"    }"},
{"lineNum":"  430","line":"  }"},
{"lineNum":"  431","line":"};"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"template <class Tuner, class Functor, class TagType,"},
{"lineNum":"  434","line":"          class TuningPermissionFunctor, class Map, class Policy>"},
{"lineNum":"  435","line":"void generic_report_results(const std::string& label_in, Map& map,"},
{"lineNum":"  436","line":"                            Policy& policy, const Functor&, const TagType&,"},
{"lineNum":"  437","line":"                            const TuningPermissionFunctor& should_tune) {"},
{"lineNum":"  438","line":"  if (should_tune(policy)) {"},
{"lineNum":"  439","line":"    std::string label = label_in;"},
{"lineNum":"  440","line":"    if (label_in.empty()) {"},
{"lineNum":"  441","line":"      using policy_type ="},
{"lineNum":"  442","line":"          typename std::remove_reference<decltype(policy)>::type;"},
{"lineNum":"  443","line":"      using work_tag = typename policy_type::work_tag;"},
{"lineNum":"  444","line":"      Kokkos::Impl::ParallelConstructName<Functor, work_tag> name(label);"},
{"lineNum":"  445","line":"      label = name.get();"},
{"lineNum":"  446","line":"    }"},
{"lineNum":"  447","line":"    auto tuner_iter = map[label];"},
{"lineNum":"  448","line":"    tuner_iter.end();"},
{"lineNum":"  449","line":"  }"},
{"lineNum":"  450","line":"}"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"// report results for a policy type we don\'t tune (do nothing)"},
{"lineNum":"  453","line":"template <class ExecPolicy, class Functor, typename TagType>"},
{"lineNum":"  454","line":"void report_policy_results(const size_t, const std::string&, ExecPolicy&,"},
{"lineNum":"  455","line":"                           const Functor&, const TagType&) {}"},
{"lineNum":"  456","line":""},
{"lineNum":"  457","line":"// report results for a TeamPolicy"},
{"lineNum":"  458","line":"template <class Functor, class TagType, class... Properties>"},
{"lineNum":"  459","line":"void report_policy_results(const size_t /**tuning_context*/,"},
{"lineNum":"  460","line":"                           const std::string& label_in,"},
{"lineNum":"  461","line":"                           Kokkos::TeamPolicy<Properties...>& policy,"},
{"lineNum":"  462","line":"                           const Functor& functor, const TagType& tag) {"},
{"lineNum":"  463","line":"  generic_report_results<Experimental::TeamSizeTuner>("},
{"lineNum":"  464","line":"      label_in, team_tuners, policy, functor, tag,"},
{"lineNum":"  465","line":"      [](const Kokkos::TeamPolicy<Properties...>& candidate_policy) {"},
{"lineNum":"  466","line":"        return (candidate_policy.impl_auto_team_size() ||"},
{"lineNum":"  467","line":"                candidate_policy.impl_auto_vector_length());"},
{"lineNum":"  468","line":"      });"},
{"lineNum":"  469","line":"}"},
{"lineNum":"  470","line":""},
{"lineNum":"  471","line":"// report results for an MDRangePolicy"},
{"lineNum":"  472","line":"template <class Functor, class TagType, class... Properties>"},
{"lineNum":"  473","line":"void report_policy_results(const size_t /**tuning_context*/,"},
{"lineNum":"  474","line":"                           const std::string& label_in,"},
{"lineNum":"  475","line":"                           Kokkos::MDRangePolicy<Properties...>& policy,"},
{"lineNum":"  476","line":"                           const Functor& functor, const TagType& tag) {"},
{"lineNum":"  477","line":"  using Policy              = Kokkos::MDRangePolicy<Properties...>;"},
{"lineNum":"  478","line":"  static constexpr int rank = Policy::rank;"},
{"lineNum":"  479","line":"  generic_report_results<Experimental::MDRangeTuner<rank>>("},
{"lineNum":"  480","line":"      label_in, mdrange_tuners<rank>, policy, functor, tag,"},
{"lineNum":"  481","line":"      [](const Policy& candidate_policy) {"},
{"lineNum":"  482","line":"        return candidate_policy.impl_tune_tile_size();"},
{"lineNum":"  483","line":"      });"},
{"lineNum":"  484","line":"}"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"template <class ExecPolicy, class FunctorType>"},
{"lineNum":"  487","line":"void begin_parallel_for(ExecPolicy& policy, FunctorType& functor,"},
{"lineNum":"  488","line":"                        const std::string& label, uint64_t& kpID) {","class":"lineNoCov","hits":"0","possible_hits":"78",},
{"lineNum":"  489","line":"  if (Kokkos::Tools::profileLibraryLoaded()) {","class":"lineNoCov","hits":"0","possible_hits":"112",},
{"lineNum":"  490","line":"    Kokkos::Impl::ParallelConstructName<FunctorType,"},
{"lineNum":"  491","line":"                                        typename ExecPolicy::work_tag>"},
{"lineNum":"  492","line":"        name(label);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  493","line":"    Kokkos::Tools::beginParallelFor(","class":"lineNoCov","hits":"0","possible_hits":"112",},
{"lineNum":"  494","line":"        name.get(), Kokkos::Profiling::Experimental::device_id(policy.space()),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  495","line":"        &kpID);"},
{"lineNum":"  496","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  497","line":"#ifdef KOKKOS_ENABLE_TUNING"},
{"lineNum":"  498","line":"  size_t context_id = Kokkos::Tools::Experimental::get_new_context_id();"},
{"lineNum":"  499","line":"  if (Kokkos::tune_internals()) {"},
{"lineNum":"  500","line":"    tune_policy(context_id, label, policy, functor, Kokkos::ParallelForTag{});"},
{"lineNum":"  501","line":"  }"},
{"lineNum":"  502","line":"#else"},
{"lineNum":"  503","line":"  (void)functor;"},
{"lineNum":"  504","line":"#endif"},
{"lineNum":"  505","line":"}","class":"lineNoCov","hits":"0","possible_hits":"78",},
{"lineNum":"  506","line":""},
{"lineNum":"  507","line":"template <class ExecPolicy, class FunctorType>"},
{"lineNum":"  508","line":"void end_parallel_for(ExecPolicy& policy, FunctorType& functor,"},
{"lineNum":"  509","line":"                      const std::string& label, uint64_t& kpID) {"},
{"lineNum":"  510","line":"  if (Kokkos::Tools::profileLibraryLoaded()) {","class":"lineNoCov","hits":"0","possible_hits":"114",},
{"lineNum":"  511","line":"    Kokkos::Tools::endParallelFor(kpID);","class":"lineNoCov","hits":"0","possible_hits":"114",},
{"lineNum":"  512","line":"  }"},
{"lineNum":"  513","line":"#ifdef KOKKOS_ENABLE_TUNING"},
{"lineNum":"  514","line":"  size_t context_id = Kokkos::Tools::Experimental::get_current_context_id();"},
{"lineNum":"  515","line":"  if (Kokkos::tune_internals()) {"},
{"lineNum":"  516","line":"    report_policy_results(context_id, label, policy, functor,"},
{"lineNum":"  517","line":"                          Kokkos::ParallelForTag{});"},
{"lineNum":"  518","line":"  }"},
{"lineNum":"  519","line":"#else"},
{"lineNum":"  520","line":"  (void)policy;"},
{"lineNum":"  521","line":"  (void)functor;"},
{"lineNum":"  522","line":"  (void)label;"},
{"lineNum":"  523","line":"#endif"},
{"lineNum":"  524","line":"}"},
{"lineNum":"  525","line":""},
{"lineNum":"  526","line":"template <class ExecPolicy, class FunctorType>"},
{"lineNum":"  527","line":"void begin_parallel_scan(ExecPolicy& policy, FunctorType& functor,"},
{"lineNum":"  528","line":"                         const std::string& label, uint64_t& kpID) {"},
{"lineNum":"  529","line":"  if (Kokkos::Tools::profileLibraryLoaded()) {"},
{"lineNum":"  530","line":"    Kokkos::Impl::ParallelConstructName<FunctorType,"},
{"lineNum":"  531","line":"                                        typename ExecPolicy::work_tag>"},
{"lineNum":"  532","line":"        name(label);"},
{"lineNum":"  533","line":"    Kokkos::Tools::beginParallelScan("},
{"lineNum":"  534","line":"        name.get(), Kokkos::Profiling::Experimental::device_id(policy.space()),"},
{"lineNum":"  535","line":"        &kpID);"},
{"lineNum":"  536","line":"  }"},
{"lineNum":"  537","line":"#ifdef KOKKOS_ENABLE_TUNING"},
{"lineNum":"  538","line":"  size_t context_id = Kokkos::Tools::Experimental::get_new_context_id();"},
{"lineNum":"  539","line":"  if (Kokkos::tune_internals()) {"},
{"lineNum":"  540","line":"    tune_policy(context_id, label, policy, functor, Kokkos::ParallelScanTag{});"},
{"lineNum":"  541","line":"  }"},
{"lineNum":"  542","line":"#else"},
{"lineNum":"  543","line":"  (void)functor;"},
{"lineNum":"  544","line":"#endif"},
{"lineNum":"  545","line":"}"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"template <class ExecPolicy, class FunctorType>"},
{"lineNum":"  548","line":"void end_parallel_scan(ExecPolicy& policy, FunctorType& functor,"},
{"lineNum":"  549","line":"                       const std::string& label, uint64_t& kpID) {"},
{"lineNum":"  550","line":"  if (Kokkos::Tools::profileLibraryLoaded()) {"},
{"lineNum":"  551","line":"    Kokkos::Tools::endParallelScan(kpID);"},
{"lineNum":"  552","line":"  }"},
{"lineNum":"  553","line":"#ifdef KOKKOS_ENABLE_TUNING"},
{"lineNum":"  554","line":"  size_t context_id = Kokkos::Tools::Experimental::get_current_context_id();"},
{"lineNum":"  555","line":"  if (Kokkos::tune_internals()) {"},
{"lineNum":"  556","line":"    report_policy_results(context_id, label, policy, functor,"},
{"lineNum":"  557","line":"                          Kokkos::ParallelScanTag{});"},
{"lineNum":"  558","line":"  }"},
{"lineNum":"  559","line":"#else"},
{"lineNum":"  560","line":"  (void)policy;"},
{"lineNum":"  561","line":"  (void)functor;"},
{"lineNum":"  562","line":"  (void)label;"},
{"lineNum":"  563","line":"#endif"},
{"lineNum":"  564","line":"}"},
{"lineNum":"  565","line":""},
{"lineNum":"  566","line":"template <class ReducerType, class ExecPolicy, class FunctorType>"},
{"lineNum":"  567","line":"void begin_parallel_reduce(ExecPolicy& policy, FunctorType& functor,"},
{"lineNum":"  568","line":"                           const std::string& label, uint64_t& kpID) {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  569","line":"  if (Kokkos::Tools::profileLibraryLoaded()) {","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  570","line":"    Kokkos::Impl::ParallelConstructName<FunctorType,"},
{"lineNum":"  571","line":"                                        typename ExecPolicy::work_tag>"},
{"lineNum":"  572","line":"        name(label);"},
{"lineNum":"  573","line":"    Kokkos::Tools::beginParallelReduce(","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  574","line":"        name.get(), Kokkos::Profiling::Experimental::device_id(policy.space()),"},
{"lineNum":"  575","line":"        &kpID);"},
{"lineNum":"  576","line":"  }"},
{"lineNum":"  577","line":"#ifdef KOKKOS_ENABLE_TUNING"},
{"lineNum":"  578","line":"  size_t context_id = Kokkos::Tools::Experimental::get_new_context_id();"},
{"lineNum":"  579","line":"  ReductionSwitcher<ReducerType>::tune(context_id, label, policy, functor,"},
{"lineNum":"  580","line":"                                       Kokkos::ParallelReduceTag{});"},
{"lineNum":"  581","line":"#else"},
{"lineNum":"  582","line":"  (void)functor;"},
{"lineNum":"  583","line":"#endif"},
{"lineNum":"  584","line":"}","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"template <class ReducerType, class ExecPolicy, class FunctorType>"},
{"lineNum":"  587","line":"void end_parallel_reduce(ExecPolicy& policy, FunctorType& functor,"},
{"lineNum":"  588","line":"                         const std::string& label, uint64_t& kpID) {"},
{"lineNum":"  589","line":"  if (Kokkos::Tools::profileLibraryLoaded()) {","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  590","line":"    Kokkos::Tools::endParallelReduce(kpID);","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  591","line":"  }"},
{"lineNum":"  592","line":"#ifdef KOKKOS_ENABLE_TUNING"},
{"lineNum":"  593","line":"  size_t context_id = Kokkos::Tools::Experimental::get_current_context_id();"},
{"lineNum":"  594","line":"  if (Kokkos::tune_internals()) {"},
{"lineNum":"  595","line":"    report_policy_results(context_id, label, policy, functor,"},
{"lineNum":"  596","line":"                          Kokkos::ParallelReduceTag{});"},
{"lineNum":"  597","line":"  }"},
{"lineNum":"  598","line":"#else"},
{"lineNum":"  599","line":"  (void)policy;"},
{"lineNum":"  600","line":"  (void)functor;"},
{"lineNum":"  601","line":"  (void)label;"},
{"lineNum":"  602","line":"#endif"},
{"lineNum":"  603","line":"}"},
{"lineNum":"  604","line":""},
{"lineNum":"  605","line":"}  // namespace Impl"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"}  // namespace Tools"},
{"lineNum":"  608","line":"namespace Profiling {"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"bool profileLibraryLoaded();"},
{"lineNum":"  611","line":""},
{"lineNum":"  612","line":"void beginParallelFor(const std::string& kernelPrefix, const uint32_t devID,"},
{"lineNum":"  613","line":"                      uint64_t* kernelID);"},
{"lineNum":"  614","line":"void beginParallelReduce(const std::string& kernelPrefix, const uint32_t devID,"},
{"lineNum":"  615","line":"                         uint64_t* kernelID);"},
{"lineNum":"  616","line":"void beginParallelScan(const std::string& kernelPrefix, const uint32_t devID,"},
{"lineNum":"  617","line":"                       uint64_t* kernelID);"},
{"lineNum":"  618","line":"void endParallelFor(const uint64_t kernelID);"},
{"lineNum":"  619","line":"void endParallelReduce(const uint64_t kernelID);"},
{"lineNum":"  620","line":"void endParallelScan(const uint64_t kernelID);"},
{"lineNum":"  621","line":"void pushRegion(const std::string& kName);"},
{"lineNum":"  622","line":"void popRegion();"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"void createProfileSection(const std::string& sectionName, uint32_t* secID);"},
{"lineNum":"  625","line":"void destroyProfileSection(const uint32_t secID);"},
{"lineNum":"  626","line":"void startSection(const uint32_t secID);"},
{"lineNum":"  627","line":""},
{"lineNum":"  628","line":"void stopSection(const uint32_t secID);"},
{"lineNum":"  629","line":""},
{"lineNum":"  630","line":"void markEvent(const std::string& eventName);"},
{"lineNum":"  631","line":"void allocateData(const SpaceHandle handle, const std::string name,"},
{"lineNum":"  632","line":"                  const void* data, const uint64_t size);"},
{"lineNum":"  633","line":"void deallocateData(const SpaceHandle space, const std::string label,"},
{"lineNum":"  634","line":"                    const void* ptr, const uint64_t size);"},
{"lineNum":"  635","line":"void beginDeepCopy(const SpaceHandle dst_space, const std::string dst_label,"},
{"lineNum":"  636","line":"                   const void* dst_ptr, const SpaceHandle src_space,"},
{"lineNum":"  637","line":"                   const std::string src_label, const void* src_ptr,"},
{"lineNum":"  638","line":"                   const uint64_t size);"},
{"lineNum":"  639","line":"void endDeepCopy();"},
{"lineNum":"  640","line":"void finalize();"},
{"lineNum":"  641","line":"void initialize(const std::string& = {});"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"SpaceHandle make_space_handle(const char* space_name);"},
{"lineNum":"  644","line":""},
{"lineNum":"  645","line":"namespace Experimental {"},
{"lineNum":"  646","line":"using Kokkos::Tools::Experimental::set_allocate_data_callback;"},
{"lineNum":"  647","line":"using Kokkos::Tools::Experimental::set_begin_deep_copy_callback;"},
{"lineNum":"  648","line":"using Kokkos::Tools::Experimental::set_begin_parallel_for_callback;"},
{"lineNum":"  649","line":"using Kokkos::Tools::Experimental::set_begin_parallel_reduce_callback;"},
{"lineNum":"  650","line":"using Kokkos::Tools::Experimental::set_begin_parallel_scan_callback;"},
{"lineNum":"  651","line":"using Kokkos::Tools::Experimental::set_create_profile_section_callback;"},
{"lineNum":"  652","line":"using Kokkos::Tools::Experimental::set_deallocate_data_callback;"},
{"lineNum":"  653","line":"using Kokkos::Tools::Experimental::set_destroy_profile_section_callback;"},
{"lineNum":"  654","line":"using Kokkos::Tools::Experimental::set_end_deep_copy_callback;"},
{"lineNum":"  655","line":"using Kokkos::Tools::Experimental::set_end_parallel_for_callback;"},
{"lineNum":"  656","line":"using Kokkos::Tools::Experimental::set_end_parallel_reduce_callback;"},
{"lineNum":"  657","line":"using Kokkos::Tools::Experimental::set_end_parallel_scan_callback;"},
{"lineNum":"  658","line":"using Kokkos::Tools::Experimental::set_finalize_callback;"},
{"lineNum":"  659","line":"using Kokkos::Tools::Experimental::set_init_callback;"},
{"lineNum":"  660","line":"using Kokkos::Tools::Experimental::set_parse_args_callback;"},
{"lineNum":"  661","line":"using Kokkos::Tools::Experimental::set_pop_region_callback;"},
{"lineNum":"  662","line":"using Kokkos::Tools::Experimental::set_print_help_callback;"},
{"lineNum":"  663","line":"using Kokkos::Tools::Experimental::set_profile_event_callback;"},
{"lineNum":"  664","line":"using Kokkos::Tools::Experimental::set_push_region_callback;"},
{"lineNum":"  665","line":"using Kokkos::Tools::Experimental::set_start_profile_section_callback;"},
{"lineNum":"  666","line":"using Kokkos::Tools::Experimental::set_stop_profile_section_callback;"},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"using Kokkos::Tools::Experimental::EventSet;"},
{"lineNum":"  669","line":""},
{"lineNum":"  670","line":"using Kokkos::Tools::Experimental::pause_tools;"},
{"lineNum":"  671","line":"using Kokkos::Tools::Experimental::resume_tools;"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"using Kokkos::Tools::Experimental::get_callbacks;"},
{"lineNum":"  674","line":"using Kokkos::Tools::Experimental::set_callbacks;"},
{"lineNum":"  675","line":""},
{"lineNum":"  676","line":"}  // namespace Experimental"},
{"lineNum":"  677","line":"}  // namespace Profiling"},
{"lineNum":"  678","line":""},
{"lineNum":"  679","line":"namespace Tools {"},
{"lineNum":"  680","line":"namespace Experimental {"},
{"lineNum":"  681","line":""},
{"lineNum":"  682","line":"VariableValue make_variable_value(size_t id, int64_t val);"},
{"lineNum":"  683","line":"VariableValue make_variable_value(size_t id, double val);"},
{"lineNum":"  684","line":"VariableValue make_variable_value(size_t id, const std::string& val);"},
{"lineNum":"  685","line":""},
{"lineNum":"  686","line":"SetOrRange make_candidate_set(size_t size, std::string* data);"},
{"lineNum":"  687","line":"SetOrRange make_candidate_set(size_t size, int64_t* data);"},
{"lineNum":"  688","line":"SetOrRange make_candidate_set(size_t size, double* data);"},
{"lineNum":"  689","line":"SetOrRange make_candidate_range(double lower, double upper, double step,"},
{"lineNum":"  690","line":"                                bool openLower, bool openUpper);"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"SetOrRange make_candidate_range(int64_t lower, int64_t upper, int64_t step,"},
{"lineNum":"  693","line":"                                bool openLower, bool openUpper);"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"void declare_optimization_goal(const size_t context,"},
{"lineNum":"  696","line":"                               const OptimizationGoal& goal);"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"size_t declare_output_type(const std::string& typeName, VariableInfo info);"},
{"lineNum":"  699","line":""},
{"lineNum":"  700","line":"size_t declare_input_type(const std::string& typeName, VariableInfo info);"},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"void set_input_values(size_t contextId, size_t count, VariableValue* values);"},
{"lineNum":"  703","line":""},
{"lineNum":"  704","line":"void end_context(size_t contextId);"},
{"lineNum":"  705","line":"void begin_context(size_t contextId);"},
{"lineNum":"  706","line":""},
{"lineNum":"  707","line":"void request_output_values(size_t contextId, size_t count,"},
{"lineNum":"  708","line":"                           VariableValue* values);"},
{"lineNum":"  709","line":""},
{"lineNum":"  710","line":"bool have_tuning_tool();"},
{"lineNum":"  711","line":""},
{"lineNum":"  712","line":"size_t get_new_context_id();"},
{"lineNum":"  713","line":"size_t get_current_context_id();"},
{"lineNum":"  714","line":""},
{"lineNum":"  715","line":"size_t get_new_variable_id();"},
{"lineNum":"  716","line":"}  // namespace Experimental"},
{"lineNum":"  717","line":"}  // namespace Tools"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"}  // namespace Kokkos"},
{"lineNum":"  720","line":""},
{"lineNum":"  721","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 16, "covered" : 1,};
var merged_data = [];
