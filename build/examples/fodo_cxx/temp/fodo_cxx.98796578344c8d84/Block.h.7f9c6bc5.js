var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2006-2010 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_BLOCK_H"},
{"lineNum":"   12","line":"#define EIGEN_BLOCK_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":"template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>"},
{"lineNum":"   20","line":"struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel> > : traits<XprType>"},
{"lineNum":"   21","line":"{"},
{"lineNum":"   22","line":"  typedef typename traits<XprType>::Scalar Scalar;"},
{"lineNum":"   23","line":"  typedef typename traits<XprType>::StorageKind StorageKind;"},
{"lineNum":"   24","line":"  typedef typename traits<XprType>::XprKind XprKind;"},
{"lineNum":"   25","line":"  typedef typename ref_selector<XprType>::type XprTypeNested;"},
{"lineNum":"   26","line":"  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;"},
{"lineNum":"   27","line":"  enum{"},
{"lineNum":"   28","line":"    MatrixRows = traits<XprType>::RowsAtCompileTime,"},
{"lineNum":"   29","line":"    MatrixCols = traits<XprType>::ColsAtCompileTime,"},
{"lineNum":"   30","line":"    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,"},
{"lineNum":"   31","line":"    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,"},
{"lineNum":"   32","line":"    MaxRowsAtCompileTime = BlockRows==0 ? 0"},
{"lineNum":"   33","line":"                         : RowsAtCompileTime != Dynamic ? int(RowsAtCompileTime)"},
{"lineNum":"   34","line":"                         : int(traits<XprType>::MaxRowsAtCompileTime),"},
{"lineNum":"   35","line":"    MaxColsAtCompileTime = BlockCols==0 ? 0"},
{"lineNum":"   36","line":"                         : ColsAtCompileTime != Dynamic ? int(ColsAtCompileTime)"},
{"lineNum":"   37","line":"                         : int(traits<XprType>::MaxColsAtCompileTime),"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,"},
{"lineNum":"   40","line":"    IsRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1"},
{"lineNum":"   41","line":"               : (MaxColsAtCompileTime==1&&MaxRowsAtCompileTime!=1) ? 0"},
{"lineNum":"   42","line":"               : XprTypeIsRowMajor,"},
{"lineNum":"   43","line":"    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),"},
{"lineNum":"   44","line":"    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),"},
{"lineNum":"   45","line":"    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType"},
{"lineNum":"   46","line":"                             ? int(inner_stride_at_compile_time<XprType>::ret)"},
{"lineNum":"   47","line":"                             : int(outer_stride_at_compile_time<XprType>::ret),"},
{"lineNum":"   48","line":"    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType"},
{"lineNum":"   49","line":"                             ? int(outer_stride_at_compile_time<XprType>::ret)"},
{"lineNum":"   50","line":"                             : int(inner_stride_at_compile_time<XprType>::ret),"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"    // FIXME, this traits is rather specialized for dense object and it needs to be cleaned further"},
{"lineNum":"   53","line":"    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,"},
{"lineNum":"   54","line":"    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,"},
{"lineNum":"   55","line":"    Flags = (traits<XprType>::Flags & (DirectAccessBit | (InnerPanel?CompressedAccessBit:0))) | FlagsLvalueBit | FlagsRowMajorBit,"},
{"lineNum":"   56","line":"    // FIXME DirectAccessBit should not be handled by expressions"},
{"lineNum":"   57","line":"    //"},
{"lineNum":"   58","line":"    // Alignment is needed by MapBase\'s assertions"},
{"lineNum":"   59","line":"    // We can sefely set it to false here. Internal alignment errors will be detected by an eigen_internal_assert in the respective evaluator"},
{"lineNum":"   60","line":"    Alignment = 0"},
{"lineNum":"   61","line":"  };"},
{"lineNum":"   62","line":"};"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"template<typename XprType, int BlockRows=Dynamic, int BlockCols=Dynamic, bool InnerPanel = false,"},
{"lineNum":"   65","line":"         bool HasDirectAccess = internal::has_direct_access<XprType>::ret> class BlockImpl_dense;"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"} // end namespace internal"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, typename StorageKind> class BlockImpl;"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"/** \\class Block"},
{"lineNum":"   72","line":"  * \\ingroup Core_Module"},
{"lineNum":"   73","line":"  *"},
{"lineNum":"   74","line":"  * \\brief Expression of a fixed-size or dynamic-size block"},
{"lineNum":"   75","line":"  *"},
{"lineNum":"   76","line":"  * \\tparam XprType the type of the expression in which we are taking a block"},
{"lineNum":"   77","line":"  * \\tparam BlockRows the number of rows of the block we are taking at compile time (optional)"},
{"lineNum":"   78","line":"  * \\tparam BlockCols the number of columns of the block we are taking at compile time (optional)"},
{"lineNum":"   79","line":"  * \\tparam InnerPanel is true, if the block maps to a set of rows of a row major matrix or"},
{"lineNum":"   80","line":"  *         to set of columns of a column major matrix (optional). The parameter allows to determine"},
{"lineNum":"   81","line":"  *         at compile time whether aligned access is possible on the block expression."},
{"lineNum":"   82","line":"  *"},
{"lineNum":"   83","line":"  * This class represents an expression of either a fixed-size or dynamic-size block. It is the return"},
{"lineNum":"   84","line":"  * type of DenseBase::block(Index,Index,Index,Index) and DenseBase::block<int,int>(Index,Index) and"},
{"lineNum":"   85","line":"  * most of the time this is the only way it is used."},
{"lineNum":"   86","line":"  *"},
{"lineNum":"   87","line":"  * However, if you want to directly maniputate block expressions,"},
{"lineNum":"   88","line":"  * for instance if you want to write a function returning such an expression, you"},
{"lineNum":"   89","line":"  * will need to use this class."},
{"lineNum":"   90","line":"  *"},
{"lineNum":"   91","line":"  * Here is an example illustrating the dynamic case:"},
{"lineNum":"   92","line":"  * \\include class_Block.cpp"},
{"lineNum":"   93","line":"  * Output: \\verbinclude class_Block.out"},
{"lineNum":"   94","line":"  *"},
{"lineNum":"   95","line":"  * \\note Even though this expression has dynamic size, in the case where \\a XprType"},
{"lineNum":"   96","line":"  * has fixed size, this expression inherits a fixed maximal size which means that evaluating"},
{"lineNum":"   97","line":"  * it does not cause a dynamic memory allocation."},
{"lineNum":"   98","line":"  *"},
{"lineNum":"   99","line":"  * Here is an example illustrating the fixed-size case:"},
{"lineNum":"  100","line":"  * \\include class_FixedBlock.cpp"},
{"lineNum":"  101","line":"  * Output: \\verbinclude class_FixedBlock.out"},
{"lineNum":"  102","line":"  *"},
{"lineNum":"  103","line":"  * \\sa DenseBase::block(Index,Index,Index,Index), DenseBase::block(Index,Index), class VectorBlock"},
{"lineNum":"  104","line":"  */"},
{"lineNum":"  105","line":"template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel> class Block"},
{"lineNum":"  106","line":"  : public BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, typename internal::traits<XprType>::StorageKind>"},
{"lineNum":"  107","line":"{"},
{"lineNum":"  108","line":"    typedef BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, typename internal::traits<XprType>::StorageKind> Impl;"},
{"lineNum":"  109","line":"  public:"},
{"lineNum":"  110","line":"    //typedef typename Impl::Base Base;"},
{"lineNum":"  111","line":"    typedef Impl Base;"},
{"lineNum":"  112","line":"    EIGEN_GENERIC_PUBLIC_INTERFACE(Block)"},
{"lineNum":"  113","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Block)"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    typedef typename internal::remove_all<XprType>::type NestedExpression;"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"    /** Column or Row constructor"},
{"lineNum":"  118","line":"      */"},
{"lineNum":"  119","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  120","line":"    Block(XprType& xpr, Index i) : Impl(xpr,i)"},
{"lineNum":"  121","line":"    {"},
{"lineNum":"  122","line":"      eigen_assert( (i>=0) && ("},
{"lineNum":"  123","line":"          ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && i<xpr.rows())"},
{"lineNum":"  124","line":"        ||((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && i<xpr.cols())));"},
{"lineNum":"  125","line":"    }"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    /** Fixed-size constructor"},
{"lineNum":"  128","line":"      */"},
{"lineNum":"  129","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  130","line":"    Block(XprType& xpr, Index startRow, Index startCol)"},
{"lineNum":"  131","line":"      : Impl(xpr, startRow, startCol)"},
{"lineNum":"  132","line":"    {"},
{"lineNum":"  133","line":"      EIGEN_STATIC_ASSERT(RowsAtCompileTime!=Dynamic && ColsAtCompileTime!=Dynamic,THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE)"},
{"lineNum":"  134","line":"      eigen_assert(startRow >= 0 && BlockRows >= 0 && startRow + BlockRows <= xpr.rows()"},
{"lineNum":"  135","line":"             && startCol >= 0 && BlockCols >= 0 && startCol + BlockCols <= xpr.cols());"},
{"lineNum":"  136","line":"    }"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"    /** Dynamic-size constructor"},
{"lineNum":"  139","line":"      */"},
{"lineNum":"  140","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  141","line":"    Block(XprType& xpr,"},
{"lineNum":"  142","line":"          Index startRow, Index startCol,"},
{"lineNum":"  143","line":"          Index blockRows, Index blockCols)"},
{"lineNum":"  144","line":"      : Impl(xpr, startRow, startCol, blockRows, blockCols)"},
{"lineNum":"  145","line":"    {"},
{"lineNum":"  146","line":"      eigen_assert((RowsAtCompileTime==Dynamic || RowsAtCompileTime==blockRows)"},
{"lineNum":"  147","line":"          && (ColsAtCompileTime==Dynamic || ColsAtCompileTime==blockCols));"},
{"lineNum":"  148","line":"      eigen_assert(startRow >= 0 && blockRows >= 0 && startRow  <= xpr.rows() - blockRows"},
{"lineNum":"  149","line":"          && startCol >= 0 && blockCols >= 0 && startCol <= xpr.cols() - blockCols);"},
{"lineNum":"  150","line":"    }"},
{"lineNum":"  151","line":"};"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"// The generic default implementation for dense block simplu forward to the internal::BlockImpl_dense"},
{"lineNum":"  154","line":"// that must be specialized for direct and non-direct access..."},
{"lineNum":"  155","line":"template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>"},
{"lineNum":"  156","line":"class BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Dense>"},
{"lineNum":"  157","line":"  : public internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel>"},
{"lineNum":"  158","line":"{"},
{"lineNum":"  159","line":"    typedef internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel> Impl;"},
{"lineNum":"  160","line":"    typedef typename XprType::StorageIndex StorageIndex;"},
{"lineNum":"  161","line":"  public:"},
{"lineNum":"  162","line":"    typedef Impl Base;"},
{"lineNum":"  163","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(BlockImpl)"},
{"lineNum":"  164","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE BlockImpl(XprType& xpr, Index i) : Impl(xpr,i) {}"},
{"lineNum":"  165","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE BlockImpl(XprType& xpr, Index startRow, Index startCol) : Impl(xpr, startRow, startCol) {}"},
{"lineNum":"  166","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  167","line":"    EIGEN_STRONG_INLINE BlockImpl(XprType& xpr, Index startRow, Index startCol, Index blockRows, Index blockCols)"},
{"lineNum":"  168","line":"      : Impl(xpr, startRow, startCol, blockRows, blockCols) {}"},
{"lineNum":"  169","line":"};"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"namespace internal {"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"/** \\internal Internal implementation of dense Blocks in the general case. */"},
{"lineNum":"  174","line":"template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class BlockImpl_dense"},
{"lineNum":"  175","line":"  : public internal::dense_xpr_base<Block<XprType, BlockRows, BlockCols, InnerPanel> >::type"},
{"lineNum":"  176","line":"{"},
{"lineNum":"  177","line":"    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;"},
{"lineNum":"  178","line":"    typedef typename internal::ref_selector<XprType>::non_const_type XprTypeNested;"},
{"lineNum":"  179","line":"  public:"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"    typedef typename internal::dense_xpr_base<BlockType>::type Base;"},
{"lineNum":"  182","line":"    EIGEN_DENSE_PUBLIC_INTERFACE(BlockType)"},
{"lineNum":"  183","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(BlockImpl_dense)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"    // class InnerIterator; // FIXME apparently never used"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"    /** Column or Row constructor"},
{"lineNum":"  188","line":"      */"},
{"lineNum":"  189","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  190","line":"    inline BlockImpl_dense(XprType& xpr, Index i)"},
{"lineNum":"  191","line":"      : m_xpr(xpr),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  192","line":"        // It is a row if and only if BlockRows==1 and BlockCols==XprType::ColsAtCompileTime,"},
{"lineNum":"  193","line":"        // and it is a column if and only if BlockRows==XprType::RowsAtCompileTime and BlockCols==1,"},
{"lineNum":"  194","line":"        // all other cases are invalid."},
{"lineNum":"  195","line":"        // The case a 1x1 matrix seems ambiguous, but the result is the same anyway."},
{"lineNum":"  196","line":"        m_startRow( (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? i : 0),"},
{"lineNum":"  197","line":"        m_startCol( (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? i : 0),"},
{"lineNum":"  198","line":"        m_blockRows(BlockRows==1 ? 1 : xpr.rows()),"},
{"lineNum":"  199","line":"        m_blockCols(BlockCols==1 ? 1 : xpr.cols())"},
{"lineNum":"  200","line":"    {}"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"    /** Fixed-size constructor"},
{"lineNum":"  203","line":"      */"},
{"lineNum":"  204","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  205","line":"    inline BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)"},
{"lineNum":"  206","line":"      : m_xpr(xpr), m_startRow(startRow), m_startCol(startCol),"},
{"lineNum":"  207","line":"                    m_blockRows(BlockRows), m_blockCols(BlockCols)"},
{"lineNum":"  208","line":"    {}"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"    /** Dynamic-size constructor"},
{"lineNum":"  211","line":"      */"},
{"lineNum":"  212","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  213","line":"    inline BlockImpl_dense(XprType& xpr,"},
{"lineNum":"  214","line":"          Index startRow, Index startCol,"},
{"lineNum":"  215","line":"          Index blockRows, Index blockCols)"},
{"lineNum":"  216","line":"      : m_xpr(xpr), m_startRow(startRow), m_startCol(startCol),"},
{"lineNum":"  217","line":"                    m_blockRows(blockRows), m_blockCols(blockCols)"},
{"lineNum":"  218","line":"    {}"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    EIGEN_DEVICE_FUNC inline Index rows() const { return m_blockRows.value(); }"},
{"lineNum":"  221","line":"    EIGEN_DEVICE_FUNC inline Index cols() const { return m_blockCols.value(); }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  224","line":"    inline Scalar& coeffRef(Index rowId, Index colId)"},
{"lineNum":"  225","line":"    {"},
{"lineNum":"  226","line":"      EIGEN_STATIC_ASSERT_LVALUE(XprType)"},
{"lineNum":"  227","line":"      return m_xpr.coeffRef(rowId + m_startRow.value(), colId + m_startCol.value());"},
{"lineNum":"  228","line":"    }"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  231","line":"    inline const Scalar& coeffRef(Index rowId, Index colId) const"},
{"lineNum":"  232","line":"    {"},
{"lineNum":"  233","line":"      return m_xpr.derived().coeffRef(rowId + m_startRow.value(), colId + m_startCol.value());"},
{"lineNum":"  234","line":"    }"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  237","line":"    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index rowId, Index colId) const"},
{"lineNum":"  238","line":"    {"},
{"lineNum":"  239","line":"      return m_xpr.coeff(rowId + m_startRow.value(), colId + m_startCol.value());"},
{"lineNum":"  240","line":"    }"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  243","line":"    inline Scalar& coeffRef(Index index)"},
{"lineNum":"  244","line":"    {"},
{"lineNum":"  245","line":"      EIGEN_STATIC_ASSERT_LVALUE(XprType)"},
{"lineNum":"  246","line":"      return m_xpr.coeffRef(m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),"},
{"lineNum":"  247","line":"                            m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));"},
{"lineNum":"  248","line":"    }"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  251","line":"    inline const Scalar& coeffRef(Index index) const"},
{"lineNum":"  252","line":"    {"},
{"lineNum":"  253","line":"      return m_xpr.coeffRef(m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),"},
{"lineNum":"  254","line":"                            m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));"},
{"lineNum":"  255","line":"    }"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  258","line":"    inline const CoeffReturnType coeff(Index index) const"},
{"lineNum":"  259","line":"    {"},
{"lineNum":"  260","line":"      return m_xpr.coeff(m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),"},
{"lineNum":"  261","line":"                         m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));"},
{"lineNum":"  262","line":"    }"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"    template<int LoadMode>"},
{"lineNum":"  265","line":"    EIGEN_DEVICE_FUNC inline PacketScalar packet(Index rowId, Index colId) const"},
{"lineNum":"  266","line":"    {"},
{"lineNum":"  267","line":"      return m_xpr.template packet<Unaligned>(rowId + m_startRow.value(), colId + m_startCol.value());"},
{"lineNum":"  268","line":"    }"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"    template<int LoadMode>"},
{"lineNum":"  271","line":"    EIGEN_DEVICE_FUNC inline void writePacket(Index rowId, Index colId, const PacketScalar& val)"},
{"lineNum":"  272","line":"    {"},
{"lineNum":"  273","line":"      m_xpr.template writePacket<Unaligned>(rowId + m_startRow.value(), colId + m_startCol.value(), val);"},
{"lineNum":"  274","line":"    }"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"    template<int LoadMode>"},
{"lineNum":"  277","line":"    EIGEN_DEVICE_FUNC inline PacketScalar packet(Index index) const"},
{"lineNum":"  278","line":"    {"},
{"lineNum":"  279","line":"      return m_xpr.template packet<Unaligned>"},
{"lineNum":"  280","line":"              (m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),"},
{"lineNum":"  281","line":"               m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0));"},
{"lineNum":"  282","line":"    }"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"    template<int LoadMode>"},
{"lineNum":"  285","line":"    EIGEN_DEVICE_FUNC inline void writePacket(Index index, const PacketScalar& val)"},
{"lineNum":"  286","line":"    {"},
{"lineNum":"  287","line":"      m_xpr.template writePacket<Unaligned>"},
{"lineNum":"  288","line":"         (m_startRow.value() + (RowsAtCompileTime == 1 ? 0 : index),"},
{"lineNum":"  289","line":"          m_startCol.value() + (RowsAtCompileTime == 1 ? index : 0), val);"},
{"lineNum":"  290","line":"    }"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"    #ifdef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  293","line":"    /** \\sa MapBase::data() */"},
{"lineNum":"  294","line":"    EIGEN_DEVICE_FUNC inline const Scalar* data() const;"},
{"lineNum":"  295","line":"    EIGEN_DEVICE_FUNC inline Index innerStride() const;"},
{"lineNum":"  296","line":"    EIGEN_DEVICE_FUNC inline Index outerStride() const;"},
{"lineNum":"  297","line":"    #endif"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  300","line":"    const typename internal::remove_all<XprTypeNested>::type& nestedExpression() const"},
{"lineNum":"  301","line":"    {"},
{"lineNum":"  302","line":"      return m_xpr;"},
{"lineNum":"  303","line":"    }"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  306","line":"    XprType& nestedExpression() { return m_xpr; }"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  309","line":"    StorageIndex startRow() const EIGEN_NOEXCEPT"},
{"lineNum":"  310","line":"    {"},
{"lineNum":"  311","line":"      return m_startRow.value();"},
{"lineNum":"  312","line":"    }"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  315","line":"    StorageIndex startCol() const EIGEN_NOEXCEPT"},
{"lineNum":"  316","line":"    {"},
{"lineNum":"  317","line":"      return m_startCol.value();"},
{"lineNum":"  318","line":"    }"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"  protected:"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"    XprTypeNested m_xpr;"},
{"lineNum":"  323","line":"    const internal::variable_if_dynamic<StorageIndex, (XprType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;"},
{"lineNum":"  324","line":"    const internal::variable_if_dynamic<StorageIndex, (XprType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;"},
{"lineNum":"  325","line":"    const internal::variable_if_dynamic<StorageIndex, RowsAtCompileTime> m_blockRows;"},
{"lineNum":"  326","line":"    const internal::variable_if_dynamic<StorageIndex, ColsAtCompileTime> m_blockCols;"},
{"lineNum":"  327","line":"};"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"/** \\internal Internal implementation of dense Blocks in the direct access case.*/"},
{"lineNum":"  330","line":"template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel>"},
{"lineNum":"  331","line":"class BlockImpl_dense<XprType,BlockRows,BlockCols, InnerPanel,true>"},
{"lineNum":"  332","line":"  : public MapBase<Block<XprType, BlockRows, BlockCols, InnerPanel> >"},
{"lineNum":"  333","line":"{"},
{"lineNum":"  334","line":"    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;"},
{"lineNum":"  335","line":"    typedef typename internal::ref_selector<XprType>::non_const_type XprTypeNested;"},
{"lineNum":"  336","line":"    enum {"},
{"lineNum":"  337","line":"      XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0"},
{"lineNum":"  338","line":"    };"},
{"lineNum":"  339","line":"  public:"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"    typedef MapBase<BlockType> Base;"},
{"lineNum":"  342","line":"    EIGEN_DENSE_PUBLIC_INTERFACE(BlockType)"},
{"lineNum":"  343","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(BlockImpl_dense)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"    /** Column or Row constructor"},
{"lineNum":"  346","line":"      */"},
{"lineNum":"  347","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  348","line":"    BlockImpl_dense(XprType& xpr, Index i)"},
{"lineNum":"  349","line":"      : Base(xpr.data() + i * (    ((BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) && (!XprTypeIsRowMajor))","class":"lineNoCov","hits":"0","possible_hits":"86",},
{"lineNum":"  350","line":"                                || ((BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) && ( XprTypeIsRowMajor)) ? xpr.innerStride() : xpr.outerStride()),"},
{"lineNum":"  351","line":"             BlockRows==1 ? 1 : xpr.rows(),"},
{"lineNum":"  352","line":"             BlockCols==1 ? 1 : xpr.cols()),"},
{"lineNum":"  353","line":"        m_xpr(xpr),","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  354","line":"        m_startRow( (BlockRows==1) && (BlockCols==XprType::ColsAtCompileTime) ? i : 0),"},
{"lineNum":"  355","line":"        m_startCol( (BlockRows==XprType::RowsAtCompileTime) && (BlockCols==1) ? i : 0)"},
{"lineNum":"  356","line":"    {"},
{"lineNum":"  357","line":"      init();"},
{"lineNum":"  358","line":"    }"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"    /** Fixed-size constructor"},
{"lineNum":"  361","line":"      */"},
{"lineNum":"  362","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  363","line":"    BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)"},
{"lineNum":"  364","line":"      : Base(xpr.data()+xpr.innerStride()*(XprTypeIsRowMajor?startCol:startRow) + xpr.outerStride()*(XprTypeIsRowMajor?startRow:startCol)),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  365","line":"        m_xpr(xpr), m_startRow(startRow), m_startCol(startCol)"},
{"lineNum":"  366","line":"    {"},
{"lineNum":"  367","line":"      init();"},
{"lineNum":"  368","line":"    }"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"    /** Dynamic-size constructor"},
{"lineNum":"  371","line":"      */"},
{"lineNum":"  372","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  373","line":"    BlockImpl_dense(XprType& xpr,"},
{"lineNum":"  374","line":"          Index startRow, Index startCol,"},
{"lineNum":"  375","line":"          Index blockRows, Index blockCols)"},
{"lineNum":"  376","line":"      : Base(xpr.data()+xpr.innerStride()*(XprTypeIsRowMajor?startCol:startRow) + xpr.outerStride()*(XprTypeIsRowMajor?startRow:startCol), blockRows, blockCols),","class":"lineNoCov","hits":"0","possible_hits":"138",},
{"lineNum":"  377","line":"        m_xpr(xpr), m_startRow(startRow), m_startCol(startCol)","class":"lineNoCov","hits":"0","possible_hits":"68",},
{"lineNum":"  378","line":"    {"},
{"lineNum":"  379","line":"      init();"},
{"lineNum":"  380","line":"    }"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  383","line":"    const typename internal::remove_all<XprTypeNested>::type& nestedExpression() const EIGEN_NOEXCEPT"},
{"lineNum":"  384","line":"    {"},
{"lineNum":"  385","line":"      return m_xpr;"},
{"lineNum":"  386","line":"    }"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  389","line":"    XprType& nestedExpression() { return m_xpr; }"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"    /** \\sa MapBase::innerStride() */"},
{"lineNum":"  392","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  393","line":"    Index innerStride() const EIGEN_NOEXCEPT"},
{"lineNum":"  394","line":"    {"},
{"lineNum":"  395","line":"      return internal::traits<BlockType>::HasSameStorageOrderAsXprType"},
{"lineNum":"  396","line":"             ? m_xpr.innerStride()"},
{"lineNum":"  397","line":"             : m_xpr.outerStride();","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  398","line":"    }"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"    /** \\sa MapBase::outerStride() */"},
{"lineNum":"  401","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  402","line":"    Index outerStride() const EIGEN_NOEXCEPT"},
{"lineNum":"  403","line":"    {"},
{"lineNum":"  404","line":"      return internal::traits<BlockType>::HasSameStorageOrderAsXprType"},
{"lineNum":"  405","line":"                    ? m_xpr.outerStride()","class":"lineNoCov","hits":"0","possible_hits":"57",},
{"lineNum":"  406","line":"                    : m_xpr.innerStride();"},
{"lineNum":"  407","line":"    }"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  410","line":"    StorageIndex startRow() const EIGEN_NOEXCEPT { return m_startRow.value(); }"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  413","line":"    StorageIndex startCol() const EIGEN_NOEXCEPT { return m_startCol.value(); }"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"  #ifndef __SUNPRO_CC"},
{"lineNum":"  416","line":"  // FIXME sunstudio is not friendly with the above friend..."},
{"lineNum":"  417","line":"  // META-FIXME there is no \'friend\' keyword around here. Is this obsolete?"},
{"lineNum":"  418","line":"  protected:"},
{"lineNum":"  419","line":"  #endif"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"    #ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  422","line":"    /** \\internal used by allowAligned() */"},
{"lineNum":"  423","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  424","line":"    BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)"},
{"lineNum":"  425","line":"      : Base(data, blockRows, blockCols), m_xpr(xpr)"},
{"lineNum":"  426","line":"    {"},
{"lineNum":"  427","line":"      init();"},
{"lineNum":"  428","line":"    }"},
{"lineNum":"  429","line":"    #endif"},
{"lineNum":"  430","line":""},
{"lineNum":"  431","line":"  protected:"},
{"lineNum":"  432","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  433","line":"    void init()"},
{"lineNum":"  434","line":"    {"},
{"lineNum":"  435","line":"      m_outerStride = internal::traits<BlockType>::HasSameStorageOrderAsXprType","class":"lineNoCov","hits":"0","possible_hits":"78",},
{"lineNum":"  436","line":"                    ? m_xpr.outerStride()"},
{"lineNum":"  437","line":"                    : m_xpr.innerStride();"},
{"lineNum":"  438","line":"    }"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"    XprTypeNested m_xpr;"},
{"lineNum":"  441","line":"    const internal::variable_if_dynamic<StorageIndex, (XprType::RowsAtCompileTime == 1 && BlockRows==1) ? 0 : Dynamic> m_startRow;"},
{"lineNum":"  442","line":"    const internal::variable_if_dynamic<StorageIndex, (XprType::ColsAtCompileTime == 1 && BlockCols==1) ? 0 : Dynamic> m_startCol;"},
{"lineNum":"  443","line":"    Index m_outerStride;"},
{"lineNum":"  444","line":"};"},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":"} // end namespace internal"},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"} // end namespace Eigen"},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"#endif // EIGEN_BLOCK_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 11, "covered" : 0,};
var merged_data = [];
