var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2014 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_SOLVE_H"},
{"lineNum":"   11","line":"#define EIGEN_SOLVE_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"template<typename Decomposition, typename RhsType, typename StorageKind> class SolveImpl;"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"/** \\class Solve"},
{"lineNum":"   20","line":"  * \\ingroup Core_Module"},
{"lineNum":"   21","line":"  *"},
{"lineNum":"   22","line":"  * \\brief Pseudo expression representing a solving operation"},
{"lineNum":"   23","line":"  *"},
{"lineNum":"   24","line":"  * \\tparam Decomposition the type of the matrix or decomposition object"},
{"lineNum":"   25","line":"  * \\tparam Rhstype the type of the right-hand side"},
{"lineNum":"   26","line":"  *"},
{"lineNum":"   27","line":"  * This class represents an expression of A.solve(B)"},
{"lineNum":"   28","line":"  * and most of the time this is the only way it is used."},
{"lineNum":"   29","line":"  *"},
{"lineNum":"   30","line":"  */"},
{"lineNum":"   31","line":"namespace internal {"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"// this solve_traits class permits to determine the evaluation type with respect to storage kind (Dense vs Sparse)"},
{"lineNum":"   34","line":"template<typename Decomposition, typename RhsType,typename StorageKind> struct solve_traits;"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"template<typename Decomposition, typename RhsType>"},
{"lineNum":"   37","line":"struct solve_traits<Decomposition,RhsType,Dense>"},
{"lineNum":"   38","line":"{"},
{"lineNum":"   39","line":"  typedef typename make_proper_matrix_type<typename RhsType::Scalar,"},
{"lineNum":"   40","line":"                 Decomposition::ColsAtCompileTime,"},
{"lineNum":"   41","line":"                 RhsType::ColsAtCompileTime,"},
{"lineNum":"   42","line":"                 RhsType::PlainObject::Options,"},
{"lineNum":"   43","line":"                 Decomposition::MaxColsAtCompileTime,"},
{"lineNum":"   44","line":"                 RhsType::MaxColsAtCompileTime>::type PlainObject;"},
{"lineNum":"   45","line":"};"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"template<typename Decomposition, typename RhsType>"},
{"lineNum":"   48","line":"struct traits<Solve<Decomposition, RhsType> >"},
{"lineNum":"   49","line":"  : traits<typename solve_traits<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>::PlainObject>"},
{"lineNum":"   50","line":"{"},
{"lineNum":"   51","line":"  typedef typename solve_traits<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>::PlainObject PlainObject;"},
{"lineNum":"   52","line":"  typedef typename promote_index_type<typename Decomposition::StorageIndex, typename RhsType::StorageIndex>::type StorageIndex;"},
{"lineNum":"   53","line":"  typedef traits<PlainObject> BaseTraits;"},
{"lineNum":"   54","line":"  enum {"},
{"lineNum":"   55","line":"    Flags = BaseTraits::Flags & RowMajorBit,"},
{"lineNum":"   56","line":"    CoeffReadCost = HugeCost"},
{"lineNum":"   57","line":"  };"},
{"lineNum":"   58","line":"};"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"}"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"template<typename Decomposition, typename RhsType>"},
{"lineNum":"   64","line":"class Solve : public SolveImpl<Decomposition,RhsType,typename internal::traits<RhsType>::StorageKind>"},
{"lineNum":"   65","line":"{"},
{"lineNum":"   66","line":"public:"},
{"lineNum":"   67","line":"  typedef typename internal::traits<Solve>::PlainObject PlainObject;"},
{"lineNum":"   68","line":"  typedef typename internal::traits<Solve>::StorageIndex StorageIndex;"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"  Solve(const Decomposition &dec, const RhsType &rhs)"},
{"lineNum":"   71","line":"    : m_dec(dec), m_rhs(rhs)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   72","line":"  {}"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_dec.cols(); }"},
{"lineNum":"   75","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"  EIGEN_DEVICE_FUNC const Decomposition& dec() const { return m_dec; }"},
{"lineNum":"   78","line":"  EIGEN_DEVICE_FUNC const RhsType&       rhs() const { return m_rhs; }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"protected:"},
{"lineNum":"   81","line":"  const Decomposition &m_dec;"},
{"lineNum":"   82","line":"  const typename internal::ref_selector<RhsType>::type m_rhs;"},
{"lineNum":"   83","line":"};"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"// Specialization of the Solve expression for dense results"},
{"lineNum":"   87","line":"template<typename Decomposition, typename RhsType>"},
{"lineNum":"   88","line":"class SolveImpl<Decomposition,RhsType,Dense>"},
{"lineNum":"   89","line":"  : public MatrixBase<Solve<Decomposition,RhsType> >"},
{"lineNum":"   90","line":"{"},
{"lineNum":"   91","line":"  typedef Solve<Decomposition,RhsType> Derived;"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"public:"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"  typedef MatrixBase<Solve<Decomposition,RhsType> > Base;"},
{"lineNum":"   96","line":"  EIGEN_DENSE_PUBLIC_INTERFACE(Derived)"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"private:"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"  Scalar coeff(Index row, Index col) const;"},
{"lineNum":"  101","line":"  Scalar coeff(Index i) const;"},
{"lineNum":"  102","line":"};"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"// Generic API dispatcher"},
{"lineNum":"  105","line":"template<typename Decomposition, typename RhsType, typename StorageKind>"},
{"lineNum":"  106","line":"class SolveImpl : public internal::generic_xpr_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>::type"},
{"lineNum":"  107","line":"{"},
{"lineNum":"  108","line":"  public:"},
{"lineNum":"  109","line":"    typedef typename internal::generic_xpr_base<Solve<Decomposition,RhsType>, MatrixXpr, StorageKind>::type Base;"},
{"lineNum":"  110","line":"};"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"namespace internal {"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"// Evaluator of Solve -> eval into a temporary"},
{"lineNum":"  115","line":"template<typename Decomposition, typename RhsType>"},
{"lineNum":"  116","line":"struct evaluator<Solve<Decomposition,RhsType> >"},
{"lineNum":"  117","line":"  : public evaluator<typename Solve<Decomposition,RhsType>::PlainObject>"},
{"lineNum":"  118","line":"{"},
{"lineNum":"  119","line":"  typedef Solve<Decomposition,RhsType> SolveType;"},
{"lineNum":"  120","line":"  typedef typename SolveType::PlainObject PlainObject;"},
{"lineNum":"  121","line":"  typedef evaluator<PlainObject> Base;"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"  enum { Flags = Base::Flags | EvalBeforeNestingBit };"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"  EIGEN_DEVICE_FUNC explicit evaluator(const SolveType& solve)"},
{"lineNum":"  126","line":"    : m_result(solve.rows(), solve.cols())"},
{"lineNum":"  127","line":"  {"},
{"lineNum":"  128","line":"    ::new (static_cast<Base*>(this)) Base(m_result);"},
{"lineNum":"  129","line":"    solve.dec()._solve_impl(solve.rhs(), m_result);"},
{"lineNum":"  130","line":"  }"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"protected:"},
{"lineNum":"  133","line":"  PlainObject m_result;"},
{"lineNum":"  134","line":"};"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"// Specialization for \"dst = dec.solve(rhs)\""},
{"lineNum":"  137","line":"// NOTE we need to specialize it for Dense2Dense to avoid ambiguous specialization error and a Sparse2Sparse specialization must exist somewhere"},
{"lineNum":"  138","line":"template<typename DstXprType, typename DecType, typename RhsType, typename Scalar>"},
{"lineNum":"  139","line":"struct Assignment<DstXprType, Solve<DecType,RhsType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>"},
{"lineNum":"  140","line":"{"},
{"lineNum":"  141","line":"  typedef Solve<DecType,RhsType> SrcXprType;"},
{"lineNum":"  142","line":"  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)"},
{"lineNum":"  143","line":"  {"},
{"lineNum":"  144","line":"    Index dstRows = src.rows();"},
{"lineNum":"  145","line":"    Index dstCols = src.cols();"},
{"lineNum":"  146","line":"    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  147","line":"      dst.resize(dstRows, dstCols);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"    src.dec()._solve_impl(src.rhs(), dst);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  150","line":"  }"},
{"lineNum":"  151","line":"};"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"// Specialization for \"dst = dec.transpose().solve(rhs)\""},
{"lineNum":"  154","line":"template<typename DstXprType, typename DecType, typename RhsType, typename Scalar>"},
{"lineNum":"  155","line":"struct Assignment<DstXprType, Solve<Transpose<const DecType>,RhsType>, internal::assign_op<Scalar,Scalar>, Dense2Dense>"},
{"lineNum":"  156","line":"{"},
{"lineNum":"  157","line":"  typedef Solve<Transpose<const DecType>,RhsType> SrcXprType;"},
{"lineNum":"  158","line":"  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)"},
{"lineNum":"  159","line":"  {"},
{"lineNum":"  160","line":"    Index dstRows = src.rows();"},
{"lineNum":"  161","line":"    Index dstCols = src.cols();"},
{"lineNum":"  162","line":"    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))"},
{"lineNum":"  163","line":"      dst.resize(dstRows, dstCols);"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"    src.dec().nestedExpression().template _solve_impl_transposed<false>(src.rhs(), dst);"},
{"lineNum":"  166","line":"  }"},
{"lineNum":"  167","line":"};"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"// Specialization for \"dst = dec.adjoint().solve(rhs)\""},
{"lineNum":"  170","line":"template<typename DstXprType, typename DecType, typename RhsType, typename Scalar>"},
{"lineNum":"  171","line":"struct Assignment<DstXprType, Solve<CwiseUnaryOp<internal::scalar_conjugate_op<typename DecType::Scalar>, const Transpose<const DecType> >,RhsType>,"},
{"lineNum":"  172","line":"                  internal::assign_op<Scalar,Scalar>, Dense2Dense>"},
{"lineNum":"  173","line":"{"},
{"lineNum":"  174","line":"  typedef Solve<CwiseUnaryOp<internal::scalar_conjugate_op<typename DecType::Scalar>, const Transpose<const DecType> >,RhsType> SrcXprType;"},
{"lineNum":"  175","line":"  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)"},
{"lineNum":"  176","line":"  {"},
{"lineNum":"  177","line":"    Index dstRows = src.rows();"},
{"lineNum":"  178","line":"    Index dstCols = src.cols();"},
{"lineNum":"  179","line":"    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))"},
{"lineNum":"  180","line":"      dst.resize(dstRows, dstCols);"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"    src.dec().nestedExpression().nestedExpression().template _solve_impl_transposed<true>(src.rhs(), dst);"},
{"lineNum":"  183","line":"  }"},
{"lineNum":"  184","line":"};"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"} // end namespace internal"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"} // end namespace Eigen"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"#endif // EIGEN_SOLVE_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 5, "covered" : 0,};
var merged_data = [];
