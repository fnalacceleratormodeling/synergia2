var data = {lines:[
{"lineNum":"    1","line":"/*============================================================================="},
{"lineNum":"    2","line":"    Copyright (c) 2001-2011 Joel de Guzman"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"    Distributed under the Boost Software License, Version 1.0. (See accompanying"},
{"lineNum":"    5","line":"    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    6","line":"==============================================================================*/"},
{"lineNum":"    7","line":"#if !defined(BOOST_SPIRIT_GRAMMAR_FEBRUARY_19_2007_0236PM)"},
{"lineNum":"    8","line":"#define BOOST_SPIRIT_GRAMMAR_FEBRUARY_19_2007_0236PM"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#if defined(_MSC_VER)"},
{"lineNum":"   11","line":"#pragma once"},
{"lineNum":"   12","line":"#endif"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include <boost/spirit/home/support/unused.hpp>"},
{"lineNum":"   15","line":"#include <boost/spirit/home/support/info.hpp>"},
{"lineNum":"   16","line":"#include <boost/spirit/home/support/assert_msg.hpp>"},
{"lineNum":"   17","line":"#include <boost/spirit/home/qi/domain.hpp>"},
{"lineNum":"   18","line":"#include <boost/spirit/home/qi/nonterminal/rule.hpp>"},
{"lineNum":"   19","line":"#include <boost/spirit/home/qi/nonterminal/nonterminal_fwd.hpp>"},
{"lineNum":"   20","line":"#include <boost/spirit/home/qi/reference.hpp>"},
{"lineNum":"   21","line":"#include <boost/noncopyable.hpp>"},
{"lineNum":"   22","line":"#include <boost/type_traits/is_same.hpp>"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"namespace boost { namespace spirit { namespace qi"},
{"lineNum":"   25","line":"{"},
{"lineNum":"   26","line":"    template <"},
{"lineNum":"   27","line":"        typename Iterator, typename T1, typename T2, typename T3"},
{"lineNum":"   28","line":"      , typename T4>"},
{"lineNum":"   29","line":"    struct grammar"},
{"lineNum":"   30","line":"      : proto::extends<"},
{"lineNum":"   31","line":"            typename proto::terminal<"},
{"lineNum":"   32","line":"                reference<rule<Iterator, T1, T2, T3, T4> const>"},
{"lineNum":"   33","line":"            >::type"},
{"lineNum":"   34","line":"          , grammar<Iterator, T1, T2, T3, T4>"},
{"lineNum":"   35","line":"        >"},
{"lineNum":"   36","line":"      , parser<grammar<Iterator, T1, T2, T3, T4> >"},
{"lineNum":"   37","line":"      , noncopyable"},
{"lineNum":"   38","line":"    {"},
{"lineNum":"   39","line":"        typedef Iterator iterator_type;"},
{"lineNum":"   40","line":"        typedef rule<Iterator, T1, T2, T3, T4> start_type;"},
{"lineNum":"   41","line":"        typedef typename start_type::sig_type sig_type;"},
{"lineNum":"   42","line":"        typedef typename start_type::locals_type locals_type;"},
{"lineNum":"   43","line":"        typedef typename start_type::skipper_type skipper_type;"},
{"lineNum":"   44","line":"        typedef typename start_type::encoding_type encoding_type;"},
{"lineNum":"   45","line":"        typedef grammar<Iterator, T1, T2, T3, T4> base_type;"},
{"lineNum":"   46","line":"        typedef reference<start_type const> reference_;"},
{"lineNum":"   47","line":"        typedef typename proto::terminal<reference_>::type terminal;"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"        static size_t const params_size = start_type::params_size;"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"        template <typename Context, typename Iterator_>"},
{"lineNum":"   52","line":"        struct attribute"},
{"lineNum":"   53","line":"        {"},
{"lineNum":"   54","line":"            typedef typename start_type::attr_type type;"},
{"lineNum":"   55","line":"        };"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"        grammar("},
{"lineNum":"   58","line":"            start_type const& start"},
{"lineNum":"   59","line":"          , std::string const& name = \"unnamed-grammar\")"},
{"lineNum":"   60","line":"        : proto::extends<terminal, base_type>(terminal::make(reference_(start)))"},
{"lineNum":"   61","line":"        , name_(name)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   62","line":"        {}"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"        // This constructor is used to catch if the start rule is not"},
{"lineNum":"   65","line":"        // compatible with the grammar."},
{"lineNum":"   66","line":"        template <typename Iterator_,"},
{"lineNum":"   67","line":"            typename T1_, typename T2_, typename T3_, typename T4_>"},
{"lineNum":"   68","line":"        grammar("},
{"lineNum":"   69","line":"            rule<Iterator_, T1_, T2_, T3_, T4_> const&"},
{"lineNum":"   70","line":"          , std::string const& = \"unnamed-grammar\")"},
{"lineNum":"   71","line":"        {"},
{"lineNum":"   72","line":"            // If you see the assertion below failing then the start rule"},
{"lineNum":"   73","line":"            // passed to the constructor of the grammar is not compatible with"},
{"lineNum":"   74","line":"            // the grammar (i.e. it uses different template parameters)."},
{"lineNum":"   75","line":"            BOOST_SPIRIT_ASSERT_MSG("},
{"lineNum":"   76","line":"                (is_same<start_type, rule<Iterator_, T1_, T2_, T3_, T4_> >::value)"},
{"lineNum":"   77","line":"              , incompatible_start_rule, (rule<Iterator_, T1_, T2_, T3_, T4_>));"},
{"lineNum":"   78","line":"        }"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"        std::string name() const"},
{"lineNum":"   81","line":"        {"},
{"lineNum":"   82","line":"            return name_;"},
{"lineNum":"   83","line":"        }"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"        void name(std::string const& str)"},
{"lineNum":"   86","line":"        {"},
{"lineNum":"   87","line":"            name_ = str;"},
{"lineNum":"   88","line":"        }"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"        template <typename Context, typename Skipper, typename Attribute>"},
{"lineNum":"   91","line":"        bool parse(Iterator& first, Iterator const& last"},
{"lineNum":"   92","line":"          , Context& context, Skipper const& skipper"},
{"lineNum":"   93","line":"          , Attribute& attr_) const"},
{"lineNum":"   94","line":"        {"},
{"lineNum":"   95","line":"            return this->proto_base().child0.parse("},
{"lineNum":"   96","line":"                first, last, context, skipper, attr_);"},
{"lineNum":"   97","line":"        }"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"        template <typename Context>"},
{"lineNum":"  100","line":"        info what(Context&) const"},
{"lineNum":"  101","line":"        {"},
{"lineNum":"  102","line":"            return info(name_);"},
{"lineNum":"  103","line":"        }"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"        // bring in the operator() overloads"},
{"lineNum":"  106","line":"        start_type const& get_parameterized_subject() const"},
{"lineNum":"  107","line":"        { return this->proto_base().child0.ref.get(); }"},
{"lineNum":"  108","line":"        typedef start_type parameterized_subject_type;"},
{"lineNum":"  109","line":"        #include <boost/spirit/home/qi/nonterminal/detail/fcall.hpp>"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"        std::string name_;"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"    };"},
{"lineNum":"  114","line":"}}}"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"namespace boost { namespace spirit { namespace traits"},
{"lineNum":"  117","line":"{"},
{"lineNum":"  118","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  119","line":"    template <"},
{"lineNum":"  120","line":"        typename IteratorA, typename IteratorB, typename Attribute"},
{"lineNum":"  121","line":"      , typename Context, typename T1, typename T2, typename T3, typename T4>"},
{"lineNum":"  122","line":"    struct handles_container<"},
{"lineNum":"  123","line":"        qi::grammar<IteratorA, T1, T2, T3, T4>, Attribute, Context, IteratorB>"},
{"lineNum":"  124","line":"      : traits::is_container<"},
{"lineNum":"  125","line":"          typename attribute_of<"},
{"lineNum":"  126","line":"              qi::grammar<IteratorA, T1, T2, T3, T4>, Context, IteratorB"},
{"lineNum":"  127","line":"          >::type"},
{"lineNum":"  128","line":"        >"},
{"lineNum":"  129","line":"    {};"},
{"lineNum":"  130","line":"}}}"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
