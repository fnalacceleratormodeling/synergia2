var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2008-2009 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"// Copyright (C) 2009 Kenneth Riddile <kfriddile@yahoo.com>"},
{"lineNum":"    7","line":"// Copyright (C) 2010 Hauke Heibel <hauke.heibel@gmail.com>"},
{"lineNum":"    8","line":"// Copyright (C) 2010 Thomas Capricelli <orzel@freehackers.org>"},
{"lineNum":"    9","line":"// Copyright (C) 2013 Pavel Holoborodko <pavel@holoborodko.com>"},
{"lineNum":"   10","line":"//"},
{"lineNum":"   11","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"   12","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"   13","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"/*****************************************************************************"},
{"lineNum":"   17","line":"*** Platform checks for aligned malloc functions                           ***"},
{"lineNum":"   18","line":"*****************************************************************************/"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"#ifndef EIGEN_MEMORY_H"},
{"lineNum":"   21","line":"#define EIGEN_MEMORY_H"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"#ifndef EIGEN_MALLOC_ALREADY_ALIGNED"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"// Try to determine automatically if malloc is already aligned."},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"// On 64-bit systems, glibc\'s malloc returns 16-byte-aligned pointers, see:"},
{"lineNum":"   28","line":"//   http://www.gnu.org/s/libc/manual/html_node/Aligned-Memory-Blocks.html"},
{"lineNum":"   29","line":"// This is true at least since glibc 2.8."},
{"lineNum":"   30","line":"// This leaves the question how to detect 64-bit. According to this document,"},
{"lineNum":"   31","line":"//   http://gcc.fyxm.net/summit/2003/Porting%20to%2064%20bit.pdf"},
{"lineNum":"   32","line":"// page 114, \"[The] LP64 model [...] is used by all 64-bit UNIX ports\" so it\'s indeed"},
{"lineNum":"   33","line":"// quite safe, at least within the context of glibc, to equate 64-bit with LP64."},
{"lineNum":"   34","line":"#if defined(__GLIBC__) && ((__GLIBC__>=2 && __GLIBC_MINOR__ >= 8) || __GLIBC__>2) \\"},
{"lineNum":"   35","line":" && defined(__LP64__) && ! defined( __SANITIZE_ADDRESS__ ) && (EIGEN_DEFAULT_ALIGN_BYTES == 16)"},
{"lineNum":"   36","line":"  #define EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED 1"},
{"lineNum":"   37","line":"#else"},
{"lineNum":"   38","line":"  #define EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED 0"},
{"lineNum":"   39","line":"#endif"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"// FreeBSD 6 seems to have 16-byte aligned malloc"},
{"lineNum":"   42","line":"//   See http://svn.freebsd.org/viewvc/base/stable/6/lib/libc/stdlib/malloc.c?view=markup"},
{"lineNum":"   43","line":"// FreeBSD 7 seems to have 16-byte aligned malloc except on ARM and MIPS architectures"},
{"lineNum":"   44","line":"//   See http://svn.freebsd.org/viewvc/base/stable/7/lib/libc/stdlib/malloc.c?view=markup"},
{"lineNum":"   45","line":"#if defined(__FreeBSD__) && !(EIGEN_ARCH_ARM || EIGEN_ARCH_MIPS) && (EIGEN_DEFAULT_ALIGN_BYTES == 16)"},
{"lineNum":"   46","line":"  #define EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED 1"},
{"lineNum":"   47","line":"#else"},
{"lineNum":"   48","line":"  #define EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED 0"},
{"lineNum":"   49","line":"#endif"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"#if (EIGEN_OS_MAC && (EIGEN_DEFAULT_ALIGN_BYTES == 16))     \\"},
{"lineNum":"   52","line":" || (EIGEN_OS_WIN64 && (EIGEN_DEFAULT_ALIGN_BYTES == 16))   \\"},
{"lineNum":"   53","line":" || EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED              \\"},
{"lineNum":"   54","line":" || EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED"},
{"lineNum":"   55","line":"  #define EIGEN_MALLOC_ALREADY_ALIGNED 1"},
{"lineNum":"   56","line":"#else"},
{"lineNum":"   57","line":"  #define EIGEN_MALLOC_ALREADY_ALIGNED 0"},
{"lineNum":"   58","line":"#endif"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"#endif"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"#include \"../InternalHeaderCheck.h\""},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"namespace Eigen {"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"namespace internal {"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"   69","line":"inline void throw_std_bad_alloc()"},
{"lineNum":"   70","line":"{"},
{"lineNum":"   71","line":"  #ifdef EIGEN_EXCEPTIONS"},
{"lineNum":"   72","line":"    throw std::bad_alloc();","class":"lineNoCov","hits":"0","possible_hits":"55",},
{"lineNum":"   73","line":"  #else"},
{"lineNum":"   74","line":"    std::size_t huge = static_cast<std::size_t>(-1);"},
{"lineNum":"   75","line":"    #if defined(EIGEN_HIPCC)"},
{"lineNum":"   76","line":"    //"},
{"lineNum":"   77","line":"    // calls to \"::operator new\" are to be treated as opaque function calls (i.e no inlining),"},
{"lineNum":"   78","line":"    // and as a consequence the code in the #else block triggers the hipcc warning :"},
{"lineNum":"   79","line":"    // \"no overloaded function has restriction specifiers that are compatible with the ambient context\""},
{"lineNum":"   80","line":"    //"},
{"lineNum":"   81","line":"    // \"throw_std_bad_alloc\" has the EIGEN_DEVICE_FUNC attribute, so it seems that hipcc expects"},
{"lineNum":"   82","line":"    // the same on \"operator new\""},
{"lineNum":"   83","line":"    // Reverting code back to the old version in this #if block for the hipcc compiler"},
{"lineNum":"   84","line":"    //"},
{"lineNum":"   85","line":"    new int[huge];"},
{"lineNum":"   86","line":"    #else"},
{"lineNum":"   87","line":"    void* unused = ::operator new(huge);"},
{"lineNum":"   88","line":"    EIGEN_UNUSED_VARIABLE(unused);"},
{"lineNum":"   89","line":"    #endif"},
{"lineNum":"   90","line":"  #endif"},
{"lineNum":"   91","line":"}"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"/*****************************************************************************"},
{"lineNum":"   94","line":"*** Implementation of handmade aligned functions                           ***"},
{"lineNum":"   95","line":"*****************************************************************************/"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"/* ----- Hand made implementations of aligned malloc/free and realloc ----- */"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"/** \\internal Like malloc, but the returned pointer is guaranteed to be 16-byte aligned."},
{"lineNum":"  100","line":"  * Fast, but wastes 16 additional bytes of memory. Does not throw any exception."},
{"lineNum":"  101","line":"  */"},
{"lineNum":"  102","line":"EIGEN_DEVICE_FUNC inline void* handmade_aligned_malloc(std::size_t size, std::size_t alignment = EIGEN_DEFAULT_ALIGN_BYTES)"},
{"lineNum":"  103","line":"{"},
{"lineNum":"  104","line":"  eigen_assert(alignment >= sizeof(void*) && (alignment & (alignment-1)) == 0 && \"Alignment must be at least sizeof(void*) and a power of 2\");"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"  EIGEN_USING_STD(malloc)"},
{"lineNum":"  107","line":"  void *original = malloc(size+alignment);"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"  if (original == 0) return 0;"},
{"lineNum":"  110","line":"  void *aligned = reinterpret_cast<void*>((reinterpret_cast<std::size_t>(original) & ~(std::size_t(alignment-1))) + alignment);"},
{"lineNum":"  111","line":"  *(reinterpret_cast<void**>(aligned) - 1) = original;"},
{"lineNum":"  112","line":"  return aligned;"},
{"lineNum":"  113","line":"}"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"/** \\internal Frees memory allocated with handmade_aligned_malloc */"},
{"lineNum":"  116","line":"EIGEN_DEVICE_FUNC inline void handmade_aligned_free(void *ptr)"},
{"lineNum":"  117","line":"{"},
{"lineNum":"  118","line":"  if (ptr) {"},
{"lineNum":"  119","line":"    EIGEN_USING_STD(free)"},
{"lineNum":"  120","line":"    free(*(reinterpret_cast<void**>(ptr) - 1));"},
{"lineNum":"  121","line":"  }"},
{"lineNum":"  122","line":"}"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"/** \\internal"},
{"lineNum":"  125","line":"  * \\brief Reallocates aligned memory."},
{"lineNum":"  126","line":"  * Since we know that our handmade version is based on std::malloc"},
{"lineNum":"  127","line":"  * we can use std::realloc to implement efficient reallocation."},
{"lineNum":"  128","line":"  */"},
{"lineNum":"  129","line":"inline void* handmade_aligned_realloc(void* ptr, std::size_t size, std::size_t = 0)"},
{"lineNum":"  130","line":"{"},
{"lineNum":"  131","line":"  if (ptr == 0) return handmade_aligned_malloc(size);"},
{"lineNum":"  132","line":"  void *original = *(reinterpret_cast<void**>(ptr) - 1);"},
{"lineNum":"  133","line":"  std::ptrdiff_t previous_offset = static_cast<char *>(ptr)-static_cast<char *>(original);"},
{"lineNum":"  134","line":"  original = std::realloc(original,size+EIGEN_DEFAULT_ALIGN_BYTES);"},
{"lineNum":"  135","line":"  if (original == 0) return 0;"},
{"lineNum":"  136","line":"  void *aligned = reinterpret_cast<void*>((reinterpret_cast<std::size_t>(original) & ~(std::size_t(EIGEN_DEFAULT_ALIGN_BYTES-1))) + EIGEN_DEFAULT_ALIGN_BYTES);"},
{"lineNum":"  137","line":"  void *previous_aligned = static_cast<char *>(original)+previous_offset;"},
{"lineNum":"  138","line":"  if(aligned!=previous_aligned)"},
{"lineNum":"  139","line":"    std::memmove(aligned, previous_aligned, size);"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"  *(reinterpret_cast<void**>(aligned) - 1) = original;"},
{"lineNum":"  142","line":"  return aligned;"},
{"lineNum":"  143","line":"}"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"/*****************************************************************************"},
{"lineNum":"  146","line":"*** Implementation of portable aligned versions of malloc/free/realloc     ***"},
{"lineNum":"  147","line":"*****************************************************************************/"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"#ifdef EIGEN_NO_MALLOC"},
{"lineNum":"  150","line":"EIGEN_DEVICE_FUNC inline void check_that_malloc_is_allowed()"},
{"lineNum":"  151","line":"{"},
{"lineNum":"  152","line":"  eigen_assert(false && \"heap allocation is forbidden (EIGEN_NO_MALLOC is defined)\");"},
{"lineNum":"  153","line":"}"},
{"lineNum":"  154","line":"#elif defined EIGEN_RUNTIME_NO_MALLOC"},
{"lineNum":"  155","line":"EIGEN_DEVICE_FUNC inline bool is_malloc_allowed_impl(bool update, bool new_value = false)"},
{"lineNum":"  156","line":"{"},
{"lineNum":"  157","line":"  static bool value = true;"},
{"lineNum":"  158","line":"  if (update == 1)"},
{"lineNum":"  159","line":"    value = new_value;"},
{"lineNum":"  160","line":"  return value;"},
{"lineNum":"  161","line":"}"},
{"lineNum":"  162","line":"EIGEN_DEVICE_FUNC inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }"},
{"lineNum":"  163","line":"EIGEN_DEVICE_FUNC inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }"},
{"lineNum":"  164","line":"EIGEN_DEVICE_FUNC inline void check_that_malloc_is_allowed()"},
{"lineNum":"  165","line":"{"},
{"lineNum":"  166","line":"  eigen_assert(is_malloc_allowed() && \"heap allocation is forbidden (EIGEN_RUNTIME_NO_MALLOC is defined and g_is_malloc_allowed is false)\");"},
{"lineNum":"  167","line":"}"},
{"lineNum":"  168","line":"#else"},
{"lineNum":"  169","line":"EIGEN_DEVICE_FUNC inline void check_that_malloc_is_allowed()"},
{"lineNum":"  170","line":"{}"},
{"lineNum":"  171","line":"#endif"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"/** \\internal Allocates \\a size bytes. The returned pointer is guaranteed to have 16 or 32 bytes alignment depending on the requirements."},
{"lineNum":"  174","line":"  * On allocation error, the returned pointer is null, and std::bad_alloc is thrown."},
{"lineNum":"  175","line":"  */"},
{"lineNum":"  176","line":"EIGEN_DEVICE_FUNC inline void* aligned_malloc(std::size_t size)"},
{"lineNum":"  177","line":"{"},
{"lineNum":"  178","line":"  check_that_malloc_is_allowed();"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"  void *result;"},
{"lineNum":"  181","line":"  #if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"    EIGEN_USING_STD(malloc)"},
{"lineNum":"  184","line":"    result = malloc(size);","class":"lineNoCov","hits":"0","possible_hits":"125",},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"    #if EIGEN_DEFAULT_ALIGN_BYTES==16"},
{"lineNum":"  187","line":"    eigen_assert((size<16 || (std::size_t(result)%16)==0) && \"System\'s malloc returned an unaligned pointer. Compile with EIGEN_MALLOC_ALREADY_ALIGNED=0 to fallback to handmade aligned memory allocator.\");"},
{"lineNum":"  188","line":"    #endif"},
{"lineNum":"  189","line":"  #else"},
{"lineNum":"  190","line":"    result = handmade_aligned_malloc(size);"},
{"lineNum":"  191","line":"  #endif"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"  if(!result && size)","class":"lineNoCov","hits":"0","possible_hits":"125",},
{"lineNum":"  194","line":"    throw_std_bad_alloc();"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"  return result;"},
{"lineNum":"  197","line":"}"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"/** \\internal Frees memory allocated with aligned_malloc. */"},
{"lineNum":"  200","line":"EIGEN_DEVICE_FUNC inline void aligned_free(void *ptr)"},
{"lineNum":"  201","line":"{"},
{"lineNum":"  202","line":"  #if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    EIGEN_USING_STD(free)"},
{"lineNum":"  205","line":"    free(ptr);","class":"lineNoCov","hits":"0","possible_hits":"436",},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"  #else"},
{"lineNum":"  208","line":"    handmade_aligned_free(ptr);"},
{"lineNum":"  209","line":"  #endif"},
{"lineNum":"  210","line":"}"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"/**"},
{"lineNum":"  213","line":"  * \\internal"},
{"lineNum":"  214","line":"  * \\brief Reallocates an aligned block of memory."},
{"lineNum":"  215","line":"  * \\throws std::bad_alloc on allocation failure"},
{"lineNum":"  216","line":"  */"},
{"lineNum":"  217","line":"inline void* aligned_realloc(void *ptr, std::size_t new_size, std::size_t old_size)"},
{"lineNum":"  218","line":"{"},
{"lineNum":"  219","line":"  EIGEN_UNUSED_VARIABLE(old_size)"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"  void *result;"},
{"lineNum":"  222","line":"#if (EIGEN_DEFAULT_ALIGN_BYTES==0) || EIGEN_MALLOC_ALREADY_ALIGNED"},
{"lineNum":"  223","line":"  result = std::realloc(ptr,new_size);"},
{"lineNum":"  224","line":"#else"},
{"lineNum":"  225","line":"  result = handmade_aligned_realloc(ptr,new_size,old_size);"},
{"lineNum":"  226","line":"#endif"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"  if (!result && new_size)"},
{"lineNum":"  229","line":"    throw_std_bad_alloc();"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"  return result;"},
{"lineNum":"  232","line":"}"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"/*****************************************************************************"},
{"lineNum":"  235","line":"*** Implementation of conditionally aligned functions                      ***"},
{"lineNum":"  236","line":"*****************************************************************************/"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"/** \\internal Allocates \\a size bytes. If Align is true, then the returned ptr is 16-byte-aligned."},
{"lineNum":"  239","line":"  * On allocation error, the returned pointer is null, and a std::bad_alloc is thrown."},
{"lineNum":"  240","line":"  */"},
{"lineNum":"  241","line":"template<bool Align> EIGEN_DEVICE_FUNC inline void* conditional_aligned_malloc(std::size_t size)"},
{"lineNum":"  242","line":"{"},
{"lineNum":"  243","line":"  return aligned_malloc(size);"},
{"lineNum":"  244","line":"}"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"template<> EIGEN_DEVICE_FUNC inline void* conditional_aligned_malloc<false>(std::size_t size)"},
{"lineNum":"  247","line":"{"},
{"lineNum":"  248","line":"  check_that_malloc_is_allowed();"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"  EIGEN_USING_STD(malloc)"},
{"lineNum":"  251","line":"  void *result = malloc(size);"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"  if(!result && size)"},
{"lineNum":"  254","line":"    throw_std_bad_alloc();"},
{"lineNum":"  255","line":"  return result;"},
{"lineNum":"  256","line":"}"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"/** \\internal Frees memory allocated with conditional_aligned_malloc */"},
{"lineNum":"  259","line":"template<bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_free(void *ptr)"},
{"lineNum":"  260","line":"{"},
{"lineNum":"  261","line":"  aligned_free(ptr);"},
{"lineNum":"  262","line":"}"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"template<> EIGEN_DEVICE_FUNC inline void conditional_aligned_free<false>(void *ptr)"},
{"lineNum":"  265","line":"{"},
{"lineNum":"  266","line":"  EIGEN_USING_STD(free)"},
{"lineNum":"  267","line":"  free(ptr);"},
{"lineNum":"  268","line":"}"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"template<bool Align> inline void* conditional_aligned_realloc(void* ptr, std::size_t new_size, std::size_t old_size)"},
{"lineNum":"  271","line":"{"},
{"lineNum":"  272","line":"  return aligned_realloc(ptr, new_size, old_size);"},
{"lineNum":"  273","line":"}"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"template<> inline void* conditional_aligned_realloc<false>(void* ptr, std::size_t new_size, std::size_t)"},
{"lineNum":"  276","line":"{"},
{"lineNum":"  277","line":"  return std::realloc(ptr, new_size);"},
{"lineNum":"  278","line":"}"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"/*****************************************************************************"},
{"lineNum":"  281","line":"*** Construction/destruction of array elements                             ***"},
{"lineNum":"  282","line":"*****************************************************************************/"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"/** \\internal Destructs the elements of an array."},
{"lineNum":"  285","line":"  * The \\a size parameters tells on how many objects to call the destructor of T."},
{"lineNum":"  286","line":"  */"},
{"lineNum":"  287","line":"template<typename T> EIGEN_DEVICE_FUNC inline void destruct_elements_of_array(T *ptr, std::size_t size)"},
{"lineNum":"  288","line":"{"},
{"lineNum":"  289","line":"  // always destruct an array starting from the end."},
{"lineNum":"  290","line":"  if(ptr)"},
{"lineNum":"  291","line":"    while(size) ptr[--size].~T();"},
{"lineNum":"  292","line":"}"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"/** \\internal Constructs the elements of an array."},
{"lineNum":"  295","line":"  * The \\a size parameter tells on how many objects to call the constructor of T."},
{"lineNum":"  296","line":"  */"},
{"lineNum":"  297","line":"template<typename T> EIGEN_DEVICE_FUNC inline T* construct_elements_of_array(T *ptr, std::size_t size)"},
{"lineNum":"  298","line":"{"},
{"lineNum":"  299","line":"  std::size_t i;"},
{"lineNum":"  300","line":"  EIGEN_TRY"},
{"lineNum":"  301","line":"  {"},
{"lineNum":"  302","line":"      for (i = 0; i < size; ++i) ::new (ptr + i) T;","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  303","line":"      return ptr;"},
{"lineNum":"  304","line":"  }"},
{"lineNum":"  305","line":"  EIGEN_CATCH(...)"},
{"lineNum":"  306","line":"  {"},
{"lineNum":"  307","line":"    destruct_elements_of_array(ptr, i);"},
{"lineNum":"  308","line":"    EIGEN_THROW;"},
{"lineNum":"  309","line":"  }"},
{"lineNum":"  310","line":"  return NULL;"},
{"lineNum":"  311","line":"}"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"/*****************************************************************************"},
{"lineNum":"  314","line":"*** Implementation of aligned new/delete-like functions                    ***"},
{"lineNum":"  315","line":"*****************************************************************************/"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"template<typename T>"},
{"lineNum":"  318","line":"EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE void check_size_for_overflow(std::size_t size)"},
{"lineNum":"  319","line":"{"},
{"lineNum":"  320","line":"  if(size > std::size_t(-1) / sizeof(T))","class":"lineNoCov","hits":"0","possible_hits":"109",},
{"lineNum":"  321","line":"    throw_std_bad_alloc();"},
{"lineNum":"  322","line":"}"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"/** \\internal Allocates \\a size objects of type T. The returned pointer is guaranteed to have 16 bytes alignment."},
{"lineNum":"  325","line":"  * On allocation error, the returned pointer is undefined, but a std::bad_alloc is thrown."},
{"lineNum":"  326","line":"  * The default constructor of T is called."},
{"lineNum":"  327","line":"  */"},
{"lineNum":"  328","line":"template<typename T> EIGEN_DEVICE_FUNC inline T* aligned_new(std::size_t size)"},
{"lineNum":"  329","line":"{"},
{"lineNum":"  330","line":"  check_size_for_overflow<T>(size);"},
{"lineNum":"  331","line":"  T *result = reinterpret_cast<T*>(aligned_malloc(sizeof(T)*size));","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  332","line":"  EIGEN_TRY"},
{"lineNum":"  333","line":"  {"},
{"lineNum":"  334","line":"    return construct_elements_of_array(result, size);"},
{"lineNum":"  335","line":"  }"},
{"lineNum":"  336","line":"  EIGEN_CATCH(...)"},
{"lineNum":"  337","line":"  {"},
{"lineNum":"  338","line":"    aligned_free(result);"},
{"lineNum":"  339","line":"    EIGEN_THROW;"},
{"lineNum":"  340","line":"  }"},
{"lineNum":"  341","line":"  return result;"},
{"lineNum":"  342","line":"}"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_new(std::size_t size)"},
{"lineNum":"  345","line":"{"},
{"lineNum":"  346","line":"  check_size_for_overflow<T>(size);"},
{"lineNum":"  347","line":"  T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));"},
{"lineNum":"  348","line":"  EIGEN_TRY"},
{"lineNum":"  349","line":"  {"},
{"lineNum":"  350","line":"    return construct_elements_of_array(result, size);"},
{"lineNum":"  351","line":"  }"},
{"lineNum":"  352","line":"  EIGEN_CATCH(...)"},
{"lineNum":"  353","line":"  {"},
{"lineNum":"  354","line":"    conditional_aligned_free<Align>(result);"},
{"lineNum":"  355","line":"    EIGEN_THROW;"},
{"lineNum":"  356","line":"  }"},
{"lineNum":"  357","line":"  return result;"},
{"lineNum":"  358","line":"}"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"/** \\internal Deletes objects constructed with aligned_new"},
{"lineNum":"  361","line":"  * The \\a size parameters tells on how many objects to call the destructor of T."},
{"lineNum":"  362","line":"  */"},
{"lineNum":"  363","line":"template<typename T> EIGEN_DEVICE_FUNC inline void aligned_delete(T *ptr, std::size_t size)"},
{"lineNum":"  364","line":"{"},
{"lineNum":"  365","line":"  destruct_elements_of_array<T>(ptr, size);"},
{"lineNum":"  366","line":"  Eigen::internal::aligned_free(ptr);"},
{"lineNum":"  367","line":"}"},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"/** \\internal Deletes objects constructed with conditional_aligned_new"},
{"lineNum":"  370","line":"  * The \\a size parameters tells on how many objects to call the destructor of T."},
{"lineNum":"  371","line":"  */"},
{"lineNum":"  372","line":"template<typename T, bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_delete(T *ptr, std::size_t size)"},
{"lineNum":"  373","line":"{"},
{"lineNum":"  374","line":"  destruct_elements_of_array<T>(ptr, size);"},
{"lineNum":"  375","line":"  conditional_aligned_free<Align>(ptr);"},
{"lineNum":"  376","line":"}"},
{"lineNum":"  377","line":""},
{"lineNum":"  378","line":"template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_realloc_new(T* pts, std::size_t new_size, std::size_t old_size)"},
{"lineNum":"  379","line":"{"},
{"lineNum":"  380","line":"  check_size_for_overflow<T>(new_size);"},
{"lineNum":"  381","line":"  check_size_for_overflow<T>(old_size);"},
{"lineNum":"  382","line":"  if(new_size < old_size)"},
{"lineNum":"  383","line":"    destruct_elements_of_array(pts+new_size, old_size-new_size);"},
{"lineNum":"  384","line":"  T *result = reinterpret_cast<T*>(conditional_aligned_realloc<Align>(reinterpret_cast<void*>(pts), sizeof(T)*new_size, sizeof(T)*old_size));"},
{"lineNum":"  385","line":"  if(new_size > old_size)"},
{"lineNum":"  386","line":"  {"},
{"lineNum":"  387","line":"    EIGEN_TRY"},
{"lineNum":"  388","line":"    {"},
{"lineNum":"  389","line":"      construct_elements_of_array(result+old_size, new_size-old_size);"},
{"lineNum":"  390","line":"    }"},
{"lineNum":"  391","line":"    EIGEN_CATCH(...)"},
{"lineNum":"  392","line":"    {"},
{"lineNum":"  393","line":"      conditional_aligned_free<Align>(result);"},
{"lineNum":"  394","line":"      EIGEN_THROW;"},
{"lineNum":"  395","line":"    }"},
{"lineNum":"  396","line":"  }"},
{"lineNum":"  397","line":"  return result;"},
{"lineNum":"  398","line":"}"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":""},
{"lineNum":"  401","line":"template<typename T, bool Align> EIGEN_DEVICE_FUNC inline T* conditional_aligned_new_auto(std::size_t size)"},
{"lineNum":"  402","line":"{"},
{"lineNum":"  403","line":"  if(size==0)","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  404","line":"    return 0; // short-cut. Also fixes Bug 884"},
{"lineNum":"  405","line":"  check_size_for_overflow<T>(size);"},
{"lineNum":"  406","line":"  T *result = reinterpret_cast<T*>(conditional_aligned_malloc<Align>(sizeof(T)*size));","class":"lineNoCov","hits":"0","possible_hits":"32",},
{"lineNum":"  407","line":"  if(NumTraits<T>::RequireInitialization)"},
{"lineNum":"  408","line":"  {"},
{"lineNum":"  409","line":"    EIGEN_TRY"},
{"lineNum":"  410","line":"    {"},
{"lineNum":"  411","line":"      construct_elements_of_array(result, size);"},
{"lineNum":"  412","line":"    }"},
{"lineNum":"  413","line":"    EIGEN_CATCH(...)"},
{"lineNum":"  414","line":"    {"},
{"lineNum":"  415","line":"      conditional_aligned_free<Align>(result);"},
{"lineNum":"  416","line":"      EIGEN_THROW;"},
{"lineNum":"  417","line":"    }"},
{"lineNum":"  418","line":"  }"},
{"lineNum":"  419","line":"  return result;"},
{"lineNum":"  420","line":"}"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, std::size_t new_size, std::size_t old_size)"},
{"lineNum":"  423","line":"{"},
{"lineNum":"  424","line":"  check_size_for_overflow<T>(new_size);"},
{"lineNum":"  425","line":"  check_size_for_overflow<T>(old_size);"},
{"lineNum":"  426","line":"  if(NumTraits<T>::RequireInitialization && (new_size < old_size))"},
{"lineNum":"  427","line":"    destruct_elements_of_array(pts+new_size, old_size-new_size);"},
{"lineNum":"  428","line":"  T *result = reinterpret_cast<T*>(conditional_aligned_realloc<Align>(reinterpret_cast<void*>(pts), sizeof(T)*new_size, sizeof(T)*old_size));"},
{"lineNum":"  429","line":"  if(NumTraits<T>::RequireInitialization && (new_size > old_size))"},
{"lineNum":"  430","line":"  {"},
{"lineNum":"  431","line":"    EIGEN_TRY"},
{"lineNum":"  432","line":"    {"},
{"lineNum":"  433","line":"      construct_elements_of_array(result+old_size, new_size-old_size);"},
{"lineNum":"  434","line":"    }"},
{"lineNum":"  435","line":"    EIGEN_CATCH(...)"},
{"lineNum":"  436","line":"    {"},
{"lineNum":"  437","line":"      conditional_aligned_free<Align>(result);"},
{"lineNum":"  438","line":"      EIGEN_THROW;"},
{"lineNum":"  439","line":"    }"},
{"lineNum":"  440","line":"  }"},
{"lineNum":"  441","line":"  return result;"},
{"lineNum":"  442","line":"}"},
{"lineNum":"  443","line":""},
{"lineNum":"  444","line":"template<typename T, bool Align> EIGEN_DEVICE_FUNC inline void conditional_aligned_delete_auto(T *ptr, std::size_t size)"},
{"lineNum":"  445","line":"{"},
{"lineNum":"  446","line":"  if(NumTraits<T>::RequireInitialization)"},
{"lineNum":"  447","line":"    destruct_elements_of_array<T>(ptr, size);"},
{"lineNum":"  448","line":"  conditional_aligned_free<Align>(ptr);"},
{"lineNum":"  449","line":"}"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"/****************************************************************************/"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"/** \\internal Returns the index of the first element of the array that is well aligned with respect to the requested \\a Alignment."},
{"lineNum":"  454","line":"  *"},
{"lineNum":"  455","line":"  * \\tparam Alignment requested alignment in Bytes."},
{"lineNum":"  456","line":"  * \\param array the address of the start of the array"},
{"lineNum":"  457","line":"  * \\param size the size of the array"},
{"lineNum":"  458","line":"  *"},
{"lineNum":"  459","line":"  * \\note If no element of the array is well aligned or the requested alignment is not a multiple of a scalar,"},
{"lineNum":"  460","line":"  * the size of the array is returned. For example with SSE, the requested alignment is typically 16-bytes. If"},
{"lineNum":"  461","line":"  * packet size for the given scalar type is 1, then everything is considered well-aligned."},
{"lineNum":"  462","line":"  *"},
{"lineNum":"  463","line":"  * \\note Otherwise, if the Alignment is larger that the scalar size, we rely on the assumptions that sizeof(Scalar) is a"},
{"lineNum":"  464","line":"  * power of 2. On the other hand, we do not assume that the array address is a multiple of sizeof(Scalar), as that fails for"},
{"lineNum":"  465","line":"  * example with Scalar=double on certain 32-bit platforms, see bug #79."},
{"lineNum":"  466","line":"  *"},
{"lineNum":"  467","line":"  * There is also the variant first_aligned(const MatrixBase&) defined in DenseCoeffsBase.h."},
{"lineNum":"  468","line":"  * \\sa first_default_aligned()"},
{"lineNum":"  469","line":"  */"},
{"lineNum":"  470","line":"template<int Alignment, typename Scalar, typename Index>"},
{"lineNum":"  471","line":"EIGEN_DEVICE_FUNC inline Index first_aligned(const Scalar* array, Index size)"},
{"lineNum":"  472","line":"{"},
{"lineNum":"  473","line":"  const Index ScalarSize = sizeof(Scalar);"},
{"lineNum":"  474","line":"  const Index AlignmentSize = Alignment / ScalarSize;"},
{"lineNum":"  475","line":"  const Index AlignmentMask = AlignmentSize-1;"},
{"lineNum":"  476","line":""},
{"lineNum":"  477","line":"  if(AlignmentSize<=1)"},
{"lineNum":"  478","line":"  {"},
{"lineNum":"  479","line":"    // Either the requested alignment if smaller than a scalar, or it exactly match a 1 scalar"},
{"lineNum":"  480","line":"    // so that all elements of the array have the same alignment."},
{"lineNum":"  481","line":"    return 0;"},
{"lineNum":"  482","line":"  }"},
{"lineNum":"  483","line":"  else if( (UIntPtr(array) & (sizeof(Scalar)-1)) || (Alignment%ScalarSize)!=0)","class":"lineNoCov","hits":"0","possible_hits":"66",},
{"lineNum":"  484","line":"  {"},
{"lineNum":"  485","line":"    // The array is not aligned to the size of a single scalar, or the requested alignment is not a multiple of the scalar size."},
{"lineNum":"  486","line":"    // Consequently, no element of the array is well aligned."},
{"lineNum":"  487","line":"    return size;"},
{"lineNum":"  488","line":"  }"},
{"lineNum":"  489","line":"  else"},
{"lineNum":"  490","line":"  {"},
{"lineNum":"  491","line":"    Index first = (AlignmentSize - (Index((UIntPtr(array)/sizeof(Scalar))) & AlignmentMask)) & AlignmentMask;"},
{"lineNum":"  492","line":"    return (first < size) ? first : size;"},
{"lineNum":"  493","line":"  }"},
{"lineNum":"  494","line":"}"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"/** \\internal Returns the index of the first element of the array that is well aligned with respect the largest packet requirement."},
{"lineNum":"  497","line":"   * \\sa first_aligned(Scalar*,Index) and first_default_aligned(DenseBase<Derived>) */"},
{"lineNum":"  498","line":"template<typename Scalar, typename Index>"},
{"lineNum":"  499","line":"EIGEN_DEVICE_FUNC inline Index first_default_aligned(const Scalar* array, Index size)"},
{"lineNum":"  500","line":"{"},
{"lineNum":"  501","line":"  typedef typename packet_traits<Scalar>::type DefaultPacketType;"},
{"lineNum":"  502","line":"  return first_aligned<unpacket_traits<DefaultPacketType>::alignment>(array, size);"},
{"lineNum":"  503","line":"}"},
{"lineNum":"  504","line":""},
{"lineNum":"  505","line":"/** \\internal Returns the smallest integer multiple of \\a base and greater or equal to \\a size"},
{"lineNum":"  506","line":"  */"},
{"lineNum":"  507","line":"template<typename Index>"},
{"lineNum":"  508","line":"inline Index first_multiple(Index size, Index base)"},
{"lineNum":"  509","line":"{"},
{"lineNum":"  510","line":"  return ((size+base-1)/base)*base;"},
{"lineNum":"  511","line":"}"},
{"lineNum":"  512","line":""},
{"lineNum":"  513","line":"// std::copy is much slower than memcpy, so let\'s introduce a smart_copy which"},
{"lineNum":"  514","line":"// use memcpy on trivial types, i.e., on types that does not require an initialization ctor."},
{"lineNum":"  515","line":"template<typename T, bool UseMemcpy> struct smart_copy_helper;"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"template<typename T> EIGEN_DEVICE_FUNC void smart_copy(const T* start, const T* end, T* target)"},
{"lineNum":"  518","line":"{"},
{"lineNum":"  519","line":"  smart_copy_helper<T,!NumTraits<T>::RequireInitialization>::run(start, end, target);"},
{"lineNum":"  520","line":"}"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"template<typename T> struct smart_copy_helper<T,true> {"},
{"lineNum":"  523","line":"  EIGEN_DEVICE_FUNC static inline void run(const T* start, const T* end, T* target)"},
{"lineNum":"  524","line":"  {"},
{"lineNum":"  525","line":"    IntPtr size = IntPtr(end)-IntPtr(start);","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  526","line":"    if(size==0) return;","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  527","line":"    eigen_internal_assert(start!=0 && end!=0 && target!=0);"},
{"lineNum":"  528","line":"    EIGEN_USING_STD(memcpy)"},
{"lineNum":"  529","line":"    memcpy(target, start, size);","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  530","line":"  }"},
{"lineNum":"  531","line":"};"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"template<typename T> struct smart_copy_helper<T,false> {"},
{"lineNum":"  534","line":"  EIGEN_DEVICE_FUNC static inline void run(const T* start, const T* end, T* target)"},
{"lineNum":"  535","line":"  { std::copy(start, end, target); }"},
{"lineNum":"  536","line":"};"},
{"lineNum":"  537","line":""},
{"lineNum":"  538","line":"// intelligent memmove. falls back to std::memmove for POD types, uses std::copy otherwise."},
{"lineNum":"  539","line":"template<typename T, bool UseMemmove> struct smart_memmove_helper;"},
{"lineNum":"  540","line":""},
{"lineNum":"  541","line":"template<typename T> void smart_memmove(const T* start, const T* end, T* target)"},
{"lineNum":"  542","line":"{"},
{"lineNum":"  543","line":"  smart_memmove_helper<T,!NumTraits<T>::RequireInitialization>::run(start, end, target);"},
{"lineNum":"  544","line":"}"},
{"lineNum":"  545","line":""},
{"lineNum":"  546","line":"template<typename T> struct smart_memmove_helper<T,true> {"},
{"lineNum":"  547","line":"  static inline void run(const T* start, const T* end, T* target)"},
{"lineNum":"  548","line":"  {"},
{"lineNum":"  549","line":"    IntPtr size = IntPtr(end)-IntPtr(start);"},
{"lineNum":"  550","line":"    if(size==0) return;"},
{"lineNum":"  551","line":"    eigen_internal_assert(start!=0 && end!=0 && target!=0);"},
{"lineNum":"  552","line":"    std::memmove(target, start, size);"},
{"lineNum":"  553","line":"  }"},
{"lineNum":"  554","line":"};"},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"template<typename T> struct smart_memmove_helper<T,false> {"},
{"lineNum":"  557","line":"  static inline void run(const T* start, const T* end, T* target)"},
{"lineNum":"  558","line":"  {"},
{"lineNum":"  559","line":"    if (UIntPtr(target) < UIntPtr(start))"},
{"lineNum":"  560","line":"    {"},
{"lineNum":"  561","line":"      std::copy(start, end, target);"},
{"lineNum":"  562","line":"    }"},
{"lineNum":"  563","line":"    else"},
{"lineNum":"  564","line":"    {"},
{"lineNum":"  565","line":"      std::ptrdiff_t count = (std::ptrdiff_t(end)-std::ptrdiff_t(start)) / sizeof(T);"},
{"lineNum":"  566","line":"      std::copy_backward(start, end, target + count);"},
{"lineNum":"  567","line":"    }"},
{"lineNum":"  568","line":"  }"},
{"lineNum":"  569","line":"};"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"#if EIGEN_HAS_RVALUE_REFERENCES"},
{"lineNum":"  572","line":"template<typename T> EIGEN_DEVICE_FUNC T* smart_move(T* start, T* end, T* target)"},
{"lineNum":"  573","line":"{"},
{"lineNum":"  574","line":"  return std::move(start, end, target);"},
{"lineNum":"  575","line":"}"},
{"lineNum":"  576","line":"#else"},
{"lineNum":"  577","line":"template<typename T> EIGEN_DEVICE_FUNC T* smart_move(T* start, T* end, T* target)"},
{"lineNum":"  578","line":"{"},
{"lineNum":"  579","line":"  return std::copy(start, end, target);"},
{"lineNum":"  580","line":"}"},
{"lineNum":"  581","line":"#endif"},
{"lineNum":"  582","line":""},
{"lineNum":"  583","line":"/*****************************************************************************"},
{"lineNum":"  584","line":"*** Implementation of runtime stack allocation (falling back to malloc)    ***"},
{"lineNum":"  585","line":"*****************************************************************************/"},
{"lineNum":"  586","line":""},
{"lineNum":"  587","line":"// you can overwrite Eigen\'s default behavior regarding alloca by defining EIGEN_ALLOCA"},
{"lineNum":"  588","line":"// to the appropriate stack allocation function"},
{"lineNum":"  589","line":"#if ! defined EIGEN_ALLOCA && ! defined EIGEN_GPU_COMPILE_PHASE"},
{"lineNum":"  590","line":"  #if EIGEN_OS_LINUX || EIGEN_OS_MAC || (defined alloca)"},
{"lineNum":"  591","line":"    #define EIGEN_ALLOCA alloca"},
{"lineNum":"  592","line":"  #elif EIGEN_COMP_MSVC"},
{"lineNum":"  593","line":"    #define EIGEN_ALLOCA _alloca"},
{"lineNum":"  594","line":"  #endif"},
{"lineNum":"  595","line":"#endif"},
{"lineNum":"  596","line":""},
{"lineNum":"  597","line":"// With clang -Oz -mthumb, alloca changes the stack pointer in a way that is"},
{"lineNum":"  598","line":"// not allowed in Thumb2. -DEIGEN_STACK_ALLOCATION_LIMIT=0 doesn\'t work because"},
{"lineNum":"  599","line":"// the compiler still emits bad code because stack allocation checks use \"<=\"."},
{"lineNum":"  600","line":"// TODO: Eliminate after https://bugs.llvm.org/show_bug.cgi?id=23772"},
{"lineNum":"  601","line":"// is fixed."},
{"lineNum":"  602","line":"#if defined(__clang__) && defined(__thumb__)"},
{"lineNum":"  603","line":"  #undef EIGEN_ALLOCA"},
{"lineNum":"  604","line":"#endif"},
{"lineNum":"  605","line":""},
{"lineNum":"  606","line":"// This helper class construct the allocated memory, and takes care of destructing and freeing the handled data"},
{"lineNum":"  607","line":"// at destruction time. In practice this helper class is mainly useful to avoid memory leak in case of exceptions."},
{"lineNum":"  608","line":"template<typename T> class aligned_stack_memory_handler : noncopyable"},
{"lineNum":"  609","line":"{"},
{"lineNum":"  610","line":"  public:"},
{"lineNum":"  611","line":"    /* Creates a stack_memory_handler responsible for the buffer \\a ptr of size \\a size."},
{"lineNum":"  612","line":"     * Note that \\a ptr can be 0 regardless of the other parameters."},
{"lineNum":"  613","line":"     * This constructor takes care of constructing/initializing the elements of the buffer if required by the scalar type T (see NumTraits<T>::RequireInitialization)."},
{"lineNum":"  614","line":"     * In this case, the buffer elements will also be destructed when this handler will be destructed."},
{"lineNum":"  615","line":"     * Finally, if \\a dealloc is true, then the pointer \\a ptr is freed."},
{"lineNum":"  616","line":"     **/"},
{"lineNum":"  617","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  618","line":"    aligned_stack_memory_handler(T* ptr, std::size_t size, bool dealloc)"},
{"lineNum":"  619","line":"      : m_ptr(ptr), m_size(size), m_deallocate(dealloc)"},
{"lineNum":"  620","line":"    {"},
{"lineNum":"  621","line":"      if(NumTraits<T>::RequireInitialization && m_ptr)","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  622","line":"        Eigen::internal::construct_elements_of_array(m_ptr, size);"},
{"lineNum":"  623","line":"    }"},
{"lineNum":"  624","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  625","line":"    ~aligned_stack_memory_handler()"},
{"lineNum":"  626","line":"    {"},
{"lineNum":"  627","line":"      if(NumTraits<T>::RequireInitialization && m_ptr)"},
{"lineNum":"  628","line":"        Eigen::internal::destruct_elements_of_array<T>(m_ptr, m_size);"},
{"lineNum":"  629","line":"      if(m_deallocate)","class":"lineNoCov","hits":"0","possible_hits":"150",},
{"lineNum":"  630","line":"        Eigen::internal::aligned_free(m_ptr);"},
{"lineNum":"  631","line":"    }"},
{"lineNum":"  632","line":"  protected:"},
{"lineNum":"  633","line":"    T* m_ptr;"},
{"lineNum":"  634","line":"    std::size_t m_size;"},
{"lineNum":"  635","line":"    bool m_deallocate;"},
{"lineNum":"  636","line":"};"},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"#ifdef EIGEN_ALLOCA"},
{"lineNum":"  639","line":""},
{"lineNum":"  640","line":"template<typename Xpr, int NbEvaluations,"},
{"lineNum":"  641","line":"         bool MapExternalBuffer = nested_eval<Xpr,NbEvaluations>::Evaluate && Xpr::MaxSizeAtCompileTime==Dynamic"},
{"lineNum":"  642","line":"         >"},
{"lineNum":"  643","line":"struct local_nested_eval_wrapper"},
{"lineNum":"  644","line":"{"},
{"lineNum":"  645","line":"  static const bool NeedExternalBuffer = false;"},
{"lineNum":"  646","line":"  typedef typename Xpr::Scalar Scalar;"},
{"lineNum":"  647","line":"  typedef typename nested_eval<Xpr,NbEvaluations>::type ObjectType;"},
{"lineNum":"  648","line":"  ObjectType object;"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  651","line":"  local_nested_eval_wrapper(const Xpr& xpr, Scalar* ptr) : object(xpr)"},
{"lineNum":"  652","line":"  {"},
{"lineNum":"  653","line":"    EIGEN_UNUSED_VARIABLE(ptr);"},
{"lineNum":"  654","line":"    eigen_internal_assert(ptr==0);"},
{"lineNum":"  655","line":"  }"},
{"lineNum":"  656","line":"};"},
{"lineNum":"  657","line":""},
{"lineNum":"  658","line":"template<typename Xpr, int NbEvaluations>"},
{"lineNum":"  659","line":"struct local_nested_eval_wrapper<Xpr,NbEvaluations,true>"},
{"lineNum":"  660","line":"{"},
{"lineNum":"  661","line":"  static const bool NeedExternalBuffer = true;"},
{"lineNum":"  662","line":"  typedef typename Xpr::Scalar Scalar;"},
{"lineNum":"  663","line":"  typedef typename plain_object_eval<Xpr>::type PlainObject;"},
{"lineNum":"  664","line":"  typedef Map<PlainObject,EIGEN_DEFAULT_ALIGN_BYTES> ObjectType;"},
{"lineNum":"  665","line":"  ObjectType object;"},
{"lineNum":"  666","line":""},
{"lineNum":"  667","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  668","line":"  local_nested_eval_wrapper(const Xpr& xpr, Scalar* ptr)"},
{"lineNum":"  669","line":"    : object(ptr==0 ? reinterpret_cast<Scalar*>(Eigen::internal::aligned_malloc(sizeof(Scalar)*xpr.size())) : ptr, xpr.rows(), xpr.cols()),","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  670","line":"      m_deallocate(ptr==0)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  671","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  672","line":"    if(NumTraits<Scalar>::RequireInitialization && object.data())"},
{"lineNum":"  673","line":"      Eigen::internal::construct_elements_of_array(object.data(), object.size());"},
{"lineNum":"  674","line":"    object = xpr;"},
{"lineNum":"  675","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  676","line":""},
{"lineNum":"  677","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  678","line":"  ~local_nested_eval_wrapper()"},
{"lineNum":"  679","line":"  {"},
{"lineNum":"  680","line":"    if(NumTraits<Scalar>::RequireInitialization && object.data())"},
{"lineNum":"  681","line":"      Eigen::internal::destruct_elements_of_array(object.data(), object.size());"},
{"lineNum":"  682","line":"    if(m_deallocate)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  683","line":"      Eigen::internal::aligned_free(object.data());"},
{"lineNum":"  684","line":"  }"},
{"lineNum":"  685","line":""},
{"lineNum":"  686","line":"private:"},
{"lineNum":"  687","line":"  bool m_deallocate;"},
{"lineNum":"  688","line":"};"},
{"lineNum":"  689","line":""},
{"lineNum":"  690","line":"#endif // EIGEN_ALLOCA"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"template<typename T> class scoped_array : noncopyable"},
{"lineNum":"  693","line":"{"},
{"lineNum":"  694","line":"  T* m_ptr;"},
{"lineNum":"  695","line":"public:"},
{"lineNum":"  696","line":"  explicit scoped_array(std::ptrdiff_t size)"},
{"lineNum":"  697","line":"  {"},
{"lineNum":"  698","line":"    m_ptr = new T[size];"},
{"lineNum":"  699","line":"  }"},
{"lineNum":"  700","line":"  ~scoped_array()"},
{"lineNum":"  701","line":"  {"},
{"lineNum":"  702","line":"    delete[] m_ptr;"},
{"lineNum":"  703","line":"  }"},
{"lineNum":"  704","line":"  T& operator[](std::ptrdiff_t i) { return m_ptr[i]; }"},
{"lineNum":"  705","line":"  const T& operator[](std::ptrdiff_t i) const { return m_ptr[i]; }"},
{"lineNum":"  706","line":"  T* &ptr() { return m_ptr; }"},
{"lineNum":"  707","line":"  const T* ptr() const { return m_ptr; }"},
{"lineNum":"  708","line":"  operator const T*() const { return m_ptr; }"},
{"lineNum":"  709","line":"};"},
{"lineNum":"  710","line":""},
{"lineNum":"  711","line":"template<typename T> void swap(scoped_array<T> &a,scoped_array<T> &b)"},
{"lineNum":"  712","line":"{"},
{"lineNum":"  713","line":"  std::swap(a.ptr(),b.ptr());"},
{"lineNum":"  714","line":"}"},
{"lineNum":"  715","line":""},
{"lineNum":"  716","line":"} // end namespace internal"},
{"lineNum":"  717","line":""},
{"lineNum":"  718","line":"/** \\internal"},
{"lineNum":"  719","line":"  *"},
{"lineNum":"  720","line":"  * The macro ei_declare_aligned_stack_constructed_variable(TYPE,NAME,SIZE,BUFFER) declares, allocates,"},
{"lineNum":"  721","line":"  * and construct an aligned buffer named NAME of SIZE elements of type TYPE on the stack"},
{"lineNum":"  722","line":"  * if the size in bytes is smaller than EIGEN_STACK_ALLOCATION_LIMIT, and if stack allocation is supported by the platform"},
{"lineNum":"  723","line":"  * (currently, this is Linux, OSX and Visual Studio only). Otherwise the memory is allocated on the heap."},
{"lineNum":"  724","line":"  * The allocated buffer is automatically deleted when exiting the scope of this declaration."},
{"lineNum":"  725","line":"  * If BUFFER is non null, then the declared variable is simply an alias for BUFFER, and no allocation/deletion occurs."},
{"lineNum":"  726","line":"  * Here is an example:"},
{"lineNum":"  727","line":"  * \\code"},
{"lineNum":"  728","line":"  * {"},
{"lineNum":"  729","line":"  *   ei_declare_aligned_stack_constructed_variable(float,data,size,0);"},
{"lineNum":"  730","line":"  *   // use data[0] to data[size-1]"},
{"lineNum":"  731","line":"  * }"},
{"lineNum":"  732","line":"  * \\endcode"},
{"lineNum":"  733","line":"  * The underlying stack allocation function can controlled with the EIGEN_ALLOCA preprocessor token."},
{"lineNum":"  734","line":"  *"},
{"lineNum":"  735","line":"  * The macro ei_declare_local_nested_eval(XPR_T,XPR,N,NAME) is analogue to"},
{"lineNum":"  736","line":"  * \\code"},
{"lineNum":"  737","line":"  *   typename internal::nested_eval<XPRT_T,N>::type NAME(XPR);"},
{"lineNum":"  738","line":"  * \\endcode"},
{"lineNum":"  739","line":"  * with the advantage of using aligned stack allocation even if the maximal size of XPR at compile time is unknown."},
{"lineNum":"  740","line":"  * This is accomplished through alloca if this later is supported and if the required number of bytes"},
{"lineNum":"  741","line":"  * is below EIGEN_STACK_ALLOCATION_LIMIT."},
{"lineNum":"  742","line":"  */"},
{"lineNum":"  743","line":"#ifdef EIGEN_ALLOCA"},
{"lineNum":"  744","line":""},
{"lineNum":"  745","line":"  #if EIGEN_DEFAULT_ALIGN_BYTES>0"},
{"lineNum":"  746","line":"    // We always manually re-align the result of EIGEN_ALLOCA."},
{"lineNum":"  747","line":"    // If alloca is already aligned, the compiler should be smart enough to optimize away the re-alignment."},
{"lineNum":"  748","line":"    #define EIGEN_ALIGNED_ALLOCA(SIZE) reinterpret_cast<void*>((internal::UIntPtr(EIGEN_ALLOCA(SIZE+EIGEN_DEFAULT_ALIGN_BYTES-1)) + EIGEN_DEFAULT_ALIGN_BYTES-1) & ~(std::size_t(EIGEN_DEFAULT_ALIGN_BYTES-1)))"},
{"lineNum":"  749","line":"  #else"},
{"lineNum":"  750","line":"    #define EIGEN_ALIGNED_ALLOCA(SIZE) EIGEN_ALLOCA(SIZE)"},
{"lineNum":"  751","line":"  #endif"},
{"lineNum":"  752","line":""},
{"lineNum":"  753","line":"  #define ei_declare_aligned_stack_constructed_variable(TYPE,NAME,SIZE,BUFFER) \\"},
{"lineNum":"  754","line":"    Eigen::internal::check_size_for_overflow<TYPE>(SIZE); \\"},
{"lineNum":"  755","line":"    TYPE* NAME = (BUFFER)!=0 ? (BUFFER) \\"},
{"lineNum":"  756","line":"               : reinterpret_cast<TYPE*>( \\"},
{"lineNum":"  757","line":"                      (sizeof(TYPE)*SIZE<=EIGEN_STACK_ALLOCATION_LIMIT) ? EIGEN_ALIGNED_ALLOCA(sizeof(TYPE)*SIZE) \\"},
{"lineNum":"  758","line":"                    : Eigen::internal::aligned_malloc(sizeof(TYPE)*SIZE) );  \\"},
{"lineNum":"  759","line":"    Eigen::internal::aligned_stack_memory_handler<TYPE> EIGEN_CAT(NAME,_stack_memory_destructor)((BUFFER)==0 ? NAME : 0,SIZE,sizeof(TYPE)*SIZE>EIGEN_STACK_ALLOCATION_LIMIT)"},
{"lineNum":"  760","line":""},
{"lineNum":"  761","line":""},
{"lineNum":"  762","line":"  #define ei_declare_local_nested_eval(XPR_T,XPR,N,NAME) \\"},
{"lineNum":"  763","line":"    Eigen::internal::local_nested_eval_wrapper<XPR_T,N> EIGEN_CAT(NAME,_wrapper)(XPR, reinterpret_cast<typename XPR_T::Scalar*>( \\"},
{"lineNum":"  764","line":"      ( (Eigen::internal::local_nested_eval_wrapper<XPR_T,N>::NeedExternalBuffer) && ((sizeof(typename XPR_T::Scalar)*XPR.size())<=EIGEN_STACK_ALLOCATION_LIMIT) ) \\"},
{"lineNum":"  765","line":"        ? EIGEN_ALIGNED_ALLOCA( sizeof(typename XPR_T::Scalar)*XPR.size() ) : 0 ) ) ; \\"},
{"lineNum":"  766","line":"    typename Eigen::internal::local_nested_eval_wrapper<XPR_T,N>::ObjectType NAME(EIGEN_CAT(NAME,_wrapper).object)"},
{"lineNum":"  767","line":""},
{"lineNum":"  768","line":"#else"},
{"lineNum":"  769","line":""},
{"lineNum":"  770","line":"  #define ei_declare_aligned_stack_constructed_variable(TYPE,NAME,SIZE,BUFFER) \\"},
{"lineNum":"  771","line":"    Eigen::internal::check_size_for_overflow<TYPE>(SIZE); \\"},
{"lineNum":"  772","line":"    TYPE* NAME = (BUFFER)!=0 ? BUFFER : reinterpret_cast<TYPE*>(Eigen::internal::aligned_malloc(sizeof(TYPE)*SIZE));    \\"},
{"lineNum":"  773","line":"    Eigen::internal::aligned_stack_memory_handler<TYPE> EIGEN_CAT(NAME,_stack_memory_destructor)((BUFFER)==0 ? NAME : 0,SIZE,true)"},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":""},
{"lineNum":"  776","line":"#define ei_declare_local_nested_eval(XPR_T,XPR,N,NAME) typename Eigen::internal::nested_eval<XPR_T,N>::type NAME(XPR)"},
{"lineNum":"  777","line":""},
{"lineNum":"  778","line":"#endif"},
{"lineNum":"  779","line":""},
{"lineNum":"  780","line":""},
{"lineNum":"  781","line":"/*****************************************************************************"},
{"lineNum":"  782","line":"*** Implementation of EIGEN_MAKE_ALIGNED_OPERATOR_NEW [_IF]                ***"},
{"lineNum":"  783","line":"*****************************************************************************/"},
{"lineNum":"  784","line":""},
{"lineNum":"  785","line":"#if EIGEN_HAS_CXX17_OVERALIGN"},
{"lineNum":"  786","line":""},
{"lineNum":"  787","line":"// C++17 -> no need to bother about alignment anymore :)"},
{"lineNum":"  788","line":""},
{"lineNum":"  789","line":"#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW(NeedsToAlign)"},
{"lineNum":"  790","line":"#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)"},
{"lineNum":"  791","line":"#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW"},
{"lineNum":"  792","line":"#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(Scalar,Size)"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"#else"},
{"lineNum":"  795","line":""},
{"lineNum":"  796","line":"// HIP does not support new/delete on device."},
{"lineNum":"  797","line":"#if EIGEN_MAX_ALIGN_BYTES!=0 && !defined(EIGEN_HIP_DEVICE_COMPILE)"},
{"lineNum":"  798","line":"  #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW(NeedsToAlign) \\"},
{"lineNum":"  799","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  800","line":"      void* operator new(std::size_t size, const std::nothrow_t&) EIGEN_NO_THROW { \\"},
{"lineNum":"  801","line":"        EIGEN_TRY { return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); } \\"},
{"lineNum":"  802","line":"        EIGEN_CATCH (...) { return 0; } \\"},
{"lineNum":"  803","line":"      }"},
{"lineNum":"  804","line":"  #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign) \\"},
{"lineNum":"  805","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  806","line":"      void *operator new(std::size_t size) { \\"},
{"lineNum":"  807","line":"        return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); \\"},
{"lineNum":"  808","line":"      } \\"},
{"lineNum":"  809","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  810","line":"      void *operator new[](std::size_t size) { \\"},
{"lineNum":"  811","line":"        return Eigen::internal::conditional_aligned_malloc<NeedsToAlign>(size); \\"},
{"lineNum":"  812","line":"      } \\"},
{"lineNum":"  813","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  814","line":"      void operator delete(void * ptr) EIGEN_NO_THROW { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } \\"},
{"lineNum":"  815","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  816","line":"      void operator delete[](void * ptr) EIGEN_NO_THROW { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } \\"},
{"lineNum":"  817","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  818","line":"      void operator delete(void * ptr, std::size_t /* sz */) EIGEN_NO_THROW { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } \\"},
{"lineNum":"  819","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  820","line":"      void operator delete[](void * ptr, std::size_t /* sz */) EIGEN_NO_THROW { Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); } \\"},
{"lineNum":"  821","line":"      /* in-place new and delete. since (at least afaik) there is no actual   */ \\"},
{"lineNum":"  822","line":"      /* memory allocated we can safely let the default implementation handle */ \\"},
{"lineNum":"  823","line":"      /* this particular case. */ \\"},
{"lineNum":"  824","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  825","line":"      static void *operator new(std::size_t size, void *ptr) { return ::operator new(size,ptr); } \\"},
{"lineNum":"  826","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  827","line":"      static void *operator new[](std::size_t size, void* ptr) { return ::operator new[](size,ptr); } \\"},
{"lineNum":"  828","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  829","line":"      void operator delete(void * memory, void *ptr) EIGEN_NO_THROW { return ::operator delete(memory,ptr); } \\"},
{"lineNum":"  830","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  831","line":"      void operator delete[](void * memory, void *ptr) EIGEN_NO_THROW { return ::operator delete[](memory,ptr); } \\"},
{"lineNum":"  832","line":"      /* nothrow-new (returns zero instead of std::bad_alloc) */ \\"},
{"lineNum":"  833","line":"      EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW(NeedsToAlign) \\"},
{"lineNum":"  834","line":"      EIGEN_DEVICE_FUNC \\"},
{"lineNum":"  835","line":"      void operator delete(void *ptr, const std::nothrow_t&) EIGEN_NO_THROW { \\"},
{"lineNum":"  836","line":"        Eigen::internal::conditional_aligned_free<NeedsToAlign>(ptr); \\"},
{"lineNum":"  837","line":"      } \\"},
{"lineNum":"  838","line":"      typedef void eigen_aligned_operator_new_marker_type;"},
{"lineNum":"  839","line":"#else"},
{"lineNum":"  840","line":"  #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(NeedsToAlign)"},
{"lineNum":"  841","line":"#endif"},
{"lineNum":"  842","line":""},
{"lineNum":"  843","line":"#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(true)"},
{"lineNum":"  844","line":"#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(Scalar,Size)                        \\"},
{"lineNum":"  845","line":"  EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(bool(                                                             \\"},
{"lineNum":"  846","line":"        ((Size)!=Eigen::Dynamic) &&                                                                    \\"},
{"lineNum":"  847","line":"        (((EIGEN_MAX_ALIGN_BYTES>=16) && ((sizeof(Scalar)*(Size))%(EIGEN_MAX_ALIGN_BYTES  )==0)) ||    \\"},
{"lineNum":"  848","line":"         ((EIGEN_MAX_ALIGN_BYTES>=32) && ((sizeof(Scalar)*(Size))%(EIGEN_MAX_ALIGN_BYTES/2)==0)) ||    \\"},
{"lineNum":"  849","line":"         ((EIGEN_MAX_ALIGN_BYTES>=64) && ((sizeof(Scalar)*(Size))%(EIGEN_MAX_ALIGN_BYTES/4)==0))   )))"},
{"lineNum":"  850","line":""},
{"lineNum":"  851","line":"#endif"},
{"lineNum":"  852","line":""},
{"lineNum":"  853","line":"/****************************************************************************/"},
{"lineNum":"  854","line":""},
{"lineNum":"  855","line":"/** \\class aligned_allocator"},
{"lineNum":"  856","line":"* \\ingroup Core_Module"},
{"lineNum":"  857","line":"*"},
{"lineNum":"  858","line":"* \\brief STL compatible allocator to use with types requiring a non standrad alignment."},
{"lineNum":"  859","line":"*"},
{"lineNum":"  860","line":"* The memory is aligned as for dynamically aligned matrix/array types such as MatrixXd."},
{"lineNum":"  861","line":"* By default, it will thus provide at least 16 bytes alignment and more in following cases:"},
{"lineNum":"  862","line":"*  - 32 bytes alignment if AVX is enabled."},
{"lineNum":"  863","line":"*  - 64 bytes alignment if AVX512 is enabled."},
{"lineNum":"  864","line":"*"},
{"lineNum":"  865","line":"* This can be controlled using the \\c EIGEN_MAX_ALIGN_BYTES macro as documented"},
{"lineNum":"  866","line":"* \\link TopicPreprocessorDirectivesPerformance there \\endlink."},
{"lineNum":"  867","line":"*"},
{"lineNum":"  868","line":"* Example:"},
{"lineNum":"  869","line":"* \\code"},
{"lineNum":"  870","line":"* // Matrix4f requires 16 bytes alignment:"},
{"lineNum":"  871","line":"* std::map< int, Matrix4f, std::less<int>,"},
{"lineNum":"  872","line":"*           aligned_allocator<std::pair<const int, Matrix4f> > > my_map_mat4;"},
{"lineNum":"  873","line":"* // Vector3f does not require 16 bytes alignment, no need to use Eigen\'s allocator:"},
{"lineNum":"  874","line":"* std::map< int, Vector3f > my_map_vec3;"},
{"lineNum":"  875","line":"* \\endcode"},
{"lineNum":"  876","line":"*"},
{"lineNum":"  877","line":"* \\sa \\blank \\ref TopicStlContainers."},
{"lineNum":"  878","line":"*/"},
{"lineNum":"  879","line":"template<class T>"},
{"lineNum":"  880","line":"class aligned_allocator : public std::allocator<T>"},
{"lineNum":"  881","line":"{"},
{"lineNum":"  882","line":"public:"},
{"lineNum":"  883","line":"  typedef std::size_t     size_type;"},
{"lineNum":"  884","line":"  typedef std::ptrdiff_t  difference_type;"},
{"lineNum":"  885","line":"  typedef T*              pointer;"},
{"lineNum":"  886","line":"  typedef const T*        const_pointer;"},
{"lineNum":"  887","line":"  typedef T&              reference;"},
{"lineNum":"  888","line":"  typedef const T&        const_reference;"},
{"lineNum":"  889","line":"  typedef T               value_type;"},
{"lineNum":"  890","line":""},
{"lineNum":"  891","line":"  template<class U>"},
{"lineNum":"  892","line":"  struct rebind"},
{"lineNum":"  893","line":"  {"},
{"lineNum":"  894","line":"    typedef aligned_allocator<U> other;"},
{"lineNum":"  895","line":"  };"},
{"lineNum":"  896","line":""},
{"lineNum":"  897","line":"  aligned_allocator() : std::allocator<T>() {}"},
{"lineNum":"  898","line":""},
{"lineNum":"  899","line":"  aligned_allocator(const aligned_allocator& other) : std::allocator<T>(other) {}"},
{"lineNum":"  900","line":""},
{"lineNum":"  901","line":"  template<class U>"},
{"lineNum":"  902","line":"  aligned_allocator(const aligned_allocator<U>& other) : std::allocator<T>(other) {}"},
{"lineNum":"  903","line":""},
{"lineNum":"  904","line":"  ~aligned_allocator() {}"},
{"lineNum":"  905","line":""},
{"lineNum":"  906","line":"  #if EIGEN_COMP_GNUC_STRICT && EIGEN_GNUC_AT_LEAST(7,0)"},
{"lineNum":"  907","line":"  // In gcc std::allocator::max_size() is bugged making gcc triggers a warning:"},
{"lineNum":"  908","line":"  // eigen/Eigen/src/Core/util/Memory.h:189:12: warning: argument 1 value \'18446744073709551612\' exceeds maximum object size 9223372036854775807"},
{"lineNum":"  909","line":"  // See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=87544"},
{"lineNum":"  910","line":"  size_type max_size() const {"},
{"lineNum":"  911","line":"    return (std::numeric_limits<std::ptrdiff_t>::max)()/sizeof(T);"},
{"lineNum":"  912","line":"  }"},
{"lineNum":"  913","line":"  #endif"},
{"lineNum":"  914","line":""},
{"lineNum":"  915","line":"  pointer allocate(size_type num, const void* /*hint*/ = 0)"},
{"lineNum":"  916","line":"  {"},
{"lineNum":"  917","line":"    internal::check_size_for_overflow<T>(num);"},
{"lineNum":"  918","line":"    return static_cast<pointer>( internal::aligned_malloc(num * sizeof(T)) );"},
{"lineNum":"  919","line":"  }"},
{"lineNum":"  920","line":""},
{"lineNum":"  921","line":"  void deallocate(pointer p, size_type /*num*/)"},
{"lineNum":"  922","line":"  {"},
{"lineNum":"  923","line":"    internal::aligned_free(p);"},
{"lineNum":"  924","line":"  }"},
{"lineNum":"  925","line":"};"},
{"lineNum":"  926","line":""},
{"lineNum":"  927","line":"//---------- Cache sizes ----------"},
{"lineNum":"  928","line":""},
{"lineNum":"  929","line":"#if !defined(EIGEN_NO_CPUID)"},
{"lineNum":"  930","line":"#  if EIGEN_COMP_GNUC && EIGEN_ARCH_i386_OR_x86_64"},
{"lineNum":"  931","line":"#    if defined(__PIC__) && EIGEN_ARCH_i386"},
{"lineNum":"  932","line":"       // Case for x86 with PIC"},
{"lineNum":"  933","line":"#      define EIGEN_CPUID(abcd,func,id) \\"},
{"lineNum":"  934","line":"         __asm__ __volatile__ (\"xchgl %%ebx, %k1;cpuid; xchgl %%ebx,%k1\": \"=a\" (abcd[0]), \"=&r\" (abcd[1]), \"=c\" (abcd[2]), \"=d\" (abcd[3]) : \"a\" (func), \"c\" (id));"},
{"lineNum":"  935","line":"#    elif defined(__PIC__) && EIGEN_ARCH_x86_64"},
{"lineNum":"  936","line":"       // Case for x64 with PIC. In theory this is only a problem with recent gcc and with medium or large code model, not with the default small code model."},
{"lineNum":"  937","line":"       // However, we cannot detect which code model is used, and the xchg overhead is negligible anyway."},
{"lineNum":"  938","line":"#      define EIGEN_CPUID(abcd,func,id) \\"},
{"lineNum":"  939","line":"        __asm__ __volatile__ (\"xchg{q}\\t{%%}rbx, %q1; cpuid; xchg{q}\\t{%%}rbx, %q1\": \"=a\" (abcd[0]), \"=&r\" (abcd[1]), \"=c\" (abcd[2]), \"=d\" (abcd[3]) : \"0\" (func), \"2\" (id));"},
{"lineNum":"  940","line":"#    else"},
{"lineNum":"  941","line":"       // Case for x86_64 or x86 w/o PIC"},
{"lineNum":"  942","line":"#      define EIGEN_CPUID(abcd,func,id) \\"},
{"lineNum":"  943","line":"         __asm__ __volatile__ (\"cpuid\": \"=a\" (abcd[0]), \"=b\" (abcd[1]), \"=c\" (abcd[2]), \"=d\" (abcd[3]) : \"0\" (func), \"2\" (id) );"},
{"lineNum":"  944","line":"#    endif"},
{"lineNum":"  945","line":"#  elif EIGEN_COMP_MSVC"},
{"lineNum":"  946","line":"#    if (EIGEN_COMP_MSVC > 1500) && EIGEN_ARCH_i386_OR_x86_64"},
{"lineNum":"  947","line":"#      define EIGEN_CPUID(abcd,func,id) __cpuidex((int*)abcd,func,id)"},
{"lineNum":"  948","line":"#    endif"},
{"lineNum":"  949","line":"#  endif"},
{"lineNum":"  950","line":"#endif"},
{"lineNum":"  951","line":""},
{"lineNum":"  952","line":"namespace internal {"},
{"lineNum":"  953","line":""},
{"lineNum":"  954","line":"#ifdef EIGEN_CPUID"},
{"lineNum":"  955","line":""},
{"lineNum":"  956","line":"inline bool cpuid_is_vendor(int abcd[4], const int vendor[3])"},
{"lineNum":"  957","line":"{"},
{"lineNum":"  958","line":"  return abcd[1]==vendor[0] && abcd[3]==vendor[1] && abcd[2]==vendor[2];","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  959","line":"}"},
{"lineNum":"  960","line":""},
{"lineNum":"  961","line":"inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)"},
{"lineNum":"  962","line":"{"},
{"lineNum":"  963","line":"  int abcd[4];"},
{"lineNum":"  964","line":"  l1 = l2 = l3 = 0;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  965","line":"  int cache_id = 0;"},
{"lineNum":"  966","line":"  int cache_type = 0;"},
{"lineNum":"  967","line":"  do {"},
{"lineNum":"  968","line":"    abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;"},
{"lineNum":"  969","line":"    EIGEN_CPUID(abcd,0x4,cache_id);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  970","line":"    cache_type  = (abcd[0] & 0x0F) >> 0;"},
{"lineNum":"  971","line":"    if(cache_type==1||cache_type==3) // data or unified cache","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  972","line":"    {"},
{"lineNum":"  973","line":"      int cache_level = (abcd[0] & 0xE0) >> 5;  // A[7:5]","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  974","line":"      int ways        = (abcd[1] & 0xFFC00000) >> 22; // B[31:22]"},
{"lineNum":"  975","line":"      int partitions  = (abcd[1] & 0x003FF000) >> 12; // B[21:12]"},
{"lineNum":"  976","line":"      int line_size   = (abcd[1] & 0x00000FFF) >>  0; // B[11:0]"},
{"lineNum":"  977","line":"      int sets        = (abcd[2]);                    // C[31:0]"},
{"lineNum":"  978","line":""},
{"lineNum":"  979","line":"      int cache_size = (ways+1) * (partitions+1) * (line_size+1) * (sets+1);"},
{"lineNum":"  980","line":""},
{"lineNum":"  981","line":"      switch(cache_level)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  982","line":"      {"},
{"lineNum":"  983","line":"        case 1: l1 = cache_size; break;"},
{"lineNum":"  984","line":"        case 2: l2 = cache_size; break;"},
{"lineNum":"  985","line":"        case 3: l3 = cache_size; break;"},
{"lineNum":"  986","line":"        default: break;"},
{"lineNum":"  987","line":"      }"},
{"lineNum":"  988","line":"    }"},
{"lineNum":"  989","line":"    cache_id++;"},
{"lineNum":"  990","line":"  } while(cache_type>0 && cache_id<16);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  991","line":"}"},
{"lineNum":"  992","line":""},
{"lineNum":"  993","line":"inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)"},
{"lineNum":"  994","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  995","line":"  int abcd[4];"},
{"lineNum":"  996","line":"  abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;"},
{"lineNum":"  997","line":"  l1 = l2 = l3 = 0;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  998","line":"  EIGEN_CPUID(abcd,0x00000002,0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  999","line":"  unsigned char * bytes = reinterpret_cast<unsigned char *>(abcd)+2;"},
{"lineNum":" 1000","line":"  bool check_for_p2_core2 = false;"},
{"lineNum":" 1001","line":"  for(int i=0; i<14; ++i)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1002","line":"  {"},
{"lineNum":" 1003","line":"    switch(bytes[i])","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1004","line":"    {"},
{"lineNum":" 1005","line":"      case 0x0A: l1 = 8; break;   // 0Ah   data L1 cache, 8 KB, 2 ways, 32 byte lines"},
{"lineNum":" 1006","line":"      case 0x0C: l1 = 16; break;  // 0Ch   data L1 cache, 16 KB, 4 ways, 32 byte lines"},
{"lineNum":" 1007","line":"      case 0x0E: l1 = 24; break;  // 0Eh   data L1 cache, 24 KB, 6 ways, 64 byte lines","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1008","line":"      case 0x10: l1 = 16; break;  // 10h   data L1 cache, 16 KB, 4 ways, 32 byte lines (IA-64)"},
{"lineNum":" 1009","line":"      case 0x15: l1 = 16; break;  // 15h   code L1 cache, 16 KB, 4 ways, 32 byte lines (IA-64)"},
{"lineNum":" 1010","line":"      case 0x2C: l1 = 32; break;  // 2Ch   data L1 cache, 32 KB, 8 ways, 64 byte lines"},
{"lineNum":" 1011","line":"      case 0x30: l1 = 32; break;  // 30h   code L1 cache, 32 KB, 8 ways, 64 byte lines"},
{"lineNum":" 1012","line":"      case 0x60: l1 = 16; break;  // 60h   data L1 cache, 16 KB, 8 ways, 64 byte lines, sectored"},
{"lineNum":" 1013","line":"      case 0x66: l1 = 8; break;   // 66h   data L1 cache, 8 KB, 4 ways, 64 byte lines, sectored"},
{"lineNum":" 1014","line":"      case 0x67: l1 = 16; break;  // 67h   data L1 cache, 16 KB, 4 ways, 64 byte lines, sectored"},
{"lineNum":" 1015","line":"      case 0x68: l1 = 32; break;  // 68h   data L1 cache, 32 KB, 4 ways, 64 byte lines, sectored"},
{"lineNum":" 1016","line":"      case 0x1A: l2 = 96; break;   // code and data L2 cache, 96 KB, 6 ways, 64 byte lines (IA-64)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1017","line":"      case 0x22: l3 = 512; break;   // code and data L3 cache, 512 KB, 4 ways (!), 64 byte lines, dual-sectored","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1018","line":"      case 0x23: l3 = 1024; break;   // code and data L3 cache, 1024 KB, 8 ways, 64 byte lines, dual-sectored","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1019","line":"      case 0x25: l3 = 2048; break;   // code and data L3 cache, 2048 KB, 8 ways, 64 byte lines, dual-sectored"},
{"lineNum":" 1020","line":"      case 0x29: l3 = 4096; break;   // code and data L3 cache, 4096 KB, 8 ways, 64 byte lines, dual-sectored"},
{"lineNum":" 1021","line":"      case 0x39: l2 = 128; break;   // code and data L2 cache, 128 KB, 4 ways, 64 byte lines, sectored"},
{"lineNum":" 1022","line":"      case 0x3A: l2 = 192; break;   // code and data L2 cache, 192 KB, 6 ways, 64 byte lines, sectored","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1023","line":"      case 0x3B: l2 = 128; break;   // code and data L2 cache, 128 KB, 2 ways, 64 byte lines, sectored"},
{"lineNum":" 1024","line":"      case 0x3C: l2 = 256; break;   // code and data L2 cache, 256 KB, 4 ways, 64 byte lines, sectored"},
{"lineNum":" 1025","line":"      case 0x3D: l2 = 384; break;   // code and data L2 cache, 384 KB, 6 ways, 64 byte lines, sectored","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1026","line":"      case 0x3E: l2 = 512; break;   // code and data L2 cache, 512 KB, 4 ways, 64 byte lines, sectored"},
{"lineNum":" 1027","line":"      case 0x40: l2 = 0; break;   // no integrated L2 cache (P6 core) or L3 cache (P4 core)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1028","line":"      case 0x41: l2 = 128; break;   // code and data L2 cache, 128 KB, 4 ways, 32 byte lines"},
{"lineNum":" 1029","line":"      case 0x42: l2 = 256; break;   // code and data L2 cache, 256 KB, 4 ways, 32 byte lines"},
{"lineNum":" 1030","line":"      case 0x43: l2 = 512; break;   // code and data L2 cache, 512 KB, 4 ways, 32 byte lines"},
{"lineNum":" 1031","line":"      case 0x44: l2 = 1024; break;   // code and data L2 cache, 1024 KB, 4 ways, 32 byte lines"},
{"lineNum":" 1032","line":"      case 0x45: l2 = 2048; break;   // code and data L2 cache, 2048 KB, 4 ways, 32 byte lines"},
{"lineNum":" 1033","line":"      case 0x46: l3 = 4096; break;   // code and data L3 cache, 4096 KB, 4 ways, 64 byte lines"},
{"lineNum":" 1034","line":"      case 0x47: l3 = 8192; break;   // code and data L3 cache, 8192 KB, 8 ways, 64 byte lines"},
{"lineNum":" 1035","line":"      case 0x48: l2 = 3072; break;   // code and data L2 cache, 3072 KB, 12 ways, 64 byte lines","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1036","line":"      case 0x49: if(l2!=0) l3 = 4096; else {check_for_p2_core2=true; l3 = l2 = 4096;} break;// code and data L3 cache, 4096 KB, 16 ways, 64 byte lines (P4) or L2 for core2","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1037","line":"      case 0x4A: l3 = 6144; break;   // code and data L3 cache, 6144 KB, 12 ways, 64 byte lines","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1038","line":"      case 0x4B: l3 = 8192; break;   // code and data L3 cache, 8192 KB, 16 ways, 64 byte lines"},
{"lineNum":" 1039","line":"      case 0x4C: l3 = 12288; break;   // code and data L3 cache, 12288 KB, 12 ways, 64 byte lines","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1040","line":"      case 0x4D: l3 = 16384; break;   // code and data L3 cache, 16384 KB, 16 ways, 64 byte lines","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1041","line":"      case 0x4E: l2 = 6144; break;   // code and data L2 cache, 6144 KB, 24 ways, 64 byte lines","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1042","line":"      case 0x78: l2 = 1024; break;   // code and data L2 cache, 1024 KB, 4 ways, 64 byte lines"},
{"lineNum":" 1043","line":"      case 0x79: l2 = 128; break;   // code and data L2 cache, 128 KB, 8 ways, 64 byte lines, dual-sectored"},
{"lineNum":" 1044","line":"      case 0x7A: l2 = 256; break;   // code and data L2 cache, 256 KB, 8 ways, 64 byte lines, dual-sectored"},
{"lineNum":" 1045","line":"      case 0x7B: l2 = 512; break;   // code and data L2 cache, 512 KB, 8 ways, 64 byte lines, dual-sectored"},
{"lineNum":" 1046","line":"      case 0x7C: l2 = 1024; break;   // code and data L2 cache, 1024 KB, 8 ways, 64 byte lines, dual-sectored"},
{"lineNum":" 1047","line":"      case 0x7D: l2 = 2048; break;   // code and data L2 cache, 2048 KB, 8 ways, 64 byte lines"},
{"lineNum":" 1048","line":"      case 0x7E: l2 = 256; break;   // code and data L2 cache, 256 KB, 8 ways, 128 byte lines, sect. (IA-64)"},
{"lineNum":" 1049","line":"      case 0x7F: l2 = 512; break;   // code and data L2 cache, 512 KB, 2 ways, 64 byte lines"},
{"lineNum":" 1050","line":"      case 0x80: l2 = 512; break;   // code and data L2 cache, 512 KB, 8 ways, 64 byte lines"},
{"lineNum":" 1051","line":"      case 0x81: l2 = 128; break;   // code and data L2 cache, 128 KB, 8 ways, 32 byte lines"},
{"lineNum":" 1052","line":"      case 0x82: l2 = 256; break;   // code and data L2 cache, 256 KB, 8 ways, 32 byte lines"},
{"lineNum":" 1053","line":"      case 0x83: l2 = 512; break;   // code and data L2 cache, 512 KB, 8 ways, 32 byte lines"},
{"lineNum":" 1054","line":"      case 0x84: l2 = 1024; break;   // code and data L2 cache, 1024 KB, 8 ways, 32 byte lines"},
{"lineNum":" 1055","line":"      case 0x85: l2 = 2048; break;   // code and data L2 cache, 2048 KB, 8 ways, 32 byte lines"},
{"lineNum":" 1056","line":"      case 0x86: l2 = 512; break;   // code and data L2 cache, 512 KB, 4 ways, 64 byte lines"},
{"lineNum":" 1057","line":"      case 0x87: l2 = 1024; break;   // code and data L2 cache, 1024 KB, 8 ways, 64 byte lines"},
{"lineNum":" 1058","line":"      case 0x88: l3 = 2048; break;   // code and data L3 cache, 2048 KB, 4 ways, 64 byte lines (IA-64)"},
{"lineNum":" 1059","line":"      case 0x89: l3 = 4096; break;   // code and data L3 cache, 4096 KB, 4 ways, 64 byte lines (IA-64)"},
{"lineNum":" 1060","line":"      case 0x8A: l3 = 8192; break;   // code and data L3 cache, 8192 KB, 4 ways, 64 byte lines (IA-64)"},
{"lineNum":" 1061","line":"      case 0x8D: l3 = 3072; break;   // code and data L3 cache, 3072 KB, 12 ways, 128 byte lines (IA-64)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1062","line":""},
{"lineNum":" 1063","line":"      default: break;"},
{"lineNum":" 1064","line":"    }"},
{"lineNum":" 1065","line":"  }"},
{"lineNum":" 1066","line":"  if(check_for_p2_core2 && l2 == l3)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1067","line":"    l3 = 0;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1068","line":"  l1 *= 1024;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1069","line":"  l2 *= 1024;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1070","line":"  l3 *= 1024;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1071","line":"}","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1072","line":""},
{"lineNum":" 1073","line":"inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)"},
{"lineNum":" 1074","line":"{"},
{"lineNum":" 1075","line":"  if(max_std_funcs>=4)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1076","line":"    queryCacheSizes_intel_direct(l1,l2,l3);"},
{"lineNum":" 1077","line":"  else if(max_std_funcs>=2)"},
{"lineNum":" 1078","line":"    queryCacheSizes_intel_codes(l1,l2,l3);"},
{"lineNum":" 1079","line":"  else"},
{"lineNum":" 1080","line":"    l1 = l2 = l3 = 0;"},
{"lineNum":" 1081","line":"}"},
{"lineNum":" 1082","line":""},
{"lineNum":" 1083","line":"inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)"},
{"lineNum":" 1084","line":"{"},
{"lineNum":" 1085","line":"  int abcd[4];"},
{"lineNum":" 1086","line":"  abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;"},
{"lineNum":" 1087","line":""},
{"lineNum":" 1088","line":"  // First query the max supported function."},
{"lineNum":" 1089","line":"  EIGEN_CPUID(abcd,0x80000000,0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1090","line":"  if(static_cast<numext::uint32_t>(abcd[0]) >= static_cast<numext::uint32_t>(0x80000006))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1091","line":"  {"},
{"lineNum":" 1092","line":"    EIGEN_CPUID(abcd,0x80000005,0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1093","line":"    l1 = (abcd[2] >> 24) * 1024; // C[31:24] = L1 size in KB","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1094","line":"    abcd[0] = abcd[1] = abcd[2] = abcd[3] = 0;"},
{"lineNum":" 1095","line":"    EIGEN_CPUID(abcd,0x80000006,0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1096","line":"    l2 = (abcd[2] >> 16) * 1024; // C[31;16] = l2 cache size in KB","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1097","line":"    l3 = ((abcd[3] & 0xFFFC000) >> 18) * 512 * 1024; // D[31;18] = l3 cache size in 512KB","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1098","line":"  }"},
{"lineNum":" 1099","line":"  else"},
{"lineNum":" 1100","line":"  {"},
{"lineNum":" 1101","line":"    l1 = l2 = l3 = 0;"},
{"lineNum":" 1102","line":"  }"},
{"lineNum":" 1103","line":"}"},
{"lineNum":" 1104","line":"#endif"},
{"lineNum":" 1105","line":""},
{"lineNum":" 1106","line":"/** \\internal"},
{"lineNum":" 1107","line":" * Queries and returns the cache sizes in Bytes of the L1, L2, and L3 data caches respectively */"},
{"lineNum":" 1108","line":"inline void queryCacheSizes(int& l1, int& l2, int& l3)"},
{"lineNum":" 1109","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1110","line":"  #ifdef EIGEN_CPUID"},
{"lineNum":" 1111","line":"  int abcd[4];"},
{"lineNum":" 1112","line":"  const int GenuineIntel[] = {0x756e6547, 0x49656e69, 0x6c65746e};"},
{"lineNum":" 1113","line":"  const int AuthenticAMD[] = {0x68747541, 0x69746e65, 0x444d4163};"},
{"lineNum":" 1114","line":"  const int AMDisbetter_[] = {0x69444d41, 0x74656273, 0x21726574}; // \"AMDisbetter!\""},
{"lineNum":" 1115","line":""},
{"lineNum":" 1116","line":"  // identify the CPU vendor"},
{"lineNum":" 1117","line":"  EIGEN_CPUID(abcd,0x0,0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1118","line":"  int max_std_funcs = abcd[0];"},
{"lineNum":" 1119","line":"  if(cpuid_is_vendor(abcd,GenuineIntel))"},
{"lineNum":" 1120","line":"    queryCacheSizes_intel(l1,l2,l3,max_std_funcs);"},
{"lineNum":" 1121","line":"  else if(cpuid_is_vendor(abcd,AuthenticAMD) || cpuid_is_vendor(abcd,AMDisbetter_))"},
{"lineNum":" 1122","line":"    queryCacheSizes_amd(l1,l2,l3);"},
{"lineNum":" 1123","line":"  else"},
{"lineNum":" 1124","line":"    // by default let\'s use Intel\'s API"},
{"lineNum":" 1125","line":"    queryCacheSizes_intel(l1,l2,l3,max_std_funcs);"},
{"lineNum":" 1126","line":""},
{"lineNum":" 1127","line":"  // here is the list of other vendors:"},
{"lineNum":" 1128","line":"//   ||cpuid_is_vendor(abcd,\"VIA VIA VIA \")"},
{"lineNum":" 1129","line":"//   ||cpuid_is_vendor(abcd,\"CyrixInstead\")"},
{"lineNum":" 1130","line":"//   ||cpuid_is_vendor(abcd,\"CentaurHauls\")"},
{"lineNum":" 1131","line":"//   ||cpuid_is_vendor(abcd,\"GenuineTMx86\")"},
{"lineNum":" 1132","line":"//   ||cpuid_is_vendor(abcd,\"TransmetaCPU\")"},
{"lineNum":" 1133","line":"//   ||cpuid_is_vendor(abcd,\"RiseRiseRise\")"},
{"lineNum":" 1134","line":"//   ||cpuid_is_vendor(abcd,\"Geode by NSC\")"},
{"lineNum":" 1135","line":"//   ||cpuid_is_vendor(abcd,\"SiS SiS SiS \")"},
{"lineNum":" 1136","line":"//   ||cpuid_is_vendor(abcd,\"UMC UMC UMC \")"},
{"lineNum":" 1137","line":"//   ||cpuid_is_vendor(abcd,\"NexGenDriven\")"},
{"lineNum":" 1138","line":"  #else"},
{"lineNum":" 1139","line":"  l1 = l2 = l3 = -1;"},
{"lineNum":" 1140","line":"  #endif"},
{"lineNum":" 1141","line":"}","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":" 1142","line":""},
{"lineNum":" 1143","line":"/** \\internal"},
{"lineNum":" 1144","line":" * \\returns the size in Bytes of the L1 data cache */"},
{"lineNum":" 1145","line":"inline int queryL1CacheSize()"},
{"lineNum":" 1146","line":"{"},
{"lineNum":" 1147","line":"  int l1(-1), l2, l3;"},
{"lineNum":" 1148","line":"  queryCacheSizes(l1,l2,l3);"},
{"lineNum":" 1149","line":"  return l1;"},
{"lineNum":" 1150","line":"}"},
{"lineNum":" 1151","line":""},
{"lineNum":" 1152","line":"/** \\internal"},
{"lineNum":" 1153","line":" * \\returns the size in Bytes of the L2 or L3 cache if this later is present */"},
{"lineNum":" 1154","line":"inline int queryTopLevelCacheSize()"},
{"lineNum":" 1155","line":"{"},
{"lineNum":" 1156","line":"  int l1, l2(-1), l3(-1);"},
{"lineNum":" 1157","line":"  queryCacheSizes(l1,l2,l3);"},
{"lineNum":" 1158","line":"  return (std::max)(l2,l3);"},
{"lineNum":" 1159","line":"}"},
{"lineNum":" 1160","line":""},
{"lineNum":" 1161","line":"} // end namespace internal"},
{"lineNum":" 1162","line":""},
{"lineNum":" 1163","line":"} // end namespace Eigen"},
{"lineNum":" 1164","line":""},
{"lineNum":" 1165","line":"#endif // EIGEN_MEMORY_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 63, "covered" : 0,};
var merged_data = [];
