var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_OPENMP_PARALLEL_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_OPENMP_PARALLEL_HPP"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include <Kokkos_Macros.hpp>"},
{"lineNum":"   49","line":"#if defined(KOKKOS_ENABLE_OPENMP)"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"#include <omp.h>"},
{"lineNum":"   52","line":"#include <OpenMP/Kokkos_OpenMP_Exec.hpp>"},
{"lineNum":"   53","line":"#include <impl/Kokkos_FunctorAdapter.hpp>"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"#include <KokkosExp_MDRangePolicy.hpp>"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   58","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"namespace Kokkos {"},
{"lineNum":"   61","line":"namespace Impl {"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"template <class FunctorType, class... Traits>"},
{"lineNum":"   64","line":"class ParallelFor<FunctorType, Kokkos::RangePolicy<Traits...>, Kokkos::OpenMP> {","class":"lineNoCov","hits":"0","possible_hits":"39",},
{"lineNum":"   65","line":" private:"},
{"lineNum":"   66","line":"  using Policy    = Kokkos::RangePolicy<Traits...>;"},
{"lineNum":"   67","line":"  using WorkTag   = typename Policy::work_tag;"},
{"lineNum":"   68","line":"  using WorkRange = typename Policy::WorkRange;"},
{"lineNum":"   69","line":"  using Member    = typename Policy::member_type;"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"  OpenMPExec* m_instance;"},
{"lineNum":"   72","line":"  const FunctorType m_functor;"},
{"lineNum":"   73","line":"  const Policy m_policy;"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"  template <class TagType>"},
{"lineNum":"   76","line":"  inline static"},
{"lineNum":"   77","line":"      typename std::enable_if<std::is_same<TagType, void>::value>::type"},
{"lineNum":"   78","line":"      exec_range(const FunctorType& functor, const Member ibeg,"},
{"lineNum":"   79","line":"                 const Member iend) {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"   80","line":"#ifdef KOKKOS_ENABLE_AGGRESSIVE_VECTORIZATION"},
{"lineNum":"   81","line":"#ifdef KOKKOS_ENABLE_PRAGMA_IVDEP"},
{"lineNum":"   82","line":"#pragma ivdep"},
{"lineNum":"   83","line":"#endif"},
{"lineNum":"   84","line":"#endif"},
{"lineNum":"   85","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {","class":"lineNoCov","hits":"0","possible_hits":"552",},
{"lineNum":"   86","line":"      functor(iwork);","class":"lineNoCov","hits":"0","possible_hits":"86",},
{"lineNum":"   87","line":"    }"},
{"lineNum":"   88","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"  template <class TagType>"},
{"lineNum":"   91","line":"  inline static"},
{"lineNum":"   92","line":"      typename std::enable_if<!std::is_same<TagType, void>::value>::type"},
{"lineNum":"   93","line":"      exec_range(const FunctorType& functor, const Member ibeg,"},
{"lineNum":"   94","line":"                 const Member iend) {"},
{"lineNum":"   95","line":"    const TagType t{};"},
{"lineNum":"   96","line":"#ifdef KOKKOS_ENABLE_AGGRESSIVE_VECTORIZATION"},
{"lineNum":"   97","line":"#ifdef KOKKOS_ENABLE_PRAGMA_IVDEP"},
{"lineNum":"   98","line":"#pragma ivdep"},
{"lineNum":"   99","line":"#endif"},
{"lineNum":"  100","line":"#endif"},
{"lineNum":"  101","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {"},
{"lineNum":"  102","line":"      functor(t, iwork);"},
{"lineNum":"  103","line":"    }"},
{"lineNum":"  104","line":"  }"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":" public:"},
{"lineNum":"  107","line":"  inline void execute() const {","class":"lineNoCov","hits":"0","possible_hits":"48",},
{"lineNum":"  108","line":"    enum {"},
{"lineNum":"  109","line":"      is_dynamic = std::is_same<typename Policy::schedule_type::type,"},
{"lineNum":"  110","line":"                                Kokkos::Dynamic>::value"},
{"lineNum":"  111","line":"    };"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"    if (OpenMP::in_parallel()) {","class":"lineNoCov","hits":"0","possible_hits":"110",},
{"lineNum":"  114","line":"      exec_range<WorkTag>(m_functor, m_policy.begin(), m_policy.end());","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  115","line":"    } else {"},
{"lineNum":"  116","line":"      OpenMPExec::verify_is_master(\"Kokkos::OpenMP parallel_for\");","class":"lineNoCov","hits":"0","possible_hits":"110",},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"#pragma omp parallel num_threads(OpenMP::impl_thread_pool_size())","class":"lineNoCov","hits":"0","possible_hits":"472",},
{"lineNum":"  119","line":"      {"},
{"lineNum":"  120","line":"        HostThreadTeamData& data = *(m_instance->get_thread_data());","class":"lineNoCov","hits":"0","possible_hits":"158",},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"        data.set_work_partition(m_policy.end() - m_policy.begin(),","class":"lineNoCov","hits":"0","possible_hits":"159",},
{"lineNum":"  123","line":"                                m_policy.chunk_size());"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"        if (is_dynamic) {"},
{"lineNum":"  126","line":"          // Make sure work partition is set before stealing"},
{"lineNum":"  127","line":"          if (data.pool_rendezvous()) data.pool_rendezvous_release();"},
{"lineNum":"  128","line":"        }"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"        std::pair<int64_t, int64_t> range(0, 0);"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"        do {"},
{"lineNum":"  133","line":"          range = is_dynamic ? data.get_work_stealing_chunk()"},
{"lineNum":"  134","line":"                             : data.get_work_partition();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"          ParallelFor::template exec_range<WorkTag>(","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  137","line":"              m_functor, range.first + m_policy.begin(),","class":"lineNoCov","hits":"0","possible_hits":"159",},
{"lineNum":"  138","line":"              range.second + m_policy.begin());","class":"lineNoCov","hits":"0","possible_hits":"127",},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"        } while (is_dynamic && 0 <= range.first);"},
{"lineNum":"  141","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"66",},
{"lineNum":"  142","line":"    }"},
{"lineNum":"  143","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"48",},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"  inline ParallelFor(const FunctorType& arg_functor, Policy arg_policy)"},
{"lineNum":"  146","line":"      : m_instance(t_openmp_instance),","class":"lineNoCov","hits":"0","possible_hits":"112",},
{"lineNum":"  147","line":"        m_functor(arg_functor),","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  148","line":"        m_policy(arg_policy) {}","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  149","line":"};"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"// MDRangePolicy impl"},
{"lineNum":"  152","line":"template <class FunctorType, class... Traits>"},
{"lineNum":"  153","line":"class ParallelFor<FunctorType, Kokkos::MDRangePolicy<Traits...>,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  154","line":"                  Kokkos::OpenMP> {"},
{"lineNum":"  155","line":" private:"},
{"lineNum":"  156","line":"  using MDRangePolicy = Kokkos::MDRangePolicy<Traits...>;"},
{"lineNum":"  157","line":"  using Policy        = typename MDRangePolicy::impl_range_policy;"},
{"lineNum":"  158","line":"  using WorkTag       = typename MDRangePolicy::work_tag;"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"  using WorkRange = typename Policy::WorkRange;"},
{"lineNum":"  161","line":"  using Member    = typename Policy::member_type;"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"  using iterate_type = typename Kokkos::Impl::HostIterateTile<"},
{"lineNum":"  164","line":"      MDRangePolicy, FunctorType, typename MDRangePolicy::work_tag, void>;"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"  OpenMPExec* m_instance;"},
{"lineNum":"  167","line":"  const FunctorType m_functor;"},
{"lineNum":"  168","line":"  const MDRangePolicy m_mdr_policy;"},
{"lineNum":"  169","line":"  const Policy m_policy;  // construct as RangePolicy( 0, num_tiles"},
{"lineNum":"  170","line":"                          // ).set_chunk_size(1) in ctor"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  inline static void exec_range(const MDRangePolicy& mdr_policy,"},
{"lineNum":"  173","line":"                                const FunctorType& functor, const Member ibeg,"},
{"lineNum":"  174","line":"                                const Member iend) {"},
{"lineNum":"  175","line":"#ifdef KOKKOS_ENABLE_AGGRESSIVE_VECTORIZATION"},
{"lineNum":"  176","line":"#ifdef KOKKOS_ENABLE_PRAGMA_IVDEP"},
{"lineNum":"  177","line":"#pragma ivdep"},
{"lineNum":"  178","line":"#endif"},
{"lineNum":"  179","line":"#endif"},
{"lineNum":"  180","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {","class":"lineNoCov","hits":"0","possible_hits":"66",},
{"lineNum":"  181","line":"      iterate_type(mdr_policy, functor)(iwork);","class":"lineNoCov","hits":"0","possible_hits":"28",},
{"lineNum":"  182","line":"    }"},
{"lineNum":"  183","line":"  }"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":" public:"},
{"lineNum":"  186","line":"  inline void execute() const {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  187","line":"    enum {"},
{"lineNum":"  188","line":"      is_dynamic = std::is_same<typename Policy::schedule_type::type,"},
{"lineNum":"  189","line":"                                Kokkos::Dynamic>::value"},
{"lineNum":"  190","line":"    };"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"    if (OpenMP::in_parallel()) {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  193","line":"      ParallelFor::exec_range(m_mdr_policy, m_functor, m_policy.begin(),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  194","line":"                              m_policy.end());"},
{"lineNum":"  195","line":"    } else {"},
{"lineNum":"  196","line":"      OpenMPExec::verify_is_master(\"Kokkos::OpenMP parallel_for\");","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"#pragma omp parallel num_threads(OpenMP::impl_thread_pool_size())","class":"lineNoCov","hits":"0","possible_hits":"64",},
{"lineNum":"  199","line":"      {"},
{"lineNum":"  200","line":"        HostThreadTeamData& data = *(m_instance->get_thread_data());","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"        data.set_work_partition(m_policy.end() - m_policy.begin(),","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  203","line":"                                m_policy.chunk_size());"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"        if (is_dynamic) {"},
{"lineNum":"  206","line":"          // Make sure work partition is set before stealing"},
{"lineNum":"  207","line":"          if (data.pool_rendezvous()) data.pool_rendezvous_release();"},
{"lineNum":"  208","line":"        }"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"        std::pair<int64_t, int64_t> range(0, 0);"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"        do {"},
{"lineNum":"  213","line":"          range = is_dynamic ? data.get_work_stealing_chunk()"},
{"lineNum":"  214","line":"                             : data.get_work_partition();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"          ParallelFor::exec_range(m_mdr_policy, m_functor,"},
{"lineNum":"  217","line":"                                  range.first + m_policy.begin(),","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  218","line":"                                  range.second + m_policy.begin());","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"        } while (is_dynamic && 0 <= range.first);"},
{"lineNum":"  221","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  222","line":"      // END #pragma omp parallel"},
{"lineNum":"  223","line":"    }"},
{"lineNum":"  224","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"  inline ParallelFor(const FunctorType& arg_functor, MDRangePolicy arg_policy)"},
{"lineNum":"  227","line":"      : m_instance(t_openmp_instance),","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  228","line":"        m_functor(arg_functor),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  229","line":"        m_mdr_policy(arg_policy),","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  230","line":"        m_policy(Policy(0, m_mdr_policy.m_num_tiles).set_chunk_size(1)) {}","class":"lineNoCov","hits":"0","possible_hits":"34",},
{"lineNum":"  231","line":"  template <typename Policy, typename Functor>"},
{"lineNum":"  232","line":"  static int max_tile_size_product(const Policy&, const Functor&) {"},
{"lineNum":"  233","line":"    /**"},
{"lineNum":"  234","line":"     * 1024 here is just our guess for a reasonable max tile size,"},
{"lineNum":"  235","line":"     * it isn\'t a hardware constraint. If people see a use for larger"},
{"lineNum":"  236","line":"     * tile size products, we\'re happy to change this."},
{"lineNum":"  237","line":"     */"},
{"lineNum":"  238","line":"    return 1024;"},
{"lineNum":"  239","line":"  }"},
{"lineNum":"  240","line":"};"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"}  // namespace Impl"},
{"lineNum":"  243","line":"}  // namespace Kokkos"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  246","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"namespace Kokkos {"},
{"lineNum":"  249","line":"namespace Impl {"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"template <class FunctorType, class ReducerType, class... Traits>"},
{"lineNum":"  252","line":"class ParallelReduce<FunctorType, Kokkos::RangePolicy<Traits...>, ReducerType,","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  253","line":"                     Kokkos::OpenMP> {"},
{"lineNum":"  254","line":" private:"},
{"lineNum":"  255","line":"  using Policy = Kokkos::RangePolicy<Traits...>;"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"  using WorkTag   = typename Policy::work_tag;"},
{"lineNum":"  258","line":"  using WorkRange = typename Policy::WorkRange;"},
{"lineNum":"  259","line":"  using Member    = typename Policy::member_type;"},
{"lineNum":"  260","line":""},
{"lineNum":"  261","line":"  using Analysis ="},
{"lineNum":"  262","line":"      FunctorAnalysis<FunctorPatternInterface::REDUCE, Policy, FunctorType>;"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"  using ReducerConditional ="},
{"lineNum":"  265","line":"      Kokkos::Impl::if_c<std::is_same<InvalidType, ReducerType>::value,"},
{"lineNum":"  266","line":"                         FunctorType, ReducerType>;"},
{"lineNum":"  267","line":"  using ReducerTypeFwd = typename ReducerConditional::type;"},
{"lineNum":"  268","line":"  using WorkTagFwd ="},
{"lineNum":"  269","line":"      std::conditional_t<std::is_same<InvalidType, ReducerType>::value, WorkTag,"},
{"lineNum":"  270","line":"                         void>;"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"  // Static Assert WorkTag void if ReducerType not InvalidType"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"  using ValueInit = Kokkos::Impl::FunctorValueInit<ReducerTypeFwd, WorkTagFwd>;"},
{"lineNum":"  275","line":"  using ValueJoin = Kokkos::Impl::FunctorValueJoin<ReducerTypeFwd, WorkTagFwd>;"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"  using pointer_type   = typename Analysis::pointer_type;"},
{"lineNum":"  278","line":"  using reference_type = typename Analysis::reference_type;"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"  OpenMPExec* m_instance;"},
{"lineNum":"  281","line":"  const FunctorType m_functor;"},
{"lineNum":"  282","line":"  const Policy m_policy;"},
{"lineNum":"  283","line":"  const ReducerType m_reducer;"},
{"lineNum":"  284","line":"  const pointer_type m_result_ptr;"},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"  template <class TagType>"},
{"lineNum":"  287","line":"  inline static"},
{"lineNum":"  288","line":"      typename std::enable_if<std::is_same<TagType, void>::value>::type"},
{"lineNum":"  289","line":"      exec_range(const FunctorType& functor, const Member ibeg,"},
{"lineNum":"  290","line":"                 const Member iend, reference_type update) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  291","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {","class":"lineNoCov","hits":"0","possible_hits":"33",},
{"lineNum":"  292","line":"      functor(iwork, update);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  293","line":"    }"},
{"lineNum":"  294","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"  template <class TagType>"},
{"lineNum":"  297","line":"  inline static"},
{"lineNum":"  298","line":"      typename std::enable_if<!std::is_same<TagType, void>::value>::type"},
{"lineNum":"  299","line":"      exec_range(const FunctorType& functor, const Member ibeg,"},
{"lineNum":"  300","line":"                 const Member iend, reference_type update) {"},
{"lineNum":"  301","line":"    const TagType t{};"},
{"lineNum":"  302","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {"},
{"lineNum":"  303","line":"      functor(t, iwork, update);"},
{"lineNum":"  304","line":"    }"},
{"lineNum":"  305","line":"  }"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":" public:"},
{"lineNum":"  308","line":"  inline void execute() const {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  309","line":"    if (m_policy.end() <= m_policy.begin()) {","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  310","line":"      if (m_result_ptr) {","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  311","line":"        ValueInit::init(ReducerConditional::select(m_functor, m_reducer),"},
{"lineNum":"  312","line":"                        m_result_ptr);"},
{"lineNum":"  313","line":"        Kokkos::Impl::FunctorFinal<ReducerTypeFwd, WorkTagFwd>::final("},
{"lineNum":"  314","line":"            ReducerConditional::select(m_functor, m_reducer), m_result_ptr);"},
{"lineNum":"  315","line":"      }"},
{"lineNum":"  316","line":"      return;"},
{"lineNum":"  317","line":"    }"},
{"lineNum":"  318","line":"    enum {"},
{"lineNum":"  319","line":"      is_dynamic = std::is_same<typename Policy::schedule_type::type,"},
{"lineNum":"  320","line":"                                Kokkos::Dynamic>::value"},
{"lineNum":"  321","line":"    };"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"    OpenMPExec::verify_is_master(\"Kokkos::OpenMP parallel_reduce\");","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"    const size_t pool_reduce_bytes ="},
{"lineNum":"  326","line":"        Analysis::value_size(ReducerConditional::select(m_functor, m_reducer));"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"    m_instance->resize_thread_data(pool_reduce_bytes, 0  // team_reduce_bytes","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  329","line":"                                   ,"},
{"lineNum":"  330","line":"                                   0  // team_shared_bytes"},
{"lineNum":"  331","line":"                                   ,"},
{"lineNum":"  332","line":"                                   0  // thread_local_bytes"},
{"lineNum":"  333","line":"    );"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"    const int pool_size = OpenMP::impl_thread_pool_size();"},
{"lineNum":"  336","line":"#pragma omp parallel num_threads(pool_size)","class":"lineNoCov","hits":"0","possible_hits":"53",},
{"lineNum":"  337","line":"    {"},
{"lineNum":"  338","line":"      HostThreadTeamData& data = *(m_instance->get_thread_data());","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"      data.set_work_partition(m_policy.end() - m_policy.begin(),","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  341","line":"                              m_policy.chunk_size());"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"      if (is_dynamic) {"},
{"lineNum":"  344","line":"        // Make sure work partition is set before stealing"},
{"lineNum":"  345","line":"        if (data.pool_rendezvous()) data.pool_rendezvous_release();"},
{"lineNum":"  346","line":"      }"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"      reference_type update ="},
{"lineNum":"  349","line":"          ValueInit::init(ReducerConditional::select(m_functor, m_reducer),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  350","line":"                          data.pool_reduce_local());"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"      std::pair<int64_t, int64_t> range(0, 0);"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"      do {"},
{"lineNum":"  355","line":"        range = is_dynamic ? data.get_work_stealing_chunk()"},
{"lineNum":"  356","line":"                           : data.get_work_partition();"},
{"lineNum":"  357","line":""},
{"lineNum":"  358","line":"        ParallelReduce::template exec_range<WorkTag>(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  359","line":"            m_functor, range.first + m_policy.begin(),","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  360","line":"            range.second + m_policy.begin(), update);","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"      } while (is_dynamic && 0 <= range.first);"},
{"lineNum":"  363","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"    // Reduction:"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"    const pointer_type ptr ="},
{"lineNum":"  368","line":"        pointer_type(m_instance->get_thread_data(0)->pool_reduce_local());","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"    for (int i = 1; i < pool_size; ++i) {","class":"lineNoCov","hits":"0","possible_hits":"25",},
{"lineNum":"  371","line":"      ValueJoin::join(ReducerConditional::select(m_functor, m_reducer), ptr,"},
{"lineNum":"  372","line":"                      m_instance->get_thread_data(i)->pool_reduce_local());"},
{"lineNum":"  373","line":"    }"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"    Kokkos::Impl::FunctorFinal<ReducerTypeFwd, WorkTagFwd>::final("},
{"lineNum":"  376","line":"        ReducerConditional::select(m_functor, m_reducer), ptr);"},
{"lineNum":"  377","line":""},
{"lineNum":"  378","line":"    if (m_result_ptr) {","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  379","line":"      const int n = Analysis::value_count("},
{"lineNum":"  380","line":"          ReducerConditional::select(m_functor, m_reducer));"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"      for (int j = 0; j < n; ++j) {","class":"lineNoCov","hits":"0","possible_hits":"49",},
{"lineNum":"  383","line":"        m_result_ptr[j] = ptr[j];","class":"lineNoCov","hits":"0","possible_hits":"44",},
{"lineNum":"  384","line":"      }"},
{"lineNum":"  385","line":"    }"},
{"lineNum":"  386","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"22",},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"  //----------------------------------------"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"  template <class ViewType>"},
{"lineNum":"  391","line":"  inline ParallelReduce("},
{"lineNum":"  392","line":"      const FunctorType& arg_functor, Policy arg_policy,"},
{"lineNum":"  393","line":"      const ViewType& arg_view,"},
{"lineNum":"  394","line":"      typename std::enable_if<Kokkos::is_view<ViewType>::value &&"},
{"lineNum":"  395","line":"                                  !Kokkos::is_reducer_type<ReducerType>::value,"},
{"lineNum":"  396","line":"                              void*>::type = nullptr)"},
{"lineNum":"  397","line":"      : m_instance(t_openmp_instance),","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  398","line":"        m_functor(arg_functor),","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  399","line":"        m_policy(arg_policy),","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  400","line":"        m_reducer(InvalidType()),"},
{"lineNum":"  401","line":"        m_result_ptr(arg_view.data()) {","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  402","line":"    /*static_assert( std::is_same< typename ViewType::memory_space"},
{"lineNum":"  403","line":"                                    , Kokkos::HostSpace >::value"},
{"lineNum":"  404","line":"      , \"Reduction result on Kokkos::OpenMP must be a Kokkos::View in HostSpace\""},
{"lineNum":"  405","line":"      );*/"},
{"lineNum":"  406","line":"  }"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"  inline ParallelReduce(const FunctorType& arg_functor, Policy arg_policy,"},
{"lineNum":"  409","line":"                        const ReducerType& reducer)"},
{"lineNum":"  410","line":"      : m_instance(t_openmp_instance),"},
{"lineNum":"  411","line":"        m_functor(arg_functor),"},
{"lineNum":"  412","line":"        m_policy(arg_policy),"},
{"lineNum":"  413","line":"        m_reducer(reducer),"},
{"lineNum":"  414","line":"        m_result_ptr(reducer.view().data()) {"},
{"lineNum":"  415","line":"    /*static_assert( std::is_same< typename ViewType::memory_space"},
{"lineNum":"  416","line":"                                    , Kokkos::HostSpace >::value"},
{"lineNum":"  417","line":"      , \"Reduction result on Kokkos::OpenMP must be a Kokkos::View in HostSpace\""},
{"lineNum":"  418","line":"      );*/"},
{"lineNum":"  419","line":"  }"},
{"lineNum":"  420","line":"};"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"// MDRangePolicy impl"},
{"lineNum":"  423","line":"template <class FunctorType, class ReducerType, class... Traits>"},
{"lineNum":"  424","line":"class ParallelReduce<FunctorType, Kokkos::MDRangePolicy<Traits...>, ReducerType,"},
{"lineNum":"  425","line":"                     Kokkos::OpenMP> {"},
{"lineNum":"  426","line":" private:"},
{"lineNum":"  427","line":"  using MDRangePolicy = Kokkos::MDRangePolicy<Traits...>;"},
{"lineNum":"  428","line":"  using Policy        = typename MDRangePolicy::impl_range_policy;"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"  using WorkTag   = typename MDRangePolicy::work_tag;"},
{"lineNum":"  431","line":"  using WorkRange = typename Policy::WorkRange;"},
{"lineNum":"  432","line":"  using Member    = typename Policy::member_type;"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"  using Analysis = FunctorAnalysis<FunctorPatternInterface::REDUCE,"},
{"lineNum":"  435","line":"                                   MDRangePolicy, FunctorType>;"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"  using ReducerConditional ="},
{"lineNum":"  438","line":"      Kokkos::Impl::if_c<std::is_same<InvalidType, ReducerType>::value,"},
{"lineNum":"  439","line":"                         FunctorType, ReducerType>;"},
{"lineNum":"  440","line":"  using ReducerTypeFwd = typename ReducerConditional::type;"},
{"lineNum":"  441","line":"  using WorkTagFwd ="},
{"lineNum":"  442","line":"      std::conditional_t<std::is_same<InvalidType, ReducerType>::value, WorkTag,"},
{"lineNum":"  443","line":"                         void>;"},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"  using ValueInit = Kokkos::Impl::FunctorValueInit<ReducerTypeFwd, WorkTagFwd>;"},
{"lineNum":"  446","line":"  using ValueJoin = Kokkos::Impl::FunctorValueJoin<ReducerTypeFwd, WorkTagFwd>;"},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"  using pointer_type   = typename Analysis::pointer_type;"},
{"lineNum":"  449","line":"  using value_type     = typename Analysis::value_type;"},
{"lineNum":"  450","line":"  using reference_type = typename Analysis::reference_type;"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"  using iterate_type ="},
{"lineNum":"  453","line":"      typename Kokkos::Impl::HostIterateTile<MDRangePolicy, FunctorType,"},
{"lineNum":"  454","line":"                                             WorkTag, reference_type>;"},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"  OpenMPExec* m_instance;"},
{"lineNum":"  457","line":"  const FunctorType m_functor;"},
{"lineNum":"  458","line":"  const MDRangePolicy m_mdr_policy;"},
{"lineNum":"  459","line":"  const Policy m_policy;  // construct as RangePolicy( 0, num_tiles"},
{"lineNum":"  460","line":"                          // ).set_chunk_size(1) in ctor"},
{"lineNum":"  461","line":"  const ReducerType m_reducer;"},
{"lineNum":"  462","line":"  const pointer_type m_result_ptr;"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"  inline static void exec_range(const MDRangePolicy& mdr_policy,"},
{"lineNum":"  465","line":"                                const FunctorType& functor, const Member ibeg,"},
{"lineNum":"  466","line":"                                const Member iend, reference_type update) {"},
{"lineNum":"  467","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {"},
{"lineNum":"  468","line":"      iterate_type(mdr_policy, functor, update)(iwork);"},
{"lineNum":"  469","line":"    }"},
{"lineNum":"  470","line":"  }"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":" public:"},
{"lineNum":"  473","line":"  inline void execute() const {"},
{"lineNum":"  474","line":"    enum {"},
{"lineNum":"  475","line":"      is_dynamic = std::is_same<typename Policy::schedule_type::type,"},
{"lineNum":"  476","line":"                                Kokkos::Dynamic>::value"},
{"lineNum":"  477","line":"    };"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"    OpenMPExec::verify_is_master(\"Kokkos::OpenMP parallel_reduce\");"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"    const size_t pool_reduce_bytes ="},
{"lineNum":"  482","line":"        Analysis::value_size(ReducerConditional::select(m_functor, m_reducer));"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"    m_instance->resize_thread_data(pool_reduce_bytes, 0  // team_reduce_bytes"},
{"lineNum":"  485","line":"                                   ,"},
{"lineNum":"  486","line":"                                   0  // team_shared_bytes"},
{"lineNum":"  487","line":"                                   ,"},
{"lineNum":"  488","line":"                                   0  // thread_local_bytes"},
{"lineNum":"  489","line":"    );"},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"    const int pool_size = OpenMP::impl_thread_pool_size();"},
{"lineNum":"  492","line":"#pragma omp parallel num_threads(pool_size)"},
{"lineNum":"  493","line":"    {"},
{"lineNum":"  494","line":"      HostThreadTeamData& data = *(m_instance->get_thread_data());"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"      data.set_work_partition(m_policy.end() - m_policy.begin(),"},
{"lineNum":"  497","line":"                              m_policy.chunk_size());"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"      if (is_dynamic) {"},
{"lineNum":"  500","line":"        // Make sure work partition is set before stealing"},
{"lineNum":"  501","line":"        if (data.pool_rendezvous()) data.pool_rendezvous_release();"},
{"lineNum":"  502","line":"      }"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"      reference_type update ="},
{"lineNum":"  505","line":"          ValueInit::init(ReducerConditional::select(m_functor, m_reducer),"},
{"lineNum":"  506","line":"                          data.pool_reduce_local());"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"      std::pair<int64_t, int64_t> range(0, 0);"},
{"lineNum":"  509","line":""},
{"lineNum":"  510","line":"      do {"},
{"lineNum":"  511","line":"        range = is_dynamic ? data.get_work_stealing_chunk()"},
{"lineNum":"  512","line":"                           : data.get_work_partition();"},
{"lineNum":"  513","line":""},
{"lineNum":"  514","line":"        ParallelReduce::exec_range(m_mdr_policy, m_functor,"},
{"lineNum":"  515","line":"                                   range.first + m_policy.begin(),"},
{"lineNum":"  516","line":"                                   range.second + m_policy.begin(), update);"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"      } while (is_dynamic && 0 <= range.first);"},
{"lineNum":"  519","line":"    }"},
{"lineNum":"  520","line":"    // END #pragma omp parallel"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"    // Reduction:"},
{"lineNum":"  523","line":""},
{"lineNum":"  524","line":"    const pointer_type ptr ="},
{"lineNum":"  525","line":"        pointer_type(m_instance->get_thread_data(0)->pool_reduce_local());"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"    for (int i = 1; i < pool_size; ++i) {"},
{"lineNum":"  528","line":"      ValueJoin::join(ReducerConditional::select(m_functor, m_reducer), ptr,"},
{"lineNum":"  529","line":"                      m_instance->get_thread_data(i)->pool_reduce_local());"},
{"lineNum":"  530","line":"    }"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"    Kokkos::Impl::FunctorFinal<ReducerTypeFwd, WorkTagFwd>::final("},
{"lineNum":"  533","line":"        ReducerConditional::select(m_functor, m_reducer), ptr);"},
{"lineNum":"  534","line":""},
{"lineNum":"  535","line":"    if (m_result_ptr) {"},
{"lineNum":"  536","line":"      const int n = Analysis::value_count("},
{"lineNum":"  537","line":"          ReducerConditional::select(m_functor, m_reducer));"},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"      for (int j = 0; j < n; ++j) {"},
{"lineNum":"  540","line":"        m_result_ptr[j] = ptr[j];"},
{"lineNum":"  541","line":"      }"},
{"lineNum":"  542","line":"    }"},
{"lineNum":"  543","line":"  }"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"  //----------------------------------------"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"  template <class ViewType>"},
{"lineNum":"  548","line":"  inline ParallelReduce("},
{"lineNum":"  549","line":"      const FunctorType& arg_functor, MDRangePolicy arg_policy,"},
{"lineNum":"  550","line":"      const ViewType& arg_view,"},
{"lineNum":"  551","line":"      typename std::enable_if<Kokkos::is_view<ViewType>::value &&"},
{"lineNum":"  552","line":"                                  !Kokkos::is_reducer_type<ReducerType>::value,"},
{"lineNum":"  553","line":"                              void*>::type = nullptr)"},
{"lineNum":"  554","line":"      : m_instance(t_openmp_instance),"},
{"lineNum":"  555","line":"        m_functor(arg_functor),"},
{"lineNum":"  556","line":"        m_mdr_policy(arg_policy),"},
{"lineNum":"  557","line":"        m_policy(Policy(0, m_mdr_policy.m_num_tiles).set_chunk_size(1)),"},
{"lineNum":"  558","line":"        m_reducer(InvalidType()),"},
{"lineNum":"  559","line":"        m_result_ptr(arg_view.data()) {"},
{"lineNum":"  560","line":"    /*static_assert( std::is_same< typename ViewType::memory_space"},
{"lineNum":"  561","line":"                                    , Kokkos::HostSpace >::value"},
{"lineNum":"  562","line":"      , \"Reduction result on Kokkos::OpenMP must be a Kokkos::View in HostSpace\""},
{"lineNum":"  563","line":"      );*/"},
{"lineNum":"  564","line":"  }"},
{"lineNum":"  565","line":""},
{"lineNum":"  566","line":"  inline ParallelReduce(const FunctorType& arg_functor,"},
{"lineNum":"  567","line":"                        MDRangePolicy arg_policy, const ReducerType& reducer)"},
{"lineNum":"  568","line":"      : m_instance(t_openmp_instance),"},
{"lineNum":"  569","line":"        m_functor(arg_functor),"},
{"lineNum":"  570","line":"        m_mdr_policy(arg_policy),"},
{"lineNum":"  571","line":"        m_policy(Policy(0, m_mdr_policy.m_num_tiles).set_chunk_size(1)),"},
{"lineNum":"  572","line":"        m_reducer(reducer),"},
{"lineNum":"  573","line":"        m_result_ptr(reducer.view().data()) {"},
{"lineNum":"  574","line":"    /*static_assert( std::is_same< typename ViewType::memory_space"},
{"lineNum":"  575","line":"                                    , Kokkos::HostSpace >::value"},
{"lineNum":"  576","line":"      , \"Reduction result on Kokkos::OpenMP must be a Kokkos::View in HostSpace\""},
{"lineNum":"  577","line":"      );*/"},
{"lineNum":"  578","line":"  }"},
{"lineNum":"  579","line":"  template <typename Policy, typename Functor>"},
{"lineNum":"  580","line":"  static int max_tile_size_product(const Policy&, const Functor&) {"},
{"lineNum":"  581","line":"    /**"},
{"lineNum":"  582","line":"     * 1024 here is just our guess for a reasonable max tile size,"},
{"lineNum":"  583","line":"     * it isn\'t a hardware constraint. If people see a use for larger"},
{"lineNum":"  584","line":"     * tile size products, we\'re happy to change this."},
{"lineNum":"  585","line":"     */"},
{"lineNum":"  586","line":"    return 1024;"},
{"lineNum":"  587","line":"  }"},
{"lineNum":"  588","line":"};"},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":"}  // namespace Impl"},
{"lineNum":"  591","line":"}  // namespace Kokkos"},
{"lineNum":"  592","line":""},
{"lineNum":"  593","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  594","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  595","line":""},
{"lineNum":"  596","line":"namespace Kokkos {"},
{"lineNum":"  597","line":"namespace Impl {"},
{"lineNum":"  598","line":""},
{"lineNum":"  599","line":"template <class FunctorType, class... Traits>"},
{"lineNum":"  600","line":"class ParallelScan<FunctorType, Kokkos::RangePolicy<Traits...>,"},
{"lineNum":"  601","line":"                   Kokkos::OpenMP> {"},
{"lineNum":"  602","line":" private:"},
{"lineNum":"  603","line":"  using Policy = Kokkos::RangePolicy<Traits...>;"},
{"lineNum":"  604","line":""},
{"lineNum":"  605","line":"  using Analysis ="},
{"lineNum":"  606","line":"      FunctorAnalysis<FunctorPatternInterface::SCAN, Policy, FunctorType>;"},
{"lineNum":"  607","line":""},
{"lineNum":"  608","line":"  using WorkTag   = typename Policy::work_tag;"},
{"lineNum":"  609","line":"  using WorkRange = typename Policy::WorkRange;"},
{"lineNum":"  610","line":"  using Member    = typename Policy::member_type;"},
{"lineNum":"  611","line":""},
{"lineNum":"  612","line":"  using ValueInit = Kokkos::Impl::FunctorValueInit<FunctorType, WorkTag>;"},
{"lineNum":"  613","line":"  using ValueJoin = Kokkos::Impl::FunctorValueJoin<FunctorType, WorkTag>;"},
{"lineNum":"  614","line":"  using ValueOps  = Kokkos::Impl::FunctorValueOps<FunctorType, WorkTag>;"},
{"lineNum":"  615","line":""},
{"lineNum":"  616","line":"  using pointer_type   = typename Analysis::pointer_type;"},
{"lineNum":"  617","line":"  using reference_type = typename Analysis::reference_type;"},
{"lineNum":"  618","line":""},
{"lineNum":"  619","line":"  OpenMPExec* m_instance;"},
{"lineNum":"  620","line":"  const FunctorType m_functor;"},
{"lineNum":"  621","line":"  const Policy m_policy;"},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"  template <class TagType>"},
{"lineNum":"  624","line":"  inline static"},
{"lineNum":"  625","line":"      typename std::enable_if<std::is_same<TagType, void>::value>::type"},
{"lineNum":"  626","line":"      exec_range(const FunctorType& functor, const Member ibeg,"},
{"lineNum":"  627","line":"                 const Member iend, reference_type update, const bool final) {"},
{"lineNum":"  628","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {"},
{"lineNum":"  629","line":"      functor(iwork, update, final);"},
{"lineNum":"  630","line":"    }"},
{"lineNum":"  631","line":"  }"},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"  template <class TagType>"},
{"lineNum":"  634","line":"  inline static"},
{"lineNum":"  635","line":"      typename std::enable_if<!std::is_same<TagType, void>::value>::type"},
{"lineNum":"  636","line":"      exec_range(const FunctorType& functor, const Member ibeg,"},
{"lineNum":"  637","line":"                 const Member iend, reference_type update, const bool final) {"},
{"lineNum":"  638","line":"    const TagType t{};"},
{"lineNum":"  639","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {"},
{"lineNum":"  640","line":"      functor(t, iwork, update, final);"},
{"lineNum":"  641","line":"    }"},
{"lineNum":"  642","line":"  }"},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":" public:"},
{"lineNum":"  645","line":"  inline void execute() const {"},
{"lineNum":"  646","line":"    OpenMPExec::verify_is_master(\"Kokkos::OpenMP parallel_scan\");"},
{"lineNum":"  647","line":""},
{"lineNum":"  648","line":"    const int value_count          = Analysis::value_count(m_functor);"},
{"lineNum":"  649","line":"    const size_t pool_reduce_bytes = 2 * Analysis::value_size(m_functor);"},
{"lineNum":"  650","line":""},
{"lineNum":"  651","line":"    m_instance->resize_thread_data(pool_reduce_bytes, 0  // team_reduce_bytes"},
{"lineNum":"  652","line":"                                   ,"},
{"lineNum":"  653","line":"                                   0  // team_shared_bytes"},
{"lineNum":"  654","line":"                                   ,"},
{"lineNum":"  655","line":"                                   0  // thread_local_bytes"},
{"lineNum":"  656","line":"    );"},
{"lineNum":"  657","line":""},
{"lineNum":"  658","line":"#pragma omp parallel num_threads(OpenMP::impl_thread_pool_size())"},
{"lineNum":"  659","line":"    {"},
{"lineNum":"  660","line":"      HostThreadTeamData& data = *(m_instance->get_thread_data());"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"      const WorkRange range(m_policy, omp_get_thread_num(),"},
{"lineNum":"  663","line":"                            omp_get_num_threads());"},
{"lineNum":"  664","line":""},
{"lineNum":"  665","line":"      reference_type update_sum ="},
{"lineNum":"  666","line":"          ValueInit::init(m_functor, data.pool_reduce_local());"},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"      ParallelScan::template exec_range<WorkTag>("},
{"lineNum":"  669","line":"          m_functor, range.begin(), range.end(), update_sum, false);"},
{"lineNum":"  670","line":""},
{"lineNum":"  671","line":"      if (data.pool_rendezvous()) {"},
{"lineNum":"  672","line":"        pointer_type ptr_prev = nullptr;"},
{"lineNum":"  673","line":""},
{"lineNum":"  674","line":"        const int n = omp_get_num_threads();"},
{"lineNum":"  675","line":""},
{"lineNum":"  676","line":"        for (int i = 0; i < n; ++i) {"},
{"lineNum":"  677","line":"          pointer_type ptr ="},
{"lineNum":"  678","line":"              (pointer_type)data.pool_member(i)->pool_reduce_local();"},
{"lineNum":"  679","line":""},
{"lineNum":"  680","line":"          if (i) {"},
{"lineNum":"  681","line":"            for (int j = 0; j < value_count; ++j) {"},
{"lineNum":"  682","line":"              ptr[j + value_count] = ptr_prev[j + value_count];"},
{"lineNum":"  683","line":"            }"},
{"lineNum":"  684","line":"            ValueJoin::join(m_functor, ptr + value_count, ptr_prev);"},
{"lineNum":"  685","line":"          } else {"},
{"lineNum":"  686","line":"            ValueInit::init(m_functor, ptr + value_count);"},
{"lineNum":"  687","line":"          }"},
{"lineNum":"  688","line":""},
{"lineNum":"  689","line":"          ptr_prev = ptr;"},
{"lineNum":"  690","line":"        }"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"        data.pool_rendezvous_release();"},
{"lineNum":"  693","line":"      }"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"      reference_type update_base = ValueOps::reference("},
{"lineNum":"  696","line":"          ((pointer_type)data.pool_reduce_local()) + value_count);"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"      ParallelScan::template exec_range<WorkTag>("},
{"lineNum":"  699","line":"          m_functor, range.begin(), range.end(), update_base, true);"},
{"lineNum":"  700","line":"    }"},
{"lineNum":"  701","line":"  }"},
{"lineNum":"  702","line":""},
{"lineNum":"  703","line":"  //----------------------------------------"},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"  inline ParallelScan(const FunctorType& arg_functor, const Policy& arg_policy)"},
{"lineNum":"  706","line":"      : m_instance(t_openmp_instance),"},
{"lineNum":"  707","line":"        m_functor(arg_functor),"},
{"lineNum":"  708","line":"        m_policy(arg_policy) {}"},
{"lineNum":"  709","line":""},
{"lineNum":"  710","line":"  //----------------------------------------"},
{"lineNum":"  711","line":"};"},
{"lineNum":"  712","line":""},
{"lineNum":"  713","line":"template <class FunctorType, class ReturnType, class... Traits>"},
{"lineNum":"  714","line":"class ParallelScanWithTotal<FunctorType, Kokkos::RangePolicy<Traits...>,"},
{"lineNum":"  715","line":"                            ReturnType, Kokkos::OpenMP> {"},
{"lineNum":"  716","line":" private:"},
{"lineNum":"  717","line":"  using Policy = Kokkos::RangePolicy<Traits...>;"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"  using Analysis ="},
{"lineNum":"  720","line":"      FunctorAnalysis<FunctorPatternInterface::SCAN, Policy, FunctorType>;"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"  using WorkTag   = typename Policy::work_tag;"},
{"lineNum":"  723","line":"  using WorkRange = typename Policy::WorkRange;"},
{"lineNum":"  724","line":"  using Member    = typename Policy::member_type;"},
{"lineNum":"  725","line":""},
{"lineNum":"  726","line":"  using ValueInit = Kokkos::Impl::FunctorValueInit<FunctorType, WorkTag>;"},
{"lineNum":"  727","line":"  using ValueJoin = Kokkos::Impl::FunctorValueJoin<FunctorType, WorkTag>;"},
{"lineNum":"  728","line":"  using ValueOps  = Kokkos::Impl::FunctorValueOps<FunctorType, WorkTag>;"},
{"lineNum":"  729","line":""},
{"lineNum":"  730","line":"  using pointer_type   = typename Analysis::pointer_type;"},
{"lineNum":"  731","line":"  using reference_type = typename Analysis::reference_type;"},
{"lineNum":"  732","line":""},
{"lineNum":"  733","line":"  OpenMPExec* m_instance;"},
{"lineNum":"  734","line":"  const FunctorType m_functor;"},
{"lineNum":"  735","line":"  const Policy m_policy;"},
{"lineNum":"  736","line":"  ReturnType& m_returnvalue;"},
{"lineNum":"  737","line":""},
{"lineNum":"  738","line":"  template <class TagType>"},
{"lineNum":"  739","line":"  inline static"},
{"lineNum":"  740","line":"      typename std::enable_if<std::is_same<TagType, void>::value>::type"},
{"lineNum":"  741","line":"      exec_range(const FunctorType& functor, const Member ibeg,"},
{"lineNum":"  742","line":"                 const Member iend, reference_type update, const bool final) {"},
{"lineNum":"  743","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {"},
{"lineNum":"  744","line":"      functor(iwork, update, final);"},
{"lineNum":"  745","line":"    }"},
{"lineNum":"  746","line":"  }"},
{"lineNum":"  747","line":""},
{"lineNum":"  748","line":"  template <class TagType>"},
{"lineNum":"  749","line":"  inline static"},
{"lineNum":"  750","line":"      typename std::enable_if<!std::is_same<TagType, void>::value>::type"},
{"lineNum":"  751","line":"      exec_range(const FunctorType& functor, const Member ibeg,"},
{"lineNum":"  752","line":"                 const Member iend, reference_type update, const bool final) {"},
{"lineNum":"  753","line":"    const TagType t{};"},
{"lineNum":"  754","line":"    for (Member iwork = ibeg; iwork < iend; ++iwork) {"},
{"lineNum":"  755","line":"      functor(t, iwork, update, final);"},
{"lineNum":"  756","line":"    }"},
{"lineNum":"  757","line":"  }"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":" public:"},
{"lineNum":"  760","line":"  inline void execute() const {"},
{"lineNum":"  761","line":"    OpenMPExec::verify_is_master(\"Kokkos::OpenMP parallel_scan\");"},
{"lineNum":"  762","line":""},
{"lineNum":"  763","line":"    const int value_count          = Analysis::value_count(m_functor);"},
{"lineNum":"  764","line":"    const size_t pool_reduce_bytes = 2 * Analysis::value_size(m_functor);"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"    m_instance->resize_thread_data(pool_reduce_bytes, 0  // team_reduce_bytes"},
{"lineNum":"  767","line":"                                   ,"},
{"lineNum":"  768","line":"                                   0  // team_shared_bytes"},
{"lineNum":"  769","line":"                                   ,"},
{"lineNum":"  770","line":"                                   0  // thread_local_bytes"},
{"lineNum":"  771","line":"    );"},
{"lineNum":"  772","line":""},
{"lineNum":"  773","line":"#pragma omp parallel num_threads(OpenMP::impl_thread_pool_size())"},
{"lineNum":"  774","line":"    {"},
{"lineNum":"  775","line":"      HostThreadTeamData& data = *(m_instance->get_thread_data());"},
{"lineNum":"  776","line":""},
{"lineNum":"  777","line":"      const WorkRange range(m_policy, omp_get_thread_num(),"},
{"lineNum":"  778","line":"                            omp_get_num_threads());"},
{"lineNum":"  779","line":"      reference_type update_sum ="},
{"lineNum":"  780","line":"          ValueInit::init(m_functor, data.pool_reduce_local());"},
{"lineNum":"  781","line":""},
{"lineNum":"  782","line":"      ParallelScanWithTotal::template exec_range<WorkTag>("},
{"lineNum":"  783","line":"          m_functor, range.begin(), range.end(), update_sum, false);"},
{"lineNum":"  784","line":""},
{"lineNum":"  785","line":"      if (data.pool_rendezvous()) {"},
{"lineNum":"  786","line":"        pointer_type ptr_prev = nullptr;"},
{"lineNum":"  787","line":""},
{"lineNum":"  788","line":"        const int n = omp_get_num_threads();"},
{"lineNum":"  789","line":""},
{"lineNum":"  790","line":"        for (int i = 0; i < n; ++i) {"},
{"lineNum":"  791","line":"          pointer_type ptr ="},
{"lineNum":"  792","line":"              (pointer_type)data.pool_member(i)->pool_reduce_local();"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"          if (i) {"},
{"lineNum":"  795","line":"            for (int j = 0; j < value_count; ++j) {"},
{"lineNum":"  796","line":"              ptr[j + value_count] = ptr_prev[j + value_count];"},
{"lineNum":"  797","line":"            }"},
{"lineNum":"  798","line":"            ValueJoin::join(m_functor, ptr + value_count, ptr_prev);"},
{"lineNum":"  799","line":"          } else {"},
{"lineNum":"  800","line":"            ValueInit::init(m_functor, ptr + value_count);"},
{"lineNum":"  801","line":"          }"},
{"lineNum":"  802","line":""},
{"lineNum":"  803","line":"          ptr_prev = ptr;"},
{"lineNum":"  804","line":"        }"},
{"lineNum":"  805","line":""},
{"lineNum":"  806","line":"        data.pool_rendezvous_release();"},
{"lineNum":"  807","line":"      }"},
{"lineNum":"  808","line":""},
{"lineNum":"  809","line":"      reference_type update_base = ValueOps::reference("},
{"lineNum":"  810","line":"          ((pointer_type)data.pool_reduce_local()) + value_count);"},
{"lineNum":"  811","line":""},
{"lineNum":"  812","line":"      ParallelScanWithTotal::template exec_range<WorkTag>("},
{"lineNum":"  813","line":"          m_functor, range.begin(), range.end(), update_base, true);"},
{"lineNum":"  814","line":""},
{"lineNum":"  815","line":"      if (omp_get_thread_num() == omp_get_num_threads() - 1) {"},
{"lineNum":"  816","line":"        m_returnvalue = update_base;"},
{"lineNum":"  817","line":"      }"},
{"lineNum":"  818","line":"    }"},
{"lineNum":"  819","line":"  }"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"  //----------------------------------------"},
{"lineNum":"  822","line":""},
{"lineNum":"  823","line":"  inline ParallelScanWithTotal(const FunctorType& arg_functor,"},
{"lineNum":"  824","line":"                               const Policy& arg_policy,"},
{"lineNum":"  825","line":"                               ReturnType& arg_returnvalue)"},
{"lineNum":"  826","line":"      : m_instance(t_openmp_instance),"},
{"lineNum":"  827","line":"        m_functor(arg_functor),"},
{"lineNum":"  828","line":"        m_policy(arg_policy),"},
{"lineNum":"  829","line":"        m_returnvalue(arg_returnvalue) {}"},
{"lineNum":"  830","line":""},
{"lineNum":"  831","line":"  //----------------------------------------"},
{"lineNum":"  832","line":"};"},
{"lineNum":"  833","line":""},
{"lineNum":"  834","line":"}  // namespace Impl"},
{"lineNum":"  835","line":"}  // namespace Kokkos"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  838","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  839","line":""},
{"lineNum":"  840","line":"namespace Kokkos {"},
{"lineNum":"  841","line":"namespace Impl {"},
{"lineNum":"  842","line":""},
{"lineNum":"  843","line":"template <class FunctorType, class... Properties>"},
{"lineNum":"  844","line":"class ParallelFor<FunctorType, Kokkos::TeamPolicy<Properties...>,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  845","line":"                  Kokkos::OpenMP> {"},
{"lineNum":"  846","line":" private:"},
{"lineNum":"  847","line":"  enum { TEAM_REDUCE_SIZE = 512 };"},
{"lineNum":"  848","line":""},
{"lineNum":"  849","line":"  using Policy ="},
{"lineNum":"  850","line":"      Kokkos::Impl::TeamPolicyInternal<Kokkos::OpenMP, Properties...>;"},
{"lineNum":"  851","line":"  using WorkTag  = typename Policy::work_tag;"},
{"lineNum":"  852","line":"  using SchedTag = typename Policy::schedule_type::type;"},
{"lineNum":"  853","line":"  using Member   = typename Policy::member_type;"},
{"lineNum":"  854","line":""},
{"lineNum":"  855","line":"  OpenMPExec* m_instance;"},
{"lineNum":"  856","line":"  const FunctorType m_functor;"},
{"lineNum":"  857","line":"  const Policy m_policy;"},
{"lineNum":"  858","line":"  const int m_shmem_size;"},
{"lineNum":"  859","line":""},
{"lineNum":"  860","line":"  template <class TagType>"},
{"lineNum":"  861","line":"  inline static"},
{"lineNum":"  862","line":"      typename std::enable_if<(std::is_same<TagType, void>::value)>::type"},
{"lineNum":"  863","line":"      exec_team(const FunctorType& functor, HostThreadTeamData& data,"},
{"lineNum":"  864","line":"                const int league_rank_begin, const int league_rank_end,"},
{"lineNum":"  865","line":"                const int league_size) {"},
{"lineNum":"  866","line":"    for (int r = league_rank_begin; r < league_rank_end;) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  867","line":"      functor(Member(data, r, league_size));"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"      if (++r < league_rank_end) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  870","line":"        // Don\'t allow team members to lap one another"},
{"lineNum":"  871","line":"        // so that they don\'t overwrite shared memory."},
{"lineNum":"  872","line":"        if (data.team_rendezvous()) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  873","line":"          data.team_rendezvous_release();"},
{"lineNum":"  874","line":"        }"},
{"lineNum":"  875","line":"      }"},
{"lineNum":"  876","line":"    }"},
{"lineNum":"  877","line":"  }"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"  template <class TagType>"},
{"lineNum":"  880","line":"  inline static"},
{"lineNum":"  881","line":"      typename std::enable_if<(!std::is_same<TagType, void>::value)>::type"},
{"lineNum":"  882","line":"      exec_team(const FunctorType& functor, HostThreadTeamData& data,"},
{"lineNum":"  883","line":"                const int league_rank_begin, const int league_rank_end,"},
{"lineNum":"  884","line":"                const int league_size) {"},
{"lineNum":"  885","line":"    const TagType t{};"},
{"lineNum":"  886","line":""},
{"lineNum":"  887","line":"    for (int r = league_rank_begin; r < league_rank_end;) {"},
{"lineNum":"  888","line":"      functor(t, Member(data, r, league_size));"},
{"lineNum":"  889","line":""},
{"lineNum":"  890","line":"      if (++r < league_rank_end) {"},
{"lineNum":"  891","line":"        // Don\'t allow team members to lap one another"},
{"lineNum":"  892","line":"        // so that they don\'t overwrite shared memory."},
{"lineNum":"  893","line":"        if (data.team_rendezvous()) {"},
{"lineNum":"  894","line":"          data.team_rendezvous_release();"},
{"lineNum":"  895","line":"        }"},
{"lineNum":"  896","line":"      }"},
{"lineNum":"  897","line":"    }"},
{"lineNum":"  898","line":"  }"},
{"lineNum":"  899","line":""},
{"lineNum":"  900","line":" public:"},
{"lineNum":"  901","line":"  inline void execute() const {"},
{"lineNum":"  902","line":"    enum { is_dynamic = std::is_same<SchedTag, Kokkos::Dynamic>::value };"},
{"lineNum":"  903","line":""},
{"lineNum":"  904","line":"    OpenMPExec::verify_is_master(\"Kokkos::OpenMP parallel_for\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  905","line":""},
{"lineNum":"  906","line":"    const size_t pool_reduce_size  = 0;  // Never shrinks"},
{"lineNum":"  907","line":"    const size_t team_reduce_size  = TEAM_REDUCE_SIZE * m_policy.team_size();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  908","line":"    const size_t team_shared_size  = m_shmem_size + m_policy.scratch_size(1);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  909","line":"    const size_t thread_local_size = 0;  // Never shrinks"},
{"lineNum":"  910","line":""},
{"lineNum":"  911","line":"    m_instance->resize_thread_data(pool_reduce_size, team_reduce_size,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  912","line":"                                   team_shared_size, thread_local_size);"},
{"lineNum":"  913","line":""},
{"lineNum":"  914","line":"#pragma omp parallel num_threads(OpenMP::impl_thread_pool_size())","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  915","line":"    {"},
{"lineNum":"  916","line":"      HostThreadTeamData& data = *(m_instance->get_thread_data());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  917","line":""},
{"lineNum":"  918","line":"      const int active = data.organize_team(m_policy.team_size());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  919","line":""},
{"lineNum":"  920","line":"      if (active) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  921","line":"        data.set_work_partition("},
{"lineNum":"  922","line":"            m_policy.league_size(),"},
{"lineNum":"  923","line":"            (0 < m_policy.chunk_size() ? m_policy.chunk_size()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  924","line":"                                       : m_policy.team_iter()));"},
{"lineNum":"  925","line":"      }"},
{"lineNum":"  926","line":""},
{"lineNum":"  927","line":"      if (is_dynamic) {"},
{"lineNum":"  928","line":"        // Must synchronize to make sure each team has set its"},
{"lineNum":"  929","line":"        // partition before beginning the work stealing loop."},
{"lineNum":"  930","line":"        if (data.pool_rendezvous()) data.pool_rendezvous_release();"},
{"lineNum":"  931","line":"      }"},
{"lineNum":"  932","line":""},
{"lineNum":"  933","line":"      if (active) {"},
{"lineNum":"  934","line":"        std::pair<int64_t, int64_t> range(0, 0);"},
{"lineNum":"  935","line":""},
{"lineNum":"  936","line":"        do {"},
{"lineNum":"  937","line":"          range = is_dynamic ? data.get_work_stealing_chunk()"},
{"lineNum":"  938","line":"                             : data.get_work_partition();"},
{"lineNum":"  939","line":""},
{"lineNum":"  940","line":"          ParallelFor::template exec_team<WorkTag>(m_functor, data, range.first,"},
{"lineNum":"  941","line":"                                                   range.second,"},
{"lineNum":"  942","line":"                                                   m_policy.league_size());"},
{"lineNum":"  943","line":""},
{"lineNum":"  944","line":"        } while (is_dynamic && 0 <= range.first);"},
{"lineNum":"  945","line":"      }"},
{"lineNum":"  946","line":""},
{"lineNum":"  947","line":"      data.disband_team();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  948","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  949","line":"  }"},
{"lineNum":"  950","line":""},
{"lineNum":"  951","line":"  inline ParallelFor(const FunctorType& arg_functor, const Policy& arg_policy)"},
{"lineNum":"  952","line":"      : m_instance(t_openmp_instance),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  953","line":"        m_functor(arg_functor),"},
{"lineNum":"  954","line":"        m_policy(arg_policy),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  955","line":"        m_shmem_size(arg_policy.scratch_size(0) + arg_policy.scratch_size(1) +","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  956","line":"                     FunctorTeamShmemSize<FunctorType>::value("},
{"lineNum":"  957","line":"                         arg_functor, arg_policy.team_size())) {}"},
{"lineNum":"  958","line":"};"},
{"lineNum":"  959","line":""},
{"lineNum":"  960","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  961","line":""},
{"lineNum":"  962","line":"template <class FunctorType, class ReducerType, class... Properties>"},
{"lineNum":"  963","line":"class ParallelReduce<FunctorType, Kokkos::TeamPolicy<Properties...>,"},
{"lineNum":"  964","line":"                     ReducerType, Kokkos::OpenMP> {"},
{"lineNum":"  965","line":" private:"},
{"lineNum":"  966","line":"  enum { TEAM_REDUCE_SIZE = 512 };"},
{"lineNum":"  967","line":""},
{"lineNum":"  968","line":"  using Policy ="},
{"lineNum":"  969","line":"      Kokkos::Impl::TeamPolicyInternal<Kokkos::OpenMP, Properties...>;"},
{"lineNum":"  970","line":""},
{"lineNum":"  971","line":"  using Analysis ="},
{"lineNum":"  972","line":"      FunctorAnalysis<FunctorPatternInterface::REDUCE, Policy, FunctorType>;"},
{"lineNum":"  973","line":""},
{"lineNum":"  974","line":"  using WorkTag  = typename Policy::work_tag;"},
{"lineNum":"  975","line":"  using SchedTag = typename Policy::schedule_type::type;"},
{"lineNum":"  976","line":"  using Member   = typename Policy::member_type;"},
{"lineNum":"  977","line":""},
{"lineNum":"  978","line":"  using ReducerConditional ="},
{"lineNum":"  979","line":"      Kokkos::Impl::if_c<std::is_same<InvalidType, ReducerType>::value,"},
{"lineNum":"  980","line":"                         FunctorType, ReducerType>;"},
{"lineNum":"  981","line":""},
{"lineNum":"  982","line":"  using ReducerTypeFwd = typename ReducerConditional::type;"},
{"lineNum":"  983","line":"  using WorkTagFwd ="},
{"lineNum":"  984","line":"      std::conditional_t<std::is_same<InvalidType, ReducerType>::value, WorkTag,"},
{"lineNum":"  985","line":"                         void>;"},
{"lineNum":"  986","line":""},
{"lineNum":"  987","line":"  using ValueInit = Kokkos::Impl::FunctorValueInit<ReducerTypeFwd, WorkTagFwd>;"},
{"lineNum":"  988","line":"  using ValueJoin = Kokkos::Impl::FunctorValueJoin<ReducerTypeFwd, WorkTagFwd>;"},
{"lineNum":"  989","line":""},
{"lineNum":"  990","line":"  using pointer_type   = typename Analysis::pointer_type;"},
{"lineNum":"  991","line":"  using reference_type = typename Analysis::reference_type;"},
{"lineNum":"  992","line":""},
{"lineNum":"  993","line":"  OpenMPExec* m_instance;"},
{"lineNum":"  994","line":"  const FunctorType m_functor;"},
{"lineNum":"  995","line":"  const Policy m_policy;"},
{"lineNum":"  996","line":"  const ReducerType m_reducer;"},
{"lineNum":"  997","line":"  const pointer_type m_result_ptr;"},
{"lineNum":"  998","line":"  const int m_shmem_size;"},
{"lineNum":"  999","line":""},
{"lineNum":" 1000","line":"  template <class TagType>"},
{"lineNum":" 1001","line":"  inline static"},
{"lineNum":" 1002","line":"      typename std::enable_if<(std::is_same<TagType, void>::value)>::type"},
{"lineNum":" 1003","line":"      exec_team(const FunctorType& functor, HostThreadTeamData& data,"},
{"lineNum":" 1004","line":"                reference_type& update, const int league_rank_begin,"},
{"lineNum":" 1005","line":"                const int league_rank_end, const int league_size) {"},
{"lineNum":" 1006","line":"    for (int r = league_rank_begin; r < league_rank_end;) {"},
{"lineNum":" 1007","line":"      functor(Member(data, r, league_size), update);"},
{"lineNum":" 1008","line":""},
{"lineNum":" 1009","line":"      if (++r < league_rank_end) {"},
{"lineNum":" 1010","line":"        // Don\'t allow team members to lap one another"},
{"lineNum":" 1011","line":"        // so that they don\'t overwrite shared memory."},
{"lineNum":" 1012","line":"        if (data.team_rendezvous()) {"},
{"lineNum":" 1013","line":"          data.team_rendezvous_release();"},
{"lineNum":" 1014","line":"        }"},
{"lineNum":" 1015","line":"      }"},
{"lineNum":" 1016","line":"    }"},
{"lineNum":" 1017","line":"  }"},
{"lineNum":" 1018","line":""},
{"lineNum":" 1019","line":"  template <class TagType>"},
{"lineNum":" 1020","line":"  inline static"},
{"lineNum":" 1021","line":"      typename std::enable_if<(!std::is_same<TagType, void>::value)>::type"},
{"lineNum":" 1022","line":"      exec_team(const FunctorType& functor, HostThreadTeamData& data,"},
{"lineNum":" 1023","line":"                reference_type& update, const int league_rank_begin,"},
{"lineNum":" 1024","line":"                const int league_rank_end, const int league_size) {"},
{"lineNum":" 1025","line":"    const TagType t{};"},
{"lineNum":" 1026","line":""},
{"lineNum":" 1027","line":"    for (int r = league_rank_begin; r < league_rank_end;) {"},
{"lineNum":" 1028","line":"      functor(t, Member(data, r, league_size), update);"},
{"lineNum":" 1029","line":""},
{"lineNum":" 1030","line":"      if (++r < league_rank_end) {"},
{"lineNum":" 1031","line":"        // Don\'t allow team members to lap one another"},
{"lineNum":" 1032","line":"        // so that they don\'t overwrite shared memory."},
{"lineNum":" 1033","line":"        if (data.team_rendezvous()) {"},
{"lineNum":" 1034","line":"          data.team_rendezvous_release();"},
{"lineNum":" 1035","line":"        }"},
{"lineNum":" 1036","line":"      }"},
{"lineNum":" 1037","line":"    }"},
{"lineNum":" 1038","line":"  }"},
{"lineNum":" 1039","line":""},
{"lineNum":" 1040","line":" public:"},
{"lineNum":" 1041","line":"  inline void execute() const {"},
{"lineNum":" 1042","line":"    enum { is_dynamic = std::is_same<SchedTag, Kokkos::Dynamic>::value };"},
{"lineNum":" 1043","line":""},
{"lineNum":" 1044","line":"    if (m_policy.league_size() * m_policy.team_size() == 0) {"},
{"lineNum":" 1045","line":"      if (m_result_ptr) {"},
{"lineNum":" 1046","line":"        ValueInit::init(ReducerConditional::select(m_functor, m_reducer),"},
{"lineNum":" 1047","line":"                        m_result_ptr);"},
{"lineNum":" 1048","line":"        Kokkos::Impl::FunctorFinal<ReducerTypeFwd, WorkTagFwd>::final("},
{"lineNum":" 1049","line":"            ReducerConditional::select(m_functor, m_reducer), m_result_ptr);"},
{"lineNum":" 1050","line":"      }"},
{"lineNum":" 1051","line":"      return;"},
{"lineNum":" 1052","line":"    }"},
{"lineNum":" 1053","line":"    OpenMPExec::verify_is_master(\"Kokkos::OpenMP parallel_reduce\");"},
{"lineNum":" 1054","line":""},
{"lineNum":" 1055","line":"    const size_t pool_reduce_size ="},
{"lineNum":" 1056","line":"        Analysis::value_size(ReducerConditional::select(m_functor, m_reducer));"},
{"lineNum":" 1057","line":""},
{"lineNum":" 1058","line":"    const size_t team_reduce_size  = TEAM_REDUCE_SIZE * m_policy.team_size();"},
{"lineNum":" 1059","line":"    const size_t team_shared_size  = m_shmem_size + m_policy.scratch_size(1);"},
{"lineNum":" 1060","line":"    const size_t thread_local_size = 0;  // Never shrinks"},
{"lineNum":" 1061","line":""},
{"lineNum":" 1062","line":"    m_instance->resize_thread_data(pool_reduce_size, team_reduce_size,"},
{"lineNum":" 1063","line":"                                   team_shared_size, thread_local_size);"},
{"lineNum":" 1064","line":""},
{"lineNum":" 1065","line":"    const int pool_size = OpenMP::impl_thread_pool_size();"},
{"lineNum":" 1066","line":"#pragma omp parallel num_threads(pool_size)"},
{"lineNum":" 1067","line":"    {"},
{"lineNum":" 1068","line":"      HostThreadTeamData& data = *(m_instance->get_thread_data());"},
{"lineNum":" 1069","line":""},
{"lineNum":" 1070","line":"      const int active = data.organize_team(m_policy.team_size());"},
{"lineNum":" 1071","line":""},
{"lineNum":" 1072","line":"      if (active) {"},
{"lineNum":" 1073","line":"        data.set_work_partition("},
{"lineNum":" 1074","line":"            m_policy.league_size(),"},
{"lineNum":" 1075","line":"            (0 < m_policy.chunk_size() ? m_policy.chunk_size()"},
{"lineNum":" 1076","line":"                                       : m_policy.team_iter()));"},
{"lineNum":" 1077","line":"      }"},
{"lineNum":" 1078","line":""},
{"lineNum":" 1079","line":"      if (is_dynamic) {"},
{"lineNum":" 1080","line":"        // Must synchronize to make sure each team has set its"},
{"lineNum":" 1081","line":"        // partition before beginning the work stealing loop."},
{"lineNum":" 1082","line":"        if (data.pool_rendezvous()) data.pool_rendezvous_release();"},
{"lineNum":" 1083","line":"      }"},
{"lineNum":" 1084","line":""},
{"lineNum":" 1085","line":"      if (active) {"},
{"lineNum":" 1086","line":"        reference_type update ="},
{"lineNum":" 1087","line":"            ValueInit::init(ReducerConditional::select(m_functor, m_reducer),"},
{"lineNum":" 1088","line":"                            data.pool_reduce_local());"},
{"lineNum":" 1089","line":""},
{"lineNum":" 1090","line":"        std::pair<int64_t, int64_t> range(0, 0);"},
{"lineNum":" 1091","line":""},
{"lineNum":" 1092","line":"        do {"},
{"lineNum":" 1093","line":"          range = is_dynamic ? data.get_work_stealing_chunk()"},
{"lineNum":" 1094","line":"                             : data.get_work_partition();"},
{"lineNum":" 1095","line":""},
{"lineNum":" 1096","line":"          ParallelReduce::template exec_team<WorkTag>(m_functor, data, update,"},
{"lineNum":" 1097","line":"                                                      range.first, range.second,"},
{"lineNum":" 1098","line":"                                                      m_policy.league_size());"},
{"lineNum":" 1099","line":""},
{"lineNum":" 1100","line":"        } while (is_dynamic && 0 <= range.first);"},
{"lineNum":" 1101","line":"      } else {"},
{"lineNum":" 1102","line":"        ValueInit::init(ReducerConditional::select(m_functor, m_reducer),"},
{"lineNum":" 1103","line":"                        data.pool_reduce_local());"},
{"lineNum":" 1104","line":"      }"},
{"lineNum":" 1105","line":""},
{"lineNum":" 1106","line":"      data.disband_team();"},
{"lineNum":" 1107","line":""},
{"lineNum":" 1108","line":"      //  This thread has updated \'pool_reduce_local()\' with its"},
{"lineNum":" 1109","line":"      //  contributions to the reduction.  The parallel region is"},
{"lineNum":" 1110","line":"      //  about to terminate and the master thread will load and"},
{"lineNum":" 1111","line":"      //  reduce each \'pool_reduce_local()\' contribution."},
{"lineNum":" 1112","line":"      //  Must \'memory_fence()\' to guarantee that storing the update to"},
{"lineNum":" 1113","line":"      //  \'pool_reduce_local()\' will complete before this thread"},
{"lineNum":" 1114","line":"      //  exits the parallel region."},
{"lineNum":" 1115","line":""},
{"lineNum":" 1116","line":"      memory_fence();"},
{"lineNum":" 1117","line":"    }"},
{"lineNum":" 1118","line":""},
{"lineNum":" 1119","line":"    // Reduction:"},
{"lineNum":" 1120","line":""},
{"lineNum":" 1121","line":"    const pointer_type ptr ="},
{"lineNum":" 1122","line":"        pointer_type(m_instance->get_thread_data(0)->pool_reduce_local());"},
{"lineNum":" 1123","line":""},
{"lineNum":" 1124","line":"    for (int i = 1; i < pool_size; ++i) {"},
{"lineNum":" 1125","line":"      ValueJoin::join(ReducerConditional::select(m_functor, m_reducer), ptr,"},
{"lineNum":" 1126","line":"                      m_instance->get_thread_data(i)->pool_reduce_local());"},
{"lineNum":" 1127","line":"    }"},
{"lineNum":" 1128","line":""},
{"lineNum":" 1129","line":"    Kokkos::Impl::FunctorFinal<ReducerTypeFwd, WorkTagFwd>::final("},
{"lineNum":" 1130","line":"        ReducerConditional::select(m_functor, m_reducer), ptr);"},
{"lineNum":" 1131","line":""},
{"lineNum":" 1132","line":"    if (m_result_ptr) {"},
{"lineNum":" 1133","line":"      const int n = Analysis::value_count("},
{"lineNum":" 1134","line":"          ReducerConditional::select(m_functor, m_reducer));"},
{"lineNum":" 1135","line":""},
{"lineNum":" 1136","line":"      for (int j = 0; j < n; ++j) {"},
{"lineNum":" 1137","line":"        m_result_ptr[j] = ptr[j];"},
{"lineNum":" 1138","line":"      }"},
{"lineNum":" 1139","line":"    }"},
{"lineNum":" 1140","line":"  }"},
{"lineNum":" 1141","line":""},
{"lineNum":" 1142","line":"  //----------------------------------------"},
{"lineNum":" 1143","line":""},
{"lineNum":" 1144","line":"  template <class ViewType>"},
{"lineNum":" 1145","line":"  inline ParallelReduce("},
{"lineNum":" 1146","line":"      const FunctorType& arg_functor, const Policy& arg_policy,"},
{"lineNum":" 1147","line":"      const ViewType& arg_result,"},
{"lineNum":" 1148","line":"      typename std::enable_if<Kokkos::is_view<ViewType>::value &&"},
{"lineNum":" 1149","line":"                                  !Kokkos::is_reducer_type<ReducerType>::value,"},
{"lineNum":" 1150","line":"                              void*>::type = nullptr)"},
{"lineNum":" 1151","line":"      : m_instance(t_openmp_instance),"},
{"lineNum":" 1152","line":"        m_functor(arg_functor),"},
{"lineNum":" 1153","line":"        m_policy(arg_policy),"},
{"lineNum":" 1154","line":"        m_reducer(InvalidType()),"},
{"lineNum":" 1155","line":"        m_result_ptr(arg_result.data()),"},
{"lineNum":" 1156","line":"        m_shmem_size(arg_policy.scratch_size(0) + arg_policy.scratch_size(1) +"},
{"lineNum":" 1157","line":"                     FunctorTeamShmemSize<FunctorType>::value("},
{"lineNum":" 1158","line":"                         arg_functor, arg_policy.team_size())) {}"},
{"lineNum":" 1159","line":""},
{"lineNum":" 1160","line":"  inline ParallelReduce(const FunctorType& arg_functor, Policy arg_policy,"},
{"lineNum":" 1161","line":"                        const ReducerType& reducer)"},
{"lineNum":" 1162","line":"      : m_instance(t_openmp_instance),"},
{"lineNum":" 1163","line":"        m_functor(arg_functor),"},
{"lineNum":" 1164","line":"        m_policy(arg_policy),"},
{"lineNum":" 1165","line":"        m_reducer(reducer),"},
{"lineNum":" 1166","line":"        m_result_ptr(reducer.view().data()),"},
{"lineNum":" 1167","line":"        m_shmem_size(arg_policy.scratch_size(0) + arg_policy.scratch_size(1) +"},
{"lineNum":" 1168","line":"                     FunctorTeamShmemSize<FunctorType>::value("},
{"lineNum":" 1169","line":"                         arg_functor, arg_policy.team_size())) {"},
{"lineNum":" 1170","line":"    /*static_assert( std::is_same< typename ViewType::memory_space"},
{"lineNum":" 1171","line":"                            , Kokkos::HostSpace >::value"},
{"lineNum":" 1172","line":"    , \"Reduction result on Kokkos::OpenMP must be a Kokkos::View in HostSpace\""},
{"lineNum":" 1173","line":"    );*/"},
{"lineNum":" 1174","line":"  }"},
{"lineNum":" 1175","line":"};"},
{"lineNum":" 1176","line":""},
{"lineNum":" 1177","line":"}  // namespace Impl"},
{"lineNum":" 1178","line":"}  // namespace Kokkos"},
{"lineNum":" 1179","line":""},
{"lineNum":" 1180","line":"//----------------------------------------------------------------------------"},
{"lineNum":" 1181","line":"//----------------------------------------------------------------------------"},
{"lineNum":" 1182","line":""},
{"lineNum":" 1183","line":"#endif"},
{"lineNum":" 1184","line":"#endif /* KOKKOS_OPENMP_PARALLEL_HPP */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 86, "covered" : 0,};
var merged_data = [];
