var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2006-2010 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_MATRIX_H"},
{"lineNum":"   12","line":"#define EIGEN_MATRIX_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":"template<typename Scalar_, int Rows_, int Cols_, int Options_, int MaxRows_, int MaxCols_>"},
{"lineNum":"   20","line":"struct traits<Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_> >"},
{"lineNum":"   21","line":"{"},
{"lineNum":"   22","line":"private:"},
{"lineNum":"   23","line":"  enum { size = internal::size_at_compile_time<Rows_,Cols_>::ret };"},
{"lineNum":"   24","line":"  typedef typename find_best_packet<Scalar_,size>::type PacketScalar;"},
{"lineNum":"   25","line":"  enum {"},
{"lineNum":"   26","line":"      row_major_bit = Options_&RowMajor ? RowMajorBit : 0,"},
{"lineNum":"   27","line":"      is_dynamic_size_storage = MaxRows_==Dynamic || MaxCols_==Dynamic,"},
{"lineNum":"   28","line":"      max_size = is_dynamic_size_storage ? Dynamic : MaxRows_*MaxCols_,"},
{"lineNum":"   29","line":"      default_alignment = compute_default_alignment<Scalar_,max_size>::value,"},
{"lineNum":"   30","line":"      actual_alignment = ((Options_&DontAlign)==0) ? default_alignment : 0,"},
{"lineNum":"   31","line":"      required_alignment = unpacket_traits<PacketScalar>::alignment,"},
{"lineNum":"   32","line":"      packet_access_bit = (packet_traits<Scalar_>::Vectorizable && (EIGEN_UNALIGNED_VECTORIZE || (actual_alignment>=required_alignment))) ? PacketAccessBit : 0"},
{"lineNum":"   33","line":"    };"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"public:"},
{"lineNum":"   36","line":"  typedef Scalar_ Scalar;"},
{"lineNum":"   37","line":"  typedef Dense StorageKind;"},
{"lineNum":"   38","line":"  typedef Eigen::Index StorageIndex;"},
{"lineNum":"   39","line":"  typedef MatrixXpr XprKind;"},
{"lineNum":"   40","line":"  enum {"},
{"lineNum":"   41","line":"    RowsAtCompileTime = Rows_,"},
{"lineNum":"   42","line":"    ColsAtCompileTime = Cols_,"},
{"lineNum":"   43","line":"    MaxRowsAtCompileTime = MaxRows_,"},
{"lineNum":"   44","line":"    MaxColsAtCompileTime = MaxCols_,"},
{"lineNum":"   45","line":"    Flags = compute_matrix_flags<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_>::ret,"},
{"lineNum":"   46","line":"    Options = Options_,"},
{"lineNum":"   47","line":"    InnerStrideAtCompileTime = 1,"},
{"lineNum":"   48","line":"    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime,"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"    // FIXME, the following flag in only used to define NeedsToAlign in PlainObjectBase"},
{"lineNum":"   51","line":"    EvaluatorFlags = LinearAccessBit | DirectAccessBit | packet_access_bit | row_major_bit,"},
{"lineNum":"   52","line":"    Alignment = actual_alignment"},
{"lineNum":"   53","line":"  };"},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":"}"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"/** \\class Matrix"},
{"lineNum":"   58","line":"  * \\ingroup Core_Module"},
{"lineNum":"   59","line":"  *"},
{"lineNum":"   60","line":"  * \\brief The matrix class, also used for vectors and row-vectors"},
{"lineNum":"   61","line":"  *"},
{"lineNum":"   62","line":"  * The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen."},
{"lineNum":"   63","line":"  * Vectors are matrices with one column, and row-vectors are matrices with one row."},
{"lineNum":"   64","line":"  *"},
{"lineNum":"   65","line":"  * The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\")."},
{"lineNum":"   66","line":"  *"},
{"lineNum":"   67","line":"  * The first three template parameters are required:"},
{"lineNum":"   68","line":"  * \\tparam Scalar_ Numeric type, e.g. float, double, int or std::complex<float>."},
{"lineNum":"   69","line":"  *                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\")."},
{"lineNum":"   70","line":"  * \\tparam Rows_ Number of rows, or \\b Dynamic"},
{"lineNum":"   71","line":"  * \\tparam Cols_ Number of columns, or \\b Dynamic"},
{"lineNum":"   72","line":"  *"},
{"lineNum":"   73","line":"  * The remaining template parameters are optional -- in most cases you don\'t have to worry about them."},
{"lineNum":"   74","line":"  * \\tparam Options_ A combination of either \\b #RowMajor or \\b #ColMajor, and of either"},
{"lineNum":"   75","line":"  *                 \\b #AutoAlign or \\b #DontAlign."},
{"lineNum":"   76","line":"  *                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required"},
{"lineNum":"   77","line":"  *                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren\'t a multiple of the packet size."},
{"lineNum":"   78","line":"  * \\tparam MaxRows_ Maximum number of rows. Defaults to \\a Rows_ (\\ref maxrows \"note\")."},
{"lineNum":"   79","line":"  * \\tparam MaxCols_ Maximum number of columns. Defaults to \\a Cols_ (\\ref maxrows \"note\")."},
{"lineNum":"   80","line":"  *"},
{"lineNum":"   81","line":"  * Eigen provides a number of typedefs covering the usual cases. Here are some examples:"},
{"lineNum":"   82","line":"  *"},
{"lineNum":"   83","line":"  * \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)"},
{"lineNum":"   84","line":"  * \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)"},
{"lineNum":"   85","line":"  * \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)"},
{"lineNum":"   86","line":"  *"},
{"lineNum":"   87","line":"  * \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)"},
{"lineNum":"   88","line":"  * \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)"},
{"lineNum":"   89","line":"  *"},
{"lineNum":"   90","line":"  * \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)"},
{"lineNum":"   91","line":"  * \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)"},
{"lineNum":"   92","line":"  *"},
{"lineNum":"   93","line":"  * See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs."},
{"lineNum":"   94","line":"  *"},
{"lineNum":"   95","line":"  * You can access elements of vectors and matrices using normal subscripting:"},
{"lineNum":"   96","line":"  *"},
{"lineNum":"   97","line":"  * \\code"},
{"lineNum":"   98","line":"  * Eigen::VectorXd v(10);"},
{"lineNum":"   99","line":"  * v[0] = 0.1;"},
{"lineNum":"  100","line":"  * v[1] = 0.2;"},
{"lineNum":"  101","line":"  * v(0) = 0.3;"},
{"lineNum":"  102","line":"  * v(1) = 0.4;"},
{"lineNum":"  103","line":"  *"},
{"lineNum":"  104","line":"  * Eigen::MatrixXi m(10, 10);"},
{"lineNum":"  105","line":"  * m(0, 1) = 1;"},
{"lineNum":"  106","line":"  * m(0, 2) = 2;"},
{"lineNum":"  107","line":"  * m(0, 3) = 3;"},
{"lineNum":"  108","line":"  * \\endcode"},
{"lineNum":"  109","line":"  *"},
{"lineNum":"  110","line":"  * This class can be extended with the help of the plugin mechanism described on the page"},
{"lineNum":"  111","line":"  * \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN."},
{"lineNum":"  112","line":"  *"},
{"lineNum":"  113","line":"  * <i><b>Some notes:</b></i>"},
{"lineNum":"  114","line":"  *"},
{"lineNum":"  115","line":"  * <dl>"},
{"lineNum":"  116","line":"  * <dt><b>\\anchor dense Dense versus sparse:</b></dt>"},
{"lineNum":"  117","line":"  * <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module."},
{"lineNum":"  118","line":"  *"},
{"lineNum":"  119","line":"  * Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array."},
{"lineNum":"  120","line":"  * This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>"},
{"lineNum":"  121","line":"  *"},
{"lineNum":"  122","line":"  * <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>"},
{"lineNum":"  123","line":"  * <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array"},
{"lineNum":"  124","line":"  * of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up"},
{"lineNum":"  125","line":"  * to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time."},
{"lineNum":"  126","line":"  *"},
{"lineNum":"  127","line":"  * Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime"},
{"lineNum":"  128","line":"  * variables, and the array of coefficients is allocated dynamically on the heap."},
{"lineNum":"  129","line":"  *"},
{"lineNum":"  130","line":"  * Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map."},
{"lineNum":"  131","line":"  * If you want this behavior, see the Sparse module.</dd>"},
{"lineNum":"  132","line":"  *"},
{"lineNum":"  133","line":"  * <dt><b>\\anchor maxrows MaxRows_ and MaxCols_:</b></dt>"},
{"lineNum":"  134","line":"  * <dd>In most cases, one just leaves these parameters to the default values."},
{"lineNum":"  135","line":"  * These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases"},
{"lineNum":"  136","line":"  * when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot"},
{"lineNum":"  137","line":"  * exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case MaxRows_ and MaxCols_"},
{"lineNum":"  138","line":"  * are the dimensions of the original matrix, while Rows_ and Cols_ are Dynamic.</dd>"},
{"lineNum":"  139","line":"  * </dl>"},
{"lineNum":"  140","line":"  *"},
{"lineNum":"  141","line":"  * <i><b>ABI and storage layout</b></i>"},
{"lineNum":"  142","line":"  *"},
{"lineNum":"  143","line":"  * The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3."},
{"lineNum":"  144","line":"  * <table  class=\"manual\">"},
{"lineNum":"  145","line":"  * <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>"},
{"lineNum":"  146","line":"  * <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code"},
{"lineNum":"  147","line":"  * struct {"},
{"lineNum":"  148","line":"  *   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0"},
{"lineNum":"  149","line":"  *   Eigen::Index rows, cols;"},
{"lineNum":"  150","line":"  *  };"},
{"lineNum":"  151","line":"  * \\endcode</td></tr>"},
{"lineNum":"  152","line":"  * <tr class=\"alt\"><td>\\code"},
{"lineNum":"  153","line":"  * Matrix<T,Dynamic,1>"},
{"lineNum":"  154","line":"  * Matrix<T,1,Dynamic> \\endcode</td><td>\\code"},
{"lineNum":"  155","line":"  * struct {"},
{"lineNum":"  156","line":"  *   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0"},
{"lineNum":"  157","line":"  *   Eigen::Index size;"},
{"lineNum":"  158","line":"  *  };"},
{"lineNum":"  159","line":"  * \\endcode</td></tr>"},
{"lineNum":"  160","line":"  * <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code"},
{"lineNum":"  161","line":"  * struct {"},
{"lineNum":"  162","line":"  *   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0"},
{"lineNum":"  163","line":"  *  };"},
{"lineNum":"  164","line":"  * \\endcode</td></tr>"},
{"lineNum":"  165","line":"  * <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code"},
{"lineNum":"  166","line":"  * struct {"},
{"lineNum":"  167","line":"  *   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0"},
{"lineNum":"  168","line":"  *   Eigen::Index rows, cols;"},
{"lineNum":"  169","line":"  *  };"},
{"lineNum":"  170","line":"  * \\endcode</td></tr>"},
{"lineNum":"  171","line":"  * </table>"},
{"lineNum":"  172","line":"  * Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two"},
{"lineNum":"  173","line":"  * smaller to EIGEN_MAX_STATIC_ALIGN_BYTES."},
{"lineNum":"  174","line":"  *"},
{"lineNum":"  175","line":"  * \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,"},
{"lineNum":"  176","line":"  * \\ref TopicStorageOrders"},
{"lineNum":"  177","line":"  */"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"template<typename Scalar_, int Rows_, int Cols_, int Options_, int MaxRows_, int MaxCols_>"},
{"lineNum":"  180","line":"class Matrix"},
{"lineNum":"  181","line":"  : public PlainObjectBase<Matrix<Scalar_, Rows_, Cols_, Options_, MaxRows_, MaxCols_> >"},
{"lineNum":"  182","line":"{"},
{"lineNum":"  183","line":"  public:"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"    /** \\brief Base class typedef."},
{"lineNum":"  186","line":"      * \\sa PlainObjectBase"},
{"lineNum":"  187","line":"      */"},
{"lineNum":"  188","line":"    typedef PlainObjectBase<Matrix> Base;"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"    enum { Options = Options_ };"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"    EIGEN_DENSE_PUBLIC_INTERFACE(Matrix)"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"    typedef typename Base::PlainObject PlainObject;"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"    using Base::base;"},
{"lineNum":"  197","line":"    using Base::coeffRef;"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"    /**"},
{"lineNum":"  200","line":"      * \\brief Assigns matrices to each other."},
{"lineNum":"  201","line":"      *"},
{"lineNum":"  202","line":"      * \\note This is a special case of the templated operator=. Its purpose is"},
{"lineNum":"  203","line":"      * to prevent a default operator= from hiding the templated operator=."},
{"lineNum":"  204","line":"      *"},
{"lineNum":"  205","line":"      * \\callgraph"},
{"lineNum":"  206","line":"      */"},
{"lineNum":"  207","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  208","line":"    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)"},
{"lineNum":"  209","line":"    {"},
{"lineNum":"  210","line":"      return Base::_set(other);"},
{"lineNum":"  211","line":"    }"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    /** \\internal"},
{"lineNum":"  214","line":"      * \\brief Copies the value of the expression \\a other into \\c *this with automatic resizing."},
{"lineNum":"  215","line":"      *"},
{"lineNum":"  216","line":"      * *this might be resized to match the dimensions of \\a other. If *this was a null matrix (not already initialized),"},
{"lineNum":"  217","line":"      * it will be initialized."},
{"lineNum":"  218","line":"      *"},
{"lineNum":"  219","line":"      * Note that copying a row-vector into a vector (and conversely) is allowed."},
{"lineNum":"  220","line":"      * The resizing, if any, is then done in the appropriate way so that row-vectors"},
{"lineNum":"  221","line":"      * remain row-vectors and vectors remain vectors."},
{"lineNum":"  222","line":"      */"},
{"lineNum":"  223","line":"    template<typename OtherDerived>"},
{"lineNum":"  224","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  225","line":"    EIGEN_STRONG_INLINE Matrix& operator=(const DenseBase<OtherDerived>& other)"},
{"lineNum":"  226","line":"    {"},
{"lineNum":"  227","line":"      return Base::_set(other);"},
{"lineNum":"  228","line":"    }"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    /* Here, doxygen failed to copy the brief information when using \\copydoc */"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"    /**"},
{"lineNum":"  233","line":"      * \\brief Copies the generic expression \\a other into *this."},
{"lineNum":"  234","line":"      * \\copydetails DenseBase::operator=(const EigenBase<OtherDerived> &other)"},
{"lineNum":"  235","line":"      */"},
{"lineNum":"  236","line":"    template<typename OtherDerived>"},
{"lineNum":"  237","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  238","line":"    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)"},
{"lineNum":"  239","line":"    {"},
{"lineNum":"  240","line":"      return Base::operator=(other);"},
{"lineNum":"  241","line":"    }"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"    template<typename OtherDerived>"},
{"lineNum":"  244","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  245","line":"    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)"},
{"lineNum":"  246","line":"    {"},
{"lineNum":"  247","line":"      return Base::operator=(func);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  248","line":"    }"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"    /** \\brief Default constructor."},
{"lineNum":"  251","line":"      *"},
{"lineNum":"  252","line":"      * For fixed-size matrices, does nothing."},
{"lineNum":"  253","line":"      *"},
{"lineNum":"  254","line":"      * For dynamic-size matrices, creates an empty matrix of size 0. Does not allocate any array. Such a matrix"},
{"lineNum":"  255","line":"      * is called a null matrix. This constructor is the unique way to create null matrices: resizing"},
{"lineNum":"  256","line":"      * a matrix to 0 is not supported."},
{"lineNum":"  257","line":"      *"},
{"lineNum":"  258","line":"      * \\sa resize(Index,Index)"},
{"lineNum":"  259","line":"      */"},
{"lineNum":"  260","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  261","line":"    Matrix() : Base()"},
{"lineNum":"  262","line":"    {"},
{"lineNum":"  263","line":"      EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED"},
{"lineNum":"  264","line":"    }"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"    // FIXME is it still needed"},
{"lineNum":"  267","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  268","line":"    explicit Matrix(internal::constructor_without_unaligned_array_assert)"},
{"lineNum":"  269","line":"      : Base(internal::constructor_without_unaligned_array_assert())"},
{"lineNum":"  270","line":"    { EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED }"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"#if EIGEN_HAS_RVALUE_REFERENCES"},
{"lineNum":"  273","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  274","line":"    Matrix(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_constructible<Scalar>::value)"},
{"lineNum":"  275","line":"      : Base(std::move(other)) {}"},
{"lineNum":"  276","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  277","line":"    Matrix& operator=(Matrix&& other) EIGEN_NOEXCEPT_IF(std::is_nothrow_move_assignable<Scalar>::value)"},
{"lineNum":"  278","line":"    {"},
{"lineNum":"  279","line":"      Base::operator=(std::move(other));"},
{"lineNum":"  280","line":"      return *this;"},
{"lineNum":"  281","line":"    }"},
{"lineNum":"  282","line":"#endif"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"#if EIGEN_HAS_CXX11"},
{"lineNum":"  285","line":"    /** \\copydoc PlainObjectBase(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&... args)"},
{"lineNum":"  286","line":"     *"},
{"lineNum":"  287","line":"     * Example: \\include Matrix_variadic_ctor_cxx11.cpp"},
{"lineNum":"  288","line":"     * Output: \\verbinclude Matrix_variadic_ctor_cxx11.out"},
{"lineNum":"  289","line":"     *"},
{"lineNum":"  290","line":"     * \\sa Matrix(const std::initializer_list<std::initializer_list<Scalar>>&)"},
{"lineNum":"  291","line":"     */"},
{"lineNum":"  292","line":"    template <typename... ArgTypes>"},
{"lineNum":"  293","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  294","line":"    Matrix(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const ArgTypes&... args)"},
{"lineNum":"  295","line":"      : Base(a0, a1, a2, a3, args...) {}"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"    /** \\brief Constructs a Matrix and initializes it from the coefficients given as initializer-lists grouped by row. \\cpp11"},
{"lineNum":"  298","line":"      *"},
{"lineNum":"  299","line":"      * In the general case, the constructor takes a list of rows, each row being represented as a list of coefficients:"},
{"lineNum":"  300","line":"      *"},
{"lineNum":"  301","line":"      * Example: \\include Matrix_initializer_list_23_cxx11.cpp"},
{"lineNum":"  302","line":"      * Output: \\verbinclude Matrix_initializer_list_23_cxx11.out"},
{"lineNum":"  303","line":"      *"},
{"lineNum":"  304","line":"      * Each of the inner initializer lists must contain the exact same number of elements, otherwise an assertion is triggered."},
{"lineNum":"  305","line":"      *"},
{"lineNum":"  306","line":"      * In the case of a compile-time column vector, implicit transposition from a single row is allowed."},
{"lineNum":"  307","line":"      * Therefore <code>VectorXd{{1,2,3,4,5}}</code> is legal and the more verbose syntax"},
{"lineNum":"  308","line":"      * <code>RowVectorXd{{1},{2},{3},{4},{5}}</code> can be avoided:"},
{"lineNum":"  309","line":"      *"},
{"lineNum":"  310","line":"      * Example: \\include Matrix_initializer_list_vector_cxx11.cpp"},
{"lineNum":"  311","line":"      * Output: \\verbinclude Matrix_initializer_list_vector_cxx11.out"},
{"lineNum":"  312","line":"      *"},
{"lineNum":"  313","line":"      * In the case of fixed-sized matrices, the initializer list sizes must exactly match the matrix sizes,"},
{"lineNum":"  314","line":"      * and implicit transposition is allowed for compile-time vectors only."},
{"lineNum":"  315","line":"      *"},
{"lineNum":"  316","line":"      * \\sa Matrix(const Scalar& a0, const Scalar& a1, const Scalar& a2,  const Scalar& a3, const ArgTypes&... args)"},
{"lineNum":"  317","line":"      */"},
{"lineNum":"  318","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  319","line":"    explicit EIGEN_STRONG_INLINE Matrix(const std::initializer_list<std::initializer_list<Scalar>>& list) : Base(list) {}"},
{"lineNum":"  320","line":"#endif // end EIGEN_HAS_CXX11"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"#ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"    // This constructor is for both 1x1 matrices and dynamic vectors"},
{"lineNum":"  325","line":"    template<typename T>"},
{"lineNum":"  326","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  327","line":"    explicit Matrix(const T& x)"},
{"lineNum":"  328","line":"    {"},
{"lineNum":"  329","line":"      Base::template _init1<T>(x);"},
{"lineNum":"  330","line":"    }"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"    template<typename T0, typename T1>"},
{"lineNum":"  333","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  334","line":"    Matrix(const T0& x, const T1& y)"},
{"lineNum":"  335","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  336","line":"      Base::template _init2<T0,T1>(x, y);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  337","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"#else"},
{"lineNum":"  341","line":"    /** \\brief Constructs a fixed-sized matrix initialized with coefficients starting at \\a data */"},
{"lineNum":"  342","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  343","line":"    explicit Matrix(const Scalar *data);"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"    /** \\brief Constructs a vector or row-vector with given dimension. \\only_for_vectors"},
{"lineNum":"  346","line":"      *"},
{"lineNum":"  347","line":"      * This is useful for dynamic-size vectors. For fixed-size vectors,"},
{"lineNum":"  348","line":"      * it is redundant to pass these parameters, so one should use the default constructor"},
{"lineNum":"  349","line":"      * Matrix() instead."},
{"lineNum":"  350","line":"      *"},
{"lineNum":"  351","line":"      * \\warning This constructor is disabled for fixed-size \\c 1x1 matrices. For instance,"},
{"lineNum":"  352","line":"      * calling Matrix<double,1,1>(1) will call the initialization constructor: Matrix(const Scalar&)."},
{"lineNum":"  353","line":"      * For fixed-size \\c 1x1 matrices it is therefore recommended to use the default"},
{"lineNum":"  354","line":"      * constructor Matrix() instead, especially when using one of the non standard"},
{"lineNum":"  355","line":"      * \\c EIGEN_INITIALIZE_MATRICES_BY_{ZERO,\\c NAN} macros (see \\ref TopicPreprocessorDirectives)."},
{"lineNum":"  356","line":"      */"},
{"lineNum":"  357","line":"    EIGEN_STRONG_INLINE explicit Matrix(Index dim);"},
{"lineNum":"  358","line":"    /** \\brief Constructs an initialized 1x1 matrix with the given coefficient"},
{"lineNum":"  359","line":"      * \\sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...) */"},
{"lineNum":"  360","line":"    Matrix(const Scalar& x);"},
{"lineNum":"  361","line":"    /** \\brief Constructs an uninitialized matrix with \\a rows rows and \\a cols columns."},
{"lineNum":"  362","line":"      *"},
{"lineNum":"  363","line":"      * This is useful for dynamic-size matrices. For fixed-size matrices,"},
{"lineNum":"  364","line":"      * it is redundant to pass these parameters, so one should use the default constructor"},
{"lineNum":"  365","line":"      * Matrix() instead."},
{"lineNum":"  366","line":"      *"},
{"lineNum":"  367","line":"      * \\warning This constructor is disabled for fixed-size \\c 1x2 and \\c 2x1 vectors. For instance,"},
{"lineNum":"  368","line":"      * calling Matrix2f(2,1) will call the initialization constructor: Matrix(const Scalar& x, const Scalar& y)."},
{"lineNum":"  369","line":"      * For fixed-size \\c 1x2 or \\c 2x1 vectors it is therefore recommended to use the default"},
{"lineNum":"  370","line":"      * constructor Matrix() instead, especially when using one of the non standard"},
{"lineNum":"  371","line":"      * \\c EIGEN_INITIALIZE_MATRICES_BY_{ZERO,\\c NAN} macros (see \\ref TopicPreprocessorDirectives)."},
{"lineNum":"  372","line":"      */"},
{"lineNum":"  373","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  374","line":"    Matrix(Index rows, Index cols);"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"    /** \\brief Constructs an initialized 2D vector with given coefficients"},
{"lineNum":"  377","line":"      * \\sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...) */"},
{"lineNum":"  378","line":"    Matrix(const Scalar& x, const Scalar& y);"},
{"lineNum":"  379","line":"    #endif  // end EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"    /** \\brief Constructs an initialized 3D vector with given coefficients"},
{"lineNum":"  382","line":"      * \\sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...)"},
{"lineNum":"  383","line":"      */"},
{"lineNum":"  384","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  385","line":"    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)"},
{"lineNum":"  386","line":"    {"},
{"lineNum":"  387","line":"      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 3)"},
{"lineNum":"  388","line":"      m_storage.data()[0] = x;"},
{"lineNum":"  389","line":"      m_storage.data()[1] = y;"},
{"lineNum":"  390","line":"      m_storage.data()[2] = z;"},
{"lineNum":"  391","line":"    }"},
{"lineNum":"  392","line":"    /** \\brief Constructs an initialized 4D vector with given coefficients"},
{"lineNum":"  393","line":"      * \\sa Matrix(const Scalar&, const Scalar&, const Scalar&,  const Scalar&, const ArgTypes&...)"},
{"lineNum":"  394","line":"      */"},
{"lineNum":"  395","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  396","line":"    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)"},
{"lineNum":"  397","line":"    {"},
{"lineNum":"  398","line":"      EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(Matrix, 4)"},
{"lineNum":"  399","line":"      m_storage.data()[0] = x;"},
{"lineNum":"  400","line":"      m_storage.data()[1] = y;"},
{"lineNum":"  401","line":"      m_storage.data()[2] = z;"},
{"lineNum":"  402","line":"      m_storage.data()[3] = w;"},
{"lineNum":"  403","line":"    }"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":""},
{"lineNum":"  406","line":"    /** \\brief Copy constructor */"},
{"lineNum":"  407","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  408","line":"    EIGEN_STRONG_INLINE Matrix(const Matrix& other) : Base(other)"},
{"lineNum":"  409","line":"    { }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"    /** \\brief Copy constructor for generic expressions."},
{"lineNum":"  412","line":"      * \\sa MatrixBase::operator=(const EigenBase<OtherDerived>&)"},
{"lineNum":"  413","line":"      */"},
{"lineNum":"  414","line":"    template<typename OtherDerived>"},
{"lineNum":"  415","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  416","line":"    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)"},
{"lineNum":"  417","line":"      : Base(other.derived())","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  418","line":"    { }"},
{"lineNum":"  419","line":""},
{"lineNum":"  420","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  421","line":"    inline Index innerStride() const EIGEN_NOEXCEPT { return 1; }"},
{"lineNum":"  422","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  423","line":"    inline Index outerStride() const EIGEN_NOEXCEPT { return this->innerSize(); }"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"    /////////// Geometry module ///////////"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"    template<typename OtherDerived>"},
{"lineNum":"  428","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  429","line":"    explicit Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r);"},
{"lineNum":"  430","line":"    template<typename OtherDerived>"},
{"lineNum":"  431","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  432","line":"    Matrix& operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r);"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"    // allow to extend Matrix outside Eigen"},
{"lineNum":"  435","line":"    #ifdef EIGEN_MATRIX_PLUGIN"},
{"lineNum":"  436","line":"    #include EIGEN_MATRIX_PLUGIN"},
{"lineNum":"  437","line":"    #endif"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"  protected:"},
{"lineNum":"  440","line":"    template <typename Derived, typename OtherDerived, bool IsVector>"},
{"lineNum":"  441","line":"    friend struct internal::conservative_resize_like_impl;"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"    using Base::m_storage;"},
{"lineNum":"  444","line":"};"},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":"/** \\defgroup matrixtypedefs Global matrix typedefs"},
{"lineNum":"  447","line":"  *"},
{"lineNum":"  448","line":"  * \\ingroup Core_Module"},
{"lineNum":"  449","line":"  *"},
{"lineNum":"  450","line":"  * %Eigen defines several typedef shortcuts for most common matrix and vector types."},
{"lineNum":"  451","line":"  *"},
{"lineNum":"  452","line":"  * The general patterns are the following:"},
{"lineNum":"  453","line":"  *"},
{"lineNum":"  454","line":"  * \\c MatrixSizeType where \\c Size can be \\c 2,\\c 3,\\c 4 for fixed size square matrices or \\c X for dynamic size,"},
{"lineNum":"  455","line":"  * and where \\c Type can be \\c i for integer, \\c f for float, \\c d for double, \\c cf for complex float, \\c cd"},
{"lineNum":"  456","line":"  * for complex double."},
{"lineNum":"  457","line":"  *"},
{"lineNum":"  458","line":"  * For example, \\c Matrix3d is a fixed-size 3x3 matrix type of doubles, and \\c MatrixXf is a dynamic-size matrix of floats."},
{"lineNum":"  459","line":"  *"},
{"lineNum":"  460","line":"  * There are also \\c VectorSizeType and \\c RowVectorSizeType which are self-explanatory. For example, \\c Vector4cf is"},
{"lineNum":"  461","line":"  * a fixed-size vector of 4 complex floats."},
{"lineNum":"  462","line":"  *"},
{"lineNum":"  463","line":"  * With \\cpp11, template alias are also defined for common sizes."},
{"lineNum":"  464","line":"  * They follow the same pattern as above except that the scalar type suffix is replaced by a"},
{"lineNum":"  465","line":"  * template parameter, i.e.:"},
{"lineNum":"  466","line":"  *   - `MatrixSize<Type>` where `Size` can be \\c 2,\\c 3,\\c 4 for fixed size square matrices or \\c X for dynamic size."},
{"lineNum":"  467","line":"  *   - `MatrixXSize<Type>` and `MatrixSizeX<Type>` where `Size` can be \\c 2,\\c 3,\\c 4 for hybrid dynamic/fixed matrices."},
{"lineNum":"  468","line":"  *   - `VectorSize<Type>` and `RowVectorSize<Type>` for column and row vectors."},
{"lineNum":"  469","line":"  *"},
{"lineNum":"  470","line":"  * With \\cpp11, you can also use fully generic column and row vector types: `Vector<Type,Size>` and `RowVector<Type,Size>`."},
{"lineNum":"  471","line":"  *"},
{"lineNum":"  472","line":"  * \\sa class Matrix"},
{"lineNum":"  473","line":"  */"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"#define EIGEN_MAKE_TYPEDEFS(Type, TypeSuffix, Size, SizeSuffix)   \\"},
{"lineNum":"  476","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  477","line":"typedef Matrix<Type, Size, Size> Matrix##SizeSuffix##TypeSuffix;  \\"},
{"lineNum":"  478","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  479","line":"typedef Matrix<Type, Size, 1>    Vector##SizeSuffix##TypeSuffix;  \\"},
{"lineNum":"  480","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  481","line":"typedef Matrix<Type, 1, Size>    RowVector##SizeSuffix##TypeSuffix;"},
{"lineNum":"  482","line":""},
{"lineNum":"  483","line":"#define EIGEN_MAKE_FIXED_TYPEDEFS(Type, TypeSuffix, Size)         \\"},
{"lineNum":"  484","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  485","line":"typedef Matrix<Type, Size, Dynamic> Matrix##Size##X##TypeSuffix;  \\"},
{"lineNum":"  486","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  487","line":"typedef Matrix<Type, Dynamic, Size> Matrix##X##Size##TypeSuffix;"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"#define EIGEN_MAKE_TYPEDEFS_ALL_SIZES(Type, TypeSuffix) \\"},
{"lineNum":"  490","line":"EIGEN_MAKE_TYPEDEFS(Type, TypeSuffix, 2, 2) \\"},
{"lineNum":"  491","line":"EIGEN_MAKE_TYPEDEFS(Type, TypeSuffix, 3, 3) \\"},
{"lineNum":"  492","line":"EIGEN_MAKE_TYPEDEFS(Type, TypeSuffix, 4, 4) \\"},
{"lineNum":"  493","line":"EIGEN_MAKE_TYPEDEFS(Type, TypeSuffix, Dynamic, X) \\"},
{"lineNum":"  494","line":"EIGEN_MAKE_FIXED_TYPEDEFS(Type, TypeSuffix, 2) \\"},
{"lineNum":"  495","line":"EIGEN_MAKE_FIXED_TYPEDEFS(Type, TypeSuffix, 3) \\"},
{"lineNum":"  496","line":"EIGEN_MAKE_FIXED_TYPEDEFS(Type, TypeSuffix, 4)"},
{"lineNum":"  497","line":""},
{"lineNum":"  498","line":"EIGEN_MAKE_TYPEDEFS_ALL_SIZES(int,                  i)"},
{"lineNum":"  499","line":"EIGEN_MAKE_TYPEDEFS_ALL_SIZES(float,                f)"},
{"lineNum":"  500","line":"EIGEN_MAKE_TYPEDEFS_ALL_SIZES(double,               d)"},
{"lineNum":"  501","line":"EIGEN_MAKE_TYPEDEFS_ALL_SIZES(std::complex<float>,  cf)"},
{"lineNum":"  502","line":"EIGEN_MAKE_TYPEDEFS_ALL_SIZES(std::complex<double>, cd)"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"#undef EIGEN_MAKE_TYPEDEFS_ALL_SIZES"},
{"lineNum":"  505","line":"#undef EIGEN_MAKE_TYPEDEFS"},
{"lineNum":"  506","line":"#undef EIGEN_MAKE_FIXED_TYPEDEFS"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"#if EIGEN_HAS_CXX11"},
{"lineNum":"  509","line":""},
{"lineNum":"  510","line":"#define EIGEN_MAKE_TYPEDEFS(Size, SizeSuffix)                     \\"},
{"lineNum":"  511","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  512","line":"/** \\brief \\cpp11 */                                              \\"},
{"lineNum":"  513","line":"template <typename Type>                                          \\"},
{"lineNum":"  514","line":"using Matrix##SizeSuffix = Matrix<Type, Size, Size>;              \\"},
{"lineNum":"  515","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  516","line":"/** \\brief \\cpp11 */                                              \\"},
{"lineNum":"  517","line":"template <typename Type>                                          \\"},
{"lineNum":"  518","line":"using Vector##SizeSuffix = Matrix<Type, Size, 1>;                 \\"},
{"lineNum":"  519","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  520","line":"/** \\brief \\cpp11 */                                              \\"},
{"lineNum":"  521","line":"template <typename Type>                                          \\"},
{"lineNum":"  522","line":"using RowVector##SizeSuffix = Matrix<Type, 1, Size>;"},
{"lineNum":"  523","line":""},
{"lineNum":"  524","line":"#define EIGEN_MAKE_FIXED_TYPEDEFS(Size)                           \\"},
{"lineNum":"  525","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  526","line":"/** \\brief \\cpp11 */                                              \\"},
{"lineNum":"  527","line":"template <typename Type>                                          \\"},
{"lineNum":"  528","line":"using Matrix##Size##X = Matrix<Type, Size, Dynamic>;              \\"},
{"lineNum":"  529","line":"/** \\ingroup matrixtypedefs */                                    \\"},
{"lineNum":"  530","line":"/** \\brief \\cpp11 */                                              \\"},
{"lineNum":"  531","line":"template <typename Type>                                          \\"},
{"lineNum":"  532","line":"using Matrix##X##Size = Matrix<Type, Dynamic, Size>;"},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":"EIGEN_MAKE_TYPEDEFS(2, 2)"},
{"lineNum":"  535","line":"EIGEN_MAKE_TYPEDEFS(3, 3)"},
{"lineNum":"  536","line":"EIGEN_MAKE_TYPEDEFS(4, 4)"},
{"lineNum":"  537","line":"EIGEN_MAKE_TYPEDEFS(Dynamic, X)"},
{"lineNum":"  538","line":"EIGEN_MAKE_FIXED_TYPEDEFS(2)"},
{"lineNum":"  539","line":"EIGEN_MAKE_FIXED_TYPEDEFS(3)"},
{"lineNum":"  540","line":"EIGEN_MAKE_FIXED_TYPEDEFS(4)"},
{"lineNum":"  541","line":""},
{"lineNum":"  542","line":"/** \\ingroup matrixtypedefs"},
{"lineNum":"  543","line":"  * \\brief \\cpp11 */"},
{"lineNum":"  544","line":"template <typename Type, int Size>"},
{"lineNum":"  545","line":"using Vector = Matrix<Type, Size, 1>;"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"/** \\ingroup matrixtypedefs"},
{"lineNum":"  548","line":"  * \\brief \\cpp11 */"},
{"lineNum":"  549","line":"template <typename Type, int Size>"},
{"lineNum":"  550","line":"using RowVector = Matrix<Type, 1, Size>;"},
{"lineNum":"  551","line":""},
{"lineNum":"  552","line":"#undef EIGEN_MAKE_TYPEDEFS"},
{"lineNum":"  553","line":"#undef EIGEN_MAKE_FIXED_TYPEDEFS"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"#endif // EIGEN_HAS_CXX11"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"} // end namespace Eigen"},
{"lineNum":"  558","line":""},
{"lineNum":"  559","line":"#endif // EIGEN_MATRIX_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 6, "covered" : 0,};
var merged_data = [];
