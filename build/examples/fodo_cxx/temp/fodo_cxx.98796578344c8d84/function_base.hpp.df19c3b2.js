var data = {lines:[
{"lineNum":"    1","line":"// Boost.Function library"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"//  Copyright Douglas Gregor 2001-2006"},
{"lineNum":"    4","line":"//  Copyright Emil Dotchevski 2007"},
{"lineNum":"    5","line":"//  Use, modification and distribution is subject to the Boost Software License, Version 1.0."},
{"lineNum":"    6","line":"//  (See accompanying file LICENSE_1_0.txt or copy at"},
{"lineNum":"    7","line":"//  http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"// For more information, see http://www.boost.org"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef BOOST_FUNCTION_BASE_HEADER"},
{"lineNum":"   12","line":"#define BOOST_FUNCTION_BASE_HEADER"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include <stdexcept>"},
{"lineNum":"   15","line":"#include <string>"},
{"lineNum":"   16","line":"#include <memory>"},
{"lineNum":"   17","line":"#include <new>"},
{"lineNum":"   18","line":"#include <boost/config.hpp>"},
{"lineNum":"   19","line":"#include <boost/assert.hpp>"},
{"lineNum":"   20","line":"#include <boost/integer.hpp>"},
{"lineNum":"   21","line":"#include <boost/type_index.hpp>"},
{"lineNum":"   22","line":"#include <boost/type_traits/has_trivial_copy.hpp>"},
{"lineNum":"   23","line":"#include <boost/type_traits/has_trivial_destructor.hpp>"},
{"lineNum":"   24","line":"#include <boost/type_traits/is_const.hpp>"},
{"lineNum":"   25","line":"#include <boost/type_traits/is_integral.hpp>"},
{"lineNum":"   26","line":"#include <boost/type_traits/is_volatile.hpp>"},
{"lineNum":"   27","line":"#include <boost/type_traits/composite_traits.hpp>"},
{"lineNum":"   28","line":"#include <boost/ref.hpp>"},
{"lineNum":"   29","line":"#include <boost/type_traits/conditional.hpp>"},
{"lineNum":"   30","line":"#include <boost/config/workaround.hpp>"},
{"lineNum":"   31","line":"#include <boost/type_traits/alignment_of.hpp>"},
{"lineNum":"   32","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":"   33","line":"#include <boost/type_traits/enable_if.hpp>"},
{"lineNum":"   34","line":"#else"},
{"lineNum":"   35","line":"#include <boost/type_traits/integral_constant.hpp>"},
{"lineNum":"   36","line":"#endif"},
{"lineNum":"   37","line":"#include <boost/function_equal.hpp>"},
{"lineNum":"   38","line":"#include <boost/function/function_fwd.hpp>"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"#if defined(BOOST_MSVC)"},
{"lineNum":"   41","line":"#   pragma warning( push )"},
{"lineNum":"   42","line":"#   pragma warning( disable : 4793 ) // complaint about native code generation"},
{"lineNum":"   43","line":"#   pragma warning( disable : 4127 ) // \"conditional expression is constant\""},
{"lineNum":"   44","line":"#endif"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"#if defined(__ICL) && __ICL <= 600 || defined(__MWERKS__) && __MWERKS__ < 0x2406 && !defined(BOOST_STRICT_CONFIG)"},
{"lineNum":"   47","line":"#  define BOOST_FUNCTION_TARGET_FIX(x) x"},
{"lineNum":"   48","line":"#else"},
{"lineNum":"   49","line":"#  define BOOST_FUNCTION_TARGET_FIX(x)"},
{"lineNum":"   50","line":"#endif // __ICL etc"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"#  define BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor,Type)              \\"},
{"lineNum":"   53","line":"      typename ::boost::enable_if_<          \\"},
{"lineNum":"   54","line":"                           !(::boost::is_integral<Functor>::value), \\"},
{"lineNum":"   55","line":"                           Type>::type"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"namespace boost {"},
{"lineNum":"   58","line":"  namespace detail {"},
{"lineNum":"   59","line":"    namespace function {"},
{"lineNum":"   60","line":"      class X;"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"      /**"},
{"lineNum":"   63","line":"       * A buffer used to store small function objects in"},
{"lineNum":"   64","line":"       * boost::function. It is a union containing function pointers,"},
{"lineNum":"   65","line":"       * object pointers, and a structure that resembles a bound"},
{"lineNum":"   66","line":"       * member function pointer."},
{"lineNum":"   67","line":"       */"},
{"lineNum":"   68","line":"      union function_buffer_members"},
{"lineNum":"   69","line":"      {"},
{"lineNum":"   70","line":"        // For pointers to function objects"},
{"lineNum":"   71","line":"        typedef void* obj_ptr_t;"},
{"lineNum":"   72","line":"        mutable obj_ptr_t obj_ptr;"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"        // For pointers to std::type_info objects"},
{"lineNum":"   75","line":"        struct type_t {"},
{"lineNum":"   76","line":"          // (get_functor_type_tag, check_functor_type_tag)."},
{"lineNum":"   77","line":"          const boost::typeindex::type_info* type;"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"          // Whether the type is const-qualified."},
{"lineNum":"   80","line":"          bool const_qualified;"},
{"lineNum":"   81","line":"          // Whether the type is volatile-qualified."},
{"lineNum":"   82","line":"          bool volatile_qualified;"},
{"lineNum":"   83","line":"        } type;"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"        // For function pointers of all kinds"},
{"lineNum":"   86","line":"        typedef void (*func_ptr_t)();"},
{"lineNum":"   87","line":"        mutable func_ptr_t func_ptr;"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"        // For bound member pointers"},
{"lineNum":"   90","line":"        struct bound_memfunc_ptr_t {"},
{"lineNum":"   91","line":"          void (X::*memfunc_ptr)(int);"},
{"lineNum":"   92","line":"          void* obj_ptr;"},
{"lineNum":"   93","line":"        } bound_memfunc_ptr;"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"        // For references to function objects. We explicitly keep"},
{"lineNum":"   96","line":"        // track of the cv-qualifiers on the object referenced."},
{"lineNum":"   97","line":"        struct obj_ref_t {"},
{"lineNum":"   98","line":"          mutable void* obj_ptr;"},
{"lineNum":"   99","line":"          bool is_const_qualified;"},
{"lineNum":"  100","line":"          bool is_volatile_qualified;"},
{"lineNum":"  101","line":"        } obj_ref;"},
{"lineNum":"  102","line":"      };"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"      union BOOST_SYMBOL_VISIBLE function_buffer"},
{"lineNum":"  105","line":"      {"},
{"lineNum":"  106","line":"        // Type-specific union members"},
{"lineNum":"  107","line":"        mutable function_buffer_members members;"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"        // To relax aliasing constraints"},
{"lineNum":"  110","line":"        mutable char data[sizeof(function_buffer_members)];"},
{"lineNum":"  111","line":"      };"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"      /**"},
{"lineNum":"  114","line":"       * The unusable class is a placeholder for unused function arguments"},
{"lineNum":"  115","line":"       * It is also completely unusable except that it constructable from"},
{"lineNum":"  116","line":"       * anything. This helps compilers without partial specialization to"},
{"lineNum":"  117","line":"       * handle Boost.Function objects returning void."},
{"lineNum":"  118","line":"       */"},
{"lineNum":"  119","line":"      struct unusable"},
{"lineNum":"  120","line":"      {"},
{"lineNum":"  121","line":"        unusable() {}"},
{"lineNum":"  122","line":"        template<typename T> unusable(const T&) {}"},
{"lineNum":"  123","line":"      };"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"      /* Determine the return type. This supports compilers that do not support"},
{"lineNum":"  126","line":"       * void returns or partial specialization by silently changing the return"},
{"lineNum":"  127","line":"       * type to \"unusable\"."},
{"lineNum":"  128","line":"       */"},
{"lineNum":"  129","line":"      template<typename T> struct function_return_type { typedef T type; };"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"      template<>"},
{"lineNum":"  132","line":"      struct function_return_type<void>"},
{"lineNum":"  133","line":"      {"},
{"lineNum":"  134","line":"        typedef unusable type;"},
{"lineNum":"  135","line":"      };"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"      // The operation type to perform on the given functor/function pointer"},
{"lineNum":"  138","line":"      enum functor_manager_operation_type {"},
{"lineNum":"  139","line":"        clone_functor_tag,"},
{"lineNum":"  140","line":"        move_functor_tag,"},
{"lineNum":"  141","line":"        destroy_functor_tag,"},
{"lineNum":"  142","line":"        check_functor_type_tag,"},
{"lineNum":"  143","line":"        get_functor_type_tag"},
{"lineNum":"  144","line":"      };"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"      // Tags used to decide between different types of functions"},
{"lineNum":"  147","line":"      struct function_ptr_tag {};"},
{"lineNum":"  148","line":"      struct function_obj_tag {};"},
{"lineNum":"  149","line":"      struct member_ptr_tag {};"},
{"lineNum":"  150","line":"      struct function_obj_ref_tag {};"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"      template<typename F>"},
{"lineNum":"  153","line":"      class get_function_tag"},
{"lineNum":"  154","line":"      {"},
{"lineNum":"  155","line":"        typedef typename conditional<(is_pointer<F>::value),"},
{"lineNum":"  156","line":"                                   function_ptr_tag,"},
{"lineNum":"  157","line":"                                   function_obj_tag>::type ptr_or_obj_tag;"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"        typedef typename conditional<(is_member_pointer<F>::value),"},
{"lineNum":"  160","line":"                                   member_ptr_tag,"},
{"lineNum":"  161","line":"                                   ptr_or_obj_tag>::type ptr_or_obj_or_mem_tag;"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"        typedef typename conditional<(is_reference_wrapper<F>::value),"},
{"lineNum":"  164","line":"                                   function_obj_ref_tag,"},
{"lineNum":"  165","line":"                                   ptr_or_obj_or_mem_tag>::type or_ref_tag;"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"      public:"},
{"lineNum":"  168","line":"        typedef or_ref_tag type;"},
{"lineNum":"  169","line":"      };"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"      // The trivial manager does nothing but return the same pointer (if we"},
{"lineNum":"  172","line":"      // are cloning) or return the null pointer (if we are deleting)."},
{"lineNum":"  173","line":"      template<typename F>"},
{"lineNum":"  174","line":"      struct reference_manager"},
{"lineNum":"  175","line":"      {"},
{"lineNum":"  176","line":"        static inline void"},
{"lineNum":"  177","line":"        manage(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  178","line":"               functor_manager_operation_type op)"},
{"lineNum":"  179","line":"        {"},
{"lineNum":"  180","line":"          switch (op) {"},
{"lineNum":"  181","line":"          case clone_functor_tag:"},
{"lineNum":"  182","line":"            out_buffer.members.obj_ref = in_buffer.members.obj_ref;"},
{"lineNum":"  183","line":"            return;"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"          case move_functor_tag:"},
{"lineNum":"  186","line":"            out_buffer.members.obj_ref = in_buffer.members.obj_ref;"},
{"lineNum":"  187","line":"            in_buffer.members.obj_ref.obj_ptr = 0;"},
{"lineNum":"  188","line":"            return;"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"          case destroy_functor_tag:"},
{"lineNum":"  191","line":"            out_buffer.members.obj_ref.obj_ptr = 0;"},
{"lineNum":"  192","line":"            return;"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"          case check_functor_type_tag:"},
{"lineNum":"  195","line":"            {"},
{"lineNum":"  196","line":"              // Check whether we have the same type. We can add"},
{"lineNum":"  197","line":"              // cv-qualifiers, but we can\'t take them away."},
{"lineNum":"  198","line":"              if (*out_buffer.members.type.type == boost::typeindex::type_id<F>()"},
{"lineNum":"  199","line":"                  && (!in_buffer.members.obj_ref.is_const_qualified"},
{"lineNum":"  200","line":"                      || out_buffer.members.type.const_qualified)"},
{"lineNum":"  201","line":"                  && (!in_buffer.members.obj_ref.is_volatile_qualified"},
{"lineNum":"  202","line":"                      || out_buffer.members.type.volatile_qualified))"},
{"lineNum":"  203","line":"                out_buffer.members.obj_ptr = in_buffer.members.obj_ref.obj_ptr;"},
{"lineNum":"  204","line":"              else"},
{"lineNum":"  205","line":"                out_buffer.members.obj_ptr = 0;"},
{"lineNum":"  206","line":"            }"},
{"lineNum":"  207","line":"            return;"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"          case get_functor_type_tag:"},
{"lineNum":"  210","line":"            out_buffer.members.type.type = &boost::typeindex::type_id<F>().type_info();"},
{"lineNum":"  211","line":"            out_buffer.members.type.const_qualified = in_buffer.members.obj_ref.is_const_qualified;"},
{"lineNum":"  212","line":"            out_buffer.members.type.volatile_qualified = in_buffer.members.obj_ref.is_volatile_qualified;"},
{"lineNum":"  213","line":"            return;"},
{"lineNum":"  214","line":"          }"},
{"lineNum":"  215","line":"        }"},
{"lineNum":"  216","line":"      };"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"      /**"},
{"lineNum":"  219","line":"       * Determine if boost::function can use the small-object"},
{"lineNum":"  220","line":"       * optimization with the function object type F."},
{"lineNum":"  221","line":"       */"},
{"lineNum":"  222","line":"      template<typename F>"},
{"lineNum":"  223","line":"      struct function_allows_small_object_optimization"},
{"lineNum":"  224","line":"      {"},
{"lineNum":"  225","line":"        BOOST_STATIC_CONSTANT"},
{"lineNum":"  226","line":"          (bool,"},
{"lineNum":"  227","line":"           value = ((sizeof(F) <= sizeof(function_buffer) &&"},
{"lineNum":"  228","line":"                     (alignment_of<function_buffer>::value"},
{"lineNum":"  229","line":"                      % alignment_of<F>::value == 0))));"},
{"lineNum":"  230","line":"      };"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"      template <typename F,typename A>"},
{"lineNum":"  233","line":"      struct functor_wrapper: public F, public A"},
{"lineNum":"  234","line":"      {"},
{"lineNum":"  235","line":"        functor_wrapper( F f, A a ):"},
{"lineNum":"  236","line":"          F(f),"},
{"lineNum":"  237","line":"          A(a)"},
{"lineNum":"  238","line":"        {"},
{"lineNum":"  239","line":"        }"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"        functor_wrapper(const functor_wrapper& f) :"},
{"lineNum":"  242","line":"          F(static_cast<const F&>(f)),"},
{"lineNum":"  243","line":"          A(static_cast<const A&>(f))"},
{"lineNum":"  244","line":"        {"},
{"lineNum":"  245","line":"        }"},
{"lineNum":"  246","line":"      };"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"      /**"},
{"lineNum":"  249","line":"       * The functor_manager class contains a static function \"manage\" which"},
{"lineNum":"  250","line":"       * can clone or destroy the given function/function object pointer."},
{"lineNum":"  251","line":"       */"},
{"lineNum":"  252","line":"      template<typename Functor>"},
{"lineNum":"  253","line":"      struct functor_manager_common"},
{"lineNum":"  254","line":"      {"},
{"lineNum":"  255","line":"        typedef Functor functor_type;"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"        // Function pointers"},
{"lineNum":"  258","line":"        static inline void"},
{"lineNum":"  259","line":"        manage_ptr(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  260","line":"                functor_manager_operation_type op)"},
{"lineNum":"  261","line":"        {"},
{"lineNum":"  262","line":"          if (op == clone_functor_tag)"},
{"lineNum":"  263","line":"            out_buffer.members.func_ptr = in_buffer.members.func_ptr;"},
{"lineNum":"  264","line":"          else if (op == move_functor_tag) {"},
{"lineNum":"  265","line":"            out_buffer.members.func_ptr = in_buffer.members.func_ptr;"},
{"lineNum":"  266","line":"            in_buffer.members.func_ptr = 0;"},
{"lineNum":"  267","line":"          } else if (op == destroy_functor_tag)"},
{"lineNum":"  268","line":"            out_buffer.members.func_ptr = 0;"},
{"lineNum":"  269","line":"          else if (op == check_functor_type_tag) {"},
{"lineNum":"  270","line":"            if (*out_buffer.members.type.type == boost::typeindex::type_id<Functor>())"},
{"lineNum":"  271","line":"              out_buffer.members.obj_ptr = &in_buffer.members.func_ptr;"},
{"lineNum":"  272","line":"            else"},
{"lineNum":"  273","line":"              out_buffer.members.obj_ptr = 0;"},
{"lineNum":"  274","line":"          } else /* op == get_functor_type_tag */ {"},
{"lineNum":"  275","line":"            out_buffer.members.type.type = &boost::typeindex::type_id<Functor>().type_info();"},
{"lineNum":"  276","line":"            out_buffer.members.type.const_qualified = false;"},
{"lineNum":"  277","line":"            out_buffer.members.type.volatile_qualified = false;"},
{"lineNum":"  278","line":"          }"},
{"lineNum":"  279","line":"        }"},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"        // Function objects that fit in the small-object buffer."},
{"lineNum":"  282","line":"        static inline void"},
{"lineNum":"  283","line":"        manage_small(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  284","line":"                functor_manager_operation_type op)"},
{"lineNum":"  285","line":"        {"},
{"lineNum":"  286","line":"          if (op == clone_functor_tag || op == move_functor_tag) {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  287","line":"            const functor_type* in_functor ="},
{"lineNum":"  288","line":"              reinterpret_cast<const functor_type*>(in_buffer.data);"},
{"lineNum":"  289","line":"            new (reinterpret_cast<void*>(out_buffer.data)) functor_type(*in_functor);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"            if (op == move_functor_tag) {"},
{"lineNum":"  292","line":"              functor_type* f = reinterpret_cast<functor_type*>(in_buffer.data);"},
{"lineNum":"  293","line":"              (void)f; // suppress warning about the value of f not being used (MSVC)"},
{"lineNum":"  294","line":"              f->~Functor();"},
{"lineNum":"  295","line":"            }"},
{"lineNum":"  296","line":"          } else if (op == destroy_functor_tag) {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  297","line":"            // Some compilers (Borland, vc6, ...) are unhappy with ~functor_type."},
{"lineNum":"  298","line":"             functor_type* f = reinterpret_cast<functor_type*>(out_buffer.data);"},
{"lineNum":"  299","line":"             (void)f; // suppress warning about the value of f not being used (MSVC)"},
{"lineNum":"  300","line":"             f->~Functor();"},
{"lineNum":"  301","line":"          } else if (op == check_functor_type_tag) {"},
{"lineNum":"  302","line":"             if (*out_buffer.members.type.type == boost::typeindex::type_id<Functor>())","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  303","line":"              out_buffer.members.obj_ptr = in_buffer.data;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  304","line":"            else"},
{"lineNum":"  305","line":"              out_buffer.members.obj_ptr = 0;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  306","line":"          } else /* op == get_functor_type_tag */ {"},
{"lineNum":"  307","line":"            out_buffer.members.type.type = &boost::typeindex::type_id<Functor>().type_info();"},
{"lineNum":"  308","line":"            out_buffer.members.type.const_qualified = false;"},
{"lineNum":"  309","line":"            out_buffer.members.type.volatile_qualified = false;"},
{"lineNum":"  310","line":"          }"},
{"lineNum":"  311","line":"        }"},
{"lineNum":"  312","line":"      };"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"      template<typename Functor>"},
{"lineNum":"  315","line":"      struct functor_manager"},
{"lineNum":"  316","line":"      {"},
{"lineNum":"  317","line":"      private:"},
{"lineNum":"  318","line":"        typedef Functor functor_type;"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"        // Function pointers"},
{"lineNum":"  321","line":"        static inline void"},
{"lineNum":"  322","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  323","line":"                functor_manager_operation_type op, function_ptr_tag)"},
{"lineNum":"  324","line":"        {"},
{"lineNum":"  325","line":"          functor_manager_common<Functor>::manage_ptr(in_buffer,out_buffer,op);"},
{"lineNum":"  326","line":"        }"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"        // Function objects that fit in the small-object buffer."},
{"lineNum":"  329","line":"        static inline void"},
{"lineNum":"  330","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  331","line":"                functor_manager_operation_type op, true_type)"},
{"lineNum":"  332","line":"        {"},
{"lineNum":"  333","line":"          functor_manager_common<Functor>::manage_small(in_buffer,out_buffer,op);"},
{"lineNum":"  334","line":"        }"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"        // Function objects that require heap allocation"},
{"lineNum":"  337","line":"        static inline void"},
{"lineNum":"  338","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  339","line":"                functor_manager_operation_type op, false_type)"},
{"lineNum":"  340","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  341","line":"          if (op == clone_functor_tag) {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  342","line":"            // Clone the functor"},
{"lineNum":"  343","line":"            // GCC 2.95.3 gets the CV qualifiers wrong here, so we"},
{"lineNum":"  344","line":"            // can\'t do the static_cast that we should do."},
{"lineNum":"  345","line":"            // jewillco: Changing this to static_cast because GCC 2.95.3 is"},
{"lineNum":"  346","line":"            // obsolete."},
{"lineNum":"  347","line":"            const functor_type* f ="},
{"lineNum":"  348","line":"              static_cast<const functor_type*>(in_buffer.members.obj_ptr);","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  349","line":"            functor_type* new_f = new functor_type(*f);","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  350","line":"            out_buffer.members.obj_ptr = new_f;","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  351","line":"          } else if (op == move_functor_tag) {"},
{"lineNum":"  352","line":"            out_buffer.members.obj_ptr = in_buffer.members.obj_ptr;","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  353","line":"            in_buffer.members.obj_ptr = 0;","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  354","line":"          } else if (op == destroy_functor_tag) {"},
{"lineNum":"  355","line":"            /* Cast from the void pointer to the functor pointer type */"},
{"lineNum":"  356","line":"            functor_type* f ="},
{"lineNum":"  357","line":"              static_cast<functor_type*>(out_buffer.members.obj_ptr);","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  358","line":"            delete f;","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  359","line":"            out_buffer.members.obj_ptr = 0;"},
{"lineNum":"  360","line":"          } else if (op == check_functor_type_tag) {"},
{"lineNum":"  361","line":"            if (*out_buffer.members.type.type == boost::typeindex::type_id<Functor>())","class":"lineNoCov","hits":"0","possible_hits":"40",},
{"lineNum":"  362","line":"              out_buffer.members.obj_ptr = in_buffer.members.obj_ptr;","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  363","line":"            else"},
{"lineNum":"  364","line":"              out_buffer.members.obj_ptr = 0;"},
{"lineNum":"  365","line":"          } else /* op == get_functor_type_tag */ {"},
{"lineNum":"  366","line":"            out_buffer.members.type.type = &boost::typeindex::type_id<Functor>().type_info();","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  367","line":"            out_buffer.members.type.const_qualified = false;","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  368","line":"            out_buffer.members.type.volatile_qualified = false;"},
{"lineNum":"  369","line":"          }"},
{"lineNum":"  370","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  371","line":""},
{"lineNum":"  372","line":"        // For function objects, we determine whether the function"},
{"lineNum":"  373","line":"        // object can use the small-object optimization buffer or"},
{"lineNum":"  374","line":"        // whether we need to allocate it on the heap."},
{"lineNum":"  375","line":"        static inline void"},
{"lineNum":"  376","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  377","line":"                functor_manager_operation_type op, function_obj_tag)"},
{"lineNum":"  378","line":"        {"},
{"lineNum":"  379","line":"          manager(in_buffer, out_buffer, op,","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  380","line":"                  integral_constant<bool, (function_allows_small_object_optimization<functor_type>::value)>());"},
{"lineNum":"  381","line":"        }"},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"        // For member pointers, we use the small-object optimization buffer."},
{"lineNum":"  384","line":"        static inline void"},
{"lineNum":"  385","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  386","line":"                functor_manager_operation_type op, member_ptr_tag)"},
{"lineNum":"  387","line":"        {"},
{"lineNum":"  388","line":"          manager(in_buffer, out_buffer, op, true_type());"},
{"lineNum":"  389","line":"        }"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"      public:"},
{"lineNum":"  392","line":"        /* Dispatch to an appropriate manager based on whether we have a"},
{"lineNum":"  393","line":"           function pointer or a function object pointer. */"},
{"lineNum":"  394","line":"        static inline void"},
{"lineNum":"  395","line":"        manage(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  396","line":"               functor_manager_operation_type op)"},
{"lineNum":"  397","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  398","line":"          typedef typename get_function_tag<functor_type>::type tag_type;"},
{"lineNum":"  399","line":"          switch (op) {","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  400","line":"          case get_functor_type_tag:"},
{"lineNum":"  401","line":"            out_buffer.members.type.type = &boost::typeindex::type_id<functor_type>().type_info();","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  402","line":"            out_buffer.members.type.const_qualified = false;","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  403","line":"            out_buffer.members.type.volatile_qualified = false;"},
{"lineNum":"  404","line":"            return;"},
{"lineNum":"  405","line":""},
{"lineNum":"  406","line":"          default:"},
{"lineNum":"  407","line":"            manager(in_buffer, out_buffer, op, tag_type());"},
{"lineNum":"  408","line":"            return;"},
{"lineNum":"  409","line":"          }"},
{"lineNum":"  410","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"45",},
{"lineNum":"  411","line":"      };"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"      template<typename Functor, typename Allocator>"},
{"lineNum":"  414","line":"      struct functor_manager_a"},
{"lineNum":"  415","line":"      {"},
{"lineNum":"  416","line":"      private:"},
{"lineNum":"  417","line":"        typedef Functor functor_type;"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"        // Function pointers"},
{"lineNum":"  420","line":"        static inline void"},
{"lineNum":"  421","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  422","line":"                functor_manager_operation_type op, function_ptr_tag)"},
{"lineNum":"  423","line":"        {"},
{"lineNum":"  424","line":"          functor_manager_common<Functor>::manage_ptr(in_buffer,out_buffer,op);"},
{"lineNum":"  425","line":"        }"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"        // Function objects that fit in the small-object buffer."},
{"lineNum":"  428","line":"        static inline void"},
{"lineNum":"  429","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  430","line":"                functor_manager_operation_type op, true_type)"},
{"lineNum":"  431","line":"        {"},
{"lineNum":"  432","line":"          functor_manager_common<Functor>::manage_small(in_buffer,out_buffer,op);"},
{"lineNum":"  433","line":"        }"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"        // Function objects that require heap allocation"},
{"lineNum":"  436","line":"        static inline void"},
{"lineNum":"  437","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  438","line":"                functor_manager_operation_type op, false_type)"},
{"lineNum":"  439","line":"        {"},
{"lineNum":"  440","line":"          typedef functor_wrapper<Functor,Allocator> functor_wrapper_type;"},
{"lineNum":"  441","line":"#if defined(BOOST_NO_CXX11_ALLOCATOR)"},
{"lineNum":"  442","line":"          typedef typename Allocator::template rebind<functor_wrapper_type>::other"},
{"lineNum":"  443","line":"            wrapper_allocator_type;"},
{"lineNum":"  444","line":"          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;"},
{"lineNum":"  445","line":"#else"},
{"lineNum":"  446","line":"          using wrapper_allocator_type = typename std::allocator_traits<Allocator>::template rebind_alloc<functor_wrapper_type>;"},
{"lineNum":"  447","line":"          using wrapper_allocator_pointer_type = typename std::allocator_traits<wrapper_allocator_type>::pointer;"},
{"lineNum":"  448","line":"#endif"},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"          if (op == clone_functor_tag) {"},
{"lineNum":"  451","line":"            // Clone the functor"},
{"lineNum":"  452","line":"            // GCC 2.95.3 gets the CV qualifiers wrong here, so we"},
{"lineNum":"  453","line":"            // can\'t do the static_cast that we should do."},
{"lineNum":"  454","line":"            const functor_wrapper_type* f ="},
{"lineNum":"  455","line":"              static_cast<const functor_wrapper_type*>(in_buffer.members.obj_ptr);"},
{"lineNum":"  456","line":"            wrapper_allocator_type wrapper_allocator(static_cast<Allocator const &>(*f));"},
{"lineNum":"  457","line":"            wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);"},
{"lineNum":"  458","line":"#if defined(BOOST_NO_CXX11_ALLOCATOR)"},
{"lineNum":"  459","line":"            wrapper_allocator.construct(copy, *f);"},
{"lineNum":"  460","line":"#else"},
{"lineNum":"  461","line":"            std::allocator_traits<wrapper_allocator_type>::construct(wrapper_allocator, copy, *f);"},
{"lineNum":"  462","line":"#endif"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"            // Get back to the original pointer type"},
{"lineNum":"  465","line":"            functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);"},
{"lineNum":"  466","line":"            out_buffer.members.obj_ptr = new_f;"},
{"lineNum":"  467","line":"          } else if (op == move_functor_tag) {"},
{"lineNum":"  468","line":"            out_buffer.members.obj_ptr = in_buffer.members.obj_ptr;"},
{"lineNum":"  469","line":"            in_buffer.members.obj_ptr = 0;"},
{"lineNum":"  470","line":"          } else if (op == destroy_functor_tag) {"},
{"lineNum":"  471","line":"            /* Cast from the void pointer to the functor_wrapper_type */"},
{"lineNum":"  472","line":"            functor_wrapper_type* victim ="},
{"lineNum":"  473","line":"              static_cast<functor_wrapper_type*>(in_buffer.members.obj_ptr);"},
{"lineNum":"  474","line":"            wrapper_allocator_type wrapper_allocator(static_cast<Allocator const &>(*victim));"},
{"lineNum":"  475","line":"#if defined(BOOST_NO_CXX11_ALLOCATOR)"},
{"lineNum":"  476","line":"            wrapper_allocator.destroy(victim);"},
{"lineNum":"  477","line":"#else"},
{"lineNum":"  478","line":"            std::allocator_traits<wrapper_allocator_type>::destroy(wrapper_allocator, victim);"},
{"lineNum":"  479","line":"#endif"},
{"lineNum":"  480","line":"            wrapper_allocator.deallocate(victim,1);"},
{"lineNum":"  481","line":"            out_buffer.members.obj_ptr = 0;"},
{"lineNum":"  482","line":"          } else if (op == check_functor_type_tag) {"},
{"lineNum":"  483","line":"            if (*out_buffer.members.type.type == boost::typeindex::type_id<Functor>())"},
{"lineNum":"  484","line":"              out_buffer.members.obj_ptr = in_buffer.members.obj_ptr;"},
{"lineNum":"  485","line":"            else"},
{"lineNum":"  486","line":"              out_buffer.members.obj_ptr = 0;"},
{"lineNum":"  487","line":"          } else /* op == get_functor_type_tag */ {"},
{"lineNum":"  488","line":"            out_buffer.members.type.type = &boost::typeindex::type_id<Functor>().type_info();"},
{"lineNum":"  489","line":"            out_buffer.members.type.const_qualified = false;"},
{"lineNum":"  490","line":"            out_buffer.members.type.volatile_qualified = false;"},
{"lineNum":"  491","line":"          }"},
{"lineNum":"  492","line":"        }"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"        // For function objects, we determine whether the function"},
{"lineNum":"  495","line":"        // object can use the small-object optimization buffer or"},
{"lineNum":"  496","line":"        // whether we need to allocate it on the heap."},
{"lineNum":"  497","line":"        static inline void"},
{"lineNum":"  498","line":"        manager(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  499","line":"                functor_manager_operation_type op, function_obj_tag)"},
{"lineNum":"  500","line":"        {"},
{"lineNum":"  501","line":"          manager(in_buffer, out_buffer, op,"},
{"lineNum":"  502","line":"                  integral_constant<bool, (function_allows_small_object_optimization<functor_type>::value)>());"},
{"lineNum":"  503","line":"        }"},
{"lineNum":"  504","line":""},
{"lineNum":"  505","line":"      public:"},
{"lineNum":"  506","line":"        /* Dispatch to an appropriate manager based on whether we have a"},
{"lineNum":"  507","line":"           function pointer or a function object pointer. */"},
{"lineNum":"  508","line":"        static inline void"},
{"lineNum":"  509","line":"        manage(const function_buffer& in_buffer, function_buffer& out_buffer,"},
{"lineNum":"  510","line":"               functor_manager_operation_type op)"},
{"lineNum":"  511","line":"        {"},
{"lineNum":"  512","line":"          typedef typename get_function_tag<functor_type>::type tag_type;"},
{"lineNum":"  513","line":"          switch (op) {"},
{"lineNum":"  514","line":"          case get_functor_type_tag:"},
{"lineNum":"  515","line":"            out_buffer.members.type.type = &boost::typeindex::type_id<functor_type>().type_info();"},
{"lineNum":"  516","line":"            out_buffer.members.type.const_qualified = false;"},
{"lineNum":"  517","line":"            out_buffer.members.type.volatile_qualified = false;"},
{"lineNum":"  518","line":"            return;"},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"          default:"},
{"lineNum":"  521","line":"            manager(in_buffer, out_buffer, op, tag_type());"},
{"lineNum":"  522","line":"            return;"},
{"lineNum":"  523","line":"          }"},
{"lineNum":"  524","line":"        }"},
{"lineNum":"  525","line":"      };"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"      // A type that is only used for comparisons against zero"},
{"lineNum":"  528","line":"      struct useless_clear_type {};"},
{"lineNum":"  529","line":""},
{"lineNum":"  530","line":"#ifdef BOOST_NO_SFINAE"},
{"lineNum":"  531","line":"      // These routines perform comparisons between a Boost.Function"},
{"lineNum":"  532","line":"      // object and an arbitrary function object (when the last"},
{"lineNum":"  533","line":"      // parameter is false_type) or against zero (when the"},
{"lineNum":"  534","line":"      // last parameter is true_type). They are only necessary"},
{"lineNum":"  535","line":"      // for compilers that don\'t support SFINAE."},
{"lineNum":"  536","line":"      template<typename Function, typename Functor>"},
{"lineNum":"  537","line":"        bool"},
{"lineNum":"  538","line":"        compare_equal(const Function& f, const Functor&, int, true_type)"},
{"lineNum":"  539","line":"        { return f.empty(); }"},
{"lineNum":"  540","line":""},
{"lineNum":"  541","line":"      template<typename Function, typename Functor>"},
{"lineNum":"  542","line":"        bool"},
{"lineNum":"  543","line":"        compare_not_equal(const Function& f, const Functor&, int,"},
{"lineNum":"  544","line":"                          true_type)"},
{"lineNum":"  545","line":"        { return !f.empty(); }"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"      template<typename Function, typename Functor>"},
{"lineNum":"  548","line":"        bool"},
{"lineNum":"  549","line":"        compare_equal(const Function& f, const Functor& g, long,"},
{"lineNum":"  550","line":"                      false_type)"},
{"lineNum":"  551","line":"        {"},
{"lineNum":"  552","line":"          if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  553","line":"            return function_equal(*fp, g);"},
{"lineNum":"  554","line":"          else return false;"},
{"lineNum":"  555","line":"        }"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"      template<typename Function, typename Functor>"},
{"lineNum":"  558","line":"        bool"},
{"lineNum":"  559","line":"        compare_equal(const Function& f, const reference_wrapper<Functor>& g,"},
{"lineNum":"  560","line":"                      int, false_type)"},
{"lineNum":"  561","line":"        {"},
{"lineNum":"  562","line":"          if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  563","line":"            return fp == g.get_pointer();"},
{"lineNum":"  564","line":"          else return false;"},
{"lineNum":"  565","line":"        }"},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"      template<typename Function, typename Functor>"},
{"lineNum":"  568","line":"        bool"},
{"lineNum":"  569","line":"        compare_not_equal(const Function& f, const Functor& g, long,"},
{"lineNum":"  570","line":"                          false_type)"},
{"lineNum":"  571","line":"        {"},
{"lineNum":"  572","line":"          if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  573","line":"            return !function_equal(*fp, g);"},
{"lineNum":"  574","line":"          else return true;"},
{"lineNum":"  575","line":"        }"},
{"lineNum":"  576","line":""},
{"lineNum":"  577","line":"      template<typename Function, typename Functor>"},
{"lineNum":"  578","line":"        bool"},
{"lineNum":"  579","line":"        compare_not_equal(const Function& f,"},
{"lineNum":"  580","line":"                          const reference_wrapper<Functor>& g, int,"},
{"lineNum":"  581","line":"                          false_type)"},
{"lineNum":"  582","line":"        {"},
{"lineNum":"  583","line":"          if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  584","line":"            return fp != g.get_pointer();"},
{"lineNum":"  585","line":"          else return true;"},
{"lineNum":"  586","line":"        }"},
{"lineNum":"  587","line":"#endif // BOOST_NO_SFINAE"},
{"lineNum":"  588","line":""},
{"lineNum":"  589","line":"      /**"},
{"lineNum":"  590","line":"       * Stores the \"manager\" portion of the vtable for a"},
{"lineNum":"  591","line":"       * boost::function object."},
{"lineNum":"  592","line":"       */"},
{"lineNum":"  593","line":"      struct vtable_base"},
{"lineNum":"  594","line":"      {"},
{"lineNum":"  595","line":"        void (*manager)(const function_buffer& in_buffer,"},
{"lineNum":"  596","line":"                        function_buffer& out_buffer,"},
{"lineNum":"  597","line":"                        functor_manager_operation_type op);"},
{"lineNum":"  598","line":"      };"},
{"lineNum":"  599","line":"    } // end namespace function"},
{"lineNum":"  600","line":"  } // end namespace detail"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"/**"},
{"lineNum":"  603","line":" * The function_base class contains the basic elements needed for the"},
{"lineNum":"  604","line":" * function1, function2, function3, etc. classes. It is common to all"},
{"lineNum":"  605","line":" * functions (and as such can be used to tell if we have one of the"},
{"lineNum":"  606","line":" * functionN objects)."},
{"lineNum":"  607","line":" */"},
{"lineNum":"  608","line":"class function_base"},
{"lineNum":"  609","line":"{"},
{"lineNum":"  610","line":"public:"},
{"lineNum":"  611","line":"  function_base() : vtable(0) { }","class":"lineNoCov","hits":"0","possible_hits":"56",},
{"lineNum":"  612","line":""},
{"lineNum":"  613","line":"  /** Determine if the function is empty (i.e., has no target). */"},
{"lineNum":"  614","line":"  bool empty() const { return !vtable; }","class":"lineNoCov","hits":"0","possible_hits":"205",},
{"lineNum":"  615","line":""},
{"lineNum":"  616","line":"  /** Retrieve the type of the stored function object, or type_id<void>()"},
{"lineNum":"  617","line":"      if this is empty. */"},
{"lineNum":"  618","line":"  const boost::typeindex::type_info& target_type() const"},
{"lineNum":"  619","line":"  {"},
{"lineNum":"  620","line":"    if (!vtable) return boost::typeindex::type_id<void>().type_info();"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"    detail::function::function_buffer type;"},
{"lineNum":"  623","line":"    get_vtable()->manager(functor, type, detail::function::get_functor_type_tag);"},
{"lineNum":"  624","line":"    return *type.members.type.type;"},
{"lineNum":"  625","line":"  }"},
{"lineNum":"  626","line":""},
{"lineNum":"  627","line":"  template<typename Functor>"},
{"lineNum":"  628","line":"    Functor* target()"},
{"lineNum":"  629","line":"    {"},
{"lineNum":"  630","line":"      if (!vtable) return 0;"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":"      detail::function::function_buffer type_result;"},
{"lineNum":"  633","line":"      type_result.members.type.type = &boost::typeindex::type_id<Functor>().type_info();"},
{"lineNum":"  634","line":"      type_result.members.type.const_qualified = is_const<Functor>::value;"},
{"lineNum":"  635","line":"      type_result.members.type.volatile_qualified = is_volatile<Functor>::value;"},
{"lineNum":"  636","line":"      get_vtable()->manager(functor, type_result,"},
{"lineNum":"  637","line":"                      detail::function::check_functor_type_tag);"},
{"lineNum":"  638","line":"      return static_cast<Functor*>(type_result.members.obj_ptr);"},
{"lineNum":"  639","line":"    }"},
{"lineNum":"  640","line":""},
{"lineNum":"  641","line":"  template<typename Functor>"},
{"lineNum":"  642","line":"    const Functor* target() const"},
{"lineNum":"  643","line":"    {"},
{"lineNum":"  644","line":"      if (!vtable) return 0;"},
{"lineNum":"  645","line":""},
{"lineNum":"  646","line":"      detail::function::function_buffer type_result;"},
{"lineNum":"  647","line":"      type_result.members.type.type = &boost::typeindex::type_id<Functor>().type_info();"},
{"lineNum":"  648","line":"      type_result.members.type.const_qualified = true;"},
{"lineNum":"  649","line":"      type_result.members.type.volatile_qualified = is_volatile<Functor>::value;"},
{"lineNum":"  650","line":"      get_vtable()->manager(functor, type_result,"},
{"lineNum":"  651","line":"                      detail::function::check_functor_type_tag);"},
{"lineNum":"  652","line":"      // GCC 2.95.3 gets the CV qualifiers wrong here, so we"},
{"lineNum":"  653","line":"      // can\'t do the static_cast that we should do."},
{"lineNum":"  654","line":"      return static_cast<const Functor*>(type_result.members.obj_ptr);"},
{"lineNum":"  655","line":"    }"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"  template<typename F>"},
{"lineNum":"  658","line":"    bool contains(const F& f) const"},
{"lineNum":"  659","line":"    {"},
{"lineNum":"  660","line":"      if (const F* fp = this->template target<F>())"},
{"lineNum":"  661","line":"      {"},
{"lineNum":"  662","line":"        return function_equal(*fp, f);"},
{"lineNum":"  663","line":"      } else {"},
{"lineNum":"  664","line":"        return false;"},
{"lineNum":"  665","line":"      }"},
{"lineNum":"  666","line":"    }"},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"#if defined(__GNUC__) && __GNUC__ == 3 && __GNUC_MINOR__ <= 3"},
{"lineNum":"  669","line":"  // GCC 3.3 and newer cannot copy with the global operator==, due to"},
{"lineNum":"  670","line":"  // problems with instantiation of function return types before it"},
{"lineNum":"  671","line":"  // has been verified that the argument types match up."},
{"lineNum":"  672","line":"  template<typename Functor>"},
{"lineNum":"  673","line":"    BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  674","line":"    operator==(Functor g) const"},
{"lineNum":"  675","line":"    {"},
{"lineNum":"  676","line":"      if (const Functor* fp = target<Functor>())"},
{"lineNum":"  677","line":"        return function_equal(*fp, g);"},
{"lineNum":"  678","line":"      else return false;"},
{"lineNum":"  679","line":"    }"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"  template<typename Functor>"},
{"lineNum":"  682","line":"    BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  683","line":"    operator!=(Functor g) const"},
{"lineNum":"  684","line":"    {"},
{"lineNum":"  685","line":"      if (const Functor* fp = target<Functor>())"},
{"lineNum":"  686","line":"        return !function_equal(*fp, g);"},
{"lineNum":"  687","line":"      else return true;"},
{"lineNum":"  688","line":"    }"},
{"lineNum":"  689","line":"#endif"},
{"lineNum":"  690","line":""},
{"lineNum":"  691","line":"public: // should be protected, but GCC 2.95.3 will fail to allow access"},
{"lineNum":"  692","line":"  detail::function::vtable_base* get_vtable() const {"},
{"lineNum":"  693","line":"    return reinterpret_cast<detail::function::vtable_base*>("},
{"lineNum":"  694","line":"             reinterpret_cast<std::size_t>(vtable) & ~static_cast<std::size_t>(0x01));"},
{"lineNum":"  695","line":"  }"},
{"lineNum":"  696","line":""},
{"lineNum":"  697","line":"  bool has_trivial_copy_and_destroy() const {"},
{"lineNum":"  698","line":"    return reinterpret_cast<std::size_t>(vtable) & 0x01;","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  699","line":"  }"},
{"lineNum":"  700","line":""},
{"lineNum":"  701","line":"  detail::function::vtable_base* vtable;"},
{"lineNum":"  702","line":"  mutable detail::function::function_buffer functor;"},
{"lineNum":"  703","line":"};"},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"#if defined(BOOST_CLANG)"},
{"lineNum":"  706","line":"#   pragma clang diagnostic push"},
{"lineNum":"  707","line":"#   pragma clang diagnostic ignored \"-Wweak-vtables\""},
{"lineNum":"  708","line":"#endif"},
{"lineNum":"  709","line":"/**"},
{"lineNum":"  710","line":" * The bad_function_call exception class is thrown when a boost::function"},
{"lineNum":"  711","line":" * object is invoked"},
{"lineNum":"  712","line":" */"},
{"lineNum":"  713","line":"class BOOST_SYMBOL_VISIBLE bad_function_call : public std::runtime_error","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  714","line":"{"},
{"lineNum":"  715","line":"public:"},
{"lineNum":"  716","line":"  bad_function_call() : std::runtime_error(\"call to empty boost::function\") {}","class":"lineNoCov","hits":"0","possible_hits":"93",},
{"lineNum":"  717","line":"};"},
{"lineNum":"  718","line":"#if defined(BOOST_CLANG)"},
{"lineNum":"  719","line":"#   pragma clang diagnostic pop"},
{"lineNum":"  720","line":"#endif"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":"  723","line":"inline bool operator==(const function_base& f,"},
{"lineNum":"  724","line":"                       detail::function::useless_clear_type*)"},
{"lineNum":"  725","line":"{"},
{"lineNum":"  726","line":"  return f.empty();"},
{"lineNum":"  727","line":"}"},
{"lineNum":"  728","line":""},
{"lineNum":"  729","line":"inline bool operator!=(const function_base& f,"},
{"lineNum":"  730","line":"                       detail::function::useless_clear_type*)"},
{"lineNum":"  731","line":"{"},
{"lineNum":"  732","line":"  return !f.empty();"},
{"lineNum":"  733","line":"}"},
{"lineNum":"  734","line":""},
{"lineNum":"  735","line":"inline bool operator==(detail::function::useless_clear_type*,"},
{"lineNum":"  736","line":"                       const function_base& f)"},
{"lineNum":"  737","line":"{"},
{"lineNum":"  738","line":"  return f.empty();"},
{"lineNum":"  739","line":"}"},
{"lineNum":"  740","line":""},
{"lineNum":"  741","line":"inline bool operator!=(detail::function::useless_clear_type*,"},
{"lineNum":"  742","line":"                       const function_base& f)"},
{"lineNum":"  743","line":"{"},
{"lineNum":"  744","line":"  return !f.empty();"},
{"lineNum":"  745","line":"}"},
{"lineNum":"  746","line":"#endif"},
{"lineNum":"  747","line":""},
{"lineNum":"  748","line":"#ifdef BOOST_NO_SFINAE"},
{"lineNum":"  749","line":"// Comparisons between boost::function objects and arbitrary function objects"},
{"lineNum":"  750","line":"template<typename Functor>"},
{"lineNum":"  751","line":"  inline bool operator==(const function_base& f, Functor g)"},
{"lineNum":"  752","line":"  {"},
{"lineNum":"  753","line":"    typedef integral_constant<bool, (is_integral<Functor>::value)> integral;"},
{"lineNum":"  754","line":"    return detail::function::compare_equal(f, g, 0, integral());"},
{"lineNum":"  755","line":"  }"},
{"lineNum":"  756","line":""},
{"lineNum":"  757","line":"template<typename Functor>"},
{"lineNum":"  758","line":"  inline bool operator==(Functor g, const function_base& f)"},
{"lineNum":"  759","line":"  {"},
{"lineNum":"  760","line":"    typedef integral_constant<bool, (is_integral<Functor>::value)> integral;"},
{"lineNum":"  761","line":"    return detail::function::compare_equal(f, g, 0, integral());"},
{"lineNum":"  762","line":"  }"},
{"lineNum":"  763","line":""},
{"lineNum":"  764","line":"template<typename Functor>"},
{"lineNum":"  765","line":"  inline bool operator!=(const function_base& f, Functor g)"},
{"lineNum":"  766","line":"  {"},
{"lineNum":"  767","line":"    typedef integral_constant<bool, (is_integral<Functor>::value)> integral;"},
{"lineNum":"  768","line":"    return detail::function::compare_not_equal(f, g, 0, integral());"},
{"lineNum":"  769","line":"  }"},
{"lineNum":"  770","line":""},
{"lineNum":"  771","line":"template<typename Functor>"},
{"lineNum":"  772","line":"  inline bool operator!=(Functor g, const function_base& f)"},
{"lineNum":"  773","line":"  {"},
{"lineNum":"  774","line":"    typedef integral_constant<bool, (is_integral<Functor>::value)> integral;"},
{"lineNum":"  775","line":"    return detail::function::compare_not_equal(f, g, 0, integral());"},
{"lineNum":"  776","line":"  }"},
{"lineNum":"  777","line":"#else"},
{"lineNum":"  778","line":""},
{"lineNum":"  779","line":"#  if !(defined(__GNUC__) && __GNUC__ == 3 && __GNUC_MINOR__ <= 3)"},
{"lineNum":"  780","line":"// Comparisons between boost::function objects and arbitrary function"},
{"lineNum":"  781","line":"// objects. GCC 3.3 and before has an obnoxious bug that prevents this"},
{"lineNum":"  782","line":"// from working."},
{"lineNum":"  783","line":"template<typename Functor>"},
{"lineNum":"  784","line":"  BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  785","line":"  operator==(const function_base& f, Functor g)"},
{"lineNum":"  786","line":"  {"},
{"lineNum":"  787","line":"    if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  788","line":"      return function_equal(*fp, g);"},
{"lineNum":"  789","line":"    else return false;"},
{"lineNum":"  790","line":"  }"},
{"lineNum":"  791","line":""},
{"lineNum":"  792","line":"template<typename Functor>"},
{"lineNum":"  793","line":"  BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  794","line":"  operator==(Functor g, const function_base& f)"},
{"lineNum":"  795","line":"  {"},
{"lineNum":"  796","line":"    if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  797","line":"      return function_equal(g, *fp);"},
{"lineNum":"  798","line":"    else return false;"},
{"lineNum":"  799","line":"  }"},
{"lineNum":"  800","line":""},
{"lineNum":"  801","line":"template<typename Functor>"},
{"lineNum":"  802","line":"  BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  803","line":"  operator!=(const function_base& f, Functor g)"},
{"lineNum":"  804","line":"  {"},
{"lineNum":"  805","line":"    if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  806","line":"      return !function_equal(*fp, g);"},
{"lineNum":"  807","line":"    else return true;"},
{"lineNum":"  808","line":"  }"},
{"lineNum":"  809","line":""},
{"lineNum":"  810","line":"template<typename Functor>"},
{"lineNum":"  811","line":"  BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  812","line":"  operator!=(Functor g, const function_base& f)"},
{"lineNum":"  813","line":"  {"},
{"lineNum":"  814","line":"    if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  815","line":"      return !function_equal(g, *fp);"},
{"lineNum":"  816","line":"    else return true;"},
{"lineNum":"  817","line":"  }"},
{"lineNum":"  818","line":"#  endif"},
{"lineNum":"  819","line":""},
{"lineNum":"  820","line":"template<typename Functor>"},
{"lineNum":"  821","line":"  BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  822","line":"  operator==(const function_base& f, reference_wrapper<Functor> g)"},
{"lineNum":"  823","line":"  {"},
{"lineNum":"  824","line":"    if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  825","line":"      return fp == g.get_pointer();"},
{"lineNum":"  826","line":"    else return false;"},
{"lineNum":"  827","line":"  }"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"template<typename Functor>"},
{"lineNum":"  830","line":"  BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  831","line":"  operator==(reference_wrapper<Functor> g, const function_base& f)"},
{"lineNum":"  832","line":"  {"},
{"lineNum":"  833","line":"    if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  834","line":"      return g.get_pointer() == fp;"},
{"lineNum":"  835","line":"    else return false;"},
{"lineNum":"  836","line":"  }"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"template<typename Functor>"},
{"lineNum":"  839","line":"  BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  840","line":"  operator!=(const function_base& f, reference_wrapper<Functor> g)"},
{"lineNum":"  841","line":"  {"},
{"lineNum":"  842","line":"    if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  843","line":"      return fp != g.get_pointer();"},
{"lineNum":"  844","line":"    else return true;"},
{"lineNum":"  845","line":"  }"},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"template<typename Functor>"},
{"lineNum":"  848","line":"  BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL(Functor, bool)"},
{"lineNum":"  849","line":"  operator!=(reference_wrapper<Functor> g, const function_base& f)"},
{"lineNum":"  850","line":"  {"},
{"lineNum":"  851","line":"    if (const Functor* fp = f.template target<Functor>())"},
{"lineNum":"  852","line":"      return g.get_pointer() != fp;"},
{"lineNum":"  853","line":"    else return true;"},
{"lineNum":"  854","line":"  }"},
{"lineNum":"  855","line":""},
{"lineNum":"  856","line":"#endif // Compiler supporting SFINAE"},
{"lineNum":"  857","line":""},
{"lineNum":"  858","line":"namespace detail {"},
{"lineNum":"  859","line":"  namespace function {"},
{"lineNum":"  860","line":"    inline bool has_empty_target(const function_base* f)"},
{"lineNum":"  861","line":"    {"},
{"lineNum":"  862","line":"      return f->empty();"},
{"lineNum":"  863","line":"    }"},
{"lineNum":"  864","line":""},
{"lineNum":"  865","line":"#if BOOST_WORKAROUND(BOOST_MSVC, <= 1310)"},
{"lineNum":"  866","line":"    inline bool has_empty_target(const void*)"},
{"lineNum":"  867","line":"    {"},
{"lineNum":"  868","line":"      return false;"},
{"lineNum":"  869","line":"    }"},
{"lineNum":"  870","line":"#else"},
{"lineNum":"  871","line":"    inline bool has_empty_target(...)"},
{"lineNum":"  872","line":"    {"},
{"lineNum":"  873","line":"      return false;"},
{"lineNum":"  874","line":"    }"},
{"lineNum":"  875","line":"#endif"},
{"lineNum":"  876","line":"  } // end namespace function"},
{"lineNum":"  877","line":"} // end namespace detail"},
{"lineNum":"  878","line":"} // end namespace boost"},
{"lineNum":"  879","line":""},
{"lineNum":"  880","line":"#undef BOOST_FUNCTION_ENABLE_IF_NOT_INTEGRAL"},
{"lineNum":"  881","line":""},
{"lineNum":"  882","line":"#if defined(BOOST_MSVC)"},
{"lineNum":"  883","line":"#   pragma warning( pop )"},
{"lineNum":"  884","line":"#endif"},
{"lineNum":"  885","line":""},
{"lineNum":"  886","line":"#endif // BOOST_FUNCTION_BASE_HEADER"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 31, "covered" : 0,};
var merged_data = [];
