var data = {lines:[
{"lineNum":"    1","line":"/*============================================================================="},
{"lineNum":"    2","line":"    Copyright (c) 2001-2011 Joel de Guzman"},
{"lineNum":"    3","line":"    Copyright (c) 2001-2011 Hartmut Kaiser"},
{"lineNum":"    4","line":"    http://spirit.sourceforge.net/"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"    Distributed under the Boost Software License, Version 1.0. (See accompanying"},
{"lineNum":"    7","line":"    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    8","line":"=============================================================================*/"},
{"lineNum":"    9","line":"#if !defined(BOOST_SPIRIT_ASSIGN_TO_APR_16_2006_0812PM)"},
{"lineNum":"   10","line":"#define BOOST_SPIRIT_ASSIGN_TO_APR_16_2006_0812PM"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"#if defined(_MSC_VER)"},
{"lineNum":"   13","line":"#pragma once"},
{"lineNum":"   14","line":"#endif"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"#include <boost/spirit/home/qi/detail/construct.hpp>"},
{"lineNum":"   17","line":"#include <boost/spirit/home/support/unused.hpp>"},
{"lineNum":"   18","line":"#include <boost/spirit/home/qi/detail/attributes.hpp>"},
{"lineNum":"   19","line":"#include <boost/spirit/home/support/container.hpp>"},
{"lineNum":"   20","line":"#include <boost/fusion/include/copy.hpp>"},
{"lineNum":"   21","line":"#include <boost/fusion/adapted/struct/detail/extension.hpp>"},
{"lineNum":"   22","line":"#include <boost/ref.hpp>"},
{"lineNum":"   23","line":"#include <boost/range/iterator_range.hpp>"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"namespace boost { namespace spirit { namespace traits"},
{"lineNum":"   26","line":"{"},
{"lineNum":"   27","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"   28","line":"    //  This file contains assignment utilities. The utilities provided also"},
{"lineNum":"   29","line":"    //  accept spirit\'s unused_type; all no-ops. Compiler optimization will"},
{"lineNum":"   30","line":"    //  easily strip these away."},
{"lineNum":"   31","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"   32","line":"    namespace detail"},
{"lineNum":"   33","line":"    {"},
{"lineNum":"   34","line":"        template <typename T>"},
{"lineNum":"   35","line":"        struct is_iter_range : mpl::false_ {};"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"        template <typename I>"},
{"lineNum":"   38","line":"        struct is_iter_range<boost::iterator_range<I> > : mpl::true_ {};"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"        template <typename C>"},
{"lineNum":"   41","line":"        struct is_container_of_ranges"},
{"lineNum":"   42","line":"          : is_iter_range<typename C::value_type> {};"},
{"lineNum":"   43","line":"    }"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"    template <typename Attribute, typename Iterator, typename Enable>"},
{"lineNum":"   46","line":"    struct assign_to_attribute_from_iterators"},
{"lineNum":"   47","line":"    {"},
{"lineNum":"   48","line":"        // Common case"},
{"lineNum":"   49","line":"        static void"},
{"lineNum":"   50","line":"        call(Iterator const& first, Iterator const& last, Attribute& attr, mpl::false_)"},
{"lineNum":"   51","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   52","line":"            if (traits::is_empty(attr))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   53","line":"                attr = Attribute(first, last);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   54","line":"            else {"},
{"lineNum":"   55","line":"                for (Iterator i = first; i != last; ++i)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   56","line":"                    push_back(attr, *i);"},
{"lineNum":"   57","line":"            }"},
{"lineNum":"   58","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"        // If Attribute is a container with value_type==iterator_range<T> just push the"},
{"lineNum":"   61","line":"        // iterator_range into it"},
{"lineNum":"   62","line":"        static void"},
{"lineNum":"   63","line":"        call(Iterator const& first, Iterator const& last, Attribute& attr, mpl::true_)"},
{"lineNum":"   64","line":"        {"},
{"lineNum":"   65","line":"            typename Attribute::value_type rng(first, last);"},
{"lineNum":"   66","line":"            push_back(attr, rng);"},
{"lineNum":"   67","line":"        }"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"        static void"},
{"lineNum":"   70","line":"        call(Iterator const& first, Iterator const& last, Attribute& attr)"},
{"lineNum":"   71","line":"        {"},
{"lineNum":"   72","line":"            call(first, last, attr, detail::is_container_of_ranges<Attribute>());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   73","line":"        }"},
{"lineNum":"   74","line":"    };"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"    template <typename Attribute, typename Iterator>"},
{"lineNum":"   77","line":"    struct assign_to_attribute_from_iterators<"},
{"lineNum":"   78","line":"        reference_wrapper<Attribute>, Iterator>"},
{"lineNum":"   79","line":"    {"},
{"lineNum":"   80","line":"        static void"},
{"lineNum":"   81","line":"        call(Iterator const& first, Iterator const& last"},
{"lineNum":"   82","line":"          , reference_wrapper<Attribute> attr)"},
{"lineNum":"   83","line":"        {"},
{"lineNum":"   84","line":"            if (traits::is_empty(attr))"},
{"lineNum":"   85","line":"                attr = Attribute(first, last);"},
{"lineNum":"   86","line":"            else {"},
{"lineNum":"   87","line":"                for (Iterator i = first; i != last; ++i)"},
{"lineNum":"   88","line":"                    push_back(attr, *i);"},
{"lineNum":"   89","line":"            }"},
{"lineNum":"   90","line":"        }"},
{"lineNum":"   91","line":"    };"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"    template <typename Attribute, typename Iterator>"},
{"lineNum":"   94","line":"    struct assign_to_attribute_from_iterators<"},
{"lineNum":"   95","line":"        boost::optional<Attribute>, Iterator>"},
{"lineNum":"   96","line":"    {"},
{"lineNum":"   97","line":"        static void"},
{"lineNum":"   98","line":"        call(Iterator const& first, Iterator const& last"},
{"lineNum":"   99","line":"          , boost::optional<Attribute>& attr)"},
{"lineNum":"  100","line":"        {"},
{"lineNum":"  101","line":"            Attribute val;"},
{"lineNum":"  102","line":"            assign_to(first, last, val);"},
{"lineNum":"  103","line":"            attr = val;"},
{"lineNum":"  104","line":"        }"},
{"lineNum":"  105","line":"    };"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"    template <typename Iterator>"},
{"lineNum":"  108","line":"    struct assign_to_attribute_from_iterators<"},
{"lineNum":"  109","line":"        iterator_range<Iterator>, Iterator>"},
{"lineNum":"  110","line":"    {"},
{"lineNum":"  111","line":"        static void"},
{"lineNum":"  112","line":"        call(Iterator const& first, Iterator const& last"},
{"lineNum":"  113","line":"          , iterator_range<Iterator>& attr)"},
{"lineNum":"  114","line":"        {"},
{"lineNum":"  115","line":"            attr = iterator_range<Iterator>(first, last);"},
{"lineNum":"  116","line":"        }"},
{"lineNum":"  117","line":"    };"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    template <typename Iterator, typename Attribute>"},
{"lineNum":"  120","line":"    inline void"},
{"lineNum":"  121","line":"    assign_to(Iterator const& first, Iterator const& last, Attribute& attr)"},
{"lineNum":"  122","line":"    {"},
{"lineNum":"  123","line":"        assign_to_attribute_from_iterators<Attribute, Iterator>::"},
{"lineNum":"  124","line":"            call(first, last, attr);"},
{"lineNum":"  125","line":"    }"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    template <typename Iterator>"},
{"lineNum":"  128","line":"    inline void"},
{"lineNum":"  129","line":"    assign_to(Iterator const&, Iterator const&, unused_type)"},
{"lineNum":"  130","line":"    {"},
{"lineNum":"  131","line":"    }"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  134","line":"    template <typename T, typename Attribute>"},
{"lineNum":"  135","line":"    void assign_to(T const& val, Attribute& attr);"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"    template <typename Attribute, typename T, typename Enable>"},
{"lineNum":"  138","line":"    struct assign_to_attribute_from_value"},
{"lineNum":"  139","line":"    {"},
{"lineNum":"  140","line":"        typedef typename traits::one_element_sequence<Attribute>::type"},
{"lineNum":"  141","line":"            is_one_element_sequence;"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"        typedef typename mpl::eval_if<"},
{"lineNum":"  144","line":"            is_one_element_sequence"},
{"lineNum":"  145","line":"          , fusion::result_of::at_c<Attribute, 0>"},
{"lineNum":"  146","line":"          , mpl::identity<Attribute&>"},
{"lineNum":"  147","line":"        >::type type;"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"        template <typename T_>"},
{"lineNum":"  150","line":"        static void"},
{"lineNum":"  151","line":"        call(T_ const& val, Attribute& attr, mpl::false_)"},
{"lineNum":"  152","line":"        {"},
{"lineNum":"  153","line":"            attr = static_cast<Attribute>(val);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  154","line":"        }"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"        // This handles the case where the attribute is a single element fusion"},
{"lineNum":"  157","line":"        // sequence. We silently assign to the only element and treat it as the"},
{"lineNum":"  158","line":"        // attribute to parse the results into."},
{"lineNum":"  159","line":"        template <typename T_>"},
{"lineNum":"  160","line":"        static void"},
{"lineNum":"  161","line":"        call(T_ const& val, Attribute& attr, mpl::true_)"},
{"lineNum":"  162","line":"        {"},
{"lineNum":"  163","line":"            typedef typename fusion::result_of::value_at_c<Attribute, 0>::type"},
{"lineNum":"  164","line":"                element_type;"},
{"lineNum":"  165","line":"            fusion::at_c<0>(attr) = static_cast<element_type>(val);"},
{"lineNum":"  166","line":"        }"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"        static void"},
{"lineNum":"  169","line":"        call(T const& val, Attribute& attr)"},
{"lineNum":"  170","line":"        {"},
{"lineNum":"  171","line":"            call(val, attr, is_one_element_sequence());"},
{"lineNum":"  172","line":"        }"},
{"lineNum":"  173","line":"    };"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"    template <typename Attribute>"},
{"lineNum":"  176","line":"    struct assign_to_attribute_from_value<Attribute, Attribute>"},
{"lineNum":"  177","line":"    {"},
{"lineNum":"  178","line":"        static void"},
{"lineNum":"  179","line":"        call(Attribute const& val, Attribute& attr)"},
{"lineNum":"  180","line":"        {"},
{"lineNum":"  181","line":"            attr = val;","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  182","line":"        }"},
{"lineNum":"  183","line":"    };"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"    template <typename Attribute, typename T>"},
{"lineNum":"  186","line":"    struct assign_to_attribute_from_value<Attribute, reference_wrapper<T>"},
{"lineNum":"  187","line":"      , typename disable_if<is_same<Attribute, reference_wrapper<T> > >::type>"},
{"lineNum":"  188","line":"    {"},
{"lineNum":"  189","line":"        static void"},
{"lineNum":"  190","line":"        call(reference_wrapper<T> const& val, Attribute& attr)"},
{"lineNum":"  191","line":"        {"},
{"lineNum":"  192","line":"            assign_to(val.get(), attr);"},
{"lineNum":"  193","line":"        }"},
{"lineNum":"  194","line":"    };"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"    template <typename Attribute, typename T>"},
{"lineNum":"  197","line":"    struct assign_to_attribute_from_value<Attribute, boost::optional<T>"},
{"lineNum":"  198","line":"      , typename disable_if<is_same<Attribute, boost::optional<T> > >::type>"},
{"lineNum":"  199","line":"    {"},
{"lineNum":"  200","line":"        static void"},
{"lineNum":"  201","line":"        call(boost::optional<T> const& val, Attribute& attr)"},
{"lineNum":"  202","line":"        {"},
{"lineNum":"  203","line":"            assign_to(val.get(), attr);"},
{"lineNum":"  204","line":"        }"},
{"lineNum":"  205","line":"    };"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"    template <typename Attribute, int N, bool Const, typename T>"},
{"lineNum":"  208","line":"    struct assign_to_attribute_from_value<fusion::extension::adt_attribute_proxy<Attribute, N, Const>, T>"},
{"lineNum":"  209","line":"    {"},
{"lineNum":"  210","line":"        static void"},
{"lineNum":"  211","line":"        call(T const& val, typename fusion::extension::adt_attribute_proxy<Attribute, N, Const>& attr)"},
{"lineNum":"  212","line":"        {"},
{"lineNum":"  213","line":"            attr = val;"},
{"lineNum":"  214","line":"        }"},
{"lineNum":"  215","line":"    };"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    namespace detail"},
{"lineNum":"  218","line":"    {"},
{"lineNum":"  219","line":"        template <typename A, typename B>"},
{"lineNum":"  220","line":"        struct is_same_size_sequence"},
{"lineNum":"  221","line":"          : mpl::bool_<fusion::result_of::size<A>::value"},
{"lineNum":"  222","line":"                == fusion::result_of::size<B>::value>"},
{"lineNum":"  223","line":"        {};"},
{"lineNum":"  224","line":"    }"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"    template <typename Attribute, typename T>"},
{"lineNum":"  227","line":"    struct assign_to_attribute_from_value<Attribute, T,"},
{"lineNum":"  228","line":"            mpl::and_<"},
{"lineNum":"  229","line":"                fusion::traits::is_sequence<Attribute>,"},
{"lineNum":"  230","line":"                fusion::traits::is_sequence<T>,"},
{"lineNum":"  231","line":"                detail::is_same_size_sequence<Attribute, T>"},
{"lineNum":"  232","line":"            >"},
{"lineNum":"  233","line":"        >"},
{"lineNum":"  234","line":"    {"},
{"lineNum":"  235","line":"        static void"},
{"lineNum":"  236","line":"        call(T const& val, Attribute& attr)"},
{"lineNum":"  237","line":"        {"},
{"lineNum":"  238","line":"            fusion::copy(val, attr);"},
{"lineNum":"  239","line":"        }"},
{"lineNum":"  240","line":"    };"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  243","line":"    template <typename Attribute, typename T, typename Enable>"},
{"lineNum":"  244","line":"    struct assign_to_container_from_value"},
{"lineNum":"  245","line":"    {"},
{"lineNum":"  246","line":"        // T is not a container and not a string"},
{"lineNum":"  247","line":"        template <typename T_>"},
{"lineNum":"  248","line":"        static void call(T_ const& val, Attribute& attr, mpl::false_, mpl::false_)"},
{"lineNum":"  249","line":"        {"},
{"lineNum":"  250","line":"            traits::push_back(attr, val);"},
{"lineNum":"  251","line":"        }"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"        // T is a container (but not a string), and T is convertible to the"},
{"lineNum":"  254","line":"        // value_type of the Attribute container"},
{"lineNum":"  255","line":"        template <typename T_>"},
{"lineNum":"  256","line":"        static void"},
{"lineNum":"  257","line":"        append_to_container_not_string(T_ const& val, Attribute& attr, mpl::true_)"},
{"lineNum":"  258","line":"        {"},
{"lineNum":"  259","line":"            traits::push_back(attr, val);"},
{"lineNum":"  260","line":"        }"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"        // T is a container (but not a string), generic overload"},
{"lineNum":"  263","line":"        template <typename T_>"},
{"lineNum":"  264","line":"        static void"},
{"lineNum":"  265","line":"        append_to_container_not_string(T_ const& val, Attribute& attr, mpl::false_)"},
{"lineNum":"  266","line":"        {"},
{"lineNum":"  267","line":"            typedef typename traits::container_iterator<T_ const>::type"},
{"lineNum":"  268","line":"                iterator_type;"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"            iterator_type end = traits::end(val);"},
{"lineNum":"  271","line":"            for (iterator_type i = traits::begin(val); i != end; traits::next(i))"},
{"lineNum":"  272","line":"                traits::push_back(attr, traits::deref(i));"},
{"lineNum":"  273","line":"        }"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"        // T is a container (but not a string)"},
{"lineNum":"  276","line":"        template <typename T_>"},
{"lineNum":"  277","line":"        static void call(T_ const& val, Attribute& attr,  mpl::true_, mpl::false_)"},
{"lineNum":"  278","line":"        {"},
{"lineNum":"  279","line":"            typedef typename container_value<Attribute>::type value_type;"},
{"lineNum":"  280","line":"            typedef typename is_convertible<T, value_type>::type is_value_type;"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"            append_to_container_not_string(val, attr, is_value_type());"},
{"lineNum":"  283","line":"        }"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"        ///////////////////////////////////////////////////////////////////////"},
{"lineNum":"  286","line":"        // T is a string"},
{"lineNum":"  287","line":"        template <typename Iterator>"},
{"lineNum":"  288","line":"        static void append_to_string(Attribute& attr, Iterator begin, Iterator end)"},
{"lineNum":"  289","line":"        {"},
{"lineNum":"  290","line":"            for (Iterator i = begin; i != end; ++i)"},
{"lineNum":"  291","line":"                traits::push_back(attr, *i);"},
{"lineNum":"  292","line":"        }"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"        // T is string, but not convertible to value_type of container"},
{"lineNum":"  295","line":"        template <typename T_>"},
{"lineNum":"  296","line":"        static void append_to_container(T_ const& val, Attribute& attr, mpl::false_)"},
{"lineNum":"  297","line":"        {"},
{"lineNum":"  298","line":"            typedef typename char_type_of<T_>::type char_type;"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"            append_to_string(attr, traits::get_begin<char_type>(val)"},
{"lineNum":"  301","line":"              , traits::get_end<char_type>(val));"},
{"lineNum":"  302","line":"        }"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"        // T is string, and convertible to value_type of container"},
{"lineNum":"  305","line":"        template <typename T_>"},
{"lineNum":"  306","line":"        static void append_to_container(T_ const& val, Attribute& attr, mpl::true_)"},
{"lineNum":"  307","line":"        {"},
{"lineNum":"  308","line":"            traits::push_back(attr, val);"},
{"lineNum":"  309","line":"        }"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"        template <typename T_, typename Pred>"},
{"lineNum":"  312","line":"        static void call(T_ const& val, Attribute& attr, Pred, mpl::true_)"},
{"lineNum":"  313","line":"        {"},
{"lineNum":"  314","line":"            typedef typename container_value<Attribute>::type value_type;"},
{"lineNum":"  315","line":"            typedef typename is_convertible<T, value_type>::type is_value_type;"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"            append_to_container(val, attr, is_value_type());"},
{"lineNum":"  318","line":"        }"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"        ///////////////////////////////////////////////////////////////////////"},
{"lineNum":"  321","line":"        static void call(T const& val, Attribute& attr)"},
{"lineNum":"  322","line":"        {"},
{"lineNum":"  323","line":"            typedef typename traits::is_container<T>::type is_container;"},
{"lineNum":"  324","line":"            typedef typename traits::is_string<T>::type is_string;"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"            call(val, attr, is_container(), is_string());"},
{"lineNum":"  327","line":"        }"},
{"lineNum":"  328","line":"    };"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"    template <typename Attribute>"},
{"lineNum":"  331","line":"    struct assign_to_container_from_value<Attribute, Attribute>"},
{"lineNum":"  332","line":"    {"},
{"lineNum":"  333","line":"        static void"},
{"lineNum":"  334","line":"        call(Attribute const& val, Attribute& attr)"},
{"lineNum":"  335","line":"        {"},
{"lineNum":"  336","line":"            attr = val;"},
{"lineNum":"  337","line":"        }"},
{"lineNum":"  338","line":"    };"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"    template <typename Attribute, typename T>"},
{"lineNum":"  341","line":"    struct assign_to_container_from_value<Attribute, boost::optional<T>"},
{"lineNum":"  342","line":"      , typename disable_if<is_same<Attribute, boost::optional<T> > >::type>"},
{"lineNum":"  343","line":"    {"},
{"lineNum":"  344","line":"        static void"},
{"lineNum":"  345","line":"        call(boost::optional<T> const& val, Attribute& attr)"},
{"lineNum":"  346","line":"        {"},
{"lineNum":"  347","line":"            assign_to(val.get(), attr);"},
{"lineNum":"  348","line":"        }"},
{"lineNum":"  349","line":"    };"},
{"lineNum":"  350","line":""},
{"lineNum":"  351","line":"    template <typename Attribute, typename T>"},
{"lineNum":"  352","line":"    struct assign_to_container_from_value<Attribute, reference_wrapper<T>"},
{"lineNum":"  353","line":"      , typename disable_if<is_same<Attribute, reference_wrapper<T> > >::type>"},
{"lineNum":"  354","line":"    {"},
{"lineNum":"  355","line":"        static void"},
{"lineNum":"  356","line":"        call(reference_wrapper<T> const& val, Attribute& attr)"},
{"lineNum":"  357","line":"        {"},
{"lineNum":"  358","line":"            assign_to(val.get(), attr);"},
{"lineNum":"  359","line":"        }"},
{"lineNum":"  360","line":"    };"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  363","line":"    namespace detail"},
{"lineNum":"  364","line":"    {"},
{"lineNum":"  365","line":"        // overload for non-container attributes"},
{"lineNum":"  366","line":"        template <typename T, typename Attribute>"},
{"lineNum":"  367","line":"        inline void"},
{"lineNum":"  368","line":"        assign_to(T const& val, Attribute& attr, mpl::false_)"},
{"lineNum":"  369","line":"        {"},
{"lineNum":"  370","line":"            assign_to_attribute_from_value<Attribute, T>::call(val, attr);"},
{"lineNum":"  371","line":"        }"},
{"lineNum":"  372","line":""},
{"lineNum":"  373","line":"        // overload for containers (but not for variants or optionals"},
{"lineNum":"  374","line":"        // holding containers)"},
{"lineNum":"  375","line":"        template <typename T, typename Attribute>"},
{"lineNum":"  376","line":"        inline void"},
{"lineNum":"  377","line":"        assign_to(T const& val, Attribute& attr, mpl::true_)"},
{"lineNum":"  378","line":"        {"},
{"lineNum":"  379","line":"            assign_to_container_from_value<Attribute, T>::call(val, attr);"},
{"lineNum":"  380","line":"        }"},
{"lineNum":"  381","line":"    }"},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"    template <typename T, typename Attribute>"},
{"lineNum":"  384","line":"    inline void"},
{"lineNum":"  385","line":"    assign_to(T const& val, Attribute& attr)"},
{"lineNum":"  386","line":"    {"},
{"lineNum":"  387","line":"        typedef typename mpl::and_<"},
{"lineNum":"  388","line":"            traits::is_container<Attribute>"},
{"lineNum":"  389","line":"          , traits::not_is_variant<Attribute>"},
{"lineNum":"  390","line":"          , traits::not_is_optional<Attribute>"},
{"lineNum":"  391","line":"        >::type is_not_wrapped_container;"},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"        detail::assign_to(val, attr, is_not_wrapped_container());"},
{"lineNum":"  394","line":"    }"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"    template <typename T>"},
{"lineNum":"  397","line":"    inline void"},
{"lineNum":"  398","line":"    assign_to(T const&, unused_type)"},
{"lineNum":"  399","line":"    {"},
{"lineNum":"  400","line":"    }"},
{"lineNum":"  401","line":"}}}"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 8, "covered" : 0,};
var merged_data = [];
