var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2006-2008, 2010 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_DOT_H"},
{"lineNum":"   11","line":"#define EIGEN_DOT_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"// helper function for dot(). The problem is that if we put that in the body of dot(), then upon calling dot"},
{"lineNum":"   20","line":"// with mismatched types, the compiler emits errors about failing to instantiate cwiseProduct BEFORE"},
{"lineNum":"   21","line":"// looking at the static assertions. Thus this is a trick to get better compile errors."},
{"lineNum":"   22","line":"template<typename T, typename U,"},
{"lineNum":"   23","line":"// the NeedToTranspose condition here is taken straight from Assign.h"},
{"lineNum":"   24","line":"         bool NeedToTranspose = T::IsVectorAtCompileTime"},
{"lineNum":"   25","line":"                && U::IsVectorAtCompileTime"},
{"lineNum":"   26","line":"                && ((int(T::RowsAtCompileTime) == 1 && int(U::ColsAtCompileTime) == 1)"},
{"lineNum":"   27","line":"                      |  // FIXME | instead of || to please GCC 4.4.0 stupid warning \"suggest parentheses around &&\"."},
{"lineNum":"   28","line":"                         // revert to || as soon as not needed anymore."},
{"lineNum":"   29","line":"                    (int(T::ColsAtCompileTime) == 1 && int(U::RowsAtCompileTime) == 1))"},
{"lineNum":"   30","line":">"},
{"lineNum":"   31","line":"struct dot_nocheck"},
{"lineNum":"   32","line":"{"},
{"lineNum":"   33","line":"  typedef scalar_conj_product_op<typename traits<T>::Scalar,typename traits<U>::Scalar> conj_prod;"},
{"lineNum":"   34","line":"  typedef typename conj_prod::result_type ResScalar;"},
{"lineNum":"   35","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   36","line":"  EIGEN_STRONG_INLINE"},
{"lineNum":"   37","line":"  static ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)"},
{"lineNum":"   38","line":"  {"},
{"lineNum":"   39","line":"    return a.template binaryExpr<conj_prod>(b).sum();"},
{"lineNum":"   40","line":"  }"},
{"lineNum":"   41","line":"};"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"template<typename T, typename U>"},
{"lineNum":"   44","line":"struct dot_nocheck<T, U, true>"},
{"lineNum":"   45","line":"{"},
{"lineNum":"   46","line":"  typedef scalar_conj_product_op<typename traits<T>::Scalar,typename traits<U>::Scalar> conj_prod;"},
{"lineNum":"   47","line":"  typedef typename conj_prod::result_type ResScalar;"},
{"lineNum":"   48","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   49","line":"  EIGEN_STRONG_INLINE"},
{"lineNum":"   50","line":"  static ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)"},
{"lineNum":"   51","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   52","line":"    return a.transpose().template binaryExpr<conj_prod>(b).sum();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   53","line":"  }"},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"} // end namespace internal"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"/** \\fn MatrixBase::dot"},
{"lineNum":"   59","line":"  * \\returns the dot product of *this with other."},
{"lineNum":"   60","line":"  *"},
{"lineNum":"   61","line":"  * \\only_for_vectors"},
{"lineNum":"   62","line":"  *"},
{"lineNum":"   63","line":"  * \\note If the scalar type is complex numbers, then this function returns the hermitian"},
{"lineNum":"   64","line":"  * (sesquilinear) dot product, conjugate-linear in the first variable and linear in the"},
{"lineNum":"   65","line":"  * second variable."},
{"lineNum":"   66","line":"  *"},
{"lineNum":"   67","line":"  * \\sa squaredNorm(), norm()"},
{"lineNum":"   68","line":"  */"},
{"lineNum":"   69","line":"template<typename Derived>"},
{"lineNum":"   70","line":"template<typename OtherDerived>"},
{"lineNum":"   71","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"   72","line":"EIGEN_STRONG_INLINE"},
{"lineNum":"   73","line":"typename ScalarBinaryOpTraits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType"},
{"lineNum":"   74","line":"MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const"},
{"lineNum":"   75","line":"{"},
{"lineNum":"   76","line":"  EIGEN_STATIC_ASSERT_VECTOR_ONLY(Derived)"},
{"lineNum":"   77","line":"  EIGEN_STATIC_ASSERT_VECTOR_ONLY(OtherDerived)"},
{"lineNum":"   78","line":"  EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE(Derived,OtherDerived)"},
{"lineNum":"   79","line":"#if !(defined(EIGEN_NO_STATIC_ASSERT) && defined(EIGEN_NO_DEBUG))"},
{"lineNum":"   80","line":"  typedef internal::scalar_conj_product_op<Scalar,typename OtherDerived::Scalar> func;"},
{"lineNum":"   81","line":"  EIGEN_CHECK_BINARY_COMPATIBILIY(func,Scalar,typename OtherDerived::Scalar);"},
{"lineNum":"   82","line":"#endif"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"  eigen_assert(size() == other.size());"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"  return internal::dot_nocheck<Derived,OtherDerived>::run(*this, other);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   87","line":"}"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"//---------- implementation of L2 norm and related functions ----------"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"/** \\returns, for vectors, the squared \\em l2 norm of \\c *this, and for matrices the squared Frobenius norm."},
{"lineNum":"   92","line":"  * In both cases, it consists in the sum of the square of all the matrix entries."},
{"lineNum":"   93","line":"  * For vectors, this is also equals to the dot product of \\c *this with itself."},
{"lineNum":"   94","line":"  *"},
{"lineNum":"   95","line":"  * \\sa dot(), norm(), lpNorm()"},
{"lineNum":"   96","line":"  */"},
{"lineNum":"   97","line":"template<typename Derived>"},
{"lineNum":"   98","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const"},
{"lineNum":"   99","line":"{"},
{"lineNum":"  100","line":"  return numext::real((*this).cwiseAbs2().sum());"},
{"lineNum":"  101","line":"}"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"/** \\returns, for vectors, the \\em l2 norm of \\c *this, and for matrices the Frobenius norm."},
{"lineNum":"  104","line":"  * In both cases, it consists in the square root of the sum of the square of all the matrix entries."},
{"lineNum":"  105","line":"  * For vectors, this is also equals to the square root of the dot product of \\c *this with itself."},
{"lineNum":"  106","line":"  *"},
{"lineNum":"  107","line":"  * \\sa lpNorm(), dot(), squaredNorm()"},
{"lineNum":"  108","line":"  */"},
{"lineNum":"  109","line":"template<typename Derived>"},
{"lineNum":"  110","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const"},
{"lineNum":"  111","line":"{"},
{"lineNum":"  112","line":"  return numext::sqrt(squaredNorm());"},
{"lineNum":"  113","line":"}"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"/** \\returns an expression of the quotient of \\c *this by its own norm."},
{"lineNum":"  116","line":"  *"},
{"lineNum":"  117","line":"  * \\warning If the input vector is too small (i.e., this->norm()==0),"},
{"lineNum":"  118","line":"  *          then this function returns a copy of the input."},
{"lineNum":"  119","line":"  *"},
{"lineNum":"  120","line":"  * \\only_for_vectors"},
{"lineNum":"  121","line":"  *"},
{"lineNum":"  122","line":"  * \\sa norm(), normalize()"},
{"lineNum":"  123","line":"  */"},
{"lineNum":"  124","line":"template<typename Derived>"},
{"lineNum":"  125","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::PlainObject"},
{"lineNum":"  126","line":"MatrixBase<Derived>::normalized() const"},
{"lineNum":"  127","line":"{"},
{"lineNum":"  128","line":"  typedef typename internal::nested_eval<Derived,2>::type _Nested;"},
{"lineNum":"  129","line":"  _Nested n(derived());"},
{"lineNum":"  130","line":"  RealScalar z = n.squaredNorm();"},
{"lineNum":"  131","line":"  // NOTE: after extensive benchmarking, this conditional does not impact performance, at least on recent x86 CPU"},
{"lineNum":"  132","line":"  if(z>RealScalar(0))"},
{"lineNum":"  133","line":"    return n / numext::sqrt(z);"},
{"lineNum":"  134","line":"  else"},
{"lineNum":"  135","line":"    return n;"},
{"lineNum":"  136","line":"}"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"/** Normalizes the vector, i.e. divides it by its own norm."},
{"lineNum":"  139","line":"  *"},
{"lineNum":"  140","line":"  * \\only_for_vectors"},
{"lineNum":"  141","line":"  *"},
{"lineNum":"  142","line":"  * \\warning If the input vector is too small (i.e., this->norm()==0), then \\c *this is left unchanged."},
{"lineNum":"  143","line":"  *"},
{"lineNum":"  144","line":"  * \\sa norm(), normalized()"},
{"lineNum":"  145","line":"  */"},
{"lineNum":"  146","line":"template<typename Derived>"},
{"lineNum":"  147","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void MatrixBase<Derived>::normalize()"},
{"lineNum":"  148","line":"{"},
{"lineNum":"  149","line":"  RealScalar z = squaredNorm();"},
{"lineNum":"  150","line":"  // NOTE: after extensive benchmarking, this conditional does not impact performance, at least on recent x86 CPU"},
{"lineNum":"  151","line":"  if(z>RealScalar(0))","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  152","line":"    derived() /= numext::sqrt(z);"},
{"lineNum":"  153","line":"}"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"/** \\returns an expression of the quotient of \\c *this by its own norm while avoiding underflow and overflow."},
{"lineNum":"  156","line":"  *"},
{"lineNum":"  157","line":"  * \\only_for_vectors"},
{"lineNum":"  158","line":"  *"},
{"lineNum":"  159","line":"  * This method is analogue to the normalized() method, but it reduces the risk of"},
{"lineNum":"  160","line":"  * underflow and overflow when computing the norm."},
{"lineNum":"  161","line":"  *"},
{"lineNum":"  162","line":"  * \\warning If the input vector is too small (i.e., this->norm()==0),"},
{"lineNum":"  163","line":"  *          then this function returns a copy of the input."},
{"lineNum":"  164","line":"  *"},
{"lineNum":"  165","line":"  * \\sa stableNorm(), stableNormalize(), normalized()"},
{"lineNum":"  166","line":"  */"},
{"lineNum":"  167","line":"template<typename Derived>"},
{"lineNum":"  168","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::PlainObject"},
{"lineNum":"  169","line":"MatrixBase<Derived>::stableNormalized() const"},
{"lineNum":"  170","line":"{"},
{"lineNum":"  171","line":"  typedef typename internal::nested_eval<Derived,3>::type _Nested;"},
{"lineNum":"  172","line":"  _Nested n(derived());"},
{"lineNum":"  173","line":"  RealScalar w = n.cwiseAbs().maxCoeff();"},
{"lineNum":"  174","line":"  RealScalar z = (n/w).squaredNorm();"},
{"lineNum":"  175","line":"  if(z>RealScalar(0))"},
{"lineNum":"  176","line":"    return n / (numext::sqrt(z)*w);"},
{"lineNum":"  177","line":"  else"},
{"lineNum":"  178","line":"    return n;"},
{"lineNum":"  179","line":"}"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"/** Normalizes the vector while avoid underflow and overflow"},
{"lineNum":"  182","line":"  *"},
{"lineNum":"  183","line":"  * \\only_for_vectors"},
{"lineNum":"  184","line":"  *"},
{"lineNum":"  185","line":"  * This method is analogue to the normalize() method, but it reduces the risk of"},
{"lineNum":"  186","line":"  * underflow and overflow when computing the norm."},
{"lineNum":"  187","line":"  *"},
{"lineNum":"  188","line":"  * \\warning If the input vector is too small (i.e., this->norm()==0), then \\c *this is left unchanged."},
{"lineNum":"  189","line":"  *"},
{"lineNum":"  190","line":"  * \\sa stableNorm(), stableNormalized(), normalize()"},
{"lineNum":"  191","line":"  */"},
{"lineNum":"  192","line":"template<typename Derived>"},
{"lineNum":"  193","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void MatrixBase<Derived>::stableNormalize()"},
{"lineNum":"  194","line":"{"},
{"lineNum":"  195","line":"  RealScalar w = cwiseAbs().maxCoeff();"},
{"lineNum":"  196","line":"  RealScalar z = (derived()/w).squaredNorm();"},
{"lineNum":"  197","line":"  if(z>RealScalar(0))"},
{"lineNum":"  198","line":"    derived() /= numext::sqrt(z)*w;"},
{"lineNum":"  199","line":"}"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"//---------- implementation of other norms ----------"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"namespace internal {"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"template<typename Derived, int p>"},
{"lineNum":"  206","line":"struct lpNorm_selector"},
{"lineNum":"  207","line":"{"},
{"lineNum":"  208","line":"  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;"},
{"lineNum":"  209","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  210","line":"  static inline RealScalar run(const MatrixBase<Derived>& m)"},
{"lineNum":"  211","line":"  {"},
{"lineNum":"  212","line":"    EIGEN_USING_STD(pow)"},
{"lineNum":"  213","line":"    return pow(m.cwiseAbs().array().pow(p).sum(), RealScalar(1)/p);"},
{"lineNum":"  214","line":"  }"},
{"lineNum":"  215","line":"};"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"template<typename Derived>"},
{"lineNum":"  218","line":"struct lpNorm_selector<Derived, 1>"},
{"lineNum":"  219","line":"{"},
{"lineNum":"  220","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  221","line":"  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)"},
{"lineNum":"  222","line":"  {"},
{"lineNum":"  223","line":"    return m.cwiseAbs().sum();"},
{"lineNum":"  224","line":"  }"},
{"lineNum":"  225","line":"};"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"template<typename Derived>"},
{"lineNum":"  228","line":"struct lpNorm_selector<Derived, 2>"},
{"lineNum":"  229","line":"{"},
{"lineNum":"  230","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  231","line":"  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)"},
{"lineNum":"  232","line":"  {"},
{"lineNum":"  233","line":"    return m.norm();"},
{"lineNum":"  234","line":"  }"},
{"lineNum":"  235","line":"};"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"template<typename Derived>"},
{"lineNum":"  238","line":"struct lpNorm_selector<Derived, Infinity>"},
{"lineNum":"  239","line":"{"},
{"lineNum":"  240","line":"  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;"},
{"lineNum":"  241","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  242","line":"  static inline RealScalar run(const MatrixBase<Derived>& m)"},
{"lineNum":"  243","line":"  {"},
{"lineNum":"  244","line":"    if(Derived::SizeAtCompileTime==0 || (Derived::SizeAtCompileTime==Dynamic && m.size()==0))"},
{"lineNum":"  245","line":"      return RealScalar(0);"},
{"lineNum":"  246","line":"    return m.cwiseAbs().maxCoeff();"},
{"lineNum":"  247","line":"  }"},
{"lineNum":"  248","line":"};"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"} // end namespace internal"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"/** \\returns the \\b coefficient-wise \\f$ \\ell^p \\f$ norm of \\c *this, that is, returns the p-th root of the sum of the p-th powers of the absolute values"},
{"lineNum":"  253","line":"  *          of the coefficients of \\c *this. If \\a p is the special value \\a Eigen::Infinity, this function returns the \\f$ \\ell^\\infty \\f$"},
{"lineNum":"  254","line":"  *          norm, that is the maximum of the absolute values of the coefficients of \\c *this."},
{"lineNum":"  255","line":"  *"},
{"lineNum":"  256","line":"  * In all cases, if \\c *this is empty, then the value 0 is returned."},
{"lineNum":"  257","line":"  *"},
{"lineNum":"  258","line":"  * \\note For matrices, this function does not compute the <a href=\"https://en.wikipedia.org/wiki/Operator_norm\">operator-norm</a>. That is, if \\c *this is a matrix, then its coefficients are interpreted as a 1D vector. Nonetheless, you can easily compute the 1-norm and \\f$\\infty\\f$-norm matrix operator norms using \\link TutorialReductionsVisitorsBroadcastingReductionsNorm partial reductions \\endlink."},
{"lineNum":"  259","line":"  *"},
{"lineNum":"  260","line":"  * \\sa norm()"},
{"lineNum":"  261","line":"  */"},
{"lineNum":"  262","line":"template<typename Derived>"},
{"lineNum":"  263","line":"template<int p>"},
{"lineNum":"  264","line":"#ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  265","line":"EIGEN_DEVICE_FUNC inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real"},
{"lineNum":"  266","line":"#else"},
{"lineNum":"  267","line":"EIGEN_DEVICE_FUNC MatrixBase<Derived>::RealScalar"},
{"lineNum":"  268","line":"#endif"},
{"lineNum":"  269","line":"MatrixBase<Derived>::lpNorm() const"},
{"lineNum":"  270","line":"{"},
{"lineNum":"  271","line":"  return internal::lpNorm_selector<Derived, p>::run(*this);"},
{"lineNum":"  272","line":"}"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"//---------- implementation of isOrthogonal / isUnitary ----------"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"/** \\returns true if *this is approximately orthogonal to \\a other,"},
{"lineNum":"  277","line":"  *          within the precision given by \\a prec."},
{"lineNum":"  278","line":"  *"},
{"lineNum":"  279","line":"  * Example: \\include MatrixBase_isOrthogonal.cpp"},
{"lineNum":"  280","line":"  * Output: \\verbinclude MatrixBase_isOrthogonal.out"},
{"lineNum":"  281","line":"  */"},
{"lineNum":"  282","line":"template<typename Derived>"},
{"lineNum":"  283","line":"template<typename OtherDerived>"},
{"lineNum":"  284","line":"bool MatrixBase<Derived>::isOrthogonal"},
{"lineNum":"  285","line":"(const MatrixBase<OtherDerived>& other, const RealScalar& prec) const"},
{"lineNum":"  286","line":"{"},
{"lineNum":"  287","line":"  typename internal::nested_eval<Derived,2>::type nested(derived());"},
{"lineNum":"  288","line":"  typename internal::nested_eval<OtherDerived,2>::type otherNested(other.derived());"},
{"lineNum":"  289","line":"  return numext::abs2(nested.dot(otherNested)) <= prec * prec * nested.squaredNorm() * otherNested.squaredNorm();"},
{"lineNum":"  290","line":"}"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"/** \\returns true if *this is approximately an unitary matrix,"},
{"lineNum":"  293","line":"  *          within the precision given by \\a prec. In the case where the \\a Scalar"},
{"lineNum":"  294","line":"  *          type is real numbers, a unitary matrix is an orthogonal matrix, whence the name."},
{"lineNum":"  295","line":"  *"},
{"lineNum":"  296","line":"  * \\note This can be used to check whether a family of vectors forms an orthonormal basis."},
{"lineNum":"  297","line":"  *       Indeed, \\c m.isUnitary() returns true if and only if the columns (equivalently, the rows) of m form an"},
{"lineNum":"  298","line":"  *       orthonormal basis."},
{"lineNum":"  299","line":"  *"},
{"lineNum":"  300","line":"  * Example: \\include MatrixBase_isUnitary.cpp"},
{"lineNum":"  301","line":"  * Output: \\verbinclude MatrixBase_isUnitary.out"},
{"lineNum":"  302","line":"  */"},
{"lineNum":"  303","line":"template<typename Derived>"},
{"lineNum":"  304","line":"bool MatrixBase<Derived>::isUnitary(const RealScalar& prec) const"},
{"lineNum":"  305","line":"{"},
{"lineNum":"  306","line":"  typename internal::nested_eval<Derived,1>::type self(derived());"},
{"lineNum":"  307","line":"  for(Index i = 0; i < cols(); ++i)"},
{"lineNum":"  308","line":"  {"},
{"lineNum":"  309","line":"    if(!internal::isApprox(self.col(i).squaredNorm(), static_cast<RealScalar>(1), prec))"},
{"lineNum":"  310","line":"      return false;"},
{"lineNum":"  311","line":"    for(Index j = 0; j < i; ++j)"},
{"lineNum":"  312","line":"      if(!internal::isMuchSmallerThan(self.col(i).dot(self.col(j)), static_cast<Scalar>(1), prec))"},
{"lineNum":"  313","line":"        return false;"},
{"lineNum":"  314","line":"  }"},
{"lineNum":"  315","line":"  return true;"},
{"lineNum":"  316","line":"}"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"} // end namespace Eigen"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"#endif // EIGEN_DOT_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
