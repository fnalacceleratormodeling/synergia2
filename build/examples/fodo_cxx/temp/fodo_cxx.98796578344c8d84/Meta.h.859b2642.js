var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2015 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_META_H"},
{"lineNum":"   12","line":"#define EIGEN_META_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"../InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"#if defined(EIGEN_GPU_COMPILE_PHASE)"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":" #include <cfloat>"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":" #if defined(EIGEN_CUDA_ARCH)"},
{"lineNum":"   21","line":"  #include <math_constants.h>"},
{"lineNum":"   22","line":" #endif"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":" #if defined(EIGEN_HIP_DEVICE_COMPILE)"},
{"lineNum":"   25","line":"  #include \"Eigen/src/Core/arch/HIP/hcc/math_constants.h\""},
{"lineNum":"   26","line":"  #endif"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"#endif"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"// Recent versions of ICC require <cstdint> for pointer types below."},
{"lineNum":"   31","line":"#define EIGEN_ICC_NEEDS_CSTDINT (EIGEN_COMP_ICC>=1600 && EIGEN_COMP_CXXVER >= 11)"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"// Define portable (u)int{32,64} types"},
{"lineNum":"   34","line":"#if EIGEN_HAS_CXX11 || EIGEN_ICC_NEEDS_CSTDINT"},
{"lineNum":"   35","line":"#include <cstdint>"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"namespace Eigen {"},
{"lineNum":"   38","line":"namespace numext {"},
{"lineNum":"   39","line":"typedef std::uint8_t  uint8_t;"},
{"lineNum":"   40","line":"typedef std::int8_t   int8_t;"},
{"lineNum":"   41","line":"typedef std::uint16_t uint16_t;"},
{"lineNum":"   42","line":"typedef std::int16_t  int16_t;"},
{"lineNum":"   43","line":"typedef std::uint32_t uint32_t;"},
{"lineNum":"   44","line":"typedef std::int32_t  int32_t;"},
{"lineNum":"   45","line":"typedef std::uint64_t uint64_t;"},
{"lineNum":"   46","line":"typedef std::int64_t  int64_t;"},
{"lineNum":"   47","line":"}"},
{"lineNum":"   48","line":"}"},
{"lineNum":"   49","line":"#else"},
{"lineNum":"   50","line":"// Without c++11, all compilers able to compile Eigen also"},
{"lineNum":"   51","line":"// provide the C99 stdint.h header file."},
{"lineNum":"   52","line":"#include <stdint.h>"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"namespace Eigen {"},
{"lineNum":"   55","line":"namespace numext {"},
{"lineNum":"   56","line":"typedef ::uint8_t  uint8_t;"},
{"lineNum":"   57","line":"typedef ::int8_t   int8_t;"},
{"lineNum":"   58","line":"typedef ::uint16_t uint16_t;"},
{"lineNum":"   59","line":"typedef ::int16_t  int16_t;"},
{"lineNum":"   60","line":"typedef ::uint32_t uint32_t;"},
{"lineNum":"   61","line":"typedef ::int32_t  int32_t;"},
{"lineNum":"   62","line":"typedef ::uint64_t uint64_t;"},
{"lineNum":"   63","line":"typedef ::int64_t  int64_t;"},
{"lineNum":"   64","line":"}"},
{"lineNum":"   65","line":"}"},
{"lineNum":"   66","line":"#endif"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"namespace Eigen {"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"/**"},
{"lineNum":"   73","line":" * \\brief The Index type as used for the API."},
{"lineNum":"   74","line":" * \\details To change this, \\c \\#define the preprocessor symbol \\c EIGEN_DEFAULT_DENSE_INDEX_TYPE."},
{"lineNum":"   75","line":" * \\sa \\blank \\ref TopicPreprocessorDirectives, StorageIndex."},
{"lineNum":"   76","line":" */"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE Index;"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"namespace internal {"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"/** \\internal"},
{"lineNum":"   83","line":"  * \\file Meta.h"},
{"lineNum":"   84","line":"  * This file contains generic metaprogramming classes which are not specifically related to Eigen."},
{"lineNum":"   85","line":"  * \\note In case you wonder, yes we\'re aware that Boost already provides all these features,"},
{"lineNum":"   86","line":"  * we however don\'t want to add a dependency to Boost."},
{"lineNum":"   87","line":"  */"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"// Only recent versions of ICC complain about using ptrdiff_t to hold pointers,"},
{"lineNum":"   90","line":"// and older versions do not provide *intptr_t types."},
{"lineNum":"   91","line":"#if EIGEN_ICC_NEEDS_CSTDINT"},
{"lineNum":"   92","line":"typedef std::intptr_t  IntPtr;"},
{"lineNum":"   93","line":"typedef std::uintptr_t UIntPtr;"},
{"lineNum":"   94","line":"#else"},
{"lineNum":"   95","line":"typedef std::ptrdiff_t IntPtr;"},
{"lineNum":"   96","line":"typedef std::size_t UIntPtr;"},
{"lineNum":"   97","line":"#endif"},
{"lineNum":"   98","line":"#undef EIGEN_ICC_NEEDS_CSTDINT"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"struct true_type {  enum { value = 1 }; };"},
{"lineNum":"  101","line":"struct false_type { enum { value = 0 }; };"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"template<bool Condition>"},
{"lineNum":"  104","line":"struct bool_constant;"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"template<>"},
{"lineNum":"  107","line":"struct bool_constant<true> : true_type {};"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"template<>"},
{"lineNum":"  110","line":"struct bool_constant<false> : false_type {};"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"template<bool Condition, typename Then, typename Else>"},
{"lineNum":"  113","line":"struct conditional { typedef Then type; };"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"template<typename Then, typename Else>"},
{"lineNum":"  116","line":"struct conditional <false, Then, Else> { typedef Else type; };"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"template<typename T> struct remove_reference { typedef T type; };"},
{"lineNum":"  119","line":"template<typename T> struct remove_reference<T&> { typedef T type; };"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"template<typename T> struct remove_pointer { typedef T type; };"},
{"lineNum":"  122","line":"template<typename T> struct remove_pointer<T*> { typedef T type; };"},
{"lineNum":"  123","line":"template<typename T> struct remove_pointer<T*const> { typedef T type; };"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"template <class T> struct remove_const { typedef T type; };"},
{"lineNum":"  126","line":"template <class T> struct remove_const<const T> { typedef T type; };"},
{"lineNum":"  127","line":"template <class T> struct remove_const<const T[]> { typedef T type[]; };"},
{"lineNum":"  128","line":"template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"template<typename T> struct remove_all { typedef T type; };"},
{"lineNum":"  131","line":"template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };"},
{"lineNum":"  132","line":"template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };"},
{"lineNum":"  133","line":"template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };"},
{"lineNum":"  134","line":"template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };"},
{"lineNum":"  135","line":"template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"template<typename T> struct is_arithmetic      { enum { value = false }; };"},
{"lineNum":"  138","line":"template<> struct is_arithmetic<float>         { enum { value = true }; };"},
{"lineNum":"  139","line":"template<> struct is_arithmetic<double>        { enum { value = true }; };"},
{"lineNum":"  140","line":"template<> struct is_arithmetic<long double>   { enum { value = true }; };"},
{"lineNum":"  141","line":"template<> struct is_arithmetic<bool>          { enum { value = true }; };"},
{"lineNum":"  142","line":"template<> struct is_arithmetic<char>          { enum { value = true }; };"},
{"lineNum":"  143","line":"template<> struct is_arithmetic<signed char>   { enum { value = true }; };"},
{"lineNum":"  144","line":"template<> struct is_arithmetic<unsigned char> { enum { value = true }; };"},
{"lineNum":"  145","line":"template<> struct is_arithmetic<signed short>  { enum { value = true }; };"},
{"lineNum":"  146","line":"template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };"},
{"lineNum":"  147","line":"template<> struct is_arithmetic<signed int>    { enum { value = true }; };"},
{"lineNum":"  148","line":"template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };"},
{"lineNum":"  149","line":"template<> struct is_arithmetic<signed long>   { enum { value = true }; };"},
{"lineNum":"  150","line":"template<> struct is_arithmetic<unsigned long> { enum { value = true }; };"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"template<typename T, typename U> struct is_same { enum { value = 0 }; };"},
{"lineNum":"  153","line":"template<typename T> struct is_same<T,T> { enum { value = 1 }; };"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"template< class T >"},
{"lineNum":"  156","line":"struct is_void : is_same<void, typename remove_const<T>::type> {};"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"#if EIGEN_HAS_CXX11"},
{"lineNum":"  159","line":"template<> struct is_arithmetic<signed long long>   { enum { value = true }; };"},
{"lineNum":"  160","line":"template<> struct is_arithmetic<unsigned long long> { enum { value = true }; };"},
{"lineNum":"  161","line":"using std::is_integral;"},
{"lineNum":"  162","line":"#else"},
{"lineNum":"  163","line":"template<typename T> struct is_integral               { enum { value = false }; };"},
{"lineNum":"  164","line":"template<> struct is_integral<bool>                   { enum { value = true }; };"},
{"lineNum":"  165","line":"template<> struct is_integral<char>                   { enum { value = true }; };"},
{"lineNum":"  166","line":"template<> struct is_integral<signed char>            { enum { value = true }; };"},
{"lineNum":"  167","line":"template<> struct is_integral<unsigned char>          { enum { value = true }; };"},
{"lineNum":"  168","line":"template<> struct is_integral<signed short>           { enum { value = true }; };"},
{"lineNum":"  169","line":"template<> struct is_integral<unsigned short>         { enum { value = true }; };"},
{"lineNum":"  170","line":"template<> struct is_integral<signed int>             { enum { value = true }; };"},
{"lineNum":"  171","line":"template<> struct is_integral<unsigned int>           { enum { value = true }; };"},
{"lineNum":"  172","line":"template<> struct is_integral<signed long>            { enum { value = true }; };"},
{"lineNum":"  173","line":"template<> struct is_integral<unsigned long>          { enum { value = true }; };"},
{"lineNum":"  174","line":"#if EIGEN_COMP_MSVC"},
{"lineNum":"  175","line":"template<> struct is_integral<signed __int64>         { enum { value = true }; };"},
{"lineNum":"  176","line":"template<> struct is_integral<unsigned __int64>       { enum { value = true }; };"},
{"lineNum":"  177","line":"#endif"},
{"lineNum":"  178","line":"#endif"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"#if EIGEN_HAS_CXX11"},
{"lineNum":"  181","line":"using std::make_unsigned;"},
{"lineNum":"  182","line":"#else"},
{"lineNum":"  183","line":"// TODO: Possibly improve this implementation of make_unsigned."},
{"lineNum":"  184","line":"// It is currently used only by"},
{"lineNum":"  185","line":"// template<typename Scalar> struct random_default_impl<Scalar, false, true>."},
{"lineNum":"  186","line":"template<typename> struct make_unsigned;"},
{"lineNum":"  187","line":"template<> struct make_unsigned<char>             { typedef unsigned char type; };"},
{"lineNum":"  188","line":"template<> struct make_unsigned<signed char>      { typedef unsigned char type; };"},
{"lineNum":"  189","line":"template<> struct make_unsigned<unsigned char>    { typedef unsigned char type; };"},
{"lineNum":"  190","line":"template<> struct make_unsigned<signed short>     { typedef unsigned short type; };"},
{"lineNum":"  191","line":"template<> struct make_unsigned<unsigned short>   { typedef unsigned short type; };"},
{"lineNum":"  192","line":"template<> struct make_unsigned<signed int>       { typedef unsigned int type; };"},
{"lineNum":"  193","line":"template<> struct make_unsigned<unsigned int>     { typedef unsigned int type; };"},
{"lineNum":"  194","line":"template<> struct make_unsigned<signed long>      { typedef unsigned long type; };"},
{"lineNum":"  195","line":"template<> struct make_unsigned<unsigned long>    { typedef unsigned long type; };"},
{"lineNum":"  196","line":"#if EIGEN_COMP_MSVC"},
{"lineNum":"  197","line":"template<> struct make_unsigned<signed __int64>   { typedef unsigned __int64 type; };"},
{"lineNum":"  198","line":"template<> struct make_unsigned<unsigned __int64> { typedef unsigned __int64 type; };"},
{"lineNum":"  199","line":"#endif"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"// Some platforms define int64_t as `long long` even for C++03, where"},
{"lineNum":"  202","line":"// `long long` is not guaranteed by the standard. In this case we are missing"},
{"lineNum":"  203","line":"// the definition for make_unsigned. If we just define it, we run into issues"},
{"lineNum":"  204","line":"// where `long long` doesn\'t exist in some compilers for C++03. We therefore add"},
{"lineNum":"  205","line":"// the specialization for these platforms only."},
{"lineNum":"  206","line":"#if EIGEN_OS_MAC || EIGEN_COMP_MINGW"},
{"lineNum":"  207","line":"template<> struct make_unsigned<unsigned long long> { typedef unsigned long long type; };"},
{"lineNum":"  208","line":"template<> struct make_unsigned<long long>          { typedef unsigned long long type; };"},
{"lineNum":"  209","line":"#endif"},
{"lineNum":"  210","line":"#endif"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"template <typename T> struct add_const { typedef const T type; };"},
{"lineNum":"  213","line":"template <typename T> struct add_const<T&> { typedef T& type; };"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"template <typename T> struct is_const { enum { value = 0 }; };"},
{"lineNum":"  216","line":"template <typename T> struct is_const<T const> { enum { value = 1 }; };"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"template<typename T> struct add_const_on_value_type            { typedef const T type;  };"},
{"lineNum":"  219","line":"template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };"},
{"lineNum":"  220","line":"template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };"},
{"lineNum":"  221","line":"template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };"},
{"lineNum":"  222","line":"template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"#if EIGEN_HAS_CXX11"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"using std::is_convertible;"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"#else"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"template<typename From, typename To>"},
{"lineNum":"  231","line":"struct is_convertible_impl"},
{"lineNum":"  232","line":"{"},
{"lineNum":"  233","line":"private:"},
{"lineNum":"  234","line":"  struct any_conversion"},
{"lineNum":"  235","line":"  {"},
{"lineNum":"  236","line":"    template <typename T> any_conversion(const volatile T&);"},
{"lineNum":"  237","line":"    template <typename T> any_conversion(T&);"},
{"lineNum":"  238","line":"  };"},
{"lineNum":"  239","line":"  struct yes {int a[1];};"},
{"lineNum":"  240","line":"  struct no  {int a[2];};"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"  template<typename T>"},
{"lineNum":"  243","line":"  static yes test(T, int);"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"  template<typename T>"},
{"lineNum":"  246","line":"  static no  test(any_conversion, ...);"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"public:"},
{"lineNum":"  249","line":"  static typename internal::remove_reference<From>::type* ms_from;"},
{"lineNum":"  250","line":"#ifdef __INTEL_COMPILER"},
{"lineNum":"  251","line":"  #pragma warning push"},
{"lineNum":"  252","line":"  #pragma warning ( disable : 2259 )"},
{"lineNum":"  253","line":"#endif"},
{"lineNum":"  254","line":"  enum { value = sizeof(test<To>(*ms_from, 0))==sizeof(yes) };"},
{"lineNum":"  255","line":"#ifdef __INTEL_COMPILER"},
{"lineNum":"  256","line":"  #pragma warning pop"},
{"lineNum":"  257","line":"#endif"},
{"lineNum":"  258","line":"};"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"template<typename From, typename To>"},
{"lineNum":"  261","line":"struct is_convertible"},
{"lineNum":"  262","line":"{"},
{"lineNum":"  263","line":"  enum { value = is_convertible_impl<From,To>::value };"},
{"lineNum":"  264","line":"};"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"template<typename T>"},
{"lineNum":"  267","line":"struct is_convertible<T,T&> { enum { value = false }; };"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"template<typename T>"},
{"lineNum":"  270","line":"struct is_convertible<const T,const T&> { enum { value = true }; };"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"#endif"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"/** \\internal Allows to enable/disable an overload"},
{"lineNum":"  275","line":"  * according to a compile time condition."},
{"lineNum":"  276","line":"  */"},
{"lineNum":"  277","line":"template<bool Condition, typename T=void> struct enable_if;"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"template<typename T> struct enable_if<true,T>"},
{"lineNum":"  280","line":"{ typedef T type; };"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"#if defined(EIGEN_GPU_COMPILE_PHASE) && !EIGEN_HAS_CXX11"},
{"lineNum":"  283","line":"#if !defined(__FLT_EPSILON__)"},
{"lineNum":"  284","line":"#define __FLT_EPSILON__ FLT_EPSILON"},
{"lineNum":"  285","line":"#define __DBL_EPSILON__ DBL_EPSILON"},
{"lineNum":"  286","line":"#endif"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"namespace device {"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"template<typename T> struct numeric_limits"},
{"lineNum":"  291","line":"{"},
{"lineNum":"  292","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  293","line":"  static EIGEN_CONSTEXPR T epsilon() { return 0; }"},
{"lineNum":"  294","line":"  static T (max)() { assert(false && \"Highest not supported for this type\"); }"},
{"lineNum":"  295","line":"  static T (min)() { assert(false && \"Lowest not supported for this type\"); }"},
{"lineNum":"  296","line":"  static T infinity() { assert(false && \"Infinity not supported for this type\"); }"},
{"lineNum":"  297","line":"  static T quiet_NaN() { assert(false && \"quiet_NaN not supported for this type\"); }"},
{"lineNum":"  298","line":"};"},
{"lineNum":"  299","line":"template<> struct numeric_limits<float>"},
{"lineNum":"  300","line":"{"},
{"lineNum":"  301","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  302","line":"  static float epsilon() { return __FLT_EPSILON__; }"},
{"lineNum":"  303","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  304","line":"  static float (max)() {"},
{"lineNum":"  305","line":"  #if defined(EIGEN_CUDA_ARCH)"},
{"lineNum":"  306","line":"    return CUDART_MAX_NORMAL_F;"},
{"lineNum":"  307","line":"  #else"},
{"lineNum":"  308","line":"    return HIPRT_MAX_NORMAL_F;"},
{"lineNum":"  309","line":"  #endif"},
{"lineNum":"  310","line":"  }"},
{"lineNum":"  311","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  312","line":"  static float (min)() { return FLT_MIN; }"},
{"lineNum":"  313","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  314","line":"  static float infinity() {"},
{"lineNum":"  315","line":"  #if defined(EIGEN_CUDA_ARCH)"},
{"lineNum":"  316","line":"    return CUDART_INF_F;"},
{"lineNum":"  317","line":"  #else"},
{"lineNum":"  318","line":"    return HIPRT_INF_F;"},
{"lineNum":"  319","line":"  #endif"},
{"lineNum":"  320","line":"  }"},
{"lineNum":"  321","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  322","line":"  static float quiet_NaN() {"},
{"lineNum":"  323","line":"  #if defined(EIGEN_CUDA_ARCH)"},
{"lineNum":"  324","line":"    return CUDART_NAN_F;"},
{"lineNum":"  325","line":"  #else"},
{"lineNum":"  326","line":"    return HIPRT_NAN_F;"},
{"lineNum":"  327","line":"  #endif"},
{"lineNum":"  328","line":"  }"},
{"lineNum":"  329","line":"};"},
{"lineNum":"  330","line":"template<> struct numeric_limits<double>"},
{"lineNum":"  331","line":"{"},
{"lineNum":"  332","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  333","line":"  static double epsilon() { return __DBL_EPSILON__; }"},
{"lineNum":"  334","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  335","line":"  static double (max)() { return DBL_MAX; }"},
{"lineNum":"  336","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  337","line":"  static double (min)() { return DBL_MIN; }"},
{"lineNum":"  338","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  339","line":"  static double infinity() {"},
{"lineNum":"  340","line":"  #if defined(EIGEN_CUDA_ARCH)"},
{"lineNum":"  341","line":"    return CUDART_INF;"},
{"lineNum":"  342","line":"  #else"},
{"lineNum":"  343","line":"    return HIPRT_INF;"},
{"lineNum":"  344","line":"  #endif"},
{"lineNum":"  345","line":"  }"},
{"lineNum":"  346","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  347","line":"  static double quiet_NaN() {"},
{"lineNum":"  348","line":"  #if defined(EIGEN_CUDA_ARCH)"},
{"lineNum":"  349","line":"    return CUDART_NAN;"},
{"lineNum":"  350","line":"  #else"},
{"lineNum":"  351","line":"    return HIPRT_NAN;"},
{"lineNum":"  352","line":"  #endif"},
{"lineNum":"  353","line":"  }"},
{"lineNum":"  354","line":"};"},
{"lineNum":"  355","line":"template<> struct numeric_limits<int>"},
{"lineNum":"  356","line":"{"},
{"lineNum":"  357","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  358","line":"  static int epsilon() { return 0; }"},
{"lineNum":"  359","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  360","line":"  static int (max)() { return INT_MAX; }"},
{"lineNum":"  361","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  362","line":"  static int (min)() { return INT_MIN; }"},
{"lineNum":"  363","line":"};"},
{"lineNum":"  364","line":"template<> struct numeric_limits<unsigned int>"},
{"lineNum":"  365","line":"{"},
{"lineNum":"  366","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  367","line":"  static unsigned int epsilon() { return 0; }"},
{"lineNum":"  368","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  369","line":"  static unsigned int (max)() { return UINT_MAX; }"},
{"lineNum":"  370","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  371","line":"  static unsigned int (min)() { return 0; }"},
{"lineNum":"  372","line":"};"},
{"lineNum":"  373","line":"template<> struct numeric_limits<long>"},
{"lineNum":"  374","line":"{"},
{"lineNum":"  375","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  376","line":"  static long epsilon() { return 0; }"},
{"lineNum":"  377","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  378","line":"  static long (max)() { return LONG_MAX; }"},
{"lineNum":"  379","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  380","line":"  static long (min)() { return LONG_MIN; }"},
{"lineNum":"  381","line":"};"},
{"lineNum":"  382","line":"template<> struct numeric_limits<unsigned long>"},
{"lineNum":"  383","line":"{"},
{"lineNum":"  384","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  385","line":"  static unsigned long epsilon() { return 0; }"},
{"lineNum":"  386","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  387","line":"  static unsigned long (max)() { return ULONG_MAX; }"},
{"lineNum":"  388","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  389","line":"  static unsigned long (min)() { return 0; }"},
{"lineNum":"  390","line":"};"},
{"lineNum":"  391","line":"template<> struct numeric_limits<long long>"},
{"lineNum":"  392","line":"{"},
{"lineNum":"  393","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  394","line":"  static long long epsilon() { return 0; }"},
{"lineNum":"  395","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  396","line":"  static long long (max)() { return LLONG_MAX; }"},
{"lineNum":"  397","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  398","line":"  static long long (min)() { return LLONG_MIN; }"},
{"lineNum":"  399","line":"};"},
{"lineNum":"  400","line":"template<> struct numeric_limits<unsigned long long>"},
{"lineNum":"  401","line":"{"},
{"lineNum":"  402","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  403","line":"  static unsigned long long epsilon() { return 0; }"},
{"lineNum":"  404","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  405","line":"  static unsigned long long (max)() { return ULLONG_MAX; }"},
{"lineNum":"  406","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  407","line":"  static unsigned long long (min)() { return 0; }"},
{"lineNum":"  408","line":"};"},
{"lineNum":"  409","line":"template<> struct numeric_limits<bool>"},
{"lineNum":"  410","line":"{"},
{"lineNum":"  411","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  412","line":"  static bool epsilon() { return false; }"},
{"lineNum":"  413","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  414","line":"  static bool (max)() { return true; }"},
{"lineNum":"  415","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  416","line":"  static bool (min)() { return false; }"},
{"lineNum":"  417","line":"};"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"}"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"#endif // defined(EIGEN_GPU_COMPILE_PHASE) && !EIGEN_HAS_CXX11"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"/** \\internal"},
{"lineNum":"  424","line":"  * A base class do disable default copy ctor and copy assignment operator."},
{"lineNum":"  425","line":"  */"},
{"lineNum":"  426","line":"class noncopyable"},
{"lineNum":"  427","line":"{"},
{"lineNum":"  428","line":"  EIGEN_DEVICE_FUNC noncopyable(const noncopyable&);"},
{"lineNum":"  429","line":"  EIGEN_DEVICE_FUNC const noncopyable& operator=(const noncopyable&);"},
{"lineNum":"  430","line":"protected:"},
{"lineNum":"  431","line":"  EIGEN_DEVICE_FUNC noncopyable() {}"},
{"lineNum":"  432","line":"  EIGEN_DEVICE_FUNC ~noncopyable() {}"},
{"lineNum":"  433","line":"};"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"/** \\internal"},
{"lineNum":"  436","line":"  * Provides access to the number of elements in the object of as a compile-time constant expression."},
{"lineNum":"  437","line":"  * It \"returns\" Eigen::Dynamic if the size cannot be resolved at compile-time (default)."},
{"lineNum":"  438","line":"  *"},
{"lineNum":"  439","line":"  * Similar to std::tuple_size, but more general."},
{"lineNum":"  440","line":"  *"},
{"lineNum":"  441","line":"  * It currently supports:"},
{"lineNum":"  442","line":"  *  - any types T defining T::SizeAtCompileTime"},
{"lineNum":"  443","line":"  *  - plain C arrays as T[N]"},
{"lineNum":"  444","line":"  *  - std::array (c++11)"},
{"lineNum":"  445","line":"  *  - some internal types such as SingleRange and AllRange"},
{"lineNum":"  446","line":"  *"},
{"lineNum":"  447","line":"  * The second template parameter eases SFINAE-based specializations."},
{"lineNum":"  448","line":"  */"},
{"lineNum":"  449","line":"template<typename T, typename EnableIf = void> struct array_size {"},
{"lineNum":"  450","line":"  enum { value = Dynamic };"},
{"lineNum":"  451","line":"};"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"template<typename T> struct array_size<T,typename internal::enable_if<((T::SizeAtCompileTime&0)==0)>::type> {"},
{"lineNum":"  454","line":"  enum { value = T::SizeAtCompileTime };"},
{"lineNum":"  455","line":"};"},
{"lineNum":"  456","line":""},
{"lineNum":"  457","line":"template<typename T, int N> struct array_size<const T (&)[N]> {"},
{"lineNum":"  458","line":"  enum { value = N };"},
{"lineNum":"  459","line":"};"},
{"lineNum":"  460","line":"template<typename T, int N> struct array_size<T (&)[N]> {"},
{"lineNum":"  461","line":"  enum { value = N };"},
{"lineNum":"  462","line":"};"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"#if EIGEN_HAS_CXX11"},
{"lineNum":"  465","line":"template<typename T, std::size_t N> struct array_size<const std::array<T,N> > {"},
{"lineNum":"  466","line":"  enum { value = N };"},
{"lineNum":"  467","line":"};"},
{"lineNum":"  468","line":"template<typename T, std::size_t N> struct array_size<std::array<T,N> > {"},
{"lineNum":"  469","line":"  enum { value = N };"},
{"lineNum":"  470","line":"};"},
{"lineNum":"  471","line":"#endif"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"/** \\internal"},
{"lineNum":"  474","line":"  * Analogue of the std::size free function."},
{"lineNum":"  475","line":"  * It returns the size of the container or view \\a x of type \\c T"},
{"lineNum":"  476","line":"  *"},
{"lineNum":"  477","line":"  * It currently supports:"},
{"lineNum":"  478","line":"  *  - any types T defining a member T::size() const"},
{"lineNum":"  479","line":"  *  - plain C arrays as T[N]"},
{"lineNum":"  480","line":"  *"},
{"lineNum":"  481","line":"  */"},
{"lineNum":"  482","line":"template<typename T>"},
{"lineNum":"  483","line":"EIGEN_CONSTEXPR Index size(const T& x) { return x.size(); }"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"template<typename T,std::size_t N>"},
{"lineNum":"  486","line":"EIGEN_CONSTEXPR Index size(const T (&) [N]) { return N; }"},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"/** \\internal"},
{"lineNum":"  489","line":"  * Convenient struct to get the result type of a nullary, unary, binary, or"},
{"lineNum":"  490","line":"  * ternary functor."},
{"lineNum":"  491","line":"  *"},
{"lineNum":"  492","line":"  * Pre C++11:"},
{"lineNum":"  493","line":"  * Supports both a Func::result_type member and templated"},
{"lineNum":"  494","line":"  * Func::result<Func(ArgTypes...)>::type member."},
{"lineNum":"  495","line":"  *"},
{"lineNum":"  496","line":"  * If none of these members is provided, then the type of the first"},
{"lineNum":"  497","line":"  * argument is returned."},
{"lineNum":"  498","line":"  *"},
{"lineNum":"  499","line":"  * Post C++11:"},
{"lineNum":"  500","line":"  * This uses std::result_of. However, note the `type` member removes"},
{"lineNum":"  501","line":"  * const and converts references/pointers to their corresponding value type."},
{"lineNum":"  502","line":"  */"},
{"lineNum":"  503","line":"#if EIGEN_HAS_STD_INVOKE_RESULT"},
{"lineNum":"  504","line":"template<typename T> struct result_of;"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"template<typename F, typename... ArgTypes>"},
{"lineNum":"  507","line":"struct result_of<F(ArgTypes...)> {"},
{"lineNum":"  508","line":"  typedef typename std::invoke_result<F, ArgTypes...>::type type1;"},
{"lineNum":"  509","line":"  typedef typename remove_all<type1>::type type;"},
{"lineNum":"  510","line":"};"},
{"lineNum":"  511","line":"#elif EIGEN_HAS_STD_RESULT_OF"},
{"lineNum":"  512","line":"template<typename T> struct result_of {"},
{"lineNum":"  513","line":"  typedef typename std::result_of<T>::type type1;"},
{"lineNum":"  514","line":"  typedef typename remove_all<type1>::type type;"},
{"lineNum":"  515","line":"};"},
{"lineNum":"  516","line":"#else"},
{"lineNum":"  517","line":"template<typename T> struct result_of { };"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"struct has_none {int a[1];};"},
{"lineNum":"  520","line":"struct has_std_result_type {int a[2];};"},
{"lineNum":"  521","line":"struct has_tr1_result {int a[3];};"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"template<typename Func, int SizeOf>"},
{"lineNum":"  524","line":"struct nullary_result_of_select {};"},
{"lineNum":"  525","line":""},
{"lineNum":"  526","line":"template<typename Func>"},
{"lineNum":"  527","line":"struct nullary_result_of_select<Func, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"template<typename Func>"},
{"lineNum":"  530","line":"struct nullary_result_of_select<Func, sizeof(has_tr1_result)> {typedef typename Func::template result<Func()>::type type;};"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"template<typename Func>"},
{"lineNum":"  533","line":"struct result_of<Func()> {"},
{"lineNum":"  534","line":"    template<typename T>"},
{"lineNum":"  535","line":"    static has_std_result_type    testFunctor(T const *, typename T::result_type const * = 0);"},
{"lineNum":"  536","line":"    template<typename T>"},
{"lineNum":"  537","line":"    static has_tr1_result         testFunctor(T const *, typename T::template result<T()>::type const * = 0);"},
{"lineNum":"  538","line":"    static has_none               testFunctor(...);"},
{"lineNum":"  539","line":""},
{"lineNum":"  540","line":"    // note that the following indirection is needed for gcc-3.3"},
{"lineNum":"  541","line":"    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};"},
{"lineNum":"  542","line":"    typedef typename nullary_result_of_select<Func, FunctorType>::type type;"},
{"lineNum":"  543","line":"};"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"template<typename Func, typename ArgType, int SizeOf=sizeof(has_none)>"},
{"lineNum":"  546","line":"struct unary_result_of_select {typedef typename internal::remove_all<ArgType>::type type;};"},
{"lineNum":"  547","line":""},
{"lineNum":"  548","line":"template<typename Func, typename ArgType>"},
{"lineNum":"  549","line":"struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};"},
{"lineNum":"  550","line":""},
{"lineNum":"  551","line":"template<typename Func, typename ArgType>"},
{"lineNum":"  552","line":"struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};"},
{"lineNum":"  553","line":""},
{"lineNum":"  554","line":"template<typename Func, typename ArgType>"},
{"lineNum":"  555","line":"struct result_of<Func(ArgType)> {"},
{"lineNum":"  556","line":"    template<typename T>"},
{"lineNum":"  557","line":"    static has_std_result_type    testFunctor(T const *, typename T::result_type const * = 0);"},
{"lineNum":"  558","line":"    template<typename T>"},
{"lineNum":"  559","line":"    static has_tr1_result         testFunctor(T const *, typename T::template result<T(ArgType)>::type const * = 0);"},
{"lineNum":"  560","line":"    static has_none               testFunctor(...);"},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"    // note that the following indirection is needed for gcc-3.3"},
{"lineNum":"  563","line":"    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};"},
{"lineNum":"  564","line":"    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;"},
{"lineNum":"  565","line":"};"},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"template<typename Func, typename ArgType0, typename ArgType1, int SizeOf=sizeof(has_none)>"},
{"lineNum":"  568","line":"struct binary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};"},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"template<typename Func, typename ArgType0, typename ArgType1>"},
{"lineNum":"  571","line":"struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>"},
{"lineNum":"  572","line":"{typedef typename Func::result_type type;};"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"template<typename Func, typename ArgType0, typename ArgType1>"},
{"lineNum":"  575","line":"struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>"},
{"lineNum":"  576","line":"{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};"},
{"lineNum":"  577","line":""},
{"lineNum":"  578","line":"template<typename Func, typename ArgType0, typename ArgType1>"},
{"lineNum":"  579","line":"struct result_of<Func(ArgType0,ArgType1)> {"},
{"lineNum":"  580","line":"    template<typename T>"},
{"lineNum":"  581","line":"    static has_std_result_type    testFunctor(T const *, typename T::result_type const * = 0);"},
{"lineNum":"  582","line":"    template<typename T>"},
{"lineNum":"  583","line":"    static has_tr1_result         testFunctor(T const *, typename T::template result<T(ArgType0,ArgType1)>::type const * = 0);"},
{"lineNum":"  584","line":"    static has_none               testFunctor(...);"},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"    // note that the following indirection is needed for gcc-3.3"},
{"lineNum":"  587","line":"    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};"},
{"lineNum":"  588","line":"    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;"},
{"lineNum":"  589","line":"};"},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"template<typename Func, typename ArgType0, typename ArgType1, typename ArgType2, int SizeOf=sizeof(has_none)>"},
{"lineNum":"  592","line":"struct ternary_result_of_select {typedef typename internal::remove_all<ArgType0>::type type;};"},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"template<typename Func, typename ArgType0, typename ArgType1, typename ArgType2>"},
{"lineNum":"  595","line":"struct ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, sizeof(has_std_result_type)>"},
{"lineNum":"  596","line":"{typedef typename Func::result_type type;};"},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"template<typename Func, typename ArgType0, typename ArgType1, typename ArgType2>"},
{"lineNum":"  599","line":"struct ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, sizeof(has_tr1_result)>"},
{"lineNum":"  600","line":"{typedef typename Func::template result<Func(ArgType0,ArgType1,ArgType2)>::type type;};"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"template<typename Func, typename ArgType0, typename ArgType1, typename ArgType2>"},
{"lineNum":"  603","line":"struct result_of<Func(ArgType0,ArgType1,ArgType2)> {"},
{"lineNum":"  604","line":"    template<typename T>"},
{"lineNum":"  605","line":"    static has_std_result_type    testFunctor(T const *, typename T::result_type const * = 0);"},
{"lineNum":"  606","line":"    template<typename T>"},
{"lineNum":"  607","line":"    static has_tr1_result         testFunctor(T const *, typename T::template result<T(ArgType0,ArgType1,ArgType2)>::type const * = 0);"},
{"lineNum":"  608","line":"    static has_none               testFunctor(...);"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"    // note that the following indirection is needed for gcc-3.3"},
{"lineNum":"  611","line":"    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};"},
{"lineNum":"  612","line":"    typedef typename ternary_result_of_select<Func, ArgType0, ArgType1, ArgType2, FunctorType>::type type;"},
{"lineNum":"  613","line":"};"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"#endif"},
{"lineNum":"  616","line":""},
{"lineNum":"  617","line":"#if EIGEN_HAS_STD_INVOKE_RESULT"},
{"lineNum":"  618","line":"template<typename F, typename... ArgTypes>"},
{"lineNum":"  619","line":"struct invoke_result {"},
{"lineNum":"  620","line":"  typedef typename std::invoke_result<F, ArgTypes...>::type type1;"},
{"lineNum":"  621","line":"  typedef typename remove_all<type1>::type type;"},
{"lineNum":"  622","line":"};"},
{"lineNum":"  623","line":"#elif EIGEN_HAS_CXX11"},
{"lineNum":"  624","line":"template<typename F, typename... ArgTypes>"},
{"lineNum":"  625","line":"struct invoke_result {"},
{"lineNum":"  626","line":"  typedef typename result_of<F(ArgTypes...)>::type type1;"},
{"lineNum":"  627","line":"  typedef typename remove_all<type1>::type type;"},
{"lineNum":"  628","line":"};"},
{"lineNum":"  629","line":"#else"},
{"lineNum":"  630","line":"template<typename F, typename ArgType0 = void, typename ArgType1 = void, typename ArgType2 = void>"},
{"lineNum":"  631","line":"struct invoke_result {"},
{"lineNum":"  632","line":"  typedef typename result_of<F(ArgType0, ArgType1, ArgType2)>::type type1;"},
{"lineNum":"  633","line":"  typedef typename remove_all<type1>::type type;"},
{"lineNum":"  634","line":"};"},
{"lineNum":"  635","line":""},
{"lineNum":"  636","line":"template<typename F>"},
{"lineNum":"  637","line":"struct invoke_result<F, void, void, void> {"},
{"lineNum":"  638","line":"  typedef typename result_of<F()>::type type1;"},
{"lineNum":"  639","line":"  typedef typename remove_all<type1>::type type;"},
{"lineNum":"  640","line":"};"},
{"lineNum":"  641","line":""},
{"lineNum":"  642","line":"template<typename F, typename ArgType0>"},
{"lineNum":"  643","line":"struct invoke_result<F, ArgType0, void, void> {"},
{"lineNum":"  644","line":"  typedef typename result_of<F(ArgType0)>::type type1;"},
{"lineNum":"  645","line":"  typedef typename remove_all<type1>::type type;"},
{"lineNum":"  646","line":"};"},
{"lineNum":"  647","line":""},
{"lineNum":"  648","line":"template<typename F, typename ArgType0, typename ArgType1>"},
{"lineNum":"  649","line":"struct invoke_result<F, ArgType0, ArgType1, void> {"},
{"lineNum":"  650","line":"  typedef typename result_of<F(ArgType0, ArgType1)>::type type1;"},
{"lineNum":"  651","line":"  typedef typename remove_all<type1>::type type;"},
{"lineNum":"  652","line":"};"},
{"lineNum":"  653","line":"#endif"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"// C++14 integer/index_sequence."},
{"lineNum":"  656","line":"#if defined(__cpp_lib_integer_sequence) && __cpp_lib_integer_sequence >= 201304L && EIGEN_MAX_CPP_VER >= 14"},
{"lineNum":"  657","line":""},
{"lineNum":"  658","line":"using std::integer_sequence;"},
{"lineNum":"  659","line":"using std::make_integer_sequence;"},
{"lineNum":"  660","line":""},
{"lineNum":"  661","line":"using std::index_sequence;"},
{"lineNum":"  662","line":"using std::make_index_sequence;"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"#else"},
{"lineNum":"  665","line":""},
{"lineNum":"  666","line":"template <typename T, T... Ints>"},
{"lineNum":"  667","line":"struct integer_sequence {"},
{"lineNum":"  668","line":"  static EIGEN_CONSTEXPR size_t size() EIGEN_NOEXCEPT { return sizeof...(Ints); }"},
{"lineNum":"  669","line":"};"},
{"lineNum":"  670","line":""},
{"lineNum":"  671","line":"template <typename T, typename Sequence, T N>"},
{"lineNum":"  672","line":"struct append_integer;"},
{"lineNum":"  673","line":""},
{"lineNum":"  674","line":"template<typename T, T... Ints, T N>"},
{"lineNum":"  675","line":"struct append_integer<T, integer_sequence<T, Ints...>, N> {"},
{"lineNum":"  676","line":"  using type = integer_sequence<T, Ints..., N>;"},
{"lineNum":"  677","line":"};"},
{"lineNum":"  678","line":""},
{"lineNum":"  679","line":"template<typename T, size_t N>"},
{"lineNum":"  680","line":"struct generate_integer_sequence {"},
{"lineNum":"  681","line":"  using type = typename append_integer<T, typename generate_integer_sequence<T, N-1>::type, N-1>::type;"},
{"lineNum":"  682","line":"};"},
{"lineNum":"  683","line":""},
{"lineNum":"  684","line":"template<typename T>"},
{"lineNum":"  685","line":"struct generate_integer_sequence<T, 0> {"},
{"lineNum":"  686","line":"  using type = integer_sequence<T>;"},
{"lineNum":"  687","line":"};"},
{"lineNum":"  688","line":""},
{"lineNum":"  689","line":"template <typename T, size_t N>"},
{"lineNum":"  690","line":"using make_integer_sequence = typename generate_integer_sequence<T, N>::type;"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"template<size_t... Ints>"},
{"lineNum":"  693","line":"using index_sequence = integer_sequence<size_t, Ints...>;"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"template<size_t N>"},
{"lineNum":"  696","line":"using make_index_sequence = make_integer_sequence<size_t, N>;"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"#endif"},
{"lineNum":"  699","line":""},
{"lineNum":"  700","line":"// Reduces a sequence of bools to true if all are true, false otherwise."},
{"lineNum":"  701","line":"template<bool... values>"},
{"lineNum":"  702","line":"using reduce_all = std::is_same<integer_sequence<bool, values..., true>, integer_sequence<bool, true, values...> >;"},
{"lineNum":"  703","line":""},
{"lineNum":"  704","line":"// Reduces a sequence of bools to true if any are true, false if all false."},
{"lineNum":"  705","line":"template<bool... values>"},
{"lineNum":"  706","line":"using reduce_any = std::integral_constant<bool,"},
{"lineNum":"  707","line":"    !std::is_same<integer_sequence<bool, values..., false>, integer_sequence<bool, false, values...> >::value>;"},
{"lineNum":"  708","line":""},
{"lineNum":"  709","line":"struct meta_yes { char a[1]; };"},
{"lineNum":"  710","line":"struct meta_no  { char a[2]; };"},
{"lineNum":"  711","line":""},
{"lineNum":"  712","line":"// Check whether T::ReturnType does exist"},
{"lineNum":"  713","line":"template <typename T>"},
{"lineNum":"  714","line":"struct has_ReturnType"},
{"lineNum":"  715","line":"{"},
{"lineNum":"  716","line":"  template <typename C> static meta_yes testFunctor(C const *, typename C::ReturnType const * = 0);"},
{"lineNum":"  717","line":"  template <typename C> static meta_no  testFunctor(...);"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"  enum { value = sizeof(testFunctor<T>(static_cast<T*>(0))) == sizeof(meta_yes) };"},
{"lineNum":"  720","line":"};"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"template<typename T> const T* return_ptr();"},
{"lineNum":"  723","line":""},
{"lineNum":"  724","line":"template <typename T, typename IndexType=Index>"},
{"lineNum":"  725","line":"struct has_nullary_operator"},
{"lineNum":"  726","line":"{"},
{"lineNum":"  727","line":"  template <typename C> static meta_yes testFunctor(C const *,typename enable_if<(sizeof(return_ptr<C>()->operator()())>0)>::type * = 0);"},
{"lineNum":"  728","line":"  static meta_no testFunctor(...);"},
{"lineNum":"  729","line":""},
{"lineNum":"  730","line":"  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };"},
{"lineNum":"  731","line":"};"},
{"lineNum":"  732","line":""},
{"lineNum":"  733","line":"template <typename T, typename IndexType=Index>"},
{"lineNum":"  734","line":"struct has_unary_operator"},
{"lineNum":"  735","line":"{"},
{"lineNum":"  736","line":"  template <typename C> static meta_yes testFunctor(C const *,typename enable_if<(sizeof(return_ptr<C>()->operator()(IndexType(0)))>0)>::type * = 0);"},
{"lineNum":"  737","line":"  static meta_no testFunctor(...);"},
{"lineNum":"  738","line":""},
{"lineNum":"  739","line":"  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };"},
{"lineNum":"  740","line":"};"},
{"lineNum":"  741","line":""},
{"lineNum":"  742","line":"template <typename T, typename IndexType=Index>"},
{"lineNum":"  743","line":"struct has_binary_operator"},
{"lineNum":"  744","line":"{"},
{"lineNum":"  745","line":"  template <typename C> static meta_yes testFunctor(C const *,typename enable_if<(sizeof(return_ptr<C>()->operator()(IndexType(0),IndexType(0)))>0)>::type * = 0);"},
{"lineNum":"  746","line":"  static meta_no testFunctor(...);"},
{"lineNum":"  747","line":""},
{"lineNum":"  748","line":"  enum { value = sizeof(testFunctor(static_cast<T*>(0))) == sizeof(meta_yes) };"},
{"lineNum":"  749","line":"};"},
{"lineNum":"  750","line":""},
{"lineNum":"  751","line":"/** \\internal In short, it computes int(sqrt(\\a Y)) with \\a Y an integer."},
{"lineNum":"  752","line":"  * Usage example: \\code meta_sqrt<1023>::ret \\endcode"},
{"lineNum":"  753","line":"  */"},
{"lineNum":"  754","line":"template<int Y,"},
{"lineNum":"  755","line":"         int InfX = 0,"},
{"lineNum":"  756","line":"         int SupX = ((Y==1) ? 1 : Y/2),"},
{"lineNum":"  757","line":"         bool Done = ((SupX-InfX)<=1 ? true : ((SupX*SupX <= Y) && ((SupX+1)*(SupX+1) > Y))) >"},
{"lineNum":"  758","line":"                                // use ?: instead of || just to shut up a stupid gcc 4.3 warning"},
{"lineNum":"  759","line":"class meta_sqrt"},
{"lineNum":"  760","line":"{"},
{"lineNum":"  761","line":"    enum {"},
{"lineNum":"  762","line":"      MidX = (InfX+SupX)/2,"},
{"lineNum":"  763","line":"      TakeInf = MidX*MidX > Y ? 1 : 0,"},
{"lineNum":"  764","line":"      NewInf = int(TakeInf) ? InfX : int(MidX),"},
{"lineNum":"  765","line":"      NewSup = int(TakeInf) ? int(MidX) : SupX"},
{"lineNum":"  766","line":"    };"},
{"lineNum":"  767","line":"  public:"},
{"lineNum":"  768","line":"    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };"},
{"lineNum":"  769","line":"};"},
{"lineNum":"  770","line":""},
{"lineNum":"  771","line":"template<int Y, int InfX, int SupX>"},
{"lineNum":"  772","line":"class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };"},
{"lineNum":"  773","line":""},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":"/** \\internal Computes the least common multiple of two positive integer A and B"},
{"lineNum":"  776","line":"  * at compile-time."},
{"lineNum":"  777","line":"  */"},
{"lineNum":"  778","line":"template<int A, int B, int K=1, bool Done = ((A*K)%B)==0, bool Big=(A>=B)>"},
{"lineNum":"  779","line":"struct meta_least_common_multiple"},
{"lineNum":"  780","line":"{"},
{"lineNum":"  781","line":"  enum { ret = meta_least_common_multiple<A,B,K+1>::ret };"},
{"lineNum":"  782","line":"};"},
{"lineNum":"  783","line":"template<int A, int B, int K, bool Done>"},
{"lineNum":"  784","line":"struct meta_least_common_multiple<A,B,K,Done,false>"},
{"lineNum":"  785","line":"{"},
{"lineNum":"  786","line":"  enum { ret = meta_least_common_multiple<B,A,K>::ret };"},
{"lineNum":"  787","line":"};"},
{"lineNum":"  788","line":"template<int A, int B, int K>"},
{"lineNum":"  789","line":"struct meta_least_common_multiple<A,B,K,true,true>"},
{"lineNum":"  790","line":"{"},
{"lineNum":"  791","line":"  enum { ret = A*K };"},
{"lineNum":"  792","line":"};"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":""},
{"lineNum":"  795","line":"/** \\internal determines whether the product of two numeric types is allowed and what the return type is */"},
{"lineNum":"  796","line":"template<typename T, typename U> struct scalar_product_traits"},
{"lineNum":"  797","line":"{"},
{"lineNum":"  798","line":"  enum { Defined = 0 };"},
{"lineNum":"  799","line":"};"},
{"lineNum":"  800","line":""},
{"lineNum":"  801","line":"// FIXME quick workaround around current limitation of result_of"},
{"lineNum":"  802","line":"// template<typename Scalar, typename ArgType0, typename ArgType1>"},
{"lineNum":"  803","line":"// struct result_of<scalar_product_op<Scalar>(ArgType0,ArgType1)> {"},
{"lineNum":"  804","line":"// typedef typename scalar_product_traits<typename remove_all<ArgType0>::type, typename remove_all<ArgType1>::type>::ReturnType type;"},
{"lineNum":"  805","line":"// };"},
{"lineNum":"  806","line":""},
{"lineNum":"  807","line":"/** \\internal Obtains a POD type suitable to use as storage for an object of a size"},
{"lineNum":"  808","line":"  * of at most Len bytes, aligned as specified by \\c Align."},
{"lineNum":"  809","line":"  */"},
{"lineNum":"  810","line":"template<unsigned Len, unsigned Align>"},
{"lineNum":"  811","line":"struct aligned_storage {"},
{"lineNum":"  812","line":"  struct type {"},
{"lineNum":"  813","line":"    EIGEN_ALIGN_TO_BOUNDARY(Align) unsigned char data[Len];"},
{"lineNum":"  814","line":"  };"},
{"lineNum":"  815","line":"};"},
{"lineNum":"  816","line":""},
{"lineNum":"  817","line":"} // end namespace internal"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"namespace numext {"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"#if defined(EIGEN_GPU_COMPILE_PHASE)"},
{"lineNum":"  822","line":"template<typename T> EIGEN_DEVICE_FUNC   void swap(T &a, T &b) { T tmp = b; b = a; a = tmp; }"},
{"lineNum":"  823","line":"#else"},
{"lineNum":"  824","line":"template<typename T> EIGEN_STRONG_INLINE void swap(T &a, T &b) { std::swap(a,b); }"},
{"lineNum":"  825","line":"#endif"},
{"lineNum":"  826","line":""},
{"lineNum":"  827","line":"#if defined(EIGEN_GPU_COMPILE_PHASE) && !EIGEN_HAS_CXX11"},
{"lineNum":"  828","line":"using internal::device::numeric_limits;"},
{"lineNum":"  829","line":"#else"},
{"lineNum":"  830","line":"using std::numeric_limits;"},
{"lineNum":"  831","line":"#endif"},
{"lineNum":"  832","line":""},
{"lineNum":"  833","line":"// Integer division with rounding up."},
{"lineNum":"  834","line":"// T is assumed to be an integer type with a>=0, and b>0"},
{"lineNum":"  835","line":"template<typename T>"},
{"lineNum":"  836","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  837","line":"T div_ceil(const T &a, const T &b)"},
{"lineNum":"  838","line":"{"},
{"lineNum":"  839","line":"  return (a+b-1) / b;","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  840","line":"}"},
{"lineNum":"  841","line":""},
{"lineNum":"  842","line":"// The aim of the following functions is to bypass -Wfloat-equal warnings"},
{"lineNum":"  843","line":"// when we really want a strict equality comparison on floating points."},
{"lineNum":"  844","line":"template<typename X, typename Y> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC"},
{"lineNum":"  845","line":"bool equal_strict(const X& x,const Y& y) { return x == y; }"},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"#if !defined(EIGEN_GPU_COMPILE_PHASE) || (!defined(EIGEN_CUDA_ARCH) && defined(EIGEN_CONSTEXPR_ARE_DEVICE_FUNC))"},
{"lineNum":"  848","line":"template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC"},
{"lineNum":"  849","line":"bool equal_strict(const float& x,const float& y) { return std::equal_to<float>()(x,y); }"},
{"lineNum":"  850","line":""},
{"lineNum":"  851","line":"template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC"},
{"lineNum":"  852","line":"bool equal_strict(const double& x,const double& y) { return std::equal_to<double>()(x,y); }"},
{"lineNum":"  853","line":"#endif"},
{"lineNum":"  854","line":""},
{"lineNum":"  855","line":"template<typename X, typename Y> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC"},
{"lineNum":"  856","line":"bool not_equal_strict(const X& x,const Y& y) { return x != y; }"},
{"lineNum":"  857","line":""},
{"lineNum":"  858","line":"#if !defined(EIGEN_GPU_COMPILE_PHASE) || (!defined(EIGEN_CUDA_ARCH) && defined(EIGEN_CONSTEXPR_ARE_DEVICE_FUNC))"},
{"lineNum":"  859","line":"template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC"},
{"lineNum":"  860","line":"bool not_equal_strict(const float& x,const float& y) { return std::not_equal_to<float>()(x,y); }"},
{"lineNum":"  861","line":""},
{"lineNum":"  862","line":"template<> EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC"},
{"lineNum":"  863","line":"bool not_equal_strict(const double& x,const double& y) { return std::not_equal_to<double>()(x,y); }"},
{"lineNum":"  864","line":"#endif"},
{"lineNum":"  865","line":""},
{"lineNum":"  866","line":"} // end namespace numext"},
{"lineNum":"  867","line":""},
{"lineNum":"  868","line":"} // end namespace Eigen"},
{"lineNum":"  869","line":""},
{"lineNum":"  870","line":"#endif // EIGEN_META_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
