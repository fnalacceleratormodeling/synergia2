var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_SOLVETRIANGULAR_H"},
{"lineNum":"   11","line":"#define EIGEN_SOLVETRIANGULAR_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"// Forward declarations:"},
{"lineNum":"   20","line":"// The following two routines are implemented in the products/TriangularSolver*.h files"},
{"lineNum":"   21","line":"template<typename LhsScalar, typename RhsScalar, typename Index, int Side, int Mode, bool Conjugate, int StorageOrder>"},
{"lineNum":"   22","line":"struct triangular_solve_vector;"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"template <typename Scalar, typename Index, int Side, int Mode, bool Conjugate, int TriStorageOrder, int OtherStorageOrder, int OtherInnerStride>"},
{"lineNum":"   25","line":"struct triangular_solve_matrix;"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"// small helper struct extracting some traits on the underlying solver operation"},
{"lineNum":"   28","line":"template<typename Lhs, typename Rhs, int Side>"},
{"lineNum":"   29","line":"class trsolve_traits"},
{"lineNum":"   30","line":"{"},
{"lineNum":"   31","line":"  private:"},
{"lineNum":"   32","line":"    enum {"},
{"lineNum":"   33","line":"      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1"},
{"lineNum":"   34","line":"    };"},
{"lineNum":"   35","line":"  public:"},
{"lineNum":"   36","line":"    enum {"},
{"lineNum":"   37","line":"      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)"},
{"lineNum":"   38","line":"                  ? CompleteUnrolling : NoUnrolling,"},
{"lineNum":"   39","line":"      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic"},
{"lineNum":"   40","line":"    };"},
{"lineNum":"   41","line":"};"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"template<typename Lhs, typename Rhs,"},
{"lineNum":"   44","line":"  int Side, // can be OnTheLeft/OnTheRight"},
{"lineNum":"   45","line":"  int Mode, // can be Upper/Lower | UnitDiag"},
{"lineNum":"   46","line":"  int Unrolling = trsolve_traits<Lhs,Rhs,Side>::Unrolling,"},
{"lineNum":"   47","line":"  int RhsVectors = trsolve_traits<Lhs,Rhs,Side>::RhsVectors"},
{"lineNum":"   48","line":"  >"},
{"lineNum":"   49","line":"struct triangular_solver_selector;"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"template<typename Lhs, typename Rhs, int Side, int Mode>"},
{"lineNum":"   52","line":"struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>"},
{"lineNum":"   53","line":"{"},
{"lineNum":"   54","line":"  typedef typename Lhs::Scalar LhsScalar;"},
{"lineNum":"   55","line":"  typedef typename Rhs::Scalar RhsScalar;"},
{"lineNum":"   56","line":"  typedef blas_traits<Lhs> LhsProductTraits;"},
{"lineNum":"   57","line":"  typedef typename LhsProductTraits::ExtractType ActualLhsType;"},
{"lineNum":"   58","line":"  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;"},
{"lineNum":"   59","line":"  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)"},
{"lineNum":"   60","line":"  {"},
{"lineNum":"   61","line":"    ActualLhsType actualLhs = LhsProductTraits::extract(lhs);"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"    // FIXME find a way to allow an inner stride if packet_traits<Scalar>::size==1"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"    bool useRhsDirectly = Rhs::InnerStrideAtCompileTime==1 || rhs.innerStride()==1;"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"    ei_declare_aligned_stack_constructed_variable(RhsScalar,actualRhs,rhs.size(),"},
{"lineNum":"   68","line":"                                                  (useRhsDirectly ? rhs.data() : 0));"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"    if(!useRhsDirectly)"},
{"lineNum":"   71","line":"      MappedRhs(actualRhs,rhs.size()) = rhs;"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    triangular_solve_vector<LhsScalar, RhsScalar, Index, Side, Mode, LhsProductTraits::NeedToConjugate,"},
{"lineNum":"   74","line":"                            (int(Lhs::Flags) & RowMajorBit) ? RowMajor : ColMajor>"},
{"lineNum":"   75","line":"      ::run(actualLhs.cols(), actualLhs.data(), actualLhs.outerStride(), actualRhs);"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"    if(!useRhsDirectly)"},
{"lineNum":"   78","line":"      rhs = MappedRhs(actualRhs, rhs.size());"},
{"lineNum":"   79","line":"  }"},
{"lineNum":"   80","line":"};"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"// the rhs is a matrix"},
{"lineNum":"   83","line":"template<typename Lhs, typename Rhs, int Side, int Mode>"},
{"lineNum":"   84","line":"struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>"},
{"lineNum":"   85","line":"{"},
{"lineNum":"   86","line":"  typedef typename Rhs::Scalar Scalar;"},
{"lineNum":"   87","line":"  typedef blas_traits<Lhs> LhsProductTraits;"},
{"lineNum":"   88","line":"  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)"},
{"lineNum":"   91","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"   92","line":"    typename internal::add_const_on_value_type<ActualLhsType>::type actualLhs = LhsProductTraits::extract(lhs);"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"    const Index size = lhs.rows();"},
{"lineNum":"   95","line":"    const Index othersize = Side==OnTheLeft? rhs.cols() : rhs.rows();"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"    typedef internal::gemm_blocking_space<(Rhs::Flags&RowMajorBit) ? RowMajor : ColMajor,Scalar,Scalar,"},
{"lineNum":"   98","line":"              Rhs::MaxRowsAtCompileTime, Rhs::MaxColsAtCompileTime, Lhs::MaxRowsAtCompileTime,4> BlockingType;"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"    BlockingType blocking(rhs.rows(), rhs.cols(), size, 1, false);"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    triangular_solve_matrix<Scalar,Index,Side,Mode,LhsProductTraits::NeedToConjugate,(int(Lhs::Flags) & RowMajorBit) ? RowMajor : ColMajor,","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  103","line":"                               (Rhs::Flags&RowMajorBit) ? RowMajor : ColMajor, Rhs::InnerStrideAtCompileTime>"},
{"lineNum":"  104","line":"      ::run(size, othersize, &actualLhs.coeffRef(0,0), actualLhs.outerStride(), &rhs.coeffRef(0,0), rhs.innerStride(), rhs.outerStride(), blocking);"},
{"lineNum":"  105","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  106","line":"};"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"/***************************************************************************"},
{"lineNum":"  109","line":"* meta-unrolling implementation"},
{"lineNum":"  110","line":"***************************************************************************/"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"template<typename Lhs, typename Rhs, int Mode, int LoopIndex, int Size,"},
{"lineNum":"  113","line":"         bool Stop = LoopIndex==Size>"},
{"lineNum":"  114","line":"struct triangular_solver_unroller;"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"template<typename Lhs, typename Rhs, int Mode, int LoopIndex, int Size>"},
{"lineNum":"  117","line":"struct triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex,Size,false> {"},
{"lineNum":"  118","line":"  enum {"},
{"lineNum":"  119","line":"    IsLower = ((Mode&Lower)==Lower),"},
{"lineNum":"  120","line":"    DiagIndex  = IsLower ? LoopIndex : Size - LoopIndex - 1,"},
{"lineNum":"  121","line":"    StartIndex = IsLower ? 0         : DiagIndex+1"},
{"lineNum":"  122","line":"  };"},
{"lineNum":"  123","line":"  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)"},
{"lineNum":"  124","line":"  {"},
{"lineNum":"  125","line":"    if (LoopIndex>0)"},
{"lineNum":"  126","line":"      rhs.coeffRef(DiagIndex) -= lhs.row(DiagIndex).template segment<LoopIndex>(StartIndex).transpose()"},
{"lineNum":"  127","line":"                                .cwiseProduct(rhs.template segment<LoopIndex>(StartIndex)).sum();"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    if(!(Mode & UnitDiag))"},
{"lineNum":"  130","line":"      rhs.coeffRef(DiagIndex) /= lhs.coeff(DiagIndex,DiagIndex);"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"    triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex+1,Size>::run(lhs,rhs);"},
{"lineNum":"  133","line":"  }"},
{"lineNum":"  134","line":"};"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"template<typename Lhs, typename Rhs, int Mode, int LoopIndex, int Size>"},
{"lineNum":"  137","line":"struct triangular_solver_unroller<Lhs,Rhs,Mode,LoopIndex,Size,true> {"},
{"lineNum":"  138","line":"  static EIGEN_DEVICE_FUNC void run(const Lhs&, Rhs&) {}"},
{"lineNum":"  139","line":"};"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"template<typename Lhs, typename Rhs, int Mode>"},
{"lineNum":"  142","line":"struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {"},
{"lineNum":"  143","line":"  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)"},
{"lineNum":"  144","line":"  { triangular_solver_unroller<Lhs,Rhs,Mode,0,Rhs::SizeAtCompileTime>::run(lhs,rhs); }"},
{"lineNum":"  145","line":"};"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"template<typename Lhs, typename Rhs, int Mode>"},
{"lineNum":"  148","line":"struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {"},
{"lineNum":"  149","line":"  static EIGEN_DEVICE_FUNC void run(const Lhs& lhs, Rhs& rhs)"},
{"lineNum":"  150","line":"  {"},
{"lineNum":"  151","line":"    Transpose<const Lhs> trLhs(lhs);"},
{"lineNum":"  152","line":"    Transpose<Rhs> trRhs(rhs);"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"    triangular_solver_unroller<Transpose<const Lhs>,Transpose<Rhs>,"},
{"lineNum":"  155","line":"                              ((Mode&Upper)==Upper ? Lower : Upper) | (Mode&UnitDiag),"},
{"lineNum":"  156","line":"                              0,Rhs::SizeAtCompileTime>::run(trLhs,trRhs);"},
{"lineNum":"  157","line":"  }"},
{"lineNum":"  158","line":"};"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"} // end namespace internal"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"/***************************************************************************"},
{"lineNum":"  163","line":"* TriangularView methods"},
{"lineNum":"  164","line":"***************************************************************************/"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"#ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  167","line":"template<typename MatrixType, unsigned int Mode>"},
{"lineNum":"  168","line":"template<int Side, typename OtherDerived>"},
{"lineNum":"  169","line":"EIGEN_DEVICE_FUNC void TriangularViewImpl<MatrixType,Mode,Dense>::solveInPlace(const MatrixBase<OtherDerived>& _other) const"},
{"lineNum":"  170","line":"{"},
{"lineNum":"  171","line":"  OtherDerived& other = _other.const_cast_derived();"},
{"lineNum":"  172","line":"  eigen_assert( derived().cols() == derived().rows() && ((Side==OnTheLeft && derived().cols() == other.rows()) || (Side==OnTheRight && derived().cols() == other.cols())) );"},
{"lineNum":"  173","line":"  eigen_assert((!(int(Mode) & int(ZeroDiag))) && bool(int(Mode) & (int(Upper) | int(Lower))));"},
{"lineNum":"  174","line":"  // If solving for a 0x0 matrix, nothing to do, simply return."},
{"lineNum":"  175","line":"  if (derived().cols() == 0)","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  176","line":"    return;"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"  enum { copy = (internal::traits<OtherDerived>::Flags & RowMajorBit)  && OtherDerived::IsVectorAtCompileTime && OtherDerived::SizeAtCompileTime!=1};"},
{"lineNum":"  179","line":"  typedef typename internal::conditional<copy,"},
{"lineNum":"  180","line":"    typename internal::plain_matrix_type_column_major<OtherDerived>::type, OtherDerived&>::type OtherCopy;"},
{"lineNum":"  181","line":"  OtherCopy otherCopy(other);"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"  internal::triangular_solver_selector<MatrixType, typename internal::remove_reference<OtherCopy>::type,","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  184","line":"    Side, Mode>::run(derived().nestedExpression(), otherCopy);"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"  if (copy)"},
{"lineNum":"  187","line":"    other = otherCopy;"},
{"lineNum":"  188","line":"}"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"template<typename Derived, unsigned int Mode>"},
{"lineNum":"  191","line":"template<int Side, typename Other>"},
{"lineNum":"  192","line":"const internal::triangular_solve_retval<Side,TriangularView<Derived,Mode>,Other>"},
{"lineNum":"  193","line":"TriangularViewImpl<Derived,Mode,Dense>::solve(const MatrixBase<Other>& other) const"},
{"lineNum":"  194","line":"{"},
{"lineNum":"  195","line":"  return internal::triangular_solve_retval<Side,TriangularViewType,Other>(derived(), other.derived());"},
{"lineNum":"  196","line":"}"},
{"lineNum":"  197","line":"#endif"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"namespace internal {"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"template<int Side, typename TriangularType, typename Rhs>"},
{"lineNum":"  203","line":"struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >"},
{"lineNum":"  204","line":"{"},
{"lineNum":"  205","line":"  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;"},
{"lineNum":"  206","line":"};"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval"},
{"lineNum":"  209","line":" : public ReturnByValue<triangular_solve_retval<Side, TriangularType, Rhs> >"},
{"lineNum":"  210","line":"{"},
{"lineNum":"  211","line":"  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;"},
{"lineNum":"  212","line":"  typedef ReturnByValue<triangular_solve_retval> Base;"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)"},
{"lineNum":"  215","line":"    : m_triangularMatrix(tri), m_rhs(rhs)"},
{"lineNum":"  216","line":"  {}"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"  inline EIGEN_CONSTEXPR Index rows() const EIGEN_NOEXCEPT { return m_rhs.rows(); }"},
{"lineNum":"  219","line":"  inline EIGEN_CONSTEXPR Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"  template<typename Dest> inline void evalTo(Dest& dst) const"},
{"lineNum":"  222","line":"  {"},
{"lineNum":"  223","line":"    if(!is_same_dense(dst,m_rhs))"},
{"lineNum":"  224","line":"      dst = m_rhs;"},
{"lineNum":"  225","line":"    m_triangularMatrix.template solveInPlace<Side>(dst);"},
{"lineNum":"  226","line":"  }"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"  protected:"},
{"lineNum":"  229","line":"    const TriangularType& m_triangularMatrix;"},
{"lineNum":"  230","line":"    typename Rhs::Nested m_rhs;"},
{"lineNum":"  231","line":"};"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"} // namespace internal"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"} // end namespace Eigen"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"#endif // EIGEN_SOLVETRIANGULAR_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 5, "covered" : 0,};
var merged_data = [];
