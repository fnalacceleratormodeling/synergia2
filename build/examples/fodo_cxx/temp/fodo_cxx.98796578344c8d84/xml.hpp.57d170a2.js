var data = {lines:[
{"lineNum":"    1","line":"/*! \\file xml.hpp"},
{"lineNum":"    2","line":"    \\brief XML input and output archives */"},
{"lineNum":"    3","line":"/*"},
{"lineNum":"    4","line":"  Copyright (c) 2014, Randolph Voorhies, Shane Grant"},
{"lineNum":"    5","line":"  All rights reserved."},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"  Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    8","line":"  modification, are permitted provided that the following conditions are met:"},
{"lineNum":"    9","line":"      * Redistributions of source code must retain the above copyright"},
{"lineNum":"   10","line":"        notice, this list of conditions and the following disclaimer."},
{"lineNum":"   11","line":"      * Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   12","line":"        notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   13","line":"        documentation and/or other materials provided with the distribution."},
{"lineNum":"   14","line":"      * Neither the name of cereal nor the"},
{"lineNum":"   15","line":"        names of its contributors may be used to endorse or promote products"},
{"lineNum":"   16","line":"        derived from this software without specific prior written permission."},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"},
{"lineNum":"   19","line":"  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"},
{"lineNum":"   20","line":"  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"},
{"lineNum":"   21","line":"  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES OR SHANE GRANT BE LIABLE FOR ANY"},
{"lineNum":"   22","line":"  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"},
{"lineNum":"   23","line":"  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"},
{"lineNum":"   24","line":"  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"},
{"lineNum":"   25","line":"  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   26","line":"  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   27","line":"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   28","line":"*/"},
{"lineNum":"   29","line":"#ifndef CEREAL_ARCHIVES_XML_HPP_"},
{"lineNum":"   30","line":"#define CEREAL_ARCHIVES_XML_HPP_"},
{"lineNum":"   31","line":"#include \"cereal/cereal.hpp\""},
{"lineNum":"   32","line":"#include \"cereal/details/util.hpp\""},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"#include \"cereal/external/rapidxml/rapidxml.hpp\""},
{"lineNum":"   35","line":"#include \"cereal/external/rapidxml/rapidxml_print.hpp\""},
{"lineNum":"   36","line":"#include \"cereal/external/base64.hpp\""},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"#include <sstream>"},
{"lineNum":"   39","line":"#include <stack>"},
{"lineNum":"   40","line":"#include <vector>"},
{"lineNum":"   41","line":"#include <limits>"},
{"lineNum":"   42","line":"#include <string>"},
{"lineNum":"   43","line":"#include <cstring>"},
{"lineNum":"   44","line":"#include <cmath>"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"namespace cereal"},
{"lineNum":"   47","line":"{"},
{"lineNum":"   48","line":"  namespace xml_detail"},
{"lineNum":"   49","line":"  {"},
{"lineNum":"   50","line":"    #ifndef CEREAL_XML_STRING_VALUE"},
{"lineNum":"   51","line":"    //! The default name for the root node in a cereal xml archive."},
{"lineNum":"   52","line":"    /*! You can define CEREAL_XML_STRING_VALUE to be different assuming you do so"},
{"lineNum":"   53","line":"        before this file is included. */"},
{"lineNum":"   54","line":"    #define CEREAL_XML_STRING_VALUE \"cereal\""},
{"lineNum":"   55","line":"    #endif // CEREAL_XML_STRING_VALUE"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    //! The name given to the root node in a cereal xml archive"},
{"lineNum":"   58","line":"    static const char * CEREAL_XML_STRING = CEREAL_XML_STRING_VALUE;"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"    //! Returns true if the character is whitespace"},
{"lineNum":"   61","line":"    inline bool isWhitespace( char c )"},
{"lineNum":"   62","line":"    {"},
{"lineNum":"   63","line":"      return c == \' \' || c == \'\\t\' || c == \'\\n\' || c == \'\\r\';","class":"lineNoCov","hits":"0","possible_hits":"39",},
{"lineNum":"   64","line":"    }"},
{"lineNum":"   65","line":"  }"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"  // ######################################################################"},
{"lineNum":"   68","line":"  //! An output archive designed to save data to XML"},
{"lineNum":"   69","line":"  /*! This archive uses RapidXML to build an in memory XML tree of the"},
{"lineNum":"   70","line":"      data it serializes before outputting it to its stream upon destruction."},
{"lineNum":"   71","line":"      This archive should be used in an RAII fashion, letting"},
{"lineNum":"   72","line":"      the automatic destruction of the object cause the flush to its stream."},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"      XML archives provides a human readable output but at decreased"},
{"lineNum":"   75","line":"      performance (both in time and space) compared to binary archives."},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"      XML benefits greatly from name-value pairs, which if present, will"},
{"lineNum":"   78","line":"      name the nodes in the output.  If these are not present, each level"},
{"lineNum":"   79","line":"      of the output tree will be given an automatically generated delimited name."},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"      The precision of the output archive controls the number of decimals output"},
{"lineNum":"   82","line":"      for floating point numbers and should be sufficiently large (i.e. at least 20)"},
{"lineNum":"   83","line":"      if there is a desire to have binary equality between the numbers output and"},
{"lineNum":"   84","line":"      those read in.  In general you should expect a loss of precision when going"},
{"lineNum":"   85","line":"      from floating point to text and back."},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"      XML archives can optionally print the type of everything they serialize, which"},
{"lineNum":"   88","line":"      adds an attribute to each node."},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"      XML archives do not output the size information for any dynamically sized structure"},
{"lineNum":"   91","line":"      and instead infer it from the number of children for a node.  This means that data"},
{"lineNum":"   92","line":"      can be hand edited for dynamic sized structures and will still be readable.  This"},
{"lineNum":"   93","line":"      is accomplished through the cereal::SizeTag object, which will also add an attribute"},
{"lineNum":"   94","line":"      to its parent field."},
{"lineNum":"   95","line":"      \\ingroup Archives */"},
{"lineNum":"   96","line":"  class XMLOutputArchive : public OutputArchive<XMLOutputArchive>, public traits::TextArchive"},
{"lineNum":"   97","line":"  {"},
{"lineNum":"   98","line":"    public:"},
{"lineNum":"   99","line":"      /*! @name Common Functionality"},
{"lineNum":"  100","line":"          Common use cases for directly interacting with an XMLOutputArchive */"},
{"lineNum":"  101","line":"      //! @{"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"      //! A class containing various advanced options for the XML archive"},
{"lineNum":"  104","line":"      /*! Options can either be directly passed to the constructor, or chained using the"},
{"lineNum":"  105","line":"          modifier functions for an interface analogous to named parameters */"},
{"lineNum":"  106","line":"      class Options"},
{"lineNum":"  107","line":"      {"},
{"lineNum":"  108","line":"        public:"},
{"lineNum":"  109","line":"          //! Default options"},
{"lineNum":"  110","line":"          static Options Default(){ return Options(); }"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"          //! Specify specific options for the XMLOutputArchive"},
{"lineNum":"  113","line":"          /*! @param precision_ The precision used for floating point numbers"},
{"lineNum":"  114","line":"              @param indent_ Whether to indent each line of XML"},
{"lineNum":"  115","line":"              @param outputType_ Whether to output the type of each serialized object as an attribute"},
{"lineNum":"  116","line":"              @param sizeAttributes_ Whether dynamically sized containers output the size=dynamic attribute */"},
{"lineNum":"  117","line":"          explicit Options( int precision_ = std::numeric_limits<double>::max_digits10,"},
{"lineNum":"  118","line":"                            bool indent_ = true,"},
{"lineNum":"  119","line":"                            bool outputType_ = false,"},
{"lineNum":"  120","line":"                            bool sizeAttributes_ = true ) :"},
{"lineNum":"  121","line":"            itsPrecision( precision_ ),"},
{"lineNum":"  122","line":"            itsIndent( indent_ ),"},
{"lineNum":"  123","line":"            itsOutputType( outputType_ ),"},
{"lineNum":"  124","line":"            itsSizeAttributes( sizeAttributes_ )"},
{"lineNum":"  125","line":"          { }"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"          /*! @name Option Modifiers"},
{"lineNum":"  128","line":"              An interface for setting option settings analogous to named parameters."},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"              @code{cpp}"},
{"lineNum":"  131","line":"              cereal::XMLOutputArchive ar( myStream,"},
{"lineNum":"  132","line":"                                           cereal::XMLOutputArchive::Options()"},
{"lineNum":"  133","line":"                                           .indent(true)"},
{"lineNum":"  134","line":"                                           .sizeAttributes(false) );"},
{"lineNum":"  135","line":"              @endcode"},
{"lineNum":"  136","line":"              */"},
{"lineNum":"  137","line":"          //! @{"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"          //! Sets the precision used for floaing point numbers"},
{"lineNum":"  140","line":"          Options & precision( int value ){ itsPrecision = value; return * this; }"},
{"lineNum":"  141","line":"          //! Whether to indent each line of XML"},
{"lineNum":"  142","line":"          Options & indent( bool enable ){ itsIndent = enable; return *this; }"},
{"lineNum":"  143","line":"          //! Whether to output the type of each serialized object as an attribute"},
{"lineNum":"  144","line":"          Options & outputType( bool enable ){ itsOutputType = enable; return *this; }"},
{"lineNum":"  145","line":"          //! Whether dynamically sized containers (e.g. vector) output the size=dynamic attribute"},
{"lineNum":"  146","line":"          Options & sizeAttributes( bool enable ){ itsSizeAttributes = enable; return *this; }"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"          //! @}"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"        private:"},
{"lineNum":"  151","line":"          friend class XMLOutputArchive;"},
{"lineNum":"  152","line":"          int itsPrecision;"},
{"lineNum":"  153","line":"          bool itsIndent;"},
{"lineNum":"  154","line":"          bool itsOutputType;"},
{"lineNum":"  155","line":"          bool itsSizeAttributes;"},
{"lineNum":"  156","line":"      };"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"      //! Construct, outputting to the provided stream upon destruction"},
{"lineNum":"  159","line":"      /*! @param stream  The stream to output to.  Note that XML is only guaranteed to flush"},
{"lineNum":"  160","line":"                         its output to the stream upon destruction."},
{"lineNum":"  161","line":"          @param options The XML specific options to use.  See the Options struct"},
{"lineNum":"  162","line":"                         for the values of default parameters */"},
{"lineNum":"  163","line":"      XMLOutputArchive( std::ostream & stream, Options const & options = Options::Default() ) :"},
{"lineNum":"  164","line":"        OutputArchive<XMLOutputArchive>(this),"},
{"lineNum":"  165","line":"        itsStream(stream),"},
{"lineNum":"  166","line":"        itsOutputType( options.itsOutputType ),"},
{"lineNum":"  167","line":"        itsIndent( options.itsIndent ),"},
{"lineNum":"  168","line":"        itsSizeAttributes(options.itsSizeAttributes)"},
{"lineNum":"  169","line":"      {"},
{"lineNum":"  170","line":"        // rapidxml will delete all allocations when xml_document is cleared"},
{"lineNum":"  171","line":"        auto node = itsXML.allocate_node( rapidxml::node_declaration );"},
{"lineNum":"  172","line":"        node->append_attribute( itsXML.allocate_attribute( \"version\", \"1.0\" ) );"},
{"lineNum":"  173","line":"        node->append_attribute( itsXML.allocate_attribute( \"encoding\", \"utf-8\" ) );"},
{"lineNum":"  174","line":"        itsXML.append_node( node );"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"        // allocate root node"},
{"lineNum":"  177","line":"        auto root = itsXML.allocate_node( rapidxml::node_element, xml_detail::CEREAL_XML_STRING );"},
{"lineNum":"  178","line":"        itsXML.append_node( root );"},
{"lineNum":"  179","line":"        itsNodes.emplace( root );"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"        // set attributes on the streams"},
{"lineNum":"  182","line":"        itsStream << std::boolalpha;"},
{"lineNum":"  183","line":"        itsStream.precision( options.itsPrecision );"},
{"lineNum":"  184","line":"        itsOS << std::boolalpha;"},
{"lineNum":"  185","line":"        itsOS.precision( options.itsPrecision );"},
{"lineNum":"  186","line":"      }"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"      //! Destructor, flushes the XML"},
{"lineNum":"  189","line":"      ~XMLOutputArchive() CEREAL_NOEXCEPT"},
{"lineNum":"  190","line":"      {"},
{"lineNum":"  191","line":"        const int flags = itsIndent ? 0x0 : rapidxml::print_no_indenting;"},
{"lineNum":"  192","line":"        rapidxml::print( itsStream, itsXML, flags );"},
{"lineNum":"  193","line":"        itsXML.clear();"},
{"lineNum":"  194","line":"      }"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"      //! Saves some binary data, encoded as a base64 string, with an optional name"},
{"lineNum":"  197","line":"      /*! This can be called directly by users and it will automatically create a child node for"},
{"lineNum":"  198","line":"          the current XML node, populate it with a base64 encoded string, and optionally name"},
{"lineNum":"  199","line":"          it.  The node will be finished after it has been populated.  */"},
{"lineNum":"  200","line":"      void saveBinaryValue( const void * data, size_t size, const char * name = nullptr )"},
{"lineNum":"  201","line":"      {"},
{"lineNum":"  202","line":"        itsNodes.top().name = name;"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"        startNode();"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"        auto base64string = base64::encode( reinterpret_cast<const unsigned char *>( data ), size );"},
{"lineNum":"  207","line":"        saveValue( base64string );"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"        if( itsOutputType )"},
{"lineNum":"  210","line":"          itsNodes.top().node->append_attribute( itsXML.allocate_attribute( \"type\", \"cereal binary data\" ) );"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"        finishNode();"},
{"lineNum":"  213","line":"      }"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"      //! @}"},
{"lineNum":"  216","line":"      /*! @name Internal Functionality"},
{"lineNum":"  217","line":"          Functionality designed for use by those requiring control over the inner mechanisms of"},
{"lineNum":"  218","line":"          the XMLOutputArchive */"},
{"lineNum":"  219","line":"      //! @{"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"      //! Creates a new node that is a child of the node at the top of the stack"},
{"lineNum":"  222","line":"      /*! Nodes will be given a name that has either been pre-set by a name value pair,"},
{"lineNum":"  223","line":"          or generated based upon a counter unique to the parent node.  If you want to"},
{"lineNum":"  224","line":"          give a node a specific name, use setNextName prior to calling startNode."},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"          The node will then be pushed onto the node stack. */"},
{"lineNum":"  227","line":"      void startNode()"},
{"lineNum":"  228","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  229","line":"        // generate a name for this new node"},
{"lineNum":"  230","line":"        const auto nameString = itsNodes.top().getValueName();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"        // allocate strings for all of the data in the XML object"},
{"lineNum":"  233","line":"        auto namePtr = itsXML.allocate_string( nameString.data(), nameString.length() + 1 );","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"        // insert into the XML"},
{"lineNum":"  236","line":"        auto node = itsXML.allocate_node( rapidxml::node_element, namePtr, nullptr, nameString.size() );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  237","line":"        itsNodes.top().node->append_node( node );","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  238","line":"        itsNodes.emplace( node );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  239","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"      //! Designates the most recently added node as finished"},
{"lineNum":"  242","line":"      void finishNode()"},
{"lineNum":"  243","line":"      {"},
{"lineNum":"  244","line":"        itsNodes.pop();"},
{"lineNum":"  245","line":"      }"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"      //! Sets the name for the next node created with startNode"},
{"lineNum":"  248","line":"      void setNextName( const char * name )"},
{"lineNum":"  249","line":"      {"},
{"lineNum":"  250","line":"        itsNodes.top().name = name;","class":"lineNoCov","hits":"0","possible_hits":"179",},
{"lineNum":"  251","line":"      }"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"      //! Saves some data, encoded as a string, into the current top level node"},
{"lineNum":"  254","line":"      /*! The data will be be named with the most recent name if one exists,"},
{"lineNum":"  255","line":"          otherwise it will be given some default delimited value that depends upon"},
{"lineNum":"  256","line":"          the parent node */"},
{"lineNum":"  257","line":"      template <class T> inline"},
{"lineNum":"  258","line":"      void saveValue( T const & value )"},
{"lineNum":"  259","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  260","line":"        itsOS.clear(); itsOS.seekp( 0, std::ios::beg );","class":"lineNoCov","hits":"0","possible_hits":"23",},
{"lineNum":"  261","line":"        itsOS << value << std::ends;","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"        auto strValue = itsOS.str();"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"        // itsOS.str() may contain data from previous calls after the first \'\\0\' that was just inserted"},
{"lineNum":"  266","line":"        // and this data is counted in the length call. We make sure to remove that section so that the"},
{"lineNum":"  267","line":"        // whitespace validation is done properly"},
{"lineNum":"  268","line":"        strValue.resize(std::strlen(strValue.c_str()));","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"        // If the first or last character is a whitespace, add xml:space attribute"},
{"lineNum":"  271","line":"        const auto len = strValue.length();","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  272","line":"        if ( len > 0 && ( xml_detail::isWhitespace( strValue[0] ) || xml_detail::isWhitespace( strValue[len - 1] ) ) )","class":"lineNoCov","hits":"0","possible_hits":"71",},
{"lineNum":"  273","line":"        {"},
{"lineNum":"  274","line":"          itsNodes.top().node->append_attribute( itsXML.allocate_attribute( \"xml:space\", \"preserve\" ) );","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  275","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"        // allocate strings for all of the data in the XML object"},
{"lineNum":"  278","line":"        auto dataPtr = itsXML.allocate_string(strValue.c_str(), strValue.length() + 1 );","class":"lineNoCov","hits":"0","possible_hits":"23",},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"        // insert into the XML"},
{"lineNum":"  281","line":"        itsNodes.top().node->append_node( itsXML.allocate_node( rapidxml::node_data, nullptr, dataPtr ) );","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  282","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"      //! Overload for uint8_t prevents them from being serialized as characters"},
{"lineNum":"  285","line":"      void saveValue( uint8_t const & value )"},
{"lineNum":"  286","line":"      {"},
{"lineNum":"  287","line":"        saveValue( static_cast<uint32_t>( value ) );","class":"lineNoCov","hits":"0","possible_hits":"37",},
{"lineNum":"  288","line":"      }"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"      //! Overload for int8_t prevents them from being serialized as characters"},
{"lineNum":"  291","line":"      void saveValue( int8_t const & value )"},
{"lineNum":"  292","line":"      {"},
{"lineNum":"  293","line":"        saveValue( static_cast<int32_t>( value ) );"},
{"lineNum":"  294","line":"      }"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"      //! Causes the type to be appended as an attribute to the most recently made node if output type is set to true"},
{"lineNum":"  297","line":"      template <class T> inline"},
{"lineNum":"  298","line":"      void insertType()"},
{"lineNum":"  299","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"127",},
{"lineNum":"  300","line":"        if( !itsOutputType )","class":"lineNoCov","hits":"0","possible_hits":"127",},
{"lineNum":"  301","line":"          return;","class":"lineNoCov","hits":"0","possible_hits":"40",},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"        // generate a name for this new node"},
{"lineNum":"  304","line":"        const auto nameString = util::demangledName<T>();","class":"lineNoCov","hits":"0","possible_hits":"127",},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"        // allocate strings for all of the data in the XML object"},
{"lineNum":"  307","line":"        auto namePtr = itsXML.allocate_string( nameString.data(), nameString.length() + 1 );","class":"lineNoCov","hits":"0","possible_hits":"254",},
{"lineNum":"  308","line":""},
{"lineNum":"  309","line":"        itsNodes.top().node->append_attribute( itsXML.allocate_attribute( \"type\", namePtr ) );","class":"lineNoCov","hits":"0","possible_hits":"127",},
{"lineNum":"  310","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"167",},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"      //! Appends an attribute to the current top level node"},
{"lineNum":"  313","line":"      void appendAttribute( const char * name, const char * value )"},
{"lineNum":"  314","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  315","line":"        auto namePtr =  itsXML.allocate_string( name );"},
{"lineNum":"  316","line":"        auto valuePtr = itsXML.allocate_string( value );"},
{"lineNum":"  317","line":"        itsNodes.top().node->append_attribute( itsXML.allocate_attribute( namePtr, valuePtr ) );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  318","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"      bool hasSizeAttributes() const { return itsSizeAttributes; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"    protected:"},
{"lineNum":"  323","line":"      //! A struct that contains metadata about a node"},
{"lineNum":"  324","line":"      struct NodeInfo"},
{"lineNum":"  325","line":"      {"},
{"lineNum":"  326","line":"        NodeInfo( rapidxml::xml_node<> * n = nullptr,"},
{"lineNum":"  327","line":"                  const char * nm = nullptr ) :"},
{"lineNum":"  328","line":"          node( n ),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  329","line":"          counter( 0 ),"},
{"lineNum":"  330","line":"          name( nm )","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  331","line":"        { }"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"        rapidxml::xml_node<> * node; //!< A pointer to this node"},
{"lineNum":"  334","line":"        size_t counter;              //!< The counter for naming child nodes"},
{"lineNum":"  335","line":"        const char * name;           //!< The name for the next child node"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"        //! Gets the name for the next child node created from this node"},
{"lineNum":"  338","line":"        /*! The name will be automatically generated using the counter if"},
{"lineNum":"  339","line":"            a name has not been previously set.  If a name has been previously"},
{"lineNum":"  340","line":"            set, that name will be returned only once */"},
{"lineNum":"  341","line":"        std::string getValueName()"},
{"lineNum":"  342","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  343","line":"          if( name )","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  344","line":"          {"},
{"lineNum":"  345","line":"            auto n = name;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  346","line":"            name = nullptr;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  347","line":"            return {n};"},
{"lineNum":"  348","line":"          }"},
{"lineNum":"  349","line":"          else"},
{"lineNum":"  350","line":"            return \"value\" + std::to_string( counter++ ) + \"\\0\";","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  351","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  352","line":"      }; // NodeInfo"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"      //! @}"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"    private:"},
{"lineNum":"  357","line":"      std::ostream & itsStream;        //!< The output stream"},
{"lineNum":"  358","line":"      rapidxml::xml_document<> itsXML; //!< The XML document"},
{"lineNum":"  359","line":"      std::stack<NodeInfo> itsNodes;   //!< A stack of nodes added to the document"},
{"lineNum":"  360","line":"      std::ostringstream itsOS;        //!< Used to format strings internally"},
{"lineNum":"  361","line":"      bool itsOutputType;              //!< Controls whether type information is printed"},
{"lineNum":"  362","line":"      bool itsIndent;                  //!< Controls whether indenting is used"},
{"lineNum":"  363","line":"      bool itsSizeAttributes;          //!< Controls whether lists have a size attribute"},
{"lineNum":"  364","line":"  }; // XMLOutputArchive"},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"  // ######################################################################"},
{"lineNum":"  367","line":"  //! An output archive designed to load data from XML"},
{"lineNum":"  368","line":"  /*! This archive uses RapidXML to build an in memory XML tree of the"},
{"lineNum":"  369","line":"      data in the stream it is given before loading any types serialized."},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"      As with the output XML archive, the preferred way to use this archive is in"},
{"lineNum":"  372","line":"      an RAII fashion, ensuring its destruction after all data has been read."},
{"lineNum":"  373","line":""},
{"lineNum":"  374","line":"      Input XML should have been produced by the XMLOutputArchive.  Data can"},
{"lineNum":"  375","line":"      only be added to dynamically sized containers - the input archive will"},
{"lineNum":"  376","line":"      determine their size by looking at the number of child nodes.  Data that"},
{"lineNum":"  377","line":"      did not originate from an XMLOutputArchive is not officially supported,"},
{"lineNum":"  378","line":"      but may be possible to use if properly formatted."},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":"      The XMLInputArchive does not require that nodes are loaded in the same"},
{"lineNum":"  381","line":"      order they were saved by XMLOutputArchive.  Using name value pairs (NVPs),"},
{"lineNum":"  382","line":"      it is possible to load in an out of order fashion or otherwise skip/select"},
{"lineNum":"  383","line":"      specific nodes to load."},
{"lineNum":"  384","line":""},
{"lineNum":"  385","line":"      The default behavior of the input archive is to read sequentially starting"},
{"lineNum":"  386","line":"      with the first node and exploring its children.  When a given NVP does"},
{"lineNum":"  387","line":"      not match the read in name for a node, the archive will search for that"},
{"lineNum":"  388","line":"      node at the current level and load it if it exists.  After loading an out of"},
{"lineNum":"  389","line":"      order node, the archive will then proceed back to loading sequentially from"},
{"lineNum":"  390","line":"      its new position."},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"      Consider this simple example where loading of some data is skipped:"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"      @code{cpp}"},
{"lineNum":"  395","line":"      // imagine the input file has someData(1-9) saved in order at the top level node"},
{"lineNum":"  396","line":"      ar( someData1, someData2, someData3 );        // XML loads in the order it sees in the file"},
{"lineNum":"  397","line":"      ar( cereal::make_nvp( \"hello\", someData6 ) ); // NVP given does not"},
{"lineNum":"  398","line":"                                                    // match expected NVP name, so we search"},
{"lineNum":"  399","line":"                                                    // for the given NVP and load that value"},
{"lineNum":"  400","line":"      ar( someData7, someData8, someData9 );        // with no NVP given, loading resumes at its"},
{"lineNum":"  401","line":"                                                    // current location, proceeding sequentially"},
{"lineNum":"  402","line":"      @endcode"},
{"lineNum":"  403","line":""},
{"lineNum":"  404","line":"      \\ingroup Archives */"},
{"lineNum":"  405","line":"  class XMLInputArchive : public InputArchive<XMLInputArchive>, public traits::TextArchive"},
{"lineNum":"  406","line":"  {"},
{"lineNum":"  407","line":"    public:"},
{"lineNum":"  408","line":"      /*! @name Common Functionality"},
{"lineNum":"  409","line":"          Common use cases for directly interacting with an XMLInputArchive */"},
{"lineNum":"  410","line":"      //! @{"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":"      //! Construct, reading in from the provided stream"},
{"lineNum":"  413","line":"      /*! Reads in an entire XML document from some stream and parses it as soon"},
{"lineNum":"  414","line":"          as serialization starts"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"          @param stream The stream to read from.  Can be a stringstream or a file. */"},
{"lineNum":"  417","line":"      XMLInputArchive( std::istream & stream ) :"},
{"lineNum":"  418","line":"        InputArchive<XMLInputArchive>( this ),"},
{"lineNum":"  419","line":"        itsData( std::istreambuf_iterator<char>( stream ), std::istreambuf_iterator<char>() )"},
{"lineNum":"  420","line":"      {"},
{"lineNum":"  421","line":"        try"},
{"lineNum":"  422","line":"        {"},
{"lineNum":"  423","line":"          itsData.push_back(\'\\0\'); // rapidxml will do terrible things without the data being null terminated"},
{"lineNum":"  424","line":"          itsXML.parse<rapidxml::parse_trim_whitespace | rapidxml::parse_no_data_nodes | rapidxml::parse_declaration_node>( reinterpret_cast<char *>( itsData.data() ) );"},
{"lineNum":"  425","line":"        }"},
{"lineNum":"  426","line":"        catch( rapidxml::parse_error const & )"},
{"lineNum":"  427","line":"        {"},
{"lineNum":"  428","line":"          //std::cerr << \"-----Original-----\" << std::endl;"},
{"lineNum":"  429","line":"          //stream.seekg(0);"},
{"lineNum":"  430","line":"          //std::cout << std::string( std::istreambuf_iterator<char>( stream ), std::istreambuf_iterator<char>() ) << std::endl;"},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"          //std::cerr << \"-----Error-----\" << std::endl;"},
{"lineNum":"  433","line":"          //std::cerr << e.what() << std::endl;"},
{"lineNum":"  434","line":"          //std::cerr << e.where<char>() << std::endl;"},
{"lineNum":"  435","line":"          throw Exception(\"XML Parsing failed - likely due to invalid characters or invalid naming\");"},
{"lineNum":"  436","line":"        }"},
{"lineNum":"  437","line":""},
{"lineNum":"  438","line":"        // Parse the root"},
{"lineNum":"  439","line":"        auto root = itsXML.first_node( xml_detail::CEREAL_XML_STRING );"},
{"lineNum":"  440","line":"        if( root == nullptr )"},
{"lineNum":"  441","line":"          throw Exception(\"Could not detect cereal root node - likely due to empty or invalid input\");"},
{"lineNum":"  442","line":"        else"},
{"lineNum":"  443","line":"          itsNodes.emplace( root );"},
{"lineNum":"  444","line":"      }"},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":"      ~XMLInputArchive() CEREAL_NOEXCEPT = default;"},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"      //! Loads some binary data, encoded as a base64 string, optionally specified by some name"},
{"lineNum":"  449","line":"      /*! This will automatically start and finish a node to load the data, and can be called directly by"},
{"lineNum":"  450","line":"          users."},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"          Note that this follows the same ordering rules specified in the class description in regards"},
{"lineNum":"  453","line":"          to loading in/out of order */"},
{"lineNum":"  454","line":"      void loadBinaryValue( void * data, size_t size, const char * name = nullptr )"},
{"lineNum":"  455","line":"      {"},
{"lineNum":"  456","line":"        setNextName( name );"},
{"lineNum":"  457","line":"        startNode();"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"        std::string encoded;"},
{"lineNum":"  460","line":"        loadValue( encoded );"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"        auto decoded = base64::decode( encoded );"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"        if( size != decoded.size() )"},
{"lineNum":"  465","line":"          throw Exception(\"Decoded binary data size does not match specified size\");"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"        std::memcpy( data, decoded.data(), decoded.size() );"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"        finishNode();"},
{"lineNum":"  470","line":"      }"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"      //! @}"},
{"lineNum":"  473","line":"      /*! @name Internal Functionality"},
{"lineNum":"  474","line":"          Functionality designed for use by those requiring control over the inner mechanisms of"},
{"lineNum":"  475","line":"          the XMLInputArchive */"},
{"lineNum":"  476","line":"      //! @{"},
{"lineNum":"  477","line":""},
{"lineNum":"  478","line":"      //! Prepares to start reading the next node"},
{"lineNum":"  479","line":"      /*! This places the next node to be parsed onto the nodes stack."},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"          By default our strategy is to start with the document root node and then"},
{"lineNum":"  482","line":"          recursively iterate through all children in the order they show up in the document."},
{"lineNum":"  483","line":"          We don\'t need to know NVPs do to this; we\'ll just blindly load in the order things appear in."},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"          We check to see if the specified NVP matches what the next automatically loaded node is.  If they"},
{"lineNum":"  486","line":"          match, we just continue as normal, going in order.  If they don\'t match, we attempt to find a node"},
{"lineNum":"  487","line":"          named after the NVP that is being loaded.  If that NVP does not exist, we throw an exception. */"},
{"lineNum":"  488","line":"      void startNode()"},
{"lineNum":"  489","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  490","line":"        auto next = itsNodes.top().child; // By default we would move to the next child node","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  491","line":"        auto const expectedName = itsNodes.top().name; // this is the expected name from the NVP, if provided","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"        // If we were given an NVP name, look for it in the current level of the document."},
{"lineNum":"  494","line":"        //    We only need to do this if either we have exhausted the siblings of the current level or"},
{"lineNum":"  495","line":"        //    the NVP name does not match the name of the node we would normally read next"},
{"lineNum":"  496","line":"        if( expectedName && ( next == nullptr || std::strcmp( next->name(), expectedName ) != 0 ) )","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  497","line":"        {"},
{"lineNum":"  498","line":"          next = itsNodes.top().search( expectedName );","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"          if( next == nullptr )","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  501","line":"            throw Exception(\"XML Parsing failed - provided NVP (\" + std::string(expectedName) + \") not found\");","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  502","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"        itsNodes.emplace( next );"},
{"lineNum":"  505","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  506","line":""},
{"lineNum":"  507","line":"      //! Finishes reading the current node"},
{"lineNum":"  508","line":"      void finishNode()"},
{"lineNum":"  509","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  510","line":"        // remove current"},
{"lineNum":"  511","line":"        itsNodes.pop();"},
{"lineNum":"  512","line":""},
{"lineNum":"  513","line":"        // advance parent"},
{"lineNum":"  514","line":"        itsNodes.top().advance();"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"        // Reset name"},
{"lineNum":"  517","line":"        itsNodes.top().name = nullptr;","class":"lineNoCov","hits":"0","possible_hits":"134",},
{"lineNum":"  518","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"      //! Retrieves the current node name"},
{"lineNum":"  521","line":"      //! will return @c nullptr if the node does not have a name"},
{"lineNum":"  522","line":"      const char * getNodeName() const"},
{"lineNum":"  523","line":"      {"},
{"lineNum":"  524","line":"        return itsNodes.top().getChildName();"},
{"lineNum":"  525","line":"      }"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"      //! Sets the name for the next node created with startNode"},
{"lineNum":"  528","line":"      void setNextName( const char * name )"},
{"lineNum":"  529","line":"      {"},
{"lineNum":"  530","line":"        itsNodes.top().name = name;","class":"lineNoCov","hits":"0","possible_hits":"138",},
{"lineNum":"  531","line":"      }"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"      //! Loads a bool from the current top node"},
{"lineNum":"  534","line":"      template <class T, traits::EnableIf<std::is_unsigned<T>::value,"},
{"lineNum":"  535","line":"                                          std::is_same<T, bool>::value> = traits::sfinae> inline"},
{"lineNum":"  536","line":"      void loadValue( T & value )"},
{"lineNum":"  537","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  538","line":"        std::istringstream is( itsNodes.top().node->value() );","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  539","line":"        is.setf( std::ios::boolalpha );","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  540","line":"        is >> value;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  541","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"      //! Loads a char (signed or unsigned) from the current top node"},
{"lineNum":"  544","line":"      template <class T, traits::EnableIf<std::is_integral<T>::value,"},
{"lineNum":"  545","line":"                                          !std::is_same<T, bool>::value,"},
{"lineNum":"  546","line":"                                          sizeof(T) == sizeof(char)> = traits::sfinae> inline"},
{"lineNum":"  547","line":"      void loadValue( T & value )"},
{"lineNum":"  548","line":"      {"},
{"lineNum":"  549","line":"        value = *reinterpret_cast<T*>( itsNodes.top().node->value() );"},
{"lineNum":"  550","line":"      }"},
{"lineNum":"  551","line":""},
{"lineNum":"  552","line":"      //! Load an int8_t from the current top node (ensures we parse entire number)"},
{"lineNum":"  553","line":"      void loadValue( int8_t & value )"},
{"lineNum":"  554","line":"      {"},
{"lineNum":"  555","line":"        int32_t val; loadValue( val ); value = static_cast<int8_t>( val );"},
{"lineNum":"  556","line":"      }"},
{"lineNum":"  557","line":""},
{"lineNum":"  558","line":"      //! Load a uint8_t from the current top node (ensures we parse entire number)"},
{"lineNum":"  559","line":"      void loadValue( uint8_t & value )"},
{"lineNum":"  560","line":"      {"},
{"lineNum":"  561","line":"        uint32_t val; loadValue( val ); value = static_cast<uint8_t>( val );","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  562","line":"      }"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"      //! Loads a type best represented as an unsigned long from the current top node"},
{"lineNum":"  565","line":"      template <class T, traits::EnableIf<std::is_unsigned<T>::value,"},
{"lineNum":"  566","line":"                                          !std::is_same<T, bool>::value,"},
{"lineNum":"  567","line":"                                          !std::is_same<T, char>::value,"},
{"lineNum":"  568","line":"                                          !std::is_same<T, unsigned char>::value,"},
{"lineNum":"  569","line":"                                          sizeof(T) < sizeof(long long)> = traits::sfinae> inline"},
{"lineNum":"  570","line":"      void loadValue( T & value )"},
{"lineNum":"  571","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  572","line":"        value = static_cast<T>( std::stoul( itsNodes.top().node->value() ) );","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  573","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  574","line":""},
{"lineNum":"  575","line":"      //! Loads a type best represented as an unsigned long long from the current top node"},
{"lineNum":"  576","line":"      template <class T, traits::EnableIf<std::is_unsigned<T>::value,"},
{"lineNum":"  577","line":"                                          !std::is_same<T, bool>::value,"},
{"lineNum":"  578","line":"                                          sizeof(T) >= sizeof(long long)> = traits::sfinae> inline"},
{"lineNum":"  579","line":"      void loadValue( T & value )"},
{"lineNum":"  580","line":"      {"},
{"lineNum":"  581","line":"        value = static_cast<T>( std::stoull( itsNodes.top().node->value() ) );"},
{"lineNum":"  582","line":"      }"},
{"lineNum":"  583","line":""},
{"lineNum":"  584","line":"      //! Loads a type best represented as an int from the current top node"},
{"lineNum":"  585","line":"      template <class T, traits::EnableIf<std::is_signed<T>::value,"},
{"lineNum":"  586","line":"                                          !std::is_same<T, char>::value,"},
{"lineNum":"  587","line":"                                          sizeof(T) <= sizeof(int)> = traits::sfinae> inline"},
{"lineNum":"  588","line":"      void loadValue( T & value )"},
{"lineNum":"  589","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  590","line":"        value = static_cast<T>( std::stoi( itsNodes.top().node->value() ) );","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  591","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  592","line":""},
{"lineNum":"  593","line":"      //! Loads a type best represented as a long from the current top node"},
{"lineNum":"  594","line":"      template <class T, traits::EnableIf<std::is_signed<T>::value,"},
{"lineNum":"  595","line":"                                          (sizeof(T) > sizeof(int)),"},
{"lineNum":"  596","line":"                                          sizeof(T) <= sizeof(long)> = traits::sfinae> inline"},
{"lineNum":"  597","line":"      void loadValue( T & value )"},
{"lineNum":"  598","line":"      {"},
{"lineNum":"  599","line":"        value = static_cast<T>( std::stol( itsNodes.top().node->value() ) );"},
{"lineNum":"  600","line":"      }"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"      //! Loads a type best represented as a long long from the current top node"},
{"lineNum":"  603","line":"      template <class T, traits::EnableIf<std::is_signed<T>::value,"},
{"lineNum":"  604","line":"                                          (sizeof(T) > sizeof(long)),"},
{"lineNum":"  605","line":"                                          sizeof(T) <= sizeof(long long)> = traits::sfinae> inline"},
{"lineNum":"  606","line":"      void loadValue( T & value )"},
{"lineNum":"  607","line":"      {"},
{"lineNum":"  608","line":"        value = static_cast<T>( std::stoll( itsNodes.top().node->value() ) );"},
{"lineNum":"  609","line":"      }"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"      //! Loads a type best represented as a float from the current top node"},
{"lineNum":"  612","line":"      void loadValue( float & value )"},
{"lineNum":"  613","line":"      {"},
{"lineNum":"  614","line":"        try"},
{"lineNum":"  615","line":"        {"},
{"lineNum":"  616","line":"          value = std::stof( itsNodes.top().node->value() );"},
{"lineNum":"  617","line":"        }"},
{"lineNum":"  618","line":"        catch( std::out_of_range const & )"},
{"lineNum":"  619","line":"        {"},
{"lineNum":"  620","line":"          // special case for denormalized values"},
{"lineNum":"  621","line":"          std::istringstream is( itsNodes.top().node->value() );"},
{"lineNum":"  622","line":"          is >> value;"},
{"lineNum":"  623","line":"          if( std::fpclassify( value ) != FP_SUBNORMAL )"},
{"lineNum":"  624","line":"            throw;"},
{"lineNum":"  625","line":"        }"},
{"lineNum":"  626","line":"      }"},
{"lineNum":"  627","line":""},
{"lineNum":"  628","line":"      //! Loads a type best represented as a double from the current top node"},
{"lineNum":"  629","line":"      void loadValue( double & value )"},
{"lineNum":"  630","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  631","line":"        try"},
{"lineNum":"  632","line":"        {"},
{"lineNum":"  633","line":"          value = std::stod( itsNodes.top().node->value() );","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  634","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  635","line":"        catch( std::out_of_range const & )"},
{"lineNum":"  636","line":"        {"},
{"lineNum":"  637","line":"          // special case for denormalized values"},
{"lineNum":"  638","line":"          std::istringstream is( itsNodes.top().node->value() );","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  639","line":"          is >> value;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  640","line":"          if( std::fpclassify( value ) != FP_SUBNORMAL )","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  641","line":"            throw;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  642","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  643","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  644","line":""},
{"lineNum":"  645","line":"      //! Loads a type best represented as a long double from the current top node"},
{"lineNum":"  646","line":"      void loadValue( long double & value )"},
{"lineNum":"  647","line":"      {"},
{"lineNum":"  648","line":"        try"},
{"lineNum":"  649","line":"        {"},
{"lineNum":"  650","line":"          value = std::stold( itsNodes.top().node->value() );"},
{"lineNum":"  651","line":"        }"},
{"lineNum":"  652","line":"        catch( std::out_of_range const & )"},
{"lineNum":"  653","line":"        {"},
{"lineNum":"  654","line":"          // special case for denormalized values"},
{"lineNum":"  655","line":"          std::istringstream is( itsNodes.top().node->value() );"},
{"lineNum":"  656","line":"          is >> value;"},
{"lineNum":"  657","line":"          if( std::fpclassify( value ) != FP_SUBNORMAL )"},
{"lineNum":"  658","line":"            throw;"},
{"lineNum":"  659","line":"        }"},
{"lineNum":"  660","line":"      }"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"      //! Loads a string from the current node from the current top node"},
{"lineNum":"  663","line":"      template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  664","line":"      void loadValue( std::basic_string<CharT, Traits, Alloc> & str )"},
{"lineNum":"  665","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  666","line":"        std::basic_istringstream<CharT, Traits> is( itsNodes.top().node->value() );","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"        str.assign( std::istreambuf_iterator<CharT, Traits>( is ),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  669","line":"                    std::istreambuf_iterator<CharT, Traits>() );"},
{"lineNum":"  670","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":"      //! Loads the size of the current top node"},
{"lineNum":"  673","line":"      template <class T> inline"},
{"lineNum":"  674","line":"      void loadSize( T & value )"},
{"lineNum":"  675","line":"      {"},
{"lineNum":"  676","line":"        value = getNumChildren( itsNodes.top().node );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  677","line":"      }"},
{"lineNum":"  678","line":""},
{"lineNum":"  679","line":"    protected:"},
{"lineNum":"  680","line":"      //! Gets the number of children (usually interpreted as size) for the specified node"},
{"lineNum":"  681","line":"      static size_t getNumChildren( rapidxml::xml_node<> * node )"},
{"lineNum":"  682","line":"      {"},
{"lineNum":"  683","line":"        size_t size = 0;"},
{"lineNum":"  684","line":"        node = node->first_node(); // get first child"},
{"lineNum":"  685","line":""},
{"lineNum":"  686","line":"        while( node != nullptr )","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  687","line":"        {"},
{"lineNum":"  688","line":"          ++size;","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  689","line":"          node = node->next_sibling();"},
{"lineNum":"  690","line":"        }"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"        return size;"},
{"lineNum":"  693","line":"      }"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"      //! A struct that contains metadata about a node"},
{"lineNum":"  696","line":"      /*! Keeps track of some top level node, its number of"},
{"lineNum":"  697","line":"          remaining children, and the current active child node */"},
{"lineNum":"  698","line":"      struct NodeInfo"},
{"lineNum":"  699","line":"      {"},
{"lineNum":"  700","line":"        NodeInfo( rapidxml::xml_node<> * n = nullptr ) :"},
{"lineNum":"  701","line":"          node( n ),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  702","line":"          child( n->first_node() ),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  703","line":"          size( XMLInputArchive::getNumChildren( n ) ),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  704","line":"          name( nullptr )","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  705","line":"        { }"},
{"lineNum":"  706","line":""},
{"lineNum":"  707","line":"        //! Advances to the next sibling node of the child"},
{"lineNum":"  708","line":"        /*! If this is the last sibling child will be null after calling */"},
{"lineNum":"  709","line":"        void advance()"},
{"lineNum":"  710","line":"        {"},
{"lineNum":"  711","line":"          if( size > 0 )","class":"lineNoCov","hits":"0","possible_hits":"134",},
{"lineNum":"  712","line":"          {"},
{"lineNum":"  713","line":"            --size;","class":"lineNoCov","hits":"0","possible_hits":"134",},
{"lineNum":"  714","line":"            child = child->next_sibling();","class":"lineNoCov","hits":"0","possible_hits":"268",},
{"lineNum":"  715","line":"          }"},
{"lineNum":"  716","line":"        }"},
{"lineNum":"  717","line":""},
{"lineNum":"  718","line":"        //! Searches for a child with the given name in this node"},
{"lineNum":"  719","line":"        /*! @param searchName The name to search for (must be null terminated)"},
{"lineNum":"  720","line":"            @return The node if found, nullptr otherwise */"},
{"lineNum":"  721","line":"        rapidxml::xml_node<> * search( const char * searchName )"},
{"lineNum":"  722","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  723","line":"          if( searchName )","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  724","line":"          {"},
{"lineNum":"  725","line":"            size_t new_size = XMLInputArchive::getNumChildren( node );","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  726","line":"            const size_t name_size = rapidxml::internal::measure( searchName );"},
{"lineNum":"  727","line":""},
{"lineNum":"  728","line":"            for( auto new_child = node->first_node(); new_child != nullptr; new_child = new_child->next_sibling() )","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  729","line":"            {"},
{"lineNum":"  730","line":"              if( rapidxml::internal::compare( new_child->name(), new_child->name_size(), searchName, name_size, true ) )"},
{"lineNum":"  731","line":"              {"},
{"lineNum":"  732","line":"                size = new_size;","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  733","line":"                child = new_child;","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  734","line":""},
{"lineNum":"  735","line":"                return new_child;"},
{"lineNum":"  736","line":"              }"},
{"lineNum":"  737","line":"              --new_size;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  738","line":"            }"},
{"lineNum":"  739","line":"          }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  740","line":""},
{"lineNum":"  741","line":"          return nullptr;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  742","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  743","line":""},
{"lineNum":"  744","line":"        //! Returns the actual name of the next child node, if it exists"},
{"lineNum":"  745","line":"        const char * getChildName() const"},
{"lineNum":"  746","line":"        {"},
{"lineNum":"  747","line":"          return child ? child->name() : nullptr;"},
{"lineNum":"  748","line":"        }"},
{"lineNum":"  749","line":""},
{"lineNum":"  750","line":"        rapidxml::xml_node<> * node;  //!< A pointer to this node"},
{"lineNum":"  751","line":"        rapidxml::xml_node<> * child; //!< A pointer to its current child"},
{"lineNum":"  752","line":"        size_t size;                  //!< The remaining number of children for this node"},
{"lineNum":"  753","line":"        const char * name;            //!< The NVP name for next child node"},
{"lineNum":"  754","line":"      }; // NodeInfo"},
{"lineNum":"  755","line":""},
{"lineNum":"  756","line":"      //! @}"},
{"lineNum":"  757","line":""},
{"lineNum":"  758","line":"    private:"},
{"lineNum":"  759","line":"      std::vector<char> itsData;       //!< The raw data loaded"},
{"lineNum":"  760","line":"      rapidxml::xml_document<> itsXML; //!< The XML document"},
{"lineNum":"  761","line":"      std::stack<NodeInfo> itsNodes;   //!< A stack of nodes read from the document"},
{"lineNum":"  762","line":"  };"},
{"lineNum":"  763","line":""},
{"lineNum":"  764","line":"  // ######################################################################"},
{"lineNum":"  765","line":"  // XMLArchive prologue and epilogue functions"},
{"lineNum":"  766","line":"  // ######################################################################"},
{"lineNum":"  767","line":""},
{"lineNum":"  768","line":"  // ######################################################################"},
{"lineNum":"  769","line":"  //! Prologue for NVPs for XML output archives"},
{"lineNum":"  770","line":"  /*! NVPs do not start or finish nodes - they just set up the names */"},
{"lineNum":"  771","line":"  template <class T> inline"},
{"lineNum":"  772","line":"  void prologue( XMLOutputArchive &, NameValuePair<T> const & )"},
{"lineNum":"  773","line":"  { }"},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":"  //! Prologue for NVPs for XML input archives"},
{"lineNum":"  776","line":"  template <class T> inline"},
{"lineNum":"  777","line":"  void prologue( XMLInputArchive &, NameValuePair<T> const & )"},
{"lineNum":"  778","line":"  { }"},
{"lineNum":"  779","line":""},
{"lineNum":"  780","line":"  // ######################################################################"},
{"lineNum":"  781","line":"  //! Epilogue for NVPs for XML output archives"},
{"lineNum":"  782","line":"  /*! NVPs do not start or finish nodes - they just set up the names */"},
{"lineNum":"  783","line":"  template <class T> inline"},
{"lineNum":"  784","line":"  void epilogue( XMLOutputArchive &, NameValuePair<T> const & )"},
{"lineNum":"  785","line":"  { }"},
{"lineNum":"  786","line":""},
{"lineNum":"  787","line":"  //! Epilogue for NVPs for XML input archives"},
{"lineNum":"  788","line":"  template <class T> inline"},
{"lineNum":"  789","line":"  void epilogue( XMLInputArchive &, NameValuePair<T> const & )"},
{"lineNum":"  790","line":"  { }"},
{"lineNum":"  791","line":""},
{"lineNum":"  792","line":"  // ######################################################################"},
{"lineNum":"  793","line":"  //! Prologue for deferred data for XML archives"},
{"lineNum":"  794","line":"  /*! Do nothing for the defer wrapper */"},
{"lineNum":"  795","line":"  template <class T> inline"},
{"lineNum":"  796","line":"  void prologue( XMLOutputArchive &, DeferredData<T> const & )"},
{"lineNum":"  797","line":"  { }"},
{"lineNum":"  798","line":""},
{"lineNum":"  799","line":"  //! Prologue for deferred data for XML archives"},
{"lineNum":"  800","line":"  template <class T> inline"},
{"lineNum":"  801","line":"  void prologue( XMLInputArchive &, DeferredData<T> const & )"},
{"lineNum":"  802","line":"  { }"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"  // ######################################################################"},
{"lineNum":"  805","line":"  //! Epilogue for deferred for XML archives"},
{"lineNum":"  806","line":"  /*! NVPs do not start or finish nodes - they just set up the names */"},
{"lineNum":"  807","line":"  template <class T> inline"},
{"lineNum":"  808","line":"  void epilogue( XMLOutputArchive &, DeferredData<T> const & )"},
{"lineNum":"  809","line":"  { }"},
{"lineNum":"  810","line":""},
{"lineNum":"  811","line":"  //! Epilogue for deferred for XML archives"},
{"lineNum":"  812","line":"  /*! Do nothing for the defer wrapper */"},
{"lineNum":"  813","line":"  template <class T> inline"},
{"lineNum":"  814","line":"  void epilogue( XMLInputArchive &, DeferredData<T> const & )"},
{"lineNum":"  815","line":"  { }"},
{"lineNum":"  816","line":""},
{"lineNum":"  817","line":"  // ######################################################################"},
{"lineNum":"  818","line":"  //! Prologue for SizeTags for XML output archives"},
{"lineNum":"  819","line":"  /*! SizeTags do not start or finish nodes */"},
{"lineNum":"  820","line":"  template <class T> inline"},
{"lineNum":"  821","line":"  void prologue( XMLOutputArchive & ar, SizeTag<T> const & )"},
{"lineNum":"  822","line":"  {"},
{"lineNum":"  823","line":"      if (ar.hasSizeAttributes())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  824","line":"      {"},
{"lineNum":"  825","line":"          ar.appendAttribute(\"size\", \"dynamic\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  826","line":"      }"},
{"lineNum":"  827","line":"  }"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"  template <class T> inline"},
{"lineNum":"  830","line":"  void prologue( XMLInputArchive &, SizeTag<T> const & )"},
{"lineNum":"  831","line":"  { }"},
{"lineNum":"  832","line":""},
{"lineNum":"  833","line":"  //! Epilogue for SizeTags for XML output archives"},
{"lineNum":"  834","line":"  /*! SizeTags do not start or finish nodes */"},
{"lineNum":"  835","line":"  template <class T> inline"},
{"lineNum":"  836","line":"  void epilogue( XMLOutputArchive &, SizeTag<T> const & )"},
{"lineNum":"  837","line":"  { }"},
{"lineNum":"  838","line":""},
{"lineNum":"  839","line":"  template <class T> inline"},
{"lineNum":"  840","line":"  void epilogue( XMLInputArchive &, SizeTag<T> const & )"},
{"lineNum":"  841","line":"  { }"},
{"lineNum":"  842","line":""},
{"lineNum":"  843","line":"  // ######################################################################"},
{"lineNum":"  844","line":"  //! Prologue for all other types for XML output archives (except minimal types)"},
{"lineNum":"  845","line":"  /*! Starts a new node, named either automatically or by some NVP,"},
{"lineNum":"  846","line":"      that may be given data by the type about to be archived"},
{"lineNum":"  847","line":""},
{"lineNum":"  848","line":"      Minimal types do not start or end nodes */"},
{"lineNum":"  849","line":"  template <class T, traits::DisableIf<traits::has_minimal_base_class_serialization<T, traits::has_minimal_output_serialization, XMLOutputArchive>::value ||"},
{"lineNum":"  850","line":"                                       traits::has_minimal_output_serialization<T, XMLOutputArchive>::value> = traits::sfinae> inline"},
{"lineNum":"  851","line":"  void prologue( XMLOutputArchive & ar, T const & )"},
{"lineNum":"  852","line":"  {"},
{"lineNum":"  853","line":"    ar.startNode();","class":"lineNoCov","hits":"0","possible_hits":"261",},
{"lineNum":"  854","line":"    ar.insertType<T>();","class":"lineNoCov","hits":"0","possible_hits":"261",},
{"lineNum":"  855","line":"  }"},
{"lineNum":"  856","line":""},
{"lineNum":"  857","line":"  //! Prologue for all other types for XML input archives (except minimal types)"},
{"lineNum":"  858","line":"  template <class T, traits::DisableIf<traits::has_minimal_base_class_serialization<T, traits::has_minimal_input_serialization, XMLInputArchive>::value ||"},
{"lineNum":"  859","line":"                                       traits::has_minimal_input_serialization<T, XMLInputArchive>::value> = traits::sfinae> inline"},
{"lineNum":"  860","line":"  void prologue( XMLInputArchive & ar, T const & )"},
{"lineNum":"  861","line":"  {"},
{"lineNum":"  862","line":"    ar.startNode();","class":"lineNoCov","hits":"0","possible_hits":"215",},
{"lineNum":"  863","line":"  }"},
{"lineNum":"  864","line":""},
{"lineNum":"  865","line":"  // ######################################################################"},
{"lineNum":"  866","line":"  //! Epilogue for all other types other for XML output archives (except minimal types)"},
{"lineNum":"  867","line":"  /*! Finishes the node created in the prologue"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"      Minimal types do not start or end nodes */"},
{"lineNum":"  870","line":"  template <class T, traits::DisableIf<traits::has_minimal_base_class_serialization<T, traits::has_minimal_output_serialization, XMLOutputArchive>::value ||"},
{"lineNum":"  871","line":"                                       traits::has_minimal_output_serialization<T, XMLOutputArchive>::value> = traits::sfinae> inline"},
{"lineNum":"  872","line":"  void epilogue( XMLOutputArchive & ar, T const & )"},
{"lineNum":"  873","line":"  {"},
{"lineNum":"  874","line":"    ar.finishNode();"},
{"lineNum":"  875","line":"  }"},
{"lineNum":"  876","line":""},
{"lineNum":"  877","line":"  //! Epilogue for all other types other for XML output archives (except minimal types)"},
{"lineNum":"  878","line":"  template <class T, traits::DisableIf<traits::has_minimal_base_class_serialization<T, traits::has_minimal_input_serialization, XMLInputArchive>::value ||"},
{"lineNum":"  879","line":"                                       traits::has_minimal_input_serialization<T, XMLInputArchive>::value> = traits::sfinae> inline"},
{"lineNum":"  880","line":"  void epilogue( XMLInputArchive & ar, T const & )"},
{"lineNum":"  881","line":"  {"},
{"lineNum":"  882","line":"    ar.finishNode();","class":"lineNoCov","hits":"0","possible_hits":"86",},
{"lineNum":"  883","line":"  }"},
{"lineNum":"  884","line":""},
{"lineNum":"  885","line":"  // ######################################################################"},
{"lineNum":"  886","line":"  // Common XMLArchive serialization functions"},
{"lineNum":"  887","line":"  // ######################################################################"},
{"lineNum":"  888","line":""},
{"lineNum":"  889","line":"  //! Saving NVP types to XML"},
{"lineNum":"  890","line":"  template <class T> inline"},
{"lineNum":"  891","line":"  void CEREAL_SAVE_FUNCTION_NAME( XMLOutputArchive & ar, NameValuePair<T> const & t )"},
{"lineNum":"  892","line":"  {"},
{"lineNum":"  893","line":"    ar.setNextName( t.name );","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  894","line":"    ar( t.value );","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  895","line":"  }"},
{"lineNum":"  896","line":""},
{"lineNum":"  897","line":"  //! Loading NVP types from XML"},
{"lineNum":"  898","line":"  template <class T> inline"},
{"lineNum":"  899","line":"  void CEREAL_LOAD_FUNCTION_NAME( XMLInputArchive & ar, NameValuePair<T> & t )"},
{"lineNum":"  900","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"50",},
{"lineNum":"  901","line":"    ar.setNextName( t.name );","class":"lineNoCov","hits":"0","possible_hits":"55",},
{"lineNum":"  902","line":"    ar( t.value );","class":"lineNoCov","hits":"0","possible_hits":"72",},
{"lineNum":"  903","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"100",},
{"lineNum":"  904","line":""},
{"lineNum":"  905","line":"  // ######################################################################"},
{"lineNum":"  906","line":"  //! Saving SizeTags to XML"},
{"lineNum":"  907","line":"  template <class T> inline"},
{"lineNum":"  908","line":"  void CEREAL_SAVE_FUNCTION_NAME( XMLOutputArchive &, SizeTag<T> const & )"},
{"lineNum":"  909","line":"  { }"},
{"lineNum":"  910","line":""},
{"lineNum":"  911","line":"  //! Loading SizeTags from XML"},
{"lineNum":"  912","line":"  template <class T> inline"},
{"lineNum":"  913","line":"  void CEREAL_LOAD_FUNCTION_NAME( XMLInputArchive & ar, SizeTag<T> & st )"},
{"lineNum":"  914","line":"  {"},
{"lineNum":"  915","line":"    ar.loadSize( st.size );"},
{"lineNum":"  916","line":"  }"},
{"lineNum":"  917","line":""},
{"lineNum":"  918","line":"  // ######################################################################"},
{"lineNum":"  919","line":"  //! Saving for POD types to xml"},
{"lineNum":"  920","line":"  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline"},
{"lineNum":"  921","line":"  void CEREAL_SAVE_FUNCTION_NAME(XMLOutputArchive & ar, T const & t)"},
{"lineNum":"  922","line":"  {"},
{"lineNum":"  923","line":"    ar.saveValue( t );","class":"lineNoCov","hits":"0","possible_hits":"99",},
{"lineNum":"  924","line":"  }"},
{"lineNum":"  925","line":""},
{"lineNum":"  926","line":"  //! Loading for POD types from xml"},
{"lineNum":"  927","line":"  template <class T, traits::EnableIf<std::is_arithmetic<T>::value> = traits::sfinae> inline"},
{"lineNum":"  928","line":"  void CEREAL_LOAD_FUNCTION_NAME(XMLInputArchive & ar, T & t)"},
{"lineNum":"  929","line":"  {"},
{"lineNum":"  930","line":"    ar.loadValue( t );","class":"lineNoCov","hits":"0","possible_hits":"67",},
{"lineNum":"  931","line":"  }"},
{"lineNum":"  932","line":""},
{"lineNum":"  933","line":"  // ######################################################################"},
{"lineNum":"  934","line":"  //! saving string to xml"},
{"lineNum":"  935","line":"  template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  936","line":"  void CEREAL_SAVE_FUNCTION_NAME(XMLOutputArchive & ar, std::basic_string<CharT, Traits, Alloc> const & str)"},
{"lineNum":"  937","line":"  {"},
{"lineNum":"  938","line":"    ar.saveValue( str );","class":"lineNoCov","hits":"0","possible_hits":"25",},
{"lineNum":"  939","line":"  }"},
{"lineNum":"  940","line":""},
{"lineNum":"  941","line":"  //! loading string from xml"},
{"lineNum":"  942","line":"  template<class CharT, class Traits, class Alloc> inline"},
{"lineNum":"  943","line":"  void CEREAL_LOAD_FUNCTION_NAME(XMLInputArchive & ar, std::basic_string<CharT, Traits, Alloc> & str)"},
{"lineNum":"  944","line":"  {"},
{"lineNum":"  945","line":"    ar.loadValue( str );","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  946","line":"  }"},
{"lineNum":"  947","line":"} // namespace cereal"},
{"lineNum":"  948","line":""},
{"lineNum":"  949","line":"// register archives for polymorphic support"},
{"lineNum":"  950","line":"CEREAL_REGISTER_ARCHIVE(cereal::XMLOutputArchive)"},
{"lineNum":"  951","line":"CEREAL_REGISTER_ARCHIVE(cereal::XMLInputArchive)"},
{"lineNum":"  952","line":""},
{"lineNum":"  953","line":"// tie input and output archives together"},
{"lineNum":"  954","line":"CEREAL_SETUP_ARCHIVE_TRAITS(cereal::XMLInputArchive, cereal::XMLOutputArchive)"},
{"lineNum":"  955","line":""},
{"lineNum":"  956","line":"#endif // CEREAL_ARCHIVES_XML_HPP_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 114, "covered" : 0,};
var merged_data = [];
