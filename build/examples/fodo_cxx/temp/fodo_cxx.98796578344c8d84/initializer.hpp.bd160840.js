var data = {lines:[
{"lineNum":"    1","line":"//-----------------------------------------------------------------------------"},
{"lineNum":"    2","line":"// boost variant/detail/initializer.hpp header file"},
{"lineNum":"    3","line":"// See http://www.boost.org for updates, documentation, and revision history."},
{"lineNum":"    4","line":"//-----------------------------------------------------------------------------"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// Copyright (c) 2002-2003"},
{"lineNum":"    7","line":"// Eric Friedman, Itay Maman"},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Distributed under the Boost Software License, Version 1.0. (See"},
{"lineNum":"   10","line":"// accompanying file LICENSE_1_0.txt or copy at"},
{"lineNum":"   11","line":"// http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#ifndef BOOST_VARIANT_DETAIL_INITIALIZER_HPP"},
{"lineNum":"   14","line":"#define BOOST_VARIANT_DETAIL_INITIALIZER_HPP"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"#include <new> // for placement new"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"#include <boost/config.hpp>"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"#include <boost/call_traits.hpp>"},
{"lineNum":"   21","line":"#include <boost/detail/reference_content.hpp>"},
{"lineNum":"   22","line":"#include <boost/variant/recursive_wrapper_fwd.hpp>"},
{"lineNum":"   23","line":"#include <boost/variant/detail/move.hpp>"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"#if !defined(BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE)"},
{"lineNum":"   26","line":"#   include <boost/mpl/aux_/value_wknd.hpp>"},
{"lineNum":"   27","line":"#   include <boost/mpl/int.hpp>"},
{"lineNum":"   28","line":"#   include <boost/mpl/iter_fold.hpp>"},
{"lineNum":"   29","line":"#   include <boost/mpl/next.hpp>"},
{"lineNum":"   30","line":"#   include <boost/mpl/deref.hpp>"},
{"lineNum":"   31","line":"#   include <boost/mpl/pair.hpp>"},
{"lineNum":"   32","line":"#   include <boost/mpl/protect.hpp>"},
{"lineNum":"   33","line":"#else"},
{"lineNum":"   34","line":"#   include <boost/variant/variant_fwd.hpp>"},
{"lineNum":"   35","line":"#   include <boost/preprocessor/cat.hpp>"},
{"lineNum":"   36","line":"#   include <boost/preprocessor/enum.hpp>"},
{"lineNum":"   37","line":"#   include <boost/preprocessor/repeat.hpp>"},
{"lineNum":"   38","line":"#endif"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"namespace boost {"},
{"lineNum":"   41","line":"namespace detail { namespace variant {"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"   44","line":"// (detail) support to simulate standard overload resolution rules"},
{"lineNum":"   45","line":"//"},
{"lineNum":"   46","line":"// The below initializers allows variant to follow standard overload"},
{"lineNum":"   47","line":"// resolution rules over the specified set of bounded types."},
{"lineNum":"   48","line":"//"},
{"lineNum":"   49","line":"// On compilers where using declarations in class templates can correctly"},
{"lineNum":"   50","line":"// avoid name hiding, use an optimal solution based on the variant\'s typelist."},
{"lineNum":"   51","line":"//"},
{"lineNum":"   52","line":"// Otherwise, use a preprocessor workaround based on knowledge of the fixed"},
{"lineNum":"   53","line":"// size of the variant\'s psuedo-variadic template parameter list."},
{"lineNum":"   54","line":"//"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"#if !defined(BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE)"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"// (detail) quoted metafunction make_initializer_node"},
{"lineNum":"   59","line":"//"},
{"lineNum":"   60","line":"// Exposes a pair whose first type is a node in the initializer hierarchy."},
{"lineNum":"   61","line":"//"},
{"lineNum":"   62","line":"struct make_initializer_node"},
{"lineNum":"   63","line":"{"},
{"lineNum":"   64","line":"    template <typename BaseIndexPair, typename Iterator>"},
{"lineNum":"   65","line":"    struct apply"},
{"lineNum":"   66","line":"    {"},
{"lineNum":"   67","line":"    private: // helpers, for metafunction result (below)"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"        typedef typename BaseIndexPair::first"},
{"lineNum":"   70","line":"            base;"},
{"lineNum":"   71","line":"        typedef typename BaseIndexPair::second"},
{"lineNum":"   72","line":"            index;"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"        class initializer_node"},
{"lineNum":"   75","line":"            : public base"},
{"lineNum":"   76","line":"        {"},
{"lineNum":"   77","line":"        private: // helpers, for static functions (below)"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"            typedef typename mpl::deref<Iterator>::type"},
{"lineNum":"   80","line":"                recursive_enabled_T;"},
{"lineNum":"   81","line":"            typedef typename unwrap_recursive<recursive_enabled_T>::type"},
{"lineNum":"   82","line":"                public_T;"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES"},
{"lineNum":"   85","line":"            typedef boost::is_reference<public_T>"},
{"lineNum":"   86","line":"                is_reference_content_t;"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"            typedef typename boost::mpl::if_<is_reference_content_t, public_T, const public_T& >::type"},
{"lineNum":"   89","line":"                param_T;"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"            template <class T> struct disable_overload{};"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"            typedef typename boost::mpl::if_<is_reference_content_t, disable_overload<public_T>, public_T&& >::type"},
{"lineNum":"   94","line":"                param2_T;"},
{"lineNum":"   95","line":"#else"},
{"lineNum":"   96","line":"            typedef typename call_traits<public_T>::param_type"},
{"lineNum":"   97","line":"                param_T;"},
{"lineNum":"   98","line":"#endif"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"        public: // static functions"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"            using base::initialize;"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"            static int initialize(void* dest, param_T operand)"},
{"lineNum":"  105","line":"            {"},
{"lineNum":"  106","line":"                typedef typename boost::detail::make_reference_content<"},
{"lineNum":"  107","line":"                      recursive_enabled_T"},
{"lineNum":"  108","line":"                    >::type internal_T;"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"                new(dest) internal_T(operand);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  111","line":"                return BOOST_MPL_AUX_VALUE_WKND(index)::value; // which"},
{"lineNum":"  112","line":"            }"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES"},
{"lineNum":"  115","line":"            static int initialize(void* dest, param2_T operand)"},
{"lineNum":"  116","line":"            {"},
{"lineNum":"  117","line":"                // This assert must newer trigger, because all the reference contents are"},
{"lineNum":"  118","line":"                // handled by the initilize(void* dest, param_T operand) function above"},
{"lineNum":"  119","line":"                BOOST_ASSERT(!is_reference_content_t::value);"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"                typedef typename boost::mpl::if_<is_reference_content_t, param2_T, recursive_enabled_T>::type value_T;"},
{"lineNum":"  122","line":"                new(dest) value_T( boost::detail::variant::move(operand) );","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  123","line":"                return BOOST_MPL_AUX_VALUE_WKND(index)::value; // which"},
{"lineNum":"  124","line":"            }"},
{"lineNum":"  125","line":"#endif"},
{"lineNum":"  126","line":"        };"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"        friend class initializer_node;"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"    public: // metafunction result"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"        typedef mpl::pair<"},
{"lineNum":"  133","line":"              initializer_node"},
{"lineNum":"  134","line":"            , typename mpl::next< index >::type"},
{"lineNum":"  135","line":"            > type;"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"    };"},
{"lineNum":"  138","line":"};"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"// (detail) class initializer_root"},
{"lineNum":"  141","line":"//"},
{"lineNum":"  142","line":"// Every level of the initializer hierarchy must expose the name"},
{"lineNum":"  143","line":"// \"initialize,\" so initializer_root provides a dummy function:"},
{"lineNum":"  144","line":"//"},
{"lineNum":"  145","line":"class initializer_root"},
{"lineNum":"  146","line":"{"},
{"lineNum":"  147","line":"public: // static functions"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"    static void initialize();"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"};"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"#else // defined(BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE)"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"    // Obsolete. Remove."},
{"lineNum":"  156","line":"    #define BOOST_VARIANT_AUX_PP_INITIALIZER_TEMPLATE_PARAMS \\"},
{"lineNum":"  157","line":"          BOOST_VARIANT_ENUM_PARAMS(typename recursive_enabled_T) \\"},
{"lineNum":"  158","line":"    /**/"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"    // Obsolete. Remove."},
{"lineNum":"  161","line":"    #define BOOST_VARIANT_AUX_PP_INITIALIZER_DEFINE_PARAM_T(N) \\"},
{"lineNum":"  162","line":"        typedef typename unwrap_recursive< \\"},
{"lineNum":"  163","line":"              BOOST_PP_CAT(recursive_enabled_T,N) \\"},
{"lineNum":"  164","line":"            >::type BOOST_PP_CAT(public_T,N); \\"},
{"lineNum":"  165","line":"        typedef typename call_traits< \\"},
{"lineNum":"  166","line":"              BOOST_PP_CAT(public_T,N) \\"},
{"lineNum":"  167","line":"            >::param_type BOOST_PP_CAT(param_T,N); \\"},
{"lineNum":"  168","line":"    /**/"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"template < BOOST_VARIANT_ENUM_PARAMS(typename recursive_enabled_T) >"},
{"lineNum":"  171","line":"struct preprocessor_list_initializer"},
{"lineNum":"  172","line":"{"},
{"lineNum":"  173","line":"public: // static functions"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"    #define BOOST_VARIANT_AUX_PP_INITIALIZE_FUNCTION(z,N,_) \\"},
{"lineNum":"  176","line":"        typedef typename unwrap_recursive< \\"},
{"lineNum":"  177","line":"              BOOST_PP_CAT(recursive_enabled_T,N) \\"},
{"lineNum":"  178","line":"            >::type BOOST_PP_CAT(public_T,N); \\"},
{"lineNum":"  179","line":"        typedef typename call_traits< \\"},
{"lineNum":"  180","line":"              BOOST_PP_CAT(public_T,N) \\"},
{"lineNum":"  181","line":"            >::param_type BOOST_PP_CAT(param_T,N); \\"},
{"lineNum":"  182","line":"        static int initialize( \\"},
{"lineNum":"  183","line":"              void* dest \\"},
{"lineNum":"  184","line":"            , BOOST_PP_CAT(param_T,N) operand \\"},
{"lineNum":"  185","line":"            ) \\"},
{"lineNum":"  186","line":"        { \\"},
{"lineNum":"  187","line":"            typedef typename boost::detail::make_reference_content< \\"},
{"lineNum":"  188","line":"                  BOOST_PP_CAT(recursive_enabled_T,N) \\"},
{"lineNum":"  189","line":"                >::type internal_T; \\"},
{"lineNum":"  190","line":"            \\"},
{"lineNum":"  191","line":"            new(dest) internal_T(operand); \\"},
{"lineNum":"  192","line":"            return (N); /*which*/ \\"},
{"lineNum":"  193","line":"        } \\"},
{"lineNum":"  194","line":"        /**/"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"    BOOST_PP_REPEAT("},
{"lineNum":"  197","line":"          BOOST_VARIANT_LIMIT_TYPES"},
{"lineNum":"  198","line":"        , BOOST_VARIANT_AUX_PP_INITIALIZE_FUNCTION"},
{"lineNum":"  199","line":"        , _"},
{"lineNum":"  200","line":"        )"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"    #undef BOOST_VARIANT_AUX_PP_INITIALIZE_FUNCTION"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"};"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"#endif // BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE workaround"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"}} // namespace detail::variant"},
{"lineNum":"  209","line":"} // namespace boost"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  212","line":"// macro BOOST_VARIANT_AUX_INITIALIZER_T"},
{"lineNum":"  213","line":"//"},
{"lineNum":"  214","line":"// Given both the variant\'s typelist and a basename for forming the list of"},
{"lineNum":"  215","line":"// bounded types (i.e., T becomes T1, T2, etc.), exposes the initializer"},
{"lineNum":"  216","line":"// most appropriate to the current compiler."},
{"lineNum":"  217","line":"//"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"#if !defined(BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE)"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"#define BOOST_VARIANT_AUX_INITIALIZER_T( mpl_seq, typename_base ) \\"},
{"lineNum":"  222","line":"    ::boost::mpl::iter_fold< \\"},
{"lineNum":"  223","line":"          mpl_seq \\"},
{"lineNum":"  224","line":"        , ::boost::mpl::pair< \\"},
{"lineNum":"  225","line":"              ::boost::detail::variant::initializer_root \\"},
{"lineNum":"  226","line":"            , ::boost::mpl::int_<0> \\"},
{"lineNum":"  227","line":"            > \\"},
{"lineNum":"  228","line":"        , ::boost::mpl::protect< \\"},
{"lineNum":"  229","line":"              ::boost::detail::variant::make_initializer_node \\"},
{"lineNum":"  230","line":"            > \\"},
{"lineNum":"  231","line":"        >::type::first \\"},
{"lineNum":"  232","line":"    /**/"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"#else // defined(BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE)"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"    // Obsolete. Remove."},
{"lineNum":"  237","line":"    #define BOOST_VARIANT_AUX_PP_INITIALIZER_TEMPLATE_ARGS(typename_base) \\"},
{"lineNum":"  238","line":"          BOOST_VARIANT_ENUM_PARAMS(typename_base) \\"},
{"lineNum":"  239","line":"        /**/"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"#define BOOST_VARIANT_AUX_INITIALIZER_T( mpl_seq, typename_base ) \\"},
{"lineNum":"  242","line":"    ::boost::detail::variant::preprocessor_list_initializer< \\"},
{"lineNum":"  243","line":"          BOOST_VARIANT_ENUM_PARAMS(typename_base) \\"},
{"lineNum":"  244","line":"        > \\"},
{"lineNum":"  245","line":"    /**/"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"#endif // BOOST_NO_USING_DECLARATION_OVERLOADS_FROM_TYPENAME_BASE workaround"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"#endif // BOOST_VARIANT_DETAIL_INITIALIZER_HPP"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
