var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_FUNCTORANALYSIS_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_FUNCTORANALYSIS_HPP"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include <cstddef>"},
{"lineNum":"   49","line":"#include <Kokkos_Core_fwd.hpp>"},
{"lineNum":"   50","line":"#include <impl/Kokkos_Traits.hpp>"},
{"lineNum":"   51","line":"#include <impl/Kokkos_Tags.hpp>"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   54","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"namespace Kokkos {"},
{"lineNum":"   57","line":"namespace Impl {"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"struct FunctorPatternInterface {"},
{"lineNum":"   60","line":"  struct FOR {};"},
{"lineNum":"   61","line":"  struct REDUCE {};"},
{"lineNum":"   62","line":"  struct SCAN {};"},
{"lineNum":"   63","line":"};"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"/** \\brief  Query Functor and execution policy argument tag for value type."},
{"lineNum":"   66","line":" *"},
{"lineNum":"   67","line":" *  If \'value_type\' is not explicitly declared in the functor"},
{"lineNum":"   68","line":" *  then attempt to deduce the type from FunctorType::operator()"},
{"lineNum":"   69","line":" *  interface used by the pattern and policy."},
{"lineNum":"   70","line":" *"},
{"lineNum":"   71","line":" *  For the REDUCE pattern generate a Reducer and finalization function"},
{"lineNum":"   72","line":" *  derived from what is available within the functor."},
{"lineNum":"   73","line":" */"},
{"lineNum":"   74","line":"template <typename PatternInterface, class Policy, class Functor>"},
{"lineNum":"   75","line":"struct FunctorAnalysis {"},
{"lineNum":"   76","line":" private:"},
{"lineNum":"   77","line":"  using FOR    = FunctorPatternInterface::FOR;"},
{"lineNum":"   78","line":"  using REDUCE = FunctorPatternInterface::REDUCE;"},
{"lineNum":"   79","line":"  using SCAN   = FunctorPatternInterface::SCAN;"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"  //----------------------------------------"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"  struct VOID {};"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"  template <typename P = Policy, typename = std::false_type>"},
{"lineNum":"   86","line":"  struct has_work_tag {"},
{"lineNum":"   87","line":"    using type = void;"},
{"lineNum":"   88","line":"    using wtag = VOID;"},
{"lineNum":"   89","line":"  };"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"  template <typename P>"},
{"lineNum":"   92","line":"  struct has_work_tag<P,"},
{"lineNum":"   93","line":"                      typename std::is_same<typename P::work_tag, void>::type> {"},
{"lineNum":"   94","line":"    using type = typename P::work_tag;"},
{"lineNum":"   95","line":"    using wtag = typename P::work_tag;"},
{"lineNum":"   96","line":"  };"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"  using Tag  = typename has_work_tag<>::type;"},
{"lineNum":"   99","line":"  using WTag = typename has_work_tag<>::wtag;"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"  //----------------------------------------"},
{"lineNum":"  102","line":"  // Check for T::execution_space"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"  template <typename T, typename = std::false_type>"},
{"lineNum":"  105","line":"  struct has_execution_space {"},
{"lineNum":"  106","line":"    using type = void;"},
{"lineNum":"  107","line":"    enum : bool { value = false };"},
{"lineNum":"  108","line":"  };"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"  template <typename T>"},
{"lineNum":"  111","line":"  struct has_execution_space<"},
{"lineNum":"  112","line":"      T, typename std::is_same<typename T::execution_space, void>::type> {"},
{"lineNum":"  113","line":"    using type = typename T::execution_space;"},
{"lineNum":"  114","line":"    enum : bool { value = true };"},
{"lineNum":"  115","line":"  };"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"  using policy_has_space  = has_execution_space<Policy>;"},
{"lineNum":"  118","line":"  using functor_has_space = has_execution_space<Functor>;"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"  static_assert(!policy_has_space::value || !functor_has_space::value ||"},
{"lineNum":"  121","line":"                    std::is_same<typename policy_has_space::type,"},
{"lineNum":"  122","line":"                                 typename functor_has_space::type>::value,"},
{"lineNum":"  123","line":"                \"Execution Policy and Functor execution space must match\");"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"  //----------------------------------------"},
{"lineNum":"  126","line":"  // Check for Functor::value_type, which is either a simple type T or T[]"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"  template <typename F, typename = std::false_type>"},
{"lineNum":"  129","line":"  struct has_value_type {"},
{"lineNum":"  130","line":"    using type = void;"},
{"lineNum":"  131","line":"  };"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"  template <typename F>"},
{"lineNum":"  134","line":"  struct has_value_type<"},
{"lineNum":"  135","line":"      F, typename std::is_same<typename F::value_type, void>::type> {"},
{"lineNum":"  136","line":"    using type = typename F::value_type;"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"    static_assert(!std::is_reference<type>::value &&"},
{"lineNum":"  139","line":"                      std::rank<type>::value <= 1 &&"},
{"lineNum":"  140","line":"                      std::extent<type>::value == 0,"},
{"lineNum":"  141","line":"                  \"Kokkos Functor::value_type is T or T[]\");"},
{"lineNum":"  142","line":"  };"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"  //----------------------------------------"},
{"lineNum":"  145","line":"  // If Functor::value_type does not exist then evaluate operator(),"},
{"lineNum":"  146","line":"  // depending upon the pattern and whether the policy has a work tag,"},
{"lineNum":"  147","line":"  // to determine the reduction or scan value_type."},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"  template <typename F, typename P = PatternInterface,"},
{"lineNum":"  150","line":"            typename V = typename has_value_type<F>::type,"},
{"lineNum":"  151","line":"            bool T     = std::is_same<Tag, void>::value>"},
{"lineNum":"  152","line":"  struct deduce_value_type {"},
{"lineNum":"  153","line":"    using type = V;"},
{"lineNum":"  154","line":"  };"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"  template <typename F>"},
{"lineNum":"  157","line":"  struct deduce_value_type<F, REDUCE, void, true> {"},
{"lineNum":"  158","line":"    template <typename M, typename A>"},
{"lineNum":"  159","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, A&) const);"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"    template <typename M, typename A>"},
{"lineNum":"  162","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, M, A&) const);"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"    template <typename M, typename A>"},
{"lineNum":"  165","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, M, M, A&)"},
{"lineNum":"  166","line":"                                               const);"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"    template <typename M, typename A>"},
{"lineNum":"  169","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, M, M, M, A&)"},
{"lineNum":"  170","line":"                                               const);"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"    template <typename M, typename A>"},
{"lineNum":"  173","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, M, M, M, M, A&)"},
{"lineNum":"  174","line":"                                               const);"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    template <typename M, typename A>"},
{"lineNum":"  177","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, M, M, M, M, M,"},
{"lineNum":"  178","line":"                                                             A&) const);"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"    template <typename M, typename A>"},
{"lineNum":"  181","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, M, M, M, M, M,"},
{"lineNum":"  182","line":"                                                             M, A&) const);"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"    template <typename M, typename A>"},
{"lineNum":"  185","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, M, M, M, M, M,"},
{"lineNum":"  186","line":"                                                             M, M, A&) const);"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"    using type = decltype(deduce(&F::operator()));"},
{"lineNum":"  189","line":"  };"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"  template <typename F>"},
{"lineNum":"  192","line":"  struct deduce_value_type<F, REDUCE, void, false> {"},
{"lineNum":"  193","line":"    template <typename M, typename A>"},
{"lineNum":"  194","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, A&)"},
{"lineNum":"  195","line":"                                               const);"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"    template <typename M, typename A>"},
{"lineNum":"  198","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, M, A&)"},
{"lineNum":"  199","line":"                                               const);"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"    template <typename M, typename A>"},
{"lineNum":"  202","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, M, M, A&)"},
{"lineNum":"  203","line":"                                               const);"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"    template <typename M, typename A>"},
{"lineNum":"  206","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, M, M, M,"},
{"lineNum":"  207","line":"                                                             A&) const);"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"    template <typename M, typename A>"},
{"lineNum":"  210","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, M, M, M,"},
{"lineNum":"  211","line":"                                                             M, A&) const);"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    template <typename M, typename A>"},
{"lineNum":"  214","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, M, M, M,"},
{"lineNum":"  215","line":"                                                             M, M, A&) const);"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    template <typename M, typename A>"},
{"lineNum":"  218","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, M, M, M,"},
{"lineNum":"  219","line":"                                                             M, M, M, A&)"},
{"lineNum":"  220","line":"                                               const);"},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"    template <typename M, typename A>"},
{"lineNum":"  223","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, M, M, M,"},
{"lineNum":"  224","line":"                                                             M, M, M, M, A&)"},
{"lineNum":"  225","line":"                                               const);"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"    template <typename M, typename A>"},
{"lineNum":"  228","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, A&)"},
{"lineNum":"  229","line":"                                               const);"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"    template <typename M, typename A>"},
{"lineNum":"  232","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, M,"},
{"lineNum":"  233","line":"                                                             A&) const);"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"    template <typename M, typename A>"},
{"lineNum":"  236","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, M,"},
{"lineNum":"  237","line":"                                                             M, A&) const);"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"    template <typename M, typename A>"},
{"lineNum":"  240","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, M,"},
{"lineNum":"  241","line":"                                                             M, M, A&) const);"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"    template <typename M, typename A>"},
{"lineNum":"  244","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, M,"},
{"lineNum":"  245","line":"                                                             M, M, M, A&)"},
{"lineNum":"  246","line":"                                               const);"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"    template <typename M, typename A>"},
{"lineNum":"  249","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, M,"},
{"lineNum":"  250","line":"                                                             M, M, M, M, A&)"},
{"lineNum":"  251","line":"                                               const);"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"    template <typename M, typename A>"},
{"lineNum":"  254","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, M,"},
{"lineNum":"  255","line":"                                                             M, M, M, M, M, A&)"},
{"lineNum":"  256","line":"                                               const);"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"    template <typename M, typename A>"},
{"lineNum":"  259","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, M,"},
{"lineNum":"  260","line":"                                                             M, M, M, M, M, M,"},
{"lineNum":"  261","line":"                                                             A&) const);"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"    using type = decltype(deduce(&F::operator()));"},
{"lineNum":"  264","line":"  };"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"  template <typename F>"},
{"lineNum":"  267","line":"  struct deduce_value_type<F, SCAN, void, true> {"},
{"lineNum":"  268","line":"    template <typename M, typename A, typename I>"},
{"lineNum":"  269","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(M, A&, I) const);"},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"    using type = decltype(deduce(&F::operator()));"},
{"lineNum":"  272","line":"  };"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"  template <typename F>"},
{"lineNum":"  275","line":"  struct deduce_value_type<F, SCAN, void, false> {"},
{"lineNum":"  276","line":"    template <typename M, typename A, typename I>"},
{"lineNum":"  277","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag, M, A&, I)"},
{"lineNum":"  278","line":"                                               const);"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"    template <typename M, typename A, typename I>"},
{"lineNum":"  281","line":"    KOKKOS_INLINE_FUNCTION static A deduce(void (Functor::*)(WTag const&, M, A&,"},
{"lineNum":"  282","line":"                                                             I) const);"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"    using type = decltype(deduce(&F::operator()));"},
{"lineNum":"  285","line":"  };"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"  //----------------------------------------"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"  using candidate_type = typename deduce_value_type<Functor>::type;"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"  enum {"},
{"lineNum":"  292","line":"    candidate_is_void  = std::is_same<candidate_type, void>::value,"},
{"lineNum":"  293","line":"    candidate_is_array = std::rank<candidate_type>::value == 1"},
{"lineNum":"  294","line":"  };"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"  //----------------------------------------"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":" public:"},
{"lineNum":"  299","line":"  using execution_space = typename std::conditional<"},
{"lineNum":"  300","line":"      functor_has_space::value, typename functor_has_space::type,"},
{"lineNum":"  301","line":"      typename std::conditional<policy_has_space::value,"},
{"lineNum":"  302","line":"                                typename policy_has_space::type,"},
{"lineNum":"  303","line":"                                Kokkos::DefaultExecutionSpace>::type>::type;"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"  using value_type = typename std::remove_extent<candidate_type>::type;"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"  static_assert(!std::is_const<value_type>::value,"},
{"lineNum":"  308","line":"                \"Kokkos functor operator reduce argument cannot be const\");"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":" private:"},
{"lineNum":"  311","line":"  // Stub to avoid defining a type \'void &\'"},
{"lineNum":"  312","line":"  using ValueType ="},
{"lineNum":"  313","line":"      typename std::conditional<candidate_is_void, VOID, value_type>::type;"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":" public:"},
{"lineNum":"  316","line":"  using pointer_type ="},
{"lineNum":"  317","line":"      typename std::conditional<candidate_is_void, void, ValueType*>::type;"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"  using reference_type = typename std::conditional<"},
{"lineNum":"  320","line":"      candidate_is_array, ValueType*,"},
{"lineNum":"  321","line":"      typename std::conditional<!candidate_is_void, ValueType&,"},
{"lineNum":"  322","line":"                                void>::type>::type;"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":" private:"},
{"lineNum":"  325","line":"  template <bool IsArray, class FF>"},
{"lineNum":"  326","line":"  KOKKOS_INLINE_FUNCTION static constexpr"},
{"lineNum":"  327","line":"      typename std::enable_if<IsArray, unsigned>::type"},
{"lineNum":"  328","line":"      get_length(FF const& f) {"},
{"lineNum":"  329","line":"    return f.value_count;","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  330","line":"  }"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"  template <bool IsArray, class FF>"},
{"lineNum":"  333","line":"  KOKKOS_INLINE_FUNCTION static constexpr"},
{"lineNum":"  334","line":"      typename std::enable_if<!IsArray, unsigned>::type"},
{"lineNum":"  335","line":"      get_length(FF const&) {"},
{"lineNum":"  336","line":"    return candidate_is_void ? 0 : 1;"},
{"lineNum":"  337","line":"  }"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":" public:"},
{"lineNum":"  340","line":"  enum {"},
{"lineNum":"  341","line":"    StaticValueSize ="},
{"lineNum":"  342","line":"        !candidate_is_void && !candidate_is_array ? sizeof(ValueType) : 0"},
{"lineNum":"  343","line":"  };"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"  KOKKOS_FORCEINLINE_FUNCTION static constexpr unsigned value_count("},
{"lineNum":"  346","line":"      const Functor& f) {"},
{"lineNum":"  347","line":"    return FunctorAnalysis::template get_length<candidate_is_array>(f);"},
{"lineNum":"  348","line":"  }"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"  KOKKOS_FORCEINLINE_FUNCTION static constexpr unsigned value_size("},
{"lineNum":"  351","line":"      const Functor& f) {"},
{"lineNum":"  352","line":"    return FunctorAnalysis::template get_length<candidate_is_array>(f) *","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  353","line":"           sizeof(ValueType);"},
{"lineNum":"  354","line":"  }"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"  //----------------------------------------"},
{"lineNum":"  357","line":""},
{"lineNum":"  358","line":"  template <class Unknown>"},
{"lineNum":"  359","line":"  KOKKOS_FORCEINLINE_FUNCTION static constexpr unsigned value_count("},
{"lineNum":"  360","line":"      const Unknown&) {"},
{"lineNum":"  361","line":"    return candidate_is_void ? 0 : 1;"},
{"lineNum":"  362","line":"  }"},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"  template <class Unknown>"},
{"lineNum":"  365","line":"  KOKKOS_FORCEINLINE_FUNCTION static constexpr unsigned value_size("},
{"lineNum":"  366","line":"      const Unknown&) {"},
{"lineNum":"  367","line":"    return candidate_is_void ? 0 : sizeof(ValueType);"},
{"lineNum":"  368","line":"  }"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":" private:"},
{"lineNum":"  371","line":"  enum INTERFACE : int {"},
{"lineNum":"  372","line":"    DISABLE           = 0,"},
{"lineNum":"  373","line":"    NO_TAG_NOT_ARRAY  = 1,"},
{"lineNum":"  374","line":"    NO_TAG_IS_ARRAY   = 2,"},
{"lineNum":"  375","line":"    HAS_TAG_NOT_ARRAY = 3,"},
{"lineNum":"  376","line":"    HAS_TAG_IS_ARRAY  = 4,"},
{"lineNum":"  377","line":"    DEDUCED ="},
{"lineNum":"  378","line":"        !std::is_same<PatternInterface, REDUCE>::value"},
{"lineNum":"  379","line":"            ? DISABLE"},
{"lineNum":"  380","line":"            : (std::is_same<Tag, void>::value"},
{"lineNum":"  381","line":"                   ? (candidate_is_array ? NO_TAG_IS_ARRAY : NO_TAG_NOT_ARRAY)"},
{"lineNum":"  382","line":"                   : (candidate_is_array ? HAS_TAG_IS_ARRAY"},
{"lineNum":"  383","line":"                                         : HAS_TAG_NOT_ARRAY))"},
{"lineNum":"  384","line":"  };"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"  //----------------------------------------"},
{"lineNum":"  387","line":"  // parallel_reduce join operator"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"  template <class F, INTERFACE>"},
{"lineNum":"  390","line":"  struct has_join_function;"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"  template <class F>"},
{"lineNum":"  393","line":"  struct has_join_function<F, NO_TAG_NOT_ARRAY> {"},
{"lineNum":"  394","line":"    using vref_type  = volatile ValueType&;"},
{"lineNum":"  395","line":"    using cvref_type = const volatile ValueType&;"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(vref_type,"},
{"lineNum":"  398","line":"                                                             cvref_type) const);"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(vref_type,"},
{"lineNum":"  401","line":"                                                          cvref_type));"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"    KOKKOS_INLINE_FUNCTION static void join(F const* const f,"},
{"lineNum":"  404","line":"                                            ValueType volatile* dst,"},
{"lineNum":"  405","line":"                                            ValueType volatile const* src) {"},
{"lineNum":"  406","line":"      f->join(*dst, *src);"},
{"lineNum":"  407","line":"    }"},
{"lineNum":"  408","line":"  };"},
{"lineNum":"  409","line":""},
{"lineNum":"  410","line":"  template <class F>"},
{"lineNum":"  411","line":"  struct has_join_function<F, NO_TAG_IS_ARRAY> {"},
{"lineNum":"  412","line":"    using vref_type  = volatile ValueType*;"},
{"lineNum":"  413","line":"    using cvref_type = const volatile ValueType*;"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(vref_type,"},
{"lineNum":"  416","line":"                                                             cvref_type) const);"},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(vref_type,"},
{"lineNum":"  419","line":"                                                          cvref_type));"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"    KOKKOS_INLINE_FUNCTION static void join(F const* const f,"},
{"lineNum":"  422","line":"                                            ValueType volatile* dst,"},
{"lineNum":"  423","line":"                                            ValueType volatile const* src) {"},
{"lineNum":"  424","line":"      f->join(dst, src);"},
{"lineNum":"  425","line":"    }"},
{"lineNum":"  426","line":"  };"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"  template <class F>"},
{"lineNum":"  429","line":"  struct has_join_function<F, HAS_TAG_NOT_ARRAY> {"},
{"lineNum":"  430","line":"    using vref_type  = volatile ValueType&;"},
{"lineNum":"  431","line":"    using cvref_type = const volatile ValueType&;"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag, vref_type,"},
{"lineNum":"  434","line":"                                                             cvref_type) const);"},
{"lineNum":"  435","line":""},
{"lineNum":"  436","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag, vref_type,"},
{"lineNum":"  437","line":"                                                          cvref_type));"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag const&,"},
{"lineNum":"  440","line":"                                                             vref_type,"},
{"lineNum":"  441","line":"                                                             cvref_type) const);"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag const&,"},
{"lineNum":"  444","line":"                                                          vref_type,"},
{"lineNum":"  445","line":"                                                          cvref_type));"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"    KOKKOS_INLINE_FUNCTION static void join(F const* const f,"},
{"lineNum":"  448","line":"                                            ValueType volatile* dst,"},
{"lineNum":"  449","line":"                                            ValueType volatile const* src) {"},
{"lineNum":"  450","line":"      f->join(WTag(), *dst, *src);"},
{"lineNum":"  451","line":"    }"},
{"lineNum":"  452","line":"  };"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"  template <class F>"},
{"lineNum":"  455","line":"  struct has_join_function<F, HAS_TAG_IS_ARRAY> {"},
{"lineNum":"  456","line":"    using vref_type  = volatile ValueType*;"},
{"lineNum":"  457","line":"    using cvref_type = const volatile ValueType*;"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag, vref_type,"},
{"lineNum":"  460","line":"                                                             cvref_type) const);"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag, vref_type,"},
{"lineNum":"  463","line":"                                                          cvref_type));"},
{"lineNum":"  464","line":""},
{"lineNum":"  465","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag const&,"},
{"lineNum":"  466","line":"                                                             vref_type,"},
{"lineNum":"  467","line":"                                                             cvref_type) const);"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag const&,"},
{"lineNum":"  470","line":"                                                          vref_type,"},
{"lineNum":"  471","line":"                                                          cvref_type));"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"    KOKKOS_INLINE_FUNCTION static void join(F const* const f,"},
{"lineNum":"  474","line":"                                            ValueType volatile* dst,"},
{"lineNum":"  475","line":"                                            ValueType volatile const* src) {"},
{"lineNum":"  476","line":"      f->join(WTag(), dst, src);"},
{"lineNum":"  477","line":"    }"},
{"lineNum":"  478","line":"  };"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"  template <class F = Functor, INTERFACE = DEDUCED, typename = void>"},
{"lineNum":"  481","line":"  struct DeduceJoin {"},
{"lineNum":"  482","line":"    enum : bool { value = false };"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"    KOKKOS_INLINE_FUNCTION static void join(F const* const f,"},
{"lineNum":"  485","line":"                                            ValueType volatile* dst,"},
{"lineNum":"  486","line":"                                            ValueType volatile const* src) {"},
{"lineNum":"  487","line":"      const int n = FunctorAnalysis::value_count(*f);"},
{"lineNum":"  488","line":"      for (int i = 0; i < n; ++i) dst[i] += src[i];"},
{"lineNum":"  489","line":"    }"},
{"lineNum":"  490","line":"  };"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"  template <class F>"},
{"lineNum":"  493","line":"  struct DeduceJoin<F, DISABLE, void> {"},
{"lineNum":"  494","line":"    enum : bool { value = false };"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"    KOKKOS_INLINE_FUNCTION static void join(F const* const, ValueType volatile*,"},
{"lineNum":"  497","line":"                                            ValueType volatile const*) {}"},
{"lineNum":"  498","line":"  };"},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"  template <class F, INTERFACE I>"},
{"lineNum":"  501","line":"  struct DeduceJoin<F, I,"},
{"lineNum":"  502","line":"                    decltype(has_join_function<F, I>::enable_if(&F::join))>"},
{"lineNum":"  503","line":"      : public has_join_function<F, I> {"},
{"lineNum":"  504","line":"    enum : bool { value = true };"},
{"lineNum":"  505","line":"  };"},
{"lineNum":"  506","line":""},
{"lineNum":"  507","line":"  //----------------------------------------"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"  template <class, INTERFACE>"},
{"lineNum":"  510","line":"  struct has_init_function;"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"  template <class F>"},
{"lineNum":"  513","line":"  struct has_init_function<F, NO_TAG_NOT_ARRAY> {"},
{"lineNum":"  514","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(ValueType&) const);"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(ValueType&));"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"    KOKKOS_INLINE_FUNCTION static void init(F const* const f, ValueType* dst) {"},
{"lineNum":"  519","line":"      f->init(*dst);"},
{"lineNum":"  520","line":"    }"},
{"lineNum":"  521","line":"  };"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"  template <class F>"},
{"lineNum":"  524","line":"  struct has_init_function<F, NO_TAG_IS_ARRAY> {"},
{"lineNum":"  525","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(ValueType*) const);"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(ValueType*));"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"    KOKKOS_INLINE_FUNCTION static void init(F const* const f, ValueType* dst) {"},
{"lineNum":"  530","line":"      f->init(dst);"},
{"lineNum":"  531","line":"    }"},
{"lineNum":"  532","line":"  };"},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":"  template <class F>"},
{"lineNum":"  535","line":"  struct has_init_function<F, HAS_TAG_NOT_ARRAY> {"},
{"lineNum":"  536","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag, ValueType&)"},
{"lineNum":"  537","line":"                                                     const);"},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag const&,"},
{"lineNum":"  540","line":"                                                             ValueType&) const);"},
{"lineNum":"  541","line":""},
{"lineNum":"  542","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag, ValueType&));"},
{"lineNum":"  543","line":""},
{"lineNum":"  544","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag const&,"},
{"lineNum":"  545","line":"                                                          ValueType&));"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"    KOKKOS_INLINE_FUNCTION static void init(F const* const f, ValueType* dst) {"},
{"lineNum":"  548","line":"      f->init(WTag(), *dst);"},
{"lineNum":"  549","line":"    }"},
{"lineNum":"  550","line":"  };"},
{"lineNum":"  551","line":""},
{"lineNum":"  552","line":"  template <class F>"},
{"lineNum":"  553","line":"  struct has_init_function<F, HAS_TAG_IS_ARRAY> {"},
{"lineNum":"  554","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag, ValueType*)"},
{"lineNum":"  555","line":"                                                     const);"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag const&,"},
{"lineNum":"  558","line":"                                                             ValueType*) const);"},
{"lineNum":"  559","line":""},
{"lineNum":"  560","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag, ValueType*));"},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag const&,"},
{"lineNum":"  563","line":"                                                          ValueType*));"},
{"lineNum":"  564","line":""},
{"lineNum":"  565","line":"    KOKKOS_INLINE_FUNCTION static void init(F const* const f, ValueType* dst) {"},
{"lineNum":"  566","line":"      f->init(WTag(), dst);"},
{"lineNum":"  567","line":"    }"},
{"lineNum":"  568","line":"  };"},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"  template <class F = Functor, INTERFACE = DEDUCED, typename = void>"},
{"lineNum":"  571","line":"  struct DeduceInit {"},
{"lineNum":"  572","line":"    enum : bool { value = false };"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"    KOKKOS_INLINE_FUNCTION static void init(F const* const, ValueType* dst) {"},
{"lineNum":"  575","line":"      new (dst) ValueType();"},
{"lineNum":"  576","line":"    }"},
{"lineNum":"  577","line":"  };"},
{"lineNum":"  578","line":""},
{"lineNum":"  579","line":"  template <class F>"},
{"lineNum":"  580","line":"  struct DeduceInit<F, DISABLE, void> {"},
{"lineNum":"  581","line":"    enum : bool { value = false };"},
{"lineNum":"  582","line":""},
{"lineNum":"  583","line":"    KOKKOS_INLINE_FUNCTION static void init(F const* const, ValueType*) {}"},
{"lineNum":"  584","line":"  };"},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"  template <class F, INTERFACE I>"},
{"lineNum":"  587","line":"  struct DeduceInit<F, I,"},
{"lineNum":"  588","line":"                    decltype(has_init_function<F, I>::enable_if(&F::init))>"},
{"lineNum":"  589","line":"      : public has_init_function<F, I> {"},
{"lineNum":"  590","line":"    enum : bool { value = true };"},
{"lineNum":"  591","line":"  };"},
{"lineNum":"  592","line":""},
{"lineNum":"  593","line":"  //----------------------------------------"},
{"lineNum":"  594","line":""},
{"lineNum":"  595","line":"  template <class, INTERFACE>"},
{"lineNum":"  596","line":"  struct has_final_function;"},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"  // No tag, not array"},
{"lineNum":"  599","line":"  template <class F>"},
{"lineNum":"  600","line":"  struct has_final_function<F, NO_TAG_NOT_ARRAY> {"},
{"lineNum":"  601","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(ValueType&) const);"},
{"lineNum":"  602","line":""},
{"lineNum":"  603","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(ValueType&));"},
{"lineNum":"  604","line":""},
{"lineNum":"  605","line":"    KOKKOS_INLINE_FUNCTION static void final(F const* const f, ValueType* dst) {"},
{"lineNum":"  606","line":"      f->final(*dst);"},
{"lineNum":"  607","line":"    }"},
{"lineNum":"  608","line":"  };"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"  // No tag, is array"},
{"lineNum":"  611","line":"  template <class F>"},
{"lineNum":"  612","line":"  struct has_final_function<F, NO_TAG_IS_ARRAY> {"},
{"lineNum":"  613","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(ValueType*) const);"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(ValueType*));"},
{"lineNum":"  616","line":""},
{"lineNum":"  617","line":"    KOKKOS_INLINE_FUNCTION static void final(F const* const f, ValueType* dst) {"},
{"lineNum":"  618","line":"      f->final(dst);"},
{"lineNum":"  619","line":"    }"},
{"lineNum":"  620","line":"  };"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"  // Has tag, not array"},
{"lineNum":"  623","line":"  template <class F>"},
{"lineNum":"  624","line":"  struct has_final_function<F, HAS_TAG_NOT_ARRAY> {"},
{"lineNum":"  625","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag, ValueType&)"},
{"lineNum":"  626","line":"                                                     const);"},
{"lineNum":"  627","line":""},
{"lineNum":"  628","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag const&,"},
{"lineNum":"  629","line":"                                                             ValueType&) const);"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag, ValueType&));"},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag const&,"},
{"lineNum":"  634","line":"                                                          ValueType&));"},
{"lineNum":"  635","line":""},
{"lineNum":"  636","line":"    KOKKOS_INLINE_FUNCTION static void final(F const* const f, ValueType* dst) {"},
{"lineNum":"  637","line":"      f->final(WTag(), *dst);"},
{"lineNum":"  638","line":"    }"},
{"lineNum":"  639","line":"  };"},
{"lineNum":"  640","line":""},
{"lineNum":"  641","line":"  // Has tag, is array"},
{"lineNum":"  642","line":"  template <class F>"},
{"lineNum":"  643","line":"  struct has_final_function<F, HAS_TAG_IS_ARRAY> {"},
{"lineNum":"  644","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag, ValueType*)"},
{"lineNum":"  645","line":"                                                     const);"},
{"lineNum":"  646","line":""},
{"lineNum":"  647","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (F::*)(WTag const&,"},
{"lineNum":"  648","line":"                                                             ValueType*) const);"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag, ValueType*));"},
{"lineNum":"  651","line":""},
{"lineNum":"  652","line":"    KOKKOS_INLINE_FUNCTION static void enable_if(void (*)(WTag const&,"},
{"lineNum":"  653","line":"                                                          ValueType*));"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"    KOKKOS_INLINE_FUNCTION static void final(F const* const f, ValueType* dst) {"},
{"lineNum":"  656","line":"      f->final(WTag(), dst);"},
{"lineNum":"  657","line":"    }"},
{"lineNum":"  658","line":"  };"},
{"lineNum":"  659","line":""},
{"lineNum":"  660","line":"  template <class F = Functor, INTERFACE = DEDUCED, typename = void>"},
{"lineNum":"  661","line":"  struct DeduceFinal {"},
{"lineNum":"  662","line":"    enum : bool { value = false };"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"    KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  665","line":"    static void final(F const* const, ValueType*) {}"},
{"lineNum":"  666","line":"  };"},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"  template <class F, INTERFACE I>"},
{"lineNum":"  669","line":"  struct DeduceFinal<F, I,"},
{"lineNum":"  670","line":"                     decltype(has_final_function<F, I>::enable_if(&F::final))>"},
{"lineNum":"  671","line":"      : public has_final_function<F, I> {"},
{"lineNum":"  672","line":"    enum : bool { value = true };"},
{"lineNum":"  673","line":"  };"},
{"lineNum":"  674","line":""},
{"lineNum":"  675","line":"  //----------------------------------------"},
{"lineNum":"  676","line":""},
{"lineNum":"  677","line":"  template <class F = Functor, typename = void>"},
{"lineNum":"  678","line":"  struct DeduceTeamShmem {"},
{"lineNum":"  679","line":"    enum : bool { value = false };"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"    static size_t team_shmem_size(F const&, int) { return 0; }"},
{"lineNum":"  682","line":"  };"},
{"lineNum":"  683","line":""},
{"lineNum":"  684","line":"  template <class F>"},
{"lineNum":"  685","line":"  struct DeduceTeamShmem<"},
{"lineNum":"  686","line":"      F, typename std::enable_if<0 < sizeof(&F::team_shmem_size)>::type> {"},
{"lineNum":"  687","line":"    enum : bool { value = true };"},
{"lineNum":"  688","line":""},
{"lineNum":"  689","line":"    static size_t team_shmem_size(F const* const f, int team_size) {"},
{"lineNum":"  690","line":"      return f->team_shmem_size(team_size);"},
{"lineNum":"  691","line":"    }"},
{"lineNum":"  692","line":"  };"},
{"lineNum":"  693","line":""},
{"lineNum":"  694","line":"  template <class F>"},
{"lineNum":"  695","line":"  struct DeduceTeamShmem<"},
{"lineNum":"  696","line":"      F, typename std::enable_if<0 < sizeof(&F::shmem_size)>::type> {"},
{"lineNum":"  697","line":"    enum : bool { value = true };"},
{"lineNum":"  698","line":""},
{"lineNum":"  699","line":"    static size_t team_shmem_size(F const* const f, int team_size) {"},
{"lineNum":"  700","line":"      return f->shmem_size(team_size);"},
{"lineNum":"  701","line":"    }"},
{"lineNum":"  702","line":"  };"},
{"lineNum":"  703","line":""},
{"lineNum":"  704","line":"  //----------------------------------------"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":" public:"},
{"lineNum":"  707","line":"  inline static size_t team_shmem_size(Functor const& f) {"},
{"lineNum":"  708","line":"    return DeduceTeamShmem<>::team_shmem_size(f);"},
{"lineNum":"  709","line":"  }"},
{"lineNum":"  710","line":""},
{"lineNum":"  711","line":"  //----------------------------------------"},
{"lineNum":"  712","line":""},
{"lineNum":"  713","line":"  enum { has_join_member_function = DeduceJoin<>::value };"},
{"lineNum":"  714","line":"  enum { has_init_member_function = DeduceInit<>::value };"},
{"lineNum":"  715","line":"  enum { has_final_member_function = DeduceFinal<>::value };"},
{"lineNum":"  716","line":""},
{"lineNum":"  717","line":"  template <class MemorySpace = typename execution_space::memory_space>"},
{"lineNum":"  718","line":"  struct Reducer {"},
{"lineNum":"  719","line":"   private:"},
{"lineNum":"  720","line":"    Functor const* const m_functor;"},
{"lineNum":"  721","line":"    ValueType* const m_result;"},
{"lineNum":"  722","line":""},
{"lineNum":"  723","line":"    template <bool IsArray>"},
{"lineNum":"  724","line":"    KOKKOS_INLINE_FUNCTION constexpr"},
{"lineNum":"  725","line":"        typename std::enable_if<IsArray, FunctorAnalysis::ValueType*>::type"},
{"lineNum":"  726","line":"        ref() const noexcept {"},
{"lineNum":"  727","line":"      return m_result;"},
{"lineNum":"  728","line":"    }"},
{"lineNum":"  729","line":""},
{"lineNum":"  730","line":"    template <bool IsArray>"},
{"lineNum":"  731","line":"    KOKKOS_INLINE_FUNCTION constexpr"},
{"lineNum":"  732","line":"        typename std::enable_if<!IsArray, FunctorAnalysis::ValueType&>::type"},
{"lineNum":"  733","line":"        ref() const noexcept {"},
{"lineNum":"  734","line":"      return *m_result;"},
{"lineNum":"  735","line":"    }"},
{"lineNum":"  736","line":""},
{"lineNum":"  737","line":"    template <bool IsArray>"},
{"lineNum":"  738","line":"    KOKKOS_INLINE_FUNCTION constexpr typename std::enable_if<IsArray, int>::type"},
{"lineNum":"  739","line":"    len() const noexcept {"},
{"lineNum":"  740","line":"      return m_functor->value_count;"},
{"lineNum":"  741","line":"    }"},
{"lineNum":"  742","line":""},
{"lineNum":"  743","line":"    template <bool IsArray>"},
{"lineNum":"  744","line":"    KOKKOS_INLINE_FUNCTION constexpr"},
{"lineNum":"  745","line":"        typename std::enable_if<!IsArray, int>::type"},
{"lineNum":"  746","line":"        len() const noexcept {"},
{"lineNum":"  747","line":"      return candidate_is_void ? 0 : 1;"},
{"lineNum":"  748","line":"    }"},
{"lineNum":"  749","line":""},
{"lineNum":"  750","line":"   public:"},
{"lineNum":"  751","line":"    using reducer        = Reducer;"},
{"lineNum":"  752","line":"    using value_type     = FunctorAnalysis::value_type;"},
{"lineNum":"  753","line":"    using memory_space   = MemorySpace;"},
{"lineNum":"  754","line":"    using reference_type = FunctorAnalysis::reference_type;"},
{"lineNum":"  755","line":"    using functor_type   = Functor;  // Adapts a functor"},
{"lineNum":"  756","line":""},
{"lineNum":"  757","line":"    KOKKOS_INLINE_FUNCTION constexpr value_type* data() const noexcept {"},
{"lineNum":"  758","line":"      return m_result;"},
{"lineNum":"  759","line":"    }"},
{"lineNum":"  760","line":""},
{"lineNum":"  761","line":"    KOKKOS_INLINE_FUNCTION constexpr reference_type reference() const noexcept {"},
{"lineNum":"  762","line":"      return Reducer::template ref<candidate_is_array>();"},
{"lineNum":"  763","line":"    }"},
{"lineNum":"  764","line":""},
{"lineNum":"  765","line":"    KOKKOS_INLINE_FUNCTION constexpr int length() const noexcept {"},
{"lineNum":"  766","line":"      return Reducer::template len<candidate_is_array>();"},
{"lineNum":"  767","line":"    }"},
{"lineNum":"  768","line":""},
{"lineNum":"  769","line":"    KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  770","line":"    void copy(ValueType* const dst, ValueType const* const src) const noexcept {"},
{"lineNum":"  771","line":"      for (int i = 0; i < Reducer::template len<candidate_is_array>(); ++i)"},
{"lineNum":"  772","line":"        dst[i] = src[i];"},
{"lineNum":"  773","line":"    }"},
{"lineNum":"  774","line":""},
{"lineNum":"  775","line":"    KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  776","line":"    void join(ValueType volatile* dst, ValueType volatile const* src) const"},
{"lineNum":"  777","line":"        noexcept {"},
{"lineNum":"  778","line":"      DeduceJoin<>::join(m_functor, dst, src);"},
{"lineNum":"  779","line":"    }"},
{"lineNum":"  780","line":""},
{"lineNum":"  781","line":"    KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  782","line":"    void init(ValueType* dst) const noexcept {"},
{"lineNum":"  783","line":"      DeduceInit<>::init(m_functor, dst);"},
{"lineNum":"  784","line":"    }"},
{"lineNum":"  785","line":""},
{"lineNum":"  786","line":"    KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  787","line":"    void final(ValueType* dst) const noexcept {"},
{"lineNum":"  788","line":"      DeduceFinal<>::final(m_functor, dst);"},
{"lineNum":"  789","line":"    }"},
{"lineNum":"  790","line":""},
{"lineNum":"  791","line":"    Reducer(Reducer const&) = default;"},
{"lineNum":"  792","line":"    Reducer(Reducer&&)      = default;"},
{"lineNum":"  793","line":"    Reducer& operator=(Reducer const&) = delete;"},
{"lineNum":"  794","line":"    Reducer& operator=(Reducer&&) = delete;"},
{"lineNum":"  795","line":""},
{"lineNum":"  796","line":"    template <class S>"},
{"lineNum":"  797","line":"    using rebind = Reducer<S>;"},
{"lineNum":"  798","line":""},
{"lineNum":"  799","line":"    KOKKOS_INLINE_FUNCTION explicit constexpr Reducer("},
{"lineNum":"  800","line":"        Functor const* arg_functor = 0, ValueType* arg_value = nullptr) noexcept"},
{"lineNum":"  801","line":"        : m_functor(arg_functor), m_result(arg_value) {}"},
{"lineNum":"  802","line":"  };"},
{"lineNum":"  803","line":"};"},
{"lineNum":"  804","line":""},
{"lineNum":"  805","line":"}  // namespace Impl"},
{"lineNum":"  806","line":"}  // namespace Kokkos"},
{"lineNum":"  807","line":""},
{"lineNum":"  808","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  809","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  810","line":""},
{"lineNum":"  811","line":"#endif /* KOKKOS_FUNCTORANALYSIS_HPP */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
