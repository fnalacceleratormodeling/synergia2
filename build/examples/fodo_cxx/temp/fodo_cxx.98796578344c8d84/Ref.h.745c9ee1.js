var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2012 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_REF_H"},
{"lineNum":"   11","line":"#define EIGEN_REF_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"template<typename _PlainObjectType, int Options_, typename _StrideType>"},
{"lineNum":"   20","line":"struct traits<Ref<_PlainObjectType, Options_, _StrideType> >"},
{"lineNum":"   21","line":"  : public traits<Map<_PlainObjectType, Options_, _StrideType> >"},
{"lineNum":"   22","line":"{"},
{"lineNum":"   23","line":"  typedef _PlainObjectType PlainObjectType;"},
{"lineNum":"   24","line":"  typedef _StrideType StrideType;"},
{"lineNum":"   25","line":"  enum {"},
{"lineNum":"   26","line":"    Options = Options_,"},
{"lineNum":"   27","line":"    Flags = traits<Map<_PlainObjectType, Options_, _StrideType> >::Flags | NestByRefBit,"},
{"lineNum":"   28","line":"    Alignment = traits<Map<_PlainObjectType, Options_, _StrideType> >::Alignment"},
{"lineNum":"   29","line":"  };"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"  template<typename Derived> struct match {"},
{"lineNum":"   32","line":"    enum {"},
{"lineNum":"   33","line":"      IsVectorAtCompileTime = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime,"},
{"lineNum":"   34","line":"      HasDirectAccess = internal::has_direct_access<Derived>::ret,"},
{"lineNum":"   35","line":"      StorageOrderMatch = IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),"},
{"lineNum":"   36","line":"      InnerStrideMatch = int(StrideType::InnerStrideAtCompileTime)==int(Dynamic)"},
{"lineNum":"   37","line":"                      || int(StrideType::InnerStrideAtCompileTime)==int(Derived::InnerStrideAtCompileTime)"},
{"lineNum":"   38","line":"                      || (int(StrideType::InnerStrideAtCompileTime)==0 && int(Derived::InnerStrideAtCompileTime)==1),"},
{"lineNum":"   39","line":"      OuterStrideMatch = IsVectorAtCompileTime"},
{"lineNum":"   40","line":"                      || int(StrideType::OuterStrideAtCompileTime)==int(Dynamic) || int(StrideType::OuterStrideAtCompileTime)==int(Derived::OuterStrideAtCompileTime),"},
{"lineNum":"   41","line":"      // NOTE, this indirection of evaluator<Derived>::Alignment is needed"},
{"lineNum":"   42","line":"      // to workaround a very strange bug in MSVC related to the instantiation"},
{"lineNum":"   43","line":"      // of has_*ary_operator in evaluator<CwiseNullaryOp>."},
{"lineNum":"   44","line":"      // This line is surprisingly very sensitive. For instance, simply adding parenthesis"},
{"lineNum":"   45","line":"      // as \"DerivedAlignment = (int(evaluator<Derived>::Alignment)),\" will make MSVC fail..."},
{"lineNum":"   46","line":"      DerivedAlignment = int(evaluator<Derived>::Alignment),"},
{"lineNum":"   47","line":"      AlignmentMatch = (int(traits<PlainObjectType>::Alignment)==int(Unaligned)) || (DerivedAlignment >= int(Alignment)), // FIXME the first condition is not very clear, it should be replaced by the required alignment"},
{"lineNum":"   48","line":"      ScalarTypeMatch = internal::is_same<typename PlainObjectType::Scalar, typename Derived::Scalar>::value,"},
{"lineNum":"   49","line":"      MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && AlignmentMatch && ScalarTypeMatch"},
{"lineNum":"   50","line":"    };"},
{"lineNum":"   51","line":"    typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;"},
{"lineNum":"   52","line":"  };"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"template<typename Derived>"},
{"lineNum":"   57","line":"struct traits<RefBase<Derived> > : public traits<Derived> {};"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"}"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"template<typename Derived> class RefBase"},
{"lineNum":"   62","line":" : public MapBase<Derived>"},
{"lineNum":"   63","line":"{"},
{"lineNum":"   64","line":"  typedef typename internal::traits<Derived>::PlainObjectType PlainObjectType;"},
{"lineNum":"   65","line":"  typedef typename internal::traits<Derived>::StrideType StrideType;"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"public:"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"  typedef MapBase<Derived> Base;"},
{"lineNum":"   70","line":"  EIGEN_DENSE_PUBLIC_INTERFACE(RefBase)"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR inline Index innerStride() const"},
{"lineNum":"   73","line":"  {"},
{"lineNum":"   74","line":"    return StrideType::InnerStrideAtCompileTime != 0 ? m_stride.inner() : 1;"},
{"lineNum":"   75","line":"  }"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"  EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR inline Index outerStride() const"},
{"lineNum":"   78","line":"  {"},
{"lineNum":"   79","line":"    return StrideType::OuterStrideAtCompileTime != 0 ? m_stride.outer()"},
{"lineNum":"   80","line":"         : IsVectorAtCompileTime ? this->size()"},
{"lineNum":"   81","line":"         : int(Flags)&RowMajorBit ? this->cols()"},
{"lineNum":"   82","line":"         : this->rows();"},
{"lineNum":"   83","line":"  }"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"  EIGEN_DEVICE_FUNC RefBase()"},
{"lineNum":"   86","line":"    : Base(0,RowsAtCompileTime==Dynamic?0:RowsAtCompileTime,ColsAtCompileTime==Dynamic?0:ColsAtCompileTime),"},
{"lineNum":"   87","line":"      // Stride<> does not allow default ctor for Dynamic strides, so let\' initialize it with dummy values:"},
{"lineNum":"   88","line":"      m_stride(StrideType::OuterStrideAtCompileTime==Dynamic?0:StrideType::OuterStrideAtCompileTime,"},
{"lineNum":"   89","line":"               StrideType::InnerStrideAtCompileTime==Dynamic?0:StrideType::InnerStrideAtCompileTime)"},
{"lineNum":"   90","line":"  {}"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"  EIGEN_INHERIT_ASSIGNMENT_OPERATORS(RefBase)"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"protected:"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"  typedef Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase;"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"  // Resolves inner stride if default 0."},
{"lineNum":"   99","line":"  static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index resolveInnerStride(Index inner) {"},
{"lineNum":"  100","line":"    return inner == 0 ? 1 : inner;"},
{"lineNum":"  101","line":"  }"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"  // Resolves outer stride if default 0."},
{"lineNum":"  104","line":"  static EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR Index resolveOuterStride(Index inner, Index outer, Index rows, Index cols, bool isVectorAtCompileTime, bool isRowMajor) {"},
{"lineNum":"  105","line":"    return outer == 0 ? isVectorAtCompileTime ? inner * rows * cols : isRowMajor ? inner * cols : inner * rows : outer;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  106","line":"  }"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"  // Returns true if construction is valid, false if there is a stride mismatch,"},
{"lineNum":"  109","line":"  // and fails if there is a size mismatch."},
{"lineNum":"  110","line":"  template<typename Expression>"},
{"lineNum":"  111","line":"  EIGEN_DEVICE_FUNC bool construct(Expression& expr)"},
{"lineNum":"  112","line":"  {"},
{"lineNum":"  113","line":"    // Check matrix sizes.  If this is a compile-time vector, we do allow"},
{"lineNum":"  114","line":"    // implicitly transposing."},
{"lineNum":"  115","line":"    EIGEN_STATIC_ASSERT("},
{"lineNum":"  116","line":"      EIGEN_PREDICATE_SAME_MATRIX_SIZE(PlainObjectType, Expression)"},
{"lineNum":"  117","line":"      // If it is a vector, the transpose sizes might match."},
{"lineNum":"  118","line":"      || ( PlainObjectType::IsVectorAtCompileTime"},
{"lineNum":"  119","line":"            && ((int(PlainObjectType::RowsAtCompileTime)==Eigen::Dynamic"},
{"lineNum":"  120","line":"              || int(Expression::ColsAtCompileTime)==Eigen::Dynamic"},
{"lineNum":"  121","line":"              || int(PlainObjectType::RowsAtCompileTime)==int(Expression::ColsAtCompileTime))"},
{"lineNum":"  122","line":"            &&  (int(PlainObjectType::ColsAtCompileTime)==Eigen::Dynamic"},
{"lineNum":"  123","line":"              || int(Expression::RowsAtCompileTime)==Eigen::Dynamic"},
{"lineNum":"  124","line":"              || int(PlainObjectType::ColsAtCompileTime)==int(Expression::RowsAtCompileTime)))),"},
{"lineNum":"  125","line":"      YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES"},
{"lineNum":"  126","line":"    )"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"    // Determine runtime rows and columns."},
{"lineNum":"  129","line":"    Index rows = expr.rows();"},
{"lineNum":"  130","line":"    Index cols = expr.cols();"},
{"lineNum":"  131","line":"    if(PlainObjectType::RowsAtCompileTime==1)"},
{"lineNum":"  132","line":"    {"},
{"lineNum":"  133","line":"      eigen_assert(expr.rows()==1 || expr.cols()==1);"},
{"lineNum":"  134","line":"      rows = 1;"},
{"lineNum":"  135","line":"      cols = expr.size();"},
{"lineNum":"  136","line":"    }"},
{"lineNum":"  137","line":"    else if(PlainObjectType::ColsAtCompileTime==1)"},
{"lineNum":"  138","line":"    {"},
{"lineNum":"  139","line":"      eigen_assert(expr.rows()==1 || expr.cols()==1);"},
{"lineNum":"  140","line":"      rows = expr.size();"},
{"lineNum":"  141","line":"      cols = 1;"},
{"lineNum":"  142","line":"    }"},
{"lineNum":"  143","line":"    // Verify that the sizes are valid."},
{"lineNum":"  144","line":"    eigen_assert("},
{"lineNum":"  145","line":"      (PlainObjectType::RowsAtCompileTime == Dynamic) || (PlainObjectType::RowsAtCompileTime == rows));"},
{"lineNum":"  146","line":"    eigen_assert("},
{"lineNum":"  147","line":"      (PlainObjectType::ColsAtCompileTime == Dynamic) || (PlainObjectType::ColsAtCompileTime == cols));"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"    // If this is a vector, we might be transposing, which means that stride should swap."},
{"lineNum":"  151","line":"    const bool transpose = PlainObjectType::IsVectorAtCompileTime && (rows != expr.rows());"},
{"lineNum":"  152","line":"    // If the storage format differs, we also need to swap the stride."},
{"lineNum":"  153","line":"    const bool row_major = ((PlainObjectType::Flags)&RowMajorBit) != 0;"},
{"lineNum":"  154","line":"    const bool expr_row_major = (Expression::Flags&RowMajorBit) != 0;"},
{"lineNum":"  155","line":"    const bool storage_differs =  (row_major != expr_row_major);"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"    const bool swap_stride = (transpose != storage_differs);"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    // Determine expr\'s actual strides, resolving any defaults if zero."},
{"lineNum":"  160","line":"    const Index expr_inner_actual = resolveInnerStride(expr.innerStride());"},
{"lineNum":"  161","line":"    const Index expr_outer_actual = resolveOuterStride(expr_inner_actual,"},
{"lineNum":"  162","line":"                                                       expr.outerStride(),"},
{"lineNum":"  163","line":"                                                       expr.rows(),"},
{"lineNum":"  164","line":"                                                       expr.cols(),"},
{"lineNum":"  165","line":"                                                       Expression::IsVectorAtCompileTime != 0,"},
{"lineNum":"  166","line":"                                                       expr_row_major);"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"    // If this is a column-major row vector or row-major column vector, the inner-stride"},
{"lineNum":"  169","line":"    // is arbitrary, so set it to either the compile-time inner stride or 1."},
{"lineNum":"  170","line":"    const bool row_vector = (rows == 1);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  171","line":"    const bool col_vector = (cols == 1);","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  172","line":"    const Index inner_stride ="},
{"lineNum":"  173","line":"        ( (!row_major && row_vector) || (row_major && col_vector) ) ?"},
{"lineNum":"  174","line":"            ( StrideType::InnerStrideAtCompileTime > 0 ? Index(StrideType::InnerStrideAtCompileTime) : 1)"},
{"lineNum":"  175","line":"            : swap_stride ? expr_outer_actual : expr_inner_actual;"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"    // If this is a column-major column vector or row-major row vector, the outer-stride"},
{"lineNum":"  178","line":"    // is arbitrary, so set it to either the compile-time outer stride or vector size."},
{"lineNum":"  179","line":"    const Index outer_stride ="},
{"lineNum":"  180","line":"      ( (!row_major && col_vector) || (row_major && row_vector) ) ?","class":"lineNoCov","hits":"0","possible_hits":"33",},
{"lineNum":"  181","line":"          ( StrideType::OuterStrideAtCompileTime > 0 ? Index(StrideType::OuterStrideAtCompileTime) : rows * cols * inner_stride)"},
{"lineNum":"  182","line":"          : swap_stride ? expr_inner_actual : expr_outer_actual;"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"    // Check if given inner/outer strides are compatible with compile-time strides."},
{"lineNum":"  185","line":"    const bool inner_valid = (StrideType::InnerStrideAtCompileTime == Dynamic)"},
{"lineNum":"  186","line":"        || (resolveInnerStride(Index(StrideType::InnerStrideAtCompileTime)) == inner_stride);"},
{"lineNum":"  187","line":"    if (!inner_valid) {"},
{"lineNum":"  188","line":"      return false;"},
{"lineNum":"  189","line":"    }"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"    const bool outer_valid = (StrideType::OuterStrideAtCompileTime == Dynamic)"},
{"lineNum":"  192","line":"        || (resolveOuterStride("},
{"lineNum":"  193","line":"              inner_stride,"},
{"lineNum":"  194","line":"              Index(StrideType::OuterStrideAtCompileTime),"},
{"lineNum":"  195","line":"              rows, cols, PlainObjectType::IsVectorAtCompileTime != 0,"},
{"lineNum":"  196","line":"              row_major)"},
{"lineNum":"  197","line":"            == outer_stride);"},
{"lineNum":"  198","line":"    if (!outer_valid) {"},
{"lineNum":"  199","line":"      return false;"},
{"lineNum":"  200","line":"    }"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"    ::new (static_cast<Base*>(this)) Base(expr.data(), rows, cols);"},
{"lineNum":"  203","line":"    ::new (&m_stride) StrideBase("},
{"lineNum":"  204","line":"      (StrideType::OuterStrideAtCompileTime == 0) ? 0 : outer_stride,"},
{"lineNum":"  205","line":"      (StrideType::InnerStrideAtCompileTime == 0) ? 0 : inner_stride );"},
{"lineNum":"  206","line":"    return true;"},
{"lineNum":"  207","line":"  }"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"  StrideBase m_stride;"},
{"lineNum":"  210","line":"};"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"/** \\class Ref"},
{"lineNum":"  213","line":"  * \\ingroup Core_Module"},
{"lineNum":"  214","line":"  *"},
{"lineNum":"  215","line":"  * \\brief A matrix or vector expression mapping an existing expression"},
{"lineNum":"  216","line":"  *"},
{"lineNum":"  217","line":"  * \\tparam PlainObjectType the equivalent matrix type of the mapped data"},
{"lineNum":"  218","line":"  * \\tparam Options specifies the pointer alignment in bytes. It can be: \\c #Aligned128, , \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned."},
{"lineNum":"  219","line":"  *                 The default is \\c #Unaligned."},
{"lineNum":"  220","line":"  * \\tparam StrideType optionally specifies strides. By default, Ref implies a contiguous storage along the inner dimension (inner stride==1),"},
{"lineNum":"  221","line":"  *                   but accepts a variable outer stride (leading dimension)."},
{"lineNum":"  222","line":"  *                   This can be overridden by specifying strides."},
{"lineNum":"  223","line":"  *                   The type passed here must be a specialization of the Stride template, see examples below."},
{"lineNum":"  224","line":"  *"},
{"lineNum":"  225","line":"  * This class provides a way to write non-template functions taking Eigen objects as parameters while limiting the number of copies."},
{"lineNum":"  226","line":"  * A Ref<> object can represent either a const expression or a l-value:"},
{"lineNum":"  227","line":"  * \\code"},
{"lineNum":"  228","line":"  * // in-out argument:"},
{"lineNum":"  229","line":"  * void foo1(Ref<VectorXf> x);"},
{"lineNum":"  230","line":"  *"},
{"lineNum":"  231","line":"  * // read-only const argument:"},
{"lineNum":"  232","line":"  * void foo2(const Ref<const VectorXf>& x);"},
{"lineNum":"  233","line":"  * \\endcode"},
{"lineNum":"  234","line":"  *"},
{"lineNum":"  235","line":"  * In the in-out case, the input argument must satisfy the constraints of the actual Ref<> type, otherwise a compilation issue will be triggered."},
{"lineNum":"  236","line":"  * By default, a Ref<VectorXf> can reference any dense vector expression of float having a contiguous memory layout."},
{"lineNum":"  237","line":"  * Likewise, a Ref<MatrixXf> can reference any column-major dense matrix expression of float whose column\'s elements are contiguously stored with"},
{"lineNum":"  238","line":"  * the possibility to have a constant space in-between each column, i.e. the inner stride must be equal to 1, but the outer stride (or leading dimension)"},
{"lineNum":"  239","line":"  * can be greater than the number of rows."},
{"lineNum":"  240","line":"  *"},
{"lineNum":"  241","line":"  * In the const case, if the input expression does not match the above requirement, then it is evaluated into a temporary before being passed to the function."},
{"lineNum":"  242","line":"  * Here are some examples:"},
{"lineNum":"  243","line":"  * \\code"},
{"lineNum":"  244","line":"  * MatrixXf A;"},
{"lineNum":"  245","line":"  * VectorXf a;"},
{"lineNum":"  246","line":"  * foo1(a.head());             // OK"},
{"lineNum":"  247","line":"  * foo1(A.col());              // OK"},
{"lineNum":"  248","line":"  * foo1(A.row());              // Compilation error because here innerstride!=1"},
{"lineNum":"  249","line":"  * foo2(A.row());              // Compilation error because A.row() is a 1xN object while foo2 is expecting a Nx1 object"},
{"lineNum":"  250","line":"  * foo2(A.row().transpose());  // The row is copied into a contiguous temporary"},
{"lineNum":"  251","line":"  * foo2(2*a);                  // The expression is evaluated into a temporary"},
{"lineNum":"  252","line":"  * foo2(A.col().segment(2,4)); // No temporary"},
{"lineNum":"  253","line":"  * \\endcode"},
{"lineNum":"  254","line":"  *"},
{"lineNum":"  255","line":"  * The range of inputs that can be referenced without temporary can be enlarged using the last two template parameters."},
{"lineNum":"  256","line":"  * Here is an example accepting an innerstride!=1:"},
{"lineNum":"  257","line":"  * \\code"},
{"lineNum":"  258","line":"  * // in-out argument:"},
{"lineNum":"  259","line":"  * void foo3(Ref<VectorXf,0,InnerStride<> > x);"},
{"lineNum":"  260","line":"  * foo3(A.row());              // OK"},
{"lineNum":"  261","line":"  * \\endcode"},
{"lineNum":"  262","line":"  * The downside here is that the function foo3 might be significantly slower than foo1 because it won\'t be able to exploit vectorization, and will involve more"},
{"lineNum":"  263","line":"  * expensive address computations even if the input is contiguously stored in memory. To overcome this issue, one might propose to overload internally calling a"},
{"lineNum":"  264","line":"  * template function, e.g.:"},
{"lineNum":"  265","line":"  * \\code"},
{"lineNum":"  266","line":"  * // in the .h:"},
{"lineNum":"  267","line":"  * void foo(const Ref<MatrixXf>& A);"},
{"lineNum":"  268","line":"  * void foo(const Ref<MatrixXf,0,Stride<> >& A);"},
{"lineNum":"  269","line":"  *"},
{"lineNum":"  270","line":"  * // in the .cpp:"},
{"lineNum":"  271","line":"  * template<typename TypeOfA> void foo_impl(const TypeOfA& A) {"},
{"lineNum":"  272","line":"  *     ... // crazy code goes here"},
{"lineNum":"  273","line":"  * }"},
{"lineNum":"  274","line":"  * void foo(const Ref<MatrixXf>& A) { foo_impl(A); }"},
{"lineNum":"  275","line":"  * void foo(const Ref<MatrixXf,0,Stride<> >& A) { foo_impl(A); }"},
{"lineNum":"  276","line":"  * \\endcode"},
{"lineNum":"  277","line":"  *"},
{"lineNum":"  278","line":"  * See also the following stackoverflow questions for further references:"},
{"lineNum":"  279","line":"  *  - <a href=\"http://stackoverflow.com/questions/21132538/correct-usage-of-the-eigenref-class\">Correct usage of the Eigen::Ref<> class</a>"},
{"lineNum":"  280","line":"  *"},
{"lineNum":"  281","line":"  * \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"},
{"lineNum":"  282","line":"  */"},
{"lineNum":"  283","line":"template<typename PlainObjectType, int Options, typename StrideType> class Ref"},
{"lineNum":"  284","line":"  : public RefBase<Ref<PlainObjectType, Options, StrideType> >"},
{"lineNum":"  285","line":"{"},
{"lineNum":"  286","line":"  private:"},
{"lineNum":"  287","line":"    typedef internal::traits<Ref> Traits;"},
{"lineNum":"  288","line":"    template<typename Derived>"},
{"lineNum":"  289","line":"    EIGEN_DEVICE_FUNC inline Ref(const PlainObjectBase<Derived>& expr,"},
{"lineNum":"  290","line":"                                 typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0);"},
{"lineNum":"  291","line":"  public:"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"    typedef RefBase<Ref> Base;"},
{"lineNum":"  294","line":"    EIGEN_DENSE_PUBLIC_INTERFACE(Ref)"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"    #ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  298","line":"    template<typename Derived>"},
{"lineNum":"  299","line":"    EIGEN_DEVICE_FUNC inline Ref(PlainObjectBase<Derived>& expr,"},
{"lineNum":"  300","line":"                                 typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)"},
{"lineNum":"  301","line":"    {"},
{"lineNum":"  302","line":"      EIGEN_STATIC_ASSERT(bool(Traits::template match<Derived>::MatchAtCompileTime), STORAGE_LAYOUT_DOES_NOT_MATCH);"},
{"lineNum":"  303","line":"      // Construction must pass since we will not create temporary storage in the non-const case."},
{"lineNum":"  304","line":"      const bool success = Base::construct(expr.derived());"},
{"lineNum":"  305","line":"      EIGEN_UNUSED_VARIABLE(success)"},
{"lineNum":"  306","line":"      eigen_assert(success);"},
{"lineNum":"  307","line":"    }"},
{"lineNum":"  308","line":"    template<typename Derived>"},
{"lineNum":"  309","line":"    EIGEN_DEVICE_FUNC inline Ref(const DenseBase<Derived>& expr,"},
{"lineNum":"  310","line":"                                 typename internal::enable_if<bool(Traits::template match<Derived>::MatchAtCompileTime),Derived>::type* = 0)"},
{"lineNum":"  311","line":"    #else"},
{"lineNum":"  312","line":"    /** Implicit constructor from any dense expression */"},
{"lineNum":"  313","line":"    template<typename Derived>"},
{"lineNum":"  314","line":"    inline Ref(DenseBase<Derived>& expr)"},
{"lineNum":"  315","line":"    #endif"},
{"lineNum":"  316","line":"    {"},
{"lineNum":"  317","line":"      EIGEN_STATIC_ASSERT(bool(internal::is_lvalue<Derived>::value), THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY);"},
{"lineNum":"  318","line":"      EIGEN_STATIC_ASSERT(bool(Traits::template match<Derived>::MatchAtCompileTime), STORAGE_LAYOUT_DOES_NOT_MATCH);"},
{"lineNum":"  319","line":"      EIGEN_STATIC_ASSERT(!Derived::IsPlainObjectBase,THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY);"},
{"lineNum":"  320","line":"      // Construction must pass since we will not create temporary storage in the non-const case."},
{"lineNum":"  321","line":"      const bool success = Base::construct(expr.const_cast_derived());"},
{"lineNum":"  322","line":"      EIGEN_UNUSED_VARIABLE(success)"},
{"lineNum":"  323","line":"      eigen_assert(success);"},
{"lineNum":"  324","line":"    }"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Ref)"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"};"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"// this is the const ref version"},
{"lineNum":"  331","line":"template<typename TPlainObjectType, int Options, typename StrideType> class Ref<const TPlainObjectType, Options, StrideType>"},
{"lineNum":"  332","line":"  : public RefBase<Ref<const TPlainObjectType, Options, StrideType> >"},
{"lineNum":"  333","line":"{"},
{"lineNum":"  334","line":"    typedef internal::traits<Ref> Traits;"},
{"lineNum":"  335","line":"  public:"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"    typedef RefBase<Ref> Base;"},
{"lineNum":"  338","line":"    EIGEN_DENSE_PUBLIC_INTERFACE(Ref)"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"    template<typename Derived>"},
{"lineNum":"  341","line":"    EIGEN_DEVICE_FUNC inline Ref(const DenseBase<Derived>& expr,"},
{"lineNum":"  342","line":"                                 typename internal::enable_if<bool(Traits::template match<Derived>::ScalarTypeMatch),Derived>::type* = 0)"},
{"lineNum":"  343","line":"    {"},
{"lineNum":"  344","line":"//      std::cout << match_helper<Derived>::HasDirectAccess << \",\" << match_helper<Derived>::OuterStrideMatch << \",\" << match_helper<Derived>::InnerStrideMatch << \"\\n\";"},
{"lineNum":"  345","line":"//      std::cout << int(StrideType::OuterStrideAtCompileTime) << \" - \" << int(Derived::OuterStrideAtCompileTime) << \"\\n\";"},
{"lineNum":"  346","line":"//      std::cout << int(StrideType::InnerStrideAtCompileTime) << \" - \" << int(Derived::InnerStrideAtCompileTime) << \"\\n\";"},
{"lineNum":"  347","line":"      construct(expr.derived(), typename Traits::template match<Derived>::type());"},
{"lineNum":"  348","line":"    }"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"    EIGEN_DEVICE_FUNC inline Ref(const Ref& other) : Base(other) {"},
{"lineNum":"  351","line":"      // copy constructor shall not copy the m_object, to avoid unnecessary malloc and copy"},
{"lineNum":"  352","line":"    }"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"    template<typename OtherRef>"},
{"lineNum":"  355","line":"    EIGEN_DEVICE_FUNC inline Ref(const RefBase<OtherRef>& other) {"},
{"lineNum":"  356","line":"      construct(other.derived(), typename Traits::template match<OtherRef>::type());"},
{"lineNum":"  357","line":"    }"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"  protected:"},
{"lineNum":"  360","line":""},
{"lineNum":"  361","line":"    template<typename Expression>"},
{"lineNum":"  362","line":"    EIGEN_DEVICE_FUNC void construct(const Expression& expr,internal::true_type)"},
{"lineNum":"  363","line":"    {"},
{"lineNum":"  364","line":"      // Check if we can use the underlying expr\'s storage directly, otherwise call the copy version."},
{"lineNum":"  365","line":"      if (!Base::construct(expr)) {"},
{"lineNum":"  366","line":"        construct(expr, internal::false_type());"},
{"lineNum":"  367","line":"      }"},
{"lineNum":"  368","line":"    }"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"    template<typename Expression>"},
{"lineNum":"  371","line":"    EIGEN_DEVICE_FUNC void construct(const Expression& expr, internal::false_type)"},
{"lineNum":"  372","line":"    {"},
{"lineNum":"  373","line":"      internal::call_assignment_no_alias(m_object,expr,internal::assign_op<Scalar,Scalar>());"},
{"lineNum":"  374","line":"      Base::construct(m_object);"},
{"lineNum":"  375","line":"    }"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"  protected:"},
{"lineNum":"  378","line":"    TPlainObjectType m_object;"},
{"lineNum":"  379","line":"};"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"} // end namespace Eigen"},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"#endif // EIGEN_REF_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
