var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_TRIANGULARMATRIX_H"},
{"lineNum":"   12","line":"#define EIGEN_TRIANGULARMATRIX_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval;"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"}"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"/** \\class TriangularBase"},
{"lineNum":"   25","line":"  * \\ingroup Core_Module"},
{"lineNum":"   26","line":"  *"},
{"lineNum":"   27","line":"  * \\brief Base class for triangular part in a matrix"},
{"lineNum":"   28","line":"  */"},
{"lineNum":"   29","line":"template<typename Derived> class TriangularBase : public EigenBase<Derived>"},
{"lineNum":"   30","line":"{"},
{"lineNum":"   31","line":"  public:"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"    enum {"},
{"lineNum":"   34","line":"      Mode = internal::traits<Derived>::Mode,"},
{"lineNum":"   35","line":"      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,"},
{"lineNum":"   36","line":"      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,"},
{"lineNum":"   37","line":"      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,"},
{"lineNum":"   38","line":"      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,"},
{"lineNum":"   41","line":"                                                   internal::traits<Derived>::ColsAtCompileTime>::ret),"},
{"lineNum":"   42","line":"      /**< This is equal to the number of coefficients, i.e. the number of"},
{"lineNum":"   43","line":"          * rows times the number of columns, or to \\a Dynamic if this is not"},
{"lineNum":"   44","line":"          * known at compile-time. \\sa RowsAtCompileTime, ColsAtCompileTime */"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,"},
{"lineNum":"   47","line":"                                                   internal::traits<Derived>::MaxColsAtCompileTime>::ret)"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"    };"},
{"lineNum":"   50","line":"    typedef typename internal::traits<Derived>::Scalar Scalar;"},
{"lineNum":"   51","line":"    typedef typename internal::traits<Derived>::StorageKind StorageKind;"},
{"lineNum":"   52","line":"    typedef typename internal::traits<Derived>::StorageIndex StorageIndex;"},
{"lineNum":"   53","line":"    typedef typename internal::traits<Derived>::FullMatrixType DenseMatrixType;"},
{"lineNum":"   54","line":"    typedef DenseMatrixType DenseType;"},
{"lineNum":"   55","line":"    typedef Derived const& Nested;"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   58","line":"    inline TriangularBase() { eigen_assert(!((int(Mode) & int(UnitDiag)) && (int(Mode) & int(ZeroDiag)))); }"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"   61","line":"    inline Index rows() const EIGEN_NOEXCEPT { return derived().rows(); }"},
{"lineNum":"   62","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"   63","line":"    inline Index cols() const EIGEN_NOEXCEPT { return derived().cols(); }"},
{"lineNum":"   64","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"   65","line":"    inline Index outerStride() const EIGEN_NOEXCEPT { return derived().outerStride(); }"},
{"lineNum":"   66","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"   67","line":"    inline Index innerStride() const EIGEN_NOEXCEPT { return derived().innerStride(); }"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"    // dummy resize function"},
{"lineNum":"   70","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   71","line":"    void resize(Index rows, Index cols)"},
{"lineNum":"   72","line":"    {"},
{"lineNum":"   73","line":"      EIGEN_UNUSED_VARIABLE(rows);"},
{"lineNum":"   74","line":"      EIGEN_UNUSED_VARIABLE(cols);"},
{"lineNum":"   75","line":"      eigen_assert(rows==this->rows() && cols==this->cols());"},
{"lineNum":"   76","line":"    }"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   79","line":"    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }"},
{"lineNum":"   80","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   81","line":"    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"    /** \\see MatrixBase::copyCoeff(row,col)"},
{"lineNum":"   84","line":"      */"},
{"lineNum":"   85","line":"    template<typename Other>"},
{"lineNum":"   86","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   87","line":"    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)"},
{"lineNum":"   88","line":"    {"},
{"lineNum":"   89","line":"      derived().coeffRef(row, col) = other.coeff(row, col);"},
{"lineNum":"   90","line":"    }"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   93","line":"    inline Scalar operator()(Index row, Index col) const"},
{"lineNum":"   94","line":"    {"},
{"lineNum":"   95","line":"      check_coordinates(row, col);"},
{"lineNum":"   96","line":"      return coeff(row,col);"},
{"lineNum":"   97","line":"    }"},
{"lineNum":"   98","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   99","line":"    inline Scalar& operator()(Index row, Index col)"},
{"lineNum":"  100","line":"    {"},
{"lineNum":"  101","line":"      check_coordinates(row, col);"},
{"lineNum":"  102","line":"      return coeffRef(row,col);"},
{"lineNum":"  103","line":"    }"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"    #ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  106","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  107","line":"    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }"},
{"lineNum":"  108","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  109","line":"    inline Derived& derived() { return *static_cast<Derived*>(this); }"},
{"lineNum":"  110","line":"    #endif // not EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"    template<typename DenseDerived>"},
{"lineNum":"  113","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  114","line":"    void evalTo(MatrixBase<DenseDerived> &other) const;"},
{"lineNum":"  115","line":"    template<typename DenseDerived>"},
{"lineNum":"  116","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  117","line":"    void evalToLazy(MatrixBase<DenseDerived> &other) const;"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  120","line":"    DenseMatrixType toDenseMatrix() const"},
{"lineNum":"  121","line":"    {"},
{"lineNum":"  122","line":"      DenseMatrixType res(rows(), cols());"},
{"lineNum":"  123","line":"      evalToLazy(res);"},
{"lineNum":"  124","line":"      return res;"},
{"lineNum":"  125","line":"    }"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"  protected:"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    void check_coordinates(Index row, Index col) const"},
{"lineNum":"  130","line":"    {"},
{"lineNum":"  131","line":"      EIGEN_ONLY_USED_FOR_DEBUG(row);"},
{"lineNum":"  132","line":"      EIGEN_ONLY_USED_FOR_DEBUG(col);"},
{"lineNum":"  133","line":"      eigen_assert(col>=0 && col<cols() && row>=0 && row<rows());"},
{"lineNum":"  134","line":"      const int mode = int(Mode) & ~SelfAdjoint;"},
{"lineNum":"  135","line":"      EIGEN_ONLY_USED_FOR_DEBUG(mode);"},
{"lineNum":"  136","line":"      eigen_assert((mode==Upper && col>=row)"},
{"lineNum":"  137","line":"                || (mode==Lower && col<=row)"},
{"lineNum":"  138","line":"                || ((mode==StrictlyUpper || mode==UnitUpper) && col>row)"},
{"lineNum":"  139","line":"                || ((mode==StrictlyLower || mode==UnitLower) && col<row));"},
{"lineNum":"  140","line":"    }"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"    #ifdef EIGEN_INTERNAL_DEBUGGING"},
{"lineNum":"  143","line":"    void check_coordinates_internal(Index row, Index col) const"},
{"lineNum":"  144","line":"    {"},
{"lineNum":"  145","line":"      check_coordinates(row, col);"},
{"lineNum":"  146","line":"    }"},
{"lineNum":"  147","line":"    #else"},
{"lineNum":"  148","line":"    void check_coordinates_internal(Index , Index ) const {}"},
{"lineNum":"  149","line":"    #endif"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"};"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"/** \\class TriangularView"},
{"lineNum":"  154","line":"  * \\ingroup Core_Module"},
{"lineNum":"  155","line":"  *"},
{"lineNum":"  156","line":"  * \\brief Expression of a triangular part in a matrix"},
{"lineNum":"  157","line":"  *"},
{"lineNum":"  158","line":"  * \\param MatrixType the type of the object in which we are taking the triangular part"},
{"lineNum":"  159","line":"  * \\param Mode the kind of triangular matrix expression to construct. Can be #Upper,"},
{"lineNum":"  160","line":"  *             #Lower, #UnitUpper, #UnitLower, #StrictlyUpper, or #StrictlyLower."},
{"lineNum":"  161","line":"  *             This is in fact a bit field; it must have either #Upper or #Lower,"},
{"lineNum":"  162","line":"  *             and additionally it may have #UnitDiag or #ZeroDiag or neither."},
{"lineNum":"  163","line":"  *"},
{"lineNum":"  164","line":"  * This class represents a triangular part of a matrix, not necessarily square. Strictly speaking, for rectangular"},
{"lineNum":"  165","line":"  * matrices one should speak of \"trapezoid\" parts. This class is the return type"},
{"lineNum":"  166","line":"  * of MatrixBase::triangularView() and SparseMatrixBase::triangularView(), and most of the time this is the only way it is used."},
{"lineNum":"  167","line":"  *"},
{"lineNum":"  168","line":"  * \\sa MatrixBase::triangularView()"},
{"lineNum":"  169","line":"  */"},
{"lineNum":"  170","line":"namespace internal {"},
{"lineNum":"  171","line":"template<typename MatrixType, unsigned int Mode_>"},
{"lineNum":"  172","line":"struct traits<TriangularView<MatrixType, Mode_> > : traits<MatrixType>"},
{"lineNum":"  173","line":"{"},
{"lineNum":"  174","line":"  typedef typename ref_selector<MatrixType>::non_const_type MatrixTypeNested;"},
{"lineNum":"  175","line":"  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;"},
{"lineNum":"  176","line":"  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;"},
{"lineNum":"  177","line":"  typedef typename MatrixType::PlainObject FullMatrixType;"},
{"lineNum":"  178","line":"  typedef MatrixType ExpressionType;"},
{"lineNum":"  179","line":"  enum {"},
{"lineNum":"  180","line":"    Mode = Mode_,"},
{"lineNum":"  181","line":"    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,"},
{"lineNum":"  182","line":"    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits | FlagsLvalueBit) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit)))"},
{"lineNum":"  183","line":"  };"},
{"lineNum":"  184","line":"};"},
{"lineNum":"  185","line":"}"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"template<typename MatrixType_, unsigned int Mode_, typename StorageKind> class TriangularViewImpl;"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"template<typename MatrixType_, unsigned int Mode_> class TriangularView"},
{"lineNum":"  190","line":"  : public TriangularViewImpl<MatrixType_, Mode_, typename internal::traits<MatrixType_>::StorageKind >"},
{"lineNum":"  191","line":"{"},
{"lineNum":"  192","line":"  public:"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"    typedef TriangularViewImpl<MatrixType_, Mode_, typename internal::traits<MatrixType_>::StorageKind > Base;"},
{"lineNum":"  195","line":"    typedef typename internal::traits<TriangularView>::Scalar Scalar;"},
{"lineNum":"  196","line":"    typedef MatrixType_ MatrixType;"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"  protected:"},
{"lineNum":"  199","line":"    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;"},
{"lineNum":"  200","line":"    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;"},
{"lineNum":"  203","line":"    typedef TriangularView<typename internal::add_const<MatrixType>::type, Mode_> ConstTriangularView;"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"  public:"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;"},
{"lineNum":"  208","line":"    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned NestedExpression;"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"    enum {"},
{"lineNum":"  211","line":"      Mode = Mode_,"},
{"lineNum":"  212","line":"      Flags = internal::traits<TriangularView>::Flags,"},
{"lineNum":"  213","line":"      TransposeMode = (Mode & Upper ? Lower : 0)"},
{"lineNum":"  214","line":"                    | (Mode & Lower ? Upper : 0)"},
{"lineNum":"  215","line":"                    | (Mode & (UnitDiag))"},
{"lineNum":"  216","line":"                    | (Mode & (ZeroDiag)),"},
{"lineNum":"  217","line":"      IsVectorAtCompileTime = false"},
{"lineNum":"  218","line":"    };"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  221","line":"    explicit inline TriangularView(MatrixType& matrix) : m_matrix(matrix)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  222","line":"    {}"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(TriangularView)"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"    /** \\copydoc EigenBase::rows() */"},
{"lineNum":"  227","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  228","line":"    inline Index rows() const EIGEN_NOEXCEPT { return m_matrix.rows(); }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  229","line":"    /** \\copydoc EigenBase::cols() */"},
{"lineNum":"  230","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  231","line":"    inline Index cols() const EIGEN_NOEXCEPT { return m_matrix.cols(); }"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"    /** \\returns a const reference to the nested expression */"},
{"lineNum":"  234","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  235","line":"    const NestedExpression& nestedExpression() const { return m_matrix; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"    /** \\returns a reference to the nested expression */"},
{"lineNum":"  238","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  239","line":"    NestedExpression& nestedExpression() { return m_matrix; }"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"    typedef TriangularView<const MatrixConjugateReturnType,Mode> ConjugateReturnType;"},
{"lineNum":"  242","line":"    /** \\sa MatrixBase::conjugate() const */"},
{"lineNum":"  243","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  244","line":"    inline const ConjugateReturnType conjugate() const"},
{"lineNum":"  245","line":"    { return ConjugateReturnType(m_matrix.conjugate()); }"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"    /** \\returns an expression of the complex conjugate of \\c *this if Cond==true,"},
{"lineNum":"  248","line":"     *           returns \\c *this otherwise."},
{"lineNum":"  249","line":"     */"},
{"lineNum":"  250","line":"    template<bool Cond>"},
{"lineNum":"  251","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  252","line":"    inline typename internal::conditional<Cond,ConjugateReturnType,ConstTriangularView>::type"},
{"lineNum":"  253","line":"    conjugateIf() const"},
{"lineNum":"  254","line":"    {"},
{"lineNum":"  255","line":"      typedef typename internal::conditional<Cond,ConjugateReturnType,ConstTriangularView>::type ReturnType;"},
{"lineNum":"  256","line":"      return ReturnType(m_matrix.template conjugateIf<Cond>());"},
{"lineNum":"  257","line":"    }"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"    typedef TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> AdjointReturnType;"},
{"lineNum":"  260","line":"    /** \\sa MatrixBase::adjoint() const */"},
{"lineNum":"  261","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  262","line":"    inline const AdjointReturnType adjoint() const"},
{"lineNum":"  263","line":"    { return AdjointReturnType(m_matrix.adjoint()); }"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"    typedef TriangularView<typename MatrixType::TransposeReturnType,TransposeMode> TransposeReturnType;"},
{"lineNum":"  266","line":"     /** \\sa MatrixBase::transpose() */"},
{"lineNum":"  267","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  268","line":"    inline TransposeReturnType transpose()"},
{"lineNum":"  269","line":"    {"},
{"lineNum":"  270","line":"      EIGEN_STATIC_ASSERT_LVALUE(MatrixType)"},
{"lineNum":"  271","line":"      typename MatrixType::TransposeReturnType tmp(m_matrix);"},
{"lineNum":"  272","line":"      return TransposeReturnType(tmp);"},
{"lineNum":"  273","line":"    }"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"    typedef TriangularView<const typename MatrixType::ConstTransposeReturnType,TransposeMode> ConstTransposeReturnType;"},
{"lineNum":"  276","line":"    /** \\sa MatrixBase::transpose() const */"},
{"lineNum":"  277","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  278","line":"    inline const ConstTransposeReturnType transpose() const"},
{"lineNum":"  279","line":"    {"},
{"lineNum":"  280","line":"      return ConstTransposeReturnType(m_matrix.transpose());"},
{"lineNum":"  281","line":"    }"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"    template<typename Other>"},
{"lineNum":"  284","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  285","line":"    inline const Solve<TriangularView, Other>"},
{"lineNum":"  286","line":"    solve(const MatrixBase<Other>& other) const"},
{"lineNum":"  287","line":"    { return Solve<TriangularView, Other>(*this, other.derived()); }"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"  // workaround MSVC ICE"},
{"lineNum":"  290","line":"  #if EIGEN_COMP_MSVC"},
{"lineNum":"  291","line":"    template<int Side, typename Other>"},
{"lineNum":"  292","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  293","line":"    inline const internal::triangular_solve_retval<Side,TriangularView, Other>"},
{"lineNum":"  294","line":"    solve(const MatrixBase<Other>& other) const"},
{"lineNum":"  295","line":"    { return Base::template solve<Side>(other); }"},
{"lineNum":"  296","line":"  #else"},
{"lineNum":"  297","line":"    using Base::solve;"},
{"lineNum":"  298","line":"  #endif"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"    /** \\returns a selfadjoint view of the referenced triangular part which must be either \\c #Upper or \\c #Lower."},
{"lineNum":"  301","line":"      *"},
{"lineNum":"  302","line":"      * This is a shortcut for \\code this->nestedExpression().selfadjointView<(*this)::Mode>() \\endcode"},
{"lineNum":"  303","line":"      * \\sa MatrixBase::selfadjointView() */"},
{"lineNum":"  304","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  305","line":"    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()"},
{"lineNum":"  306","line":"    {"},
{"lineNum":"  307","line":"      EIGEN_STATIC_ASSERT((Mode&(UnitDiag|ZeroDiag))==0,PROGRAMMING_ERROR);"},
{"lineNum":"  308","line":"      return SelfAdjointView<MatrixTypeNestedNonRef,Mode>(m_matrix);"},
{"lineNum":"  309","line":"    }"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"    /** This is the const version of selfadjointView() */"},
{"lineNum":"  312","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  313","line":"    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const"},
{"lineNum":"  314","line":"    {"},
{"lineNum":"  315","line":"      EIGEN_STATIC_ASSERT((Mode&(UnitDiag|ZeroDiag))==0,PROGRAMMING_ERROR);"},
{"lineNum":"  316","line":"      return SelfAdjointView<MatrixTypeNestedNonRef,Mode>(m_matrix);"},
{"lineNum":"  317","line":"    }"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"    /** \\returns the determinant of the triangular matrix"},
{"lineNum":"  321","line":"      * \\sa MatrixBase::determinant() */"},
{"lineNum":"  322","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  323","line":"    Scalar determinant() const"},
{"lineNum":"  324","line":"    {"},
{"lineNum":"  325","line":"      if (Mode & UnitDiag)"},
{"lineNum":"  326","line":"        return 1;"},
{"lineNum":"  327","line":"      else if (Mode & ZeroDiag)"},
{"lineNum":"  328","line":"        return 0;"},
{"lineNum":"  329","line":"      else"},
{"lineNum":"  330","line":"        return m_matrix.diagonal().prod();"},
{"lineNum":"  331","line":"    }"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"  protected:"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"    MatrixTypeNested m_matrix;"},
{"lineNum":"  336","line":"};"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"/** \\ingroup Core_Module"},
{"lineNum":"  339","line":"  *"},
{"lineNum":"  340","line":"  * \\brief Base class for a triangular part in a \\b dense matrix"},
{"lineNum":"  341","line":"  *"},
{"lineNum":"  342","line":"  * This class is an abstract base class of class TriangularView, and objects of type TriangularViewImpl cannot be instantiated."},
{"lineNum":"  343","line":"  * It extends class TriangularView with additional methods which available for dense expressions only."},
{"lineNum":"  344","line":"  *"},
{"lineNum":"  345","line":"  * \\sa class TriangularView, MatrixBase::triangularView()"},
{"lineNum":"  346","line":"  */"},
{"lineNum":"  347","line":"template<typename MatrixType_, unsigned int Mode_> class TriangularViewImpl<MatrixType_,Mode_,Dense>"},
{"lineNum":"  348","line":"  : public TriangularBase<TriangularView<MatrixType_, Mode_> >"},
{"lineNum":"  349","line":"{"},
{"lineNum":"  350","line":"  public:"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"    typedef TriangularView<MatrixType_, Mode_> TriangularViewType;"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"    typedef TriangularBase<TriangularViewType> Base;"},
{"lineNum":"  355","line":"    typedef typename internal::traits<TriangularViewType>::Scalar Scalar;"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"    typedef MatrixType_ MatrixType;"},
{"lineNum":"  358","line":"    typedef typename MatrixType::PlainObject DenseMatrixType;"},
{"lineNum":"  359","line":"    typedef DenseMatrixType PlainObject;"},
{"lineNum":"  360","line":""},
{"lineNum":"  361","line":"  public:"},
{"lineNum":"  362","line":"    using Base::evalToLazy;"},
{"lineNum":"  363","line":"    using Base::derived;"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"    typedef typename internal::traits<TriangularViewType>::StorageKind StorageKind;"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"    enum {"},
{"lineNum":"  368","line":"      Mode = Mode_,"},
{"lineNum":"  369","line":"      Flags = internal::traits<TriangularViewType>::Flags"},
{"lineNum":"  370","line":"    };"},
{"lineNum":"  371","line":""},
{"lineNum":"  372","line":"    /** \\returns the outer-stride of the underlying dense matrix"},
{"lineNum":"  373","line":"      * \\sa DenseCoeffsBase::outerStride() */"},
{"lineNum":"  374","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  375","line":"    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }"},
{"lineNum":"  376","line":"    /** \\returns the inner-stride of the underlying dense matrix"},
{"lineNum":"  377","line":"      * \\sa DenseCoeffsBase::innerStride() */"},
{"lineNum":"  378","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  379","line":"    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"    /** \\sa MatrixBase::operator+=() */"},
{"lineNum":"  382","line":"    template<typename Other>"},
{"lineNum":"  383","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  384","line":"    TriangularViewType&  operator+=(const DenseBase<Other>& other) {"},
{"lineNum":"  385","line":"      internal::call_assignment_no_alias(derived(), other.derived(), internal::add_assign_op<Scalar,typename Other::Scalar>());"},
{"lineNum":"  386","line":"      return derived();"},
{"lineNum":"  387","line":"    }"},
{"lineNum":"  388","line":"    /** \\sa MatrixBase::operator-=() */"},
{"lineNum":"  389","line":"    template<typename Other>"},
{"lineNum":"  390","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  391","line":"    TriangularViewType&  operator-=(const DenseBase<Other>& other) {"},
{"lineNum":"  392","line":"      internal::call_assignment_no_alias(derived(), other.derived(), internal::sub_assign_op<Scalar,typename Other::Scalar>());"},
{"lineNum":"  393","line":"      return derived();"},
{"lineNum":"  394","line":"    }"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"    /** \\sa MatrixBase::operator*=() */"},
{"lineNum":"  397","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  398","line":"    TriangularViewType&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = derived().nestedExpression() * other; }"},
{"lineNum":"  399","line":"    /** \\sa DenseBase::operator/=() */"},
{"lineNum":"  400","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  401","line":"    TriangularViewType&  operator/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = derived().nestedExpression() / other; }"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"    /** \\sa MatrixBase::fill() */"},
{"lineNum":"  404","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  405","line":"    void fill(const Scalar& value) { setConstant(value); }"},
{"lineNum":"  406","line":"    /** \\sa MatrixBase::setConstant() */"},
{"lineNum":"  407","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  408","line":"    TriangularViewType& setConstant(const Scalar& value)"},
{"lineNum":"  409","line":"    { return *this = MatrixType::Constant(derived().rows(), derived().cols(), value); }"},
{"lineNum":"  410","line":"    /** \\sa MatrixBase::setZero() */"},
{"lineNum":"  411","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  412","line":"    TriangularViewType& setZero() { return setConstant(Scalar(0)); }"},
{"lineNum":"  413","line":"    /** \\sa MatrixBase::setOnes() */"},
{"lineNum":"  414","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  415","line":"    TriangularViewType& setOnes() { return setConstant(Scalar(1)); }"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"    /** \\sa MatrixBase::coeff()"},
{"lineNum":"  418","line":"      * \\warning the coordinates must fit into the referenced triangular part"},
{"lineNum":"  419","line":"      */"},
{"lineNum":"  420","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  421","line":"    inline Scalar coeff(Index row, Index col) const"},
{"lineNum":"  422","line":"    {"},
{"lineNum":"  423","line":"      Base::check_coordinates_internal(row, col);"},
{"lineNum":"  424","line":"      return derived().nestedExpression().coeff(row, col);"},
{"lineNum":"  425","line":"    }"},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"    /** \\sa MatrixBase::coeffRef()"},
{"lineNum":"  428","line":"      * \\warning the coordinates must fit into the referenced triangular part"},
{"lineNum":"  429","line":"      */"},
{"lineNum":"  430","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  431","line":"    inline Scalar& coeffRef(Index row, Index col)"},
{"lineNum":"  432","line":"    {"},
{"lineNum":"  433","line":"      EIGEN_STATIC_ASSERT_LVALUE(TriangularViewType);"},
{"lineNum":"  434","line":"      Base::check_coordinates_internal(row, col);"},
{"lineNum":"  435","line":"      return derived().nestedExpression().coeffRef(row, col);"},
{"lineNum":"  436","line":"    }"},
{"lineNum":"  437","line":""},
{"lineNum":"  438","line":"    /** Assigns a triangular matrix to a triangular part of a dense matrix */"},
{"lineNum":"  439","line":"    template<typename OtherDerived>"},
{"lineNum":"  440","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  441","line":"    TriangularViewType& operator=(const TriangularBase<OtherDerived>& other);"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"    /** Shortcut for\\code *this = other.other.triangularView<(*this)::Mode>() \\endcode */"},
{"lineNum":"  444","line":"    template<typename OtherDerived>"},
{"lineNum":"  445","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  446","line":"    TriangularViewType& operator=(const MatrixBase<OtherDerived>& other);"},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"#ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  449","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  450","line":"    TriangularViewType& operator=(const TriangularViewImpl& other)"},
{"lineNum":"  451","line":"    { return *this = other.derived().nestedExpression(); }"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"    template<typename OtherDerived>"},
{"lineNum":"  454","line":"    /** \\deprecated */"},
{"lineNum":"  455","line":"    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC"},
{"lineNum":"  456","line":"    void lazyAssign(const TriangularBase<OtherDerived>& other);"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"    template<typename OtherDerived>"},
{"lineNum":"  459","line":"    /** \\deprecated */"},
{"lineNum":"  460","line":"    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC"},
{"lineNum":"  461","line":"    void lazyAssign(const MatrixBase<OtherDerived>& other);"},
{"lineNum":"  462","line":"#endif"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"    /** Efficient triangular matrix times vector/matrix product */"},
{"lineNum":"  465","line":"    template<typename OtherDerived>"},
{"lineNum":"  466","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  467","line":"    const Product<TriangularViewType,OtherDerived>"},
{"lineNum":"  468","line":"    operator*(const MatrixBase<OtherDerived>& rhs) const"},
{"lineNum":"  469","line":"    {"},
{"lineNum":"  470","line":"      return Product<TriangularViewType,OtherDerived>(derived(), rhs.derived());"},
{"lineNum":"  471","line":"    }"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"    /** Efficient vector/matrix times triangular matrix product */"},
{"lineNum":"  474","line":"    template<typename OtherDerived> friend"},
{"lineNum":"  475","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  476","line":"    const Product<OtherDerived,TriangularViewType>"},
{"lineNum":"  477","line":"    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularViewImpl& rhs)"},
{"lineNum":"  478","line":"    {"},
{"lineNum":"  479","line":"      return Product<OtherDerived,TriangularViewType>(lhs.derived(),rhs.derived());"},
{"lineNum":"  480","line":"    }"},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"    /** \\returns the product of the inverse of \\c *this with \\a other, \\a *this being triangular."},
{"lineNum":"  483","line":"      *"},
{"lineNum":"  484","line":"      * This function computes the inverse-matrix matrix product inverse(\\c *this) * \\a other if"},
{"lineNum":"  485","line":"      * \\a Side==OnTheLeft (the default), or the right-inverse-multiply  \\a other * inverse(\\c *this) if"},
{"lineNum":"  486","line":"      * \\a Side==OnTheRight."},
{"lineNum":"  487","line":"      *"},
{"lineNum":"  488","line":"      * Note that the template parameter \\c Side can be omitted, in which case \\c Side==OnTheLeft"},
{"lineNum":"  489","line":"      *"},
{"lineNum":"  490","line":"      * The matrix \\c *this must be triangular and invertible (i.e., all the coefficients of the"},
{"lineNum":"  491","line":"      * diagonal must be non zero). It works as a forward (resp. backward) substitution if \\c *this"},
{"lineNum":"  492","line":"      * is an upper (resp. lower) triangular matrix."},
{"lineNum":"  493","line":"      *"},
{"lineNum":"  494","line":"      * Example: \\include Triangular_solve.cpp"},
{"lineNum":"  495","line":"      * Output: \\verbinclude Triangular_solve.out"},
{"lineNum":"  496","line":"      *"},
{"lineNum":"  497","line":"      * This function returns an expression of the inverse-multiply and can works in-place if it is assigned"},
{"lineNum":"  498","line":"      * to the same matrix or vector \\a other."},
{"lineNum":"  499","line":"      *"},
{"lineNum":"  500","line":"      * For users coming from BLAS, this function (and more specifically solveInPlace()) offer"},
{"lineNum":"  501","line":"      * all the operations supported by the \\c *TRSV and \\c *TRSM BLAS routines."},
{"lineNum":"  502","line":"      *"},
{"lineNum":"  503","line":"      * \\sa TriangularView::solveInPlace()"},
{"lineNum":"  504","line":"      */"},
{"lineNum":"  505","line":"    template<int Side, typename Other>"},
{"lineNum":"  506","line":"    inline const internal::triangular_solve_retval<Side,TriangularViewType, Other>"},
{"lineNum":"  507","line":"    solve(const MatrixBase<Other>& other) const;"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"    /** \"in-place\" version of TriangularView::solve() where the result is written in \\a other"},
{"lineNum":"  510","line":"      *"},
{"lineNum":"  511","line":"      * \\warning The parameter is only marked \'const\' to make the C++ compiler accept a temporary expression here."},
{"lineNum":"  512","line":"      * This function will const_cast it, so constness isn\'t honored here."},
{"lineNum":"  513","line":"      *"},
{"lineNum":"  514","line":"      * Note that the template parameter \\c Side can be omitted, in which case \\c Side==OnTheLeft"},
{"lineNum":"  515","line":"      *"},
{"lineNum":"  516","line":"      * See TriangularView:solve() for the details."},
{"lineNum":"  517","line":"      */"},
{"lineNum":"  518","line":"    template<int Side, typename OtherDerived>"},
{"lineNum":"  519","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  520","line":"    void solveInPlace(const MatrixBase<OtherDerived>& other) const;"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"    template<typename OtherDerived>"},
{"lineNum":"  523","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  524","line":"    void solveInPlace(const MatrixBase<OtherDerived>& other) const"},
{"lineNum":"  525","line":"    { return solveInPlace<OnTheLeft>(other); }"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"    /** Swaps the coefficients of the common triangular parts of two matrices */"},
{"lineNum":"  528","line":"    template<typename OtherDerived>"},
{"lineNum":"  529","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  530","line":"#ifdef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  531","line":"    void swap(TriangularBase<OtherDerived> &other)"},
{"lineNum":"  532","line":"#else"},
{"lineNum":"  533","line":"    void swap(TriangularBase<OtherDerived> const & other)"},
{"lineNum":"  534","line":"#endif"},
{"lineNum":"  535","line":"    {"},
{"lineNum":"  536","line":"      EIGEN_STATIC_ASSERT_LVALUE(OtherDerived);"},
{"lineNum":"  537","line":"      call_assignment(derived(), other.const_cast_derived(), internal::swap_assign_op<Scalar>());"},
{"lineNum":"  538","line":"    }"},
{"lineNum":"  539","line":""},
{"lineNum":"  540","line":"    /** Shortcut for \\code (*this).swap(other.triangularView<(*this)::Mode>()) \\endcode */"},
{"lineNum":"  541","line":"    template<typename OtherDerived>"},
{"lineNum":"  542","line":"    /** \\deprecated */"},
{"lineNum":"  543","line":"    EIGEN_DEPRECATED EIGEN_DEVICE_FUNC"},
{"lineNum":"  544","line":"    void swap(MatrixBase<OtherDerived> const & other)"},
{"lineNum":"  545","line":"    {"},
{"lineNum":"  546","line":"      EIGEN_STATIC_ASSERT_LVALUE(OtherDerived);"},
{"lineNum":"  547","line":"      call_assignment(derived(), other.const_cast_derived(), internal::swap_assign_op<Scalar>());"},
{"lineNum":"  548","line":"    }"},
{"lineNum":"  549","line":""},
{"lineNum":"  550","line":"    template<typename RhsType, typename DstType>"},
{"lineNum":"  551","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  552","line":"    EIGEN_STRONG_INLINE void _solve_impl(const RhsType &rhs, DstType &dst) const {"},
{"lineNum":"  553","line":"      if(!internal::is_same_dense(dst,rhs))"},
{"lineNum":"  554","line":"        dst = rhs;"},
{"lineNum":"  555","line":"      this->solveInPlace(dst);"},
{"lineNum":"  556","line":"    }"},
{"lineNum":"  557","line":""},
{"lineNum":"  558","line":"    template<typename ProductType>"},
{"lineNum":"  559","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  560","line":"    EIGEN_STRONG_INLINE TriangularViewType& _assignProduct(const ProductType& prod, const Scalar& alpha, bool beta);"},
{"lineNum":"  561","line":"  protected:"},
{"lineNum":"  562","line":"    EIGEN_DEFAULT_COPY_CONSTRUCTOR(TriangularViewImpl)"},
{"lineNum":"  563","line":"    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(TriangularViewImpl)"},
{"lineNum":"  564","line":""},
{"lineNum":"  565","line":"};"},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"/***************************************************************************"},
{"lineNum":"  568","line":"* Implementation of triangular evaluation/assignment"},
{"lineNum":"  569","line":"***************************************************************************/"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"#ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  572","line":"// FIXME should we keep that possibility"},
{"lineNum":"  573","line":"template<typename MatrixType, unsigned int Mode>"},
{"lineNum":"  574","line":"template<typename OtherDerived>"},
{"lineNum":"  575","line":"EIGEN_DEVICE_FUNC inline TriangularView<MatrixType, Mode>&"},
{"lineNum":"  576","line":"TriangularViewImpl<MatrixType, Mode, Dense>::operator=(const MatrixBase<OtherDerived>& other)"},
{"lineNum":"  577","line":"{"},
{"lineNum":"  578","line":"  internal::call_assignment_no_alias(derived(), other.derived(), internal::assign_op<Scalar,typename OtherDerived::Scalar>());"},
{"lineNum":"  579","line":"  return derived();"},
{"lineNum":"  580","line":"}"},
{"lineNum":"  581","line":""},
{"lineNum":"  582","line":"// FIXME should we keep that possibility"},
{"lineNum":"  583","line":"template<typename MatrixType, unsigned int Mode>"},
{"lineNum":"  584","line":"template<typename OtherDerived>"},
{"lineNum":"  585","line":"EIGEN_DEVICE_FUNC void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const MatrixBase<OtherDerived>& other)"},
{"lineNum":"  586","line":"{"},
{"lineNum":"  587","line":"  internal::call_assignment_no_alias(derived(), other.template triangularView<Mode>());"},
{"lineNum":"  588","line":"}"},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":""},
{"lineNum":"  592","line":"template<typename MatrixType, unsigned int Mode>"},
{"lineNum":"  593","line":"template<typename OtherDerived>"},
{"lineNum":"  594","line":"EIGEN_DEVICE_FUNC inline TriangularView<MatrixType, Mode>&"},
{"lineNum":"  595","line":"TriangularViewImpl<MatrixType, Mode, Dense>::operator=(const TriangularBase<OtherDerived>& other)"},
{"lineNum":"  596","line":"{"},
{"lineNum":"  597","line":"  eigen_assert(Mode == int(OtherDerived::Mode));"},
{"lineNum":"  598","line":"  internal::call_assignment(derived(), other.derived());"},
{"lineNum":"  599","line":"  return derived();"},
{"lineNum":"  600","line":"}"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"template<typename MatrixType, unsigned int Mode>"},
{"lineNum":"  603","line":"template<typename OtherDerived>"},
{"lineNum":"  604","line":"EIGEN_DEVICE_FUNC void TriangularViewImpl<MatrixType, Mode, Dense>::lazyAssign(const TriangularBase<OtherDerived>& other)"},
{"lineNum":"  605","line":"{"},
{"lineNum":"  606","line":"  eigen_assert(Mode == int(OtherDerived::Mode));"},
{"lineNum":"  607","line":"  internal::call_assignment_no_alias(derived(), other.derived());"},
{"lineNum":"  608","line":"}"},
{"lineNum":"  609","line":"#endif"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"/***************************************************************************"},
{"lineNum":"  612","line":"* Implementation of TriangularBase methods"},
{"lineNum":"  613","line":"***************************************************************************/"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"/** Assigns a triangular or selfadjoint matrix to a dense matrix."},
{"lineNum":"  616","line":"  * If the matrix is triangular, the opposite part is set to zero. */"},
{"lineNum":"  617","line":"template<typename Derived>"},
{"lineNum":"  618","line":"template<typename DenseDerived>"},
{"lineNum":"  619","line":"EIGEN_DEVICE_FUNC void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const"},
{"lineNum":"  620","line":"{"},
{"lineNum":"  621","line":"  evalToLazy(other.derived());"},
{"lineNum":"  622","line":"}"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"/***************************************************************************"},
{"lineNum":"  625","line":"* Implementation of TriangularView methods"},
{"lineNum":"  626","line":"***************************************************************************/"},
{"lineNum":"  627","line":""},
{"lineNum":"  628","line":"/***************************************************************************"},
{"lineNum":"  629","line":"* Implementation of MatrixBase methods"},
{"lineNum":"  630","line":"***************************************************************************/"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":"/**"},
{"lineNum":"  633","line":"  * \\returns an expression of a triangular view extracted from the current matrix"},
{"lineNum":"  634","line":"  *"},
{"lineNum":"  635","line":"  * The parameter \\a Mode can have the following values: \\c #Upper, \\c #StrictlyUpper, \\c #UnitUpper,"},
{"lineNum":"  636","line":"  * \\c #Lower, \\c #StrictlyLower, \\c #UnitLower."},
{"lineNum":"  637","line":"  *"},
{"lineNum":"  638","line":"  * Example: \\include MatrixBase_triangularView.cpp"},
{"lineNum":"  639","line":"  * Output: \\verbinclude MatrixBase_triangularView.out"},
{"lineNum":"  640","line":"  *"},
{"lineNum":"  641","line":"  * \\sa class TriangularView"},
{"lineNum":"  642","line":"  */"},
{"lineNum":"  643","line":"template<typename Derived>"},
{"lineNum":"  644","line":"template<unsigned int Mode>"},
{"lineNum":"  645","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  646","line":"typename MatrixBase<Derived>::template TriangularViewReturnType<Mode>::Type"},
{"lineNum":"  647","line":"MatrixBase<Derived>::triangularView()"},
{"lineNum":"  648","line":"{"},
{"lineNum":"  649","line":"  return typename TriangularViewReturnType<Mode>::Type(derived());"},
{"lineNum":"  650","line":"}"},
{"lineNum":"  651","line":""},
{"lineNum":"  652","line":"/** This is the const version of MatrixBase::triangularView() */"},
{"lineNum":"  653","line":"template<typename Derived>"},
{"lineNum":"  654","line":"template<unsigned int Mode>"},
{"lineNum":"  655","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  656","line":"typename MatrixBase<Derived>::template ConstTriangularViewReturnType<Mode>::Type"},
{"lineNum":"  657","line":"MatrixBase<Derived>::triangularView() const"},
{"lineNum":"  658","line":"{"},
{"lineNum":"  659","line":"  return typename ConstTriangularViewReturnType<Mode>::Type(derived());"},
{"lineNum":"  660","line":"}"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"/** \\returns true if *this is approximately equal to an upper triangular matrix,"},
{"lineNum":"  663","line":"  *          within the precision given by \\a prec."},
{"lineNum":"  664","line":"  *"},
{"lineNum":"  665","line":"  * \\sa isLowerTriangular()"},
{"lineNum":"  666","line":"  */"},
{"lineNum":"  667","line":"template<typename Derived>"},
{"lineNum":"  668","line":"bool MatrixBase<Derived>::isUpperTriangular(const RealScalar& prec) const"},
{"lineNum":"  669","line":"{"},
{"lineNum":"  670","line":"  RealScalar maxAbsOnUpperPart = static_cast<RealScalar>(-1);"},
{"lineNum":"  671","line":"  for(Index j = 0; j < cols(); ++j)"},
{"lineNum":"  672","line":"  {"},
{"lineNum":"  673","line":"    Index maxi = numext::mini(j, rows()-1);"},
{"lineNum":"  674","line":"    for(Index i = 0; i <= maxi; ++i)"},
{"lineNum":"  675","line":"    {"},
{"lineNum":"  676","line":"      RealScalar absValue = numext::abs(coeff(i,j));"},
{"lineNum":"  677","line":"      if(absValue > maxAbsOnUpperPart) maxAbsOnUpperPart = absValue;"},
{"lineNum":"  678","line":"    }"},
{"lineNum":"  679","line":"  }"},
{"lineNum":"  680","line":"  RealScalar threshold = maxAbsOnUpperPart * prec;"},
{"lineNum":"  681","line":"  for(Index j = 0; j < cols(); ++j)"},
{"lineNum":"  682","line":"    for(Index i = j+1; i < rows(); ++i)"},
{"lineNum":"  683","line":"      if(numext::abs(coeff(i, j)) > threshold) return false;"},
{"lineNum":"  684","line":"  return true;"},
{"lineNum":"  685","line":"}"},
{"lineNum":"  686","line":""},
{"lineNum":"  687","line":"/** \\returns true if *this is approximately equal to a lower triangular matrix,"},
{"lineNum":"  688","line":"  *          within the precision given by \\a prec."},
{"lineNum":"  689","line":"  *"},
{"lineNum":"  690","line":"  * \\sa isUpperTriangular()"},
{"lineNum":"  691","line":"  */"},
{"lineNum":"  692","line":"template<typename Derived>"},
{"lineNum":"  693","line":"bool MatrixBase<Derived>::isLowerTriangular(const RealScalar& prec) const"},
{"lineNum":"  694","line":"{"},
{"lineNum":"  695","line":"  RealScalar maxAbsOnLowerPart = static_cast<RealScalar>(-1);"},
{"lineNum":"  696","line":"  for(Index j = 0; j < cols(); ++j)"},
{"lineNum":"  697","line":"    for(Index i = j; i < rows(); ++i)"},
{"lineNum":"  698","line":"    {"},
{"lineNum":"  699","line":"      RealScalar absValue = numext::abs(coeff(i,j));"},
{"lineNum":"  700","line":"      if(absValue > maxAbsOnLowerPart) maxAbsOnLowerPart = absValue;"},
{"lineNum":"  701","line":"    }"},
{"lineNum":"  702","line":"  RealScalar threshold = maxAbsOnLowerPart * prec;"},
{"lineNum":"  703","line":"  for(Index j = 1; j < cols(); ++j)"},
{"lineNum":"  704","line":"  {"},
{"lineNum":"  705","line":"    Index maxi = numext::mini(j, rows()-1);"},
{"lineNum":"  706","line":"    for(Index i = 0; i < maxi; ++i)"},
{"lineNum":"  707","line":"      if(numext::abs(coeff(i, j)) > threshold) return false;"},
{"lineNum":"  708","line":"  }"},
{"lineNum":"  709","line":"  return true;"},
{"lineNum":"  710","line":"}"},
{"lineNum":"  711","line":""},
{"lineNum":"  712","line":""},
{"lineNum":"  713","line":"/***************************************************************************"},
{"lineNum":"  714","line":"****************************************************************************"},
{"lineNum":"  715","line":"* Evaluators and Assignment of triangular expressions"},
{"lineNum":"  716","line":"***************************************************************************"},
{"lineNum":"  717","line":"***************************************************************************/"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"namespace internal {"},
{"lineNum":"  720","line":""},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"// TODO currently a triangular expression has the form TriangularView<.,.>"},
{"lineNum":"  723","line":"//      in the future triangular-ness should be defined by the expression traits"},
{"lineNum":"  724","line":"//      such that Transpose<TriangularView<.,.> > is valid. (currently TriangularBase::transpose() is overloaded to make it work)"},
{"lineNum":"  725","line":"template<typename MatrixType, unsigned int Mode>"},
{"lineNum":"  726","line":"struct evaluator_traits<TriangularView<MatrixType,Mode> >"},
{"lineNum":"  727","line":"{"},
{"lineNum":"  728","line":"  typedef typename storage_kind_to_evaluator_kind<typename MatrixType::StorageKind>::Kind Kind;"},
{"lineNum":"  729","line":"  typedef typename glue_shapes<typename evaluator_traits<MatrixType>::Shape, TriangularShape>::type Shape;"},
{"lineNum":"  730","line":"};"},
{"lineNum":"  731","line":""},
{"lineNum":"  732","line":"template<typename MatrixType, unsigned int Mode>"},
{"lineNum":"  733","line":"struct unary_evaluator<TriangularView<MatrixType,Mode>, IndexBased>"},
{"lineNum":"  734","line":" : evaluator<typename internal::remove_all<MatrixType>::type>"},
{"lineNum":"  735","line":"{"},
{"lineNum":"  736","line":"  typedef TriangularView<MatrixType,Mode> XprType;"},
{"lineNum":"  737","line":"  typedef evaluator<typename internal::remove_all<MatrixType>::type> Base;"},
{"lineNum":"  738","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  739","line":"  unary_evaluator(const XprType &xpr) : Base(xpr.nestedExpression()) {}"},
{"lineNum":"  740","line":"};"},
{"lineNum":"  741","line":""},
{"lineNum":"  742","line":"// Additional assignment kinds:"},
{"lineNum":"  743","line":"struct Triangular2Triangular    {};"},
{"lineNum":"  744","line":"struct Triangular2Dense         {};"},
{"lineNum":"  745","line":"struct Dense2Triangular         {};"},
{"lineNum":"  746","line":""},
{"lineNum":"  747","line":""},
{"lineNum":"  748","line":"template<typename Kernel, unsigned int Mode, int UnrollCount, bool ClearOpposite> struct triangular_assignment_loop;"},
{"lineNum":"  749","line":""},
{"lineNum":"  750","line":""},
{"lineNum":"  751","line":"/** \\internal Specialization of the dense assignment kernel for triangular matrices."},
{"lineNum":"  752","line":"  * The main difference is that the triangular, diagonal, and opposite parts are processed through three different functions."},
{"lineNum":"  753","line":"  * \\tparam UpLo must be either Lower or Upper"},
{"lineNum":"  754","line":"  * \\tparam Mode must be either 0, UnitDiag, ZeroDiag, or SelfAdjoint"},
{"lineNum":"  755","line":"  */"},
{"lineNum":"  756","line":"template<int UpLo, int Mode, int SetOpposite, typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT, typename Functor, int Version = Specialized>"},
{"lineNum":"  757","line":"class triangular_dense_assignment_kernel : public generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version>"},
{"lineNum":"  758","line":"{"},
{"lineNum":"  759","line":"protected:"},
{"lineNum":"  760","line":"  typedef generic_dense_assignment_kernel<DstEvaluatorTypeT, SrcEvaluatorTypeT, Functor, Version> Base;"},
{"lineNum":"  761","line":"  typedef typename Base::DstXprType DstXprType;"},
{"lineNum":"  762","line":"  typedef typename Base::SrcXprType SrcXprType;"},
{"lineNum":"  763","line":"  using Base::m_dst;"},
{"lineNum":"  764","line":"  using Base::m_src;"},
{"lineNum":"  765","line":"  using Base::m_functor;"},
{"lineNum":"  766","line":"public:"},
{"lineNum":"  767","line":""},
{"lineNum":"  768","line":"  typedef typename Base::DstEvaluatorType DstEvaluatorType;"},
{"lineNum":"  769","line":"  typedef typename Base::SrcEvaluatorType SrcEvaluatorType;"},
{"lineNum":"  770","line":"  typedef typename Base::Scalar Scalar;"},
{"lineNum":"  771","line":"  typedef typename Base::AssignmentTraits AssignmentTraits;"},
{"lineNum":"  772","line":""},
{"lineNum":"  773","line":""},
{"lineNum":"  774","line":"  EIGEN_DEVICE_FUNC triangular_dense_assignment_kernel(DstEvaluatorType &dst, const SrcEvaluatorType &src, const Functor &func, DstXprType& dstExpr)"},
{"lineNum":"  775","line":"    : Base(dst, src, func, dstExpr)"},
{"lineNum":"  776","line":"  {}"},
{"lineNum":"  777","line":""},
{"lineNum":"  778","line":"#ifdef EIGEN_INTERNAL_DEBUGGING"},
{"lineNum":"  779","line":"  EIGEN_DEVICE_FUNC void assignCoeff(Index row, Index col)"},
{"lineNum":"  780","line":"  {"},
{"lineNum":"  781","line":"    eigen_internal_assert(row!=col);"},
{"lineNum":"  782","line":"    Base::assignCoeff(row,col);"},
{"lineNum":"  783","line":"  }"},
{"lineNum":"  784","line":"#else"},
{"lineNum":"  785","line":"  using Base::assignCoeff;"},
{"lineNum":"  786","line":"#endif"},
{"lineNum":"  787","line":""},
{"lineNum":"  788","line":"  EIGEN_DEVICE_FUNC void assignDiagonalCoeff(Index id)"},
{"lineNum":"  789","line":"  {"},
{"lineNum":"  790","line":"         if(Mode==UnitDiag && SetOpposite) m_functor.assignCoeff(m_dst.coeffRef(id,id), Scalar(1));"},
{"lineNum":"  791","line":"    else if(Mode==ZeroDiag && SetOpposite) m_functor.assignCoeff(m_dst.coeffRef(id,id), Scalar(0));"},
{"lineNum":"  792","line":"    else if(Mode==0)                       Base::assignCoeff(id,id);"},
{"lineNum":"  793","line":"  }"},
{"lineNum":"  794","line":""},
{"lineNum":"  795","line":"  EIGEN_DEVICE_FUNC void assignOppositeCoeff(Index row, Index col)"},
{"lineNum":"  796","line":"  {"},
{"lineNum":"  797","line":"    eigen_internal_assert(row!=col);"},
{"lineNum":"  798","line":"    if(SetOpposite)"},
{"lineNum":"  799","line":"      m_functor.assignCoeff(m_dst.coeffRef(row,col), Scalar(0));"},
{"lineNum":"  800","line":"  }"},
{"lineNum":"  801","line":"};"},
{"lineNum":"  802","line":""},
{"lineNum":"  803","line":"template<int Mode, bool SetOpposite, typename DstXprType, typename SrcXprType, typename Functor>"},
{"lineNum":"  804","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  805","line":"void call_triangular_assignment_loop(DstXprType& dst, const SrcXprType& src, const Functor &func)"},
{"lineNum":"  806","line":"{"},
{"lineNum":"  807","line":"  typedef evaluator<DstXprType> DstEvaluatorType;"},
{"lineNum":"  808","line":"  typedef evaluator<SrcXprType> SrcEvaluatorType;"},
{"lineNum":"  809","line":""},
{"lineNum":"  810","line":"  SrcEvaluatorType srcEvaluator(src);"},
{"lineNum":"  811","line":""},
{"lineNum":"  812","line":"  Index dstRows = src.rows();"},
{"lineNum":"  813","line":"  Index dstCols = src.cols();"},
{"lineNum":"  814","line":"  if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))"},
{"lineNum":"  815","line":"    dst.resize(dstRows, dstCols);"},
{"lineNum":"  816","line":"  DstEvaluatorType dstEvaluator(dst);"},
{"lineNum":"  817","line":""},
{"lineNum":"  818","line":"  typedef triangular_dense_assignment_kernel< Mode&(Lower|Upper),Mode&(UnitDiag|ZeroDiag|SelfAdjoint),SetOpposite,"},
{"lineNum":"  819","line":"                                              DstEvaluatorType,SrcEvaluatorType,Functor> Kernel;"},
{"lineNum":"  820","line":"  Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());"},
{"lineNum":"  821","line":""},
{"lineNum":"  822","line":"  enum {"},
{"lineNum":"  823","line":"      unroll = DstXprType::SizeAtCompileTime != Dynamic"},
{"lineNum":"  824","line":"            && SrcEvaluatorType::CoeffReadCost < HugeCost"},
{"lineNum":"  825","line":"            && DstXprType::SizeAtCompileTime * (int(DstEvaluatorType::CoeffReadCost) + int(SrcEvaluatorType::CoeffReadCost)) / 2 <= EIGEN_UNROLLING_LIMIT"},
{"lineNum":"  826","line":"    };"},
{"lineNum":"  827","line":""},
{"lineNum":"  828","line":"  triangular_assignment_loop<Kernel, Mode, unroll ? int(DstXprType::SizeAtCompileTime) : Dynamic, SetOpposite>::run(kernel);"},
{"lineNum":"  829","line":"}"},
{"lineNum":"  830","line":""},
{"lineNum":"  831","line":"template<int Mode, bool SetOpposite, typename DstXprType, typename SrcXprType>"},
{"lineNum":"  832","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  833","line":"void call_triangular_assignment_loop(DstXprType& dst, const SrcXprType& src)"},
{"lineNum":"  834","line":"{"},
{"lineNum":"  835","line":"  call_triangular_assignment_loop<Mode,SetOpposite>(dst, src, internal::assign_op<typename DstXprType::Scalar,typename SrcXprType::Scalar>());"},
{"lineNum":"  836","line":"}"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"template<> struct AssignmentKind<TriangularShape,TriangularShape> { typedef Triangular2Triangular Kind; };"},
{"lineNum":"  839","line":"template<> struct AssignmentKind<DenseShape,TriangularShape>      { typedef Triangular2Dense      Kind; };"},
{"lineNum":"  840","line":"template<> struct AssignmentKind<TriangularShape,DenseShape>      { typedef Dense2Triangular      Kind; };"},
{"lineNum":"  841","line":""},
{"lineNum":"  842","line":""},
{"lineNum":"  843","line":"template< typename DstXprType, typename SrcXprType, typename Functor>"},
{"lineNum":"  844","line":"struct Assignment<DstXprType, SrcXprType, Functor, Triangular2Triangular>"},
{"lineNum":"  845","line":"{"},
{"lineNum":"  846","line":"  EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)"},
{"lineNum":"  847","line":"  {"},
{"lineNum":"  848","line":"    eigen_assert(int(DstXprType::Mode) == int(SrcXprType::Mode));"},
{"lineNum":"  849","line":""},
{"lineNum":"  850","line":"    call_triangular_assignment_loop<DstXprType::Mode, false>(dst, src, func);"},
{"lineNum":"  851","line":"  }"},
{"lineNum":"  852","line":"};"},
{"lineNum":"  853","line":""},
{"lineNum":"  854","line":"template< typename DstXprType, typename SrcXprType, typename Functor>"},
{"lineNum":"  855","line":"struct Assignment<DstXprType, SrcXprType, Functor, Triangular2Dense>"},
{"lineNum":"  856","line":"{"},
{"lineNum":"  857","line":"  EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)"},
{"lineNum":"  858","line":"  {"},
{"lineNum":"  859","line":"    call_triangular_assignment_loop<SrcXprType::Mode, (int(SrcXprType::Mode) & int(SelfAdjoint)) == 0>(dst, src, func);"},
{"lineNum":"  860","line":"  }"},
{"lineNum":"  861","line":"};"},
{"lineNum":"  862","line":""},
{"lineNum":"  863","line":"template< typename DstXprType, typename SrcXprType, typename Functor>"},
{"lineNum":"  864","line":"struct Assignment<DstXprType, SrcXprType, Functor, Dense2Triangular>"},
{"lineNum":"  865","line":"{"},
{"lineNum":"  866","line":"  EIGEN_DEVICE_FUNC static void run(DstXprType &dst, const SrcXprType &src, const Functor &func)"},
{"lineNum":"  867","line":"  {"},
{"lineNum":"  868","line":"    call_triangular_assignment_loop<DstXprType::Mode, false>(dst, src, func);"},
{"lineNum":"  869","line":"  }"},
{"lineNum":"  870","line":"};"},
{"lineNum":"  871","line":""},
{"lineNum":"  872","line":""},
{"lineNum":"  873","line":"template<typename Kernel, unsigned int Mode, int UnrollCount, bool SetOpposite>"},
{"lineNum":"  874","line":"struct triangular_assignment_loop"},
{"lineNum":"  875","line":"{"},
{"lineNum":"  876","line":"  // FIXME: this is not very clean, perhaps this information should be provided by the kernel?"},
{"lineNum":"  877","line":"  typedef typename Kernel::DstEvaluatorType DstEvaluatorType;"},
{"lineNum":"  878","line":"  typedef typename DstEvaluatorType::XprType DstXprType;"},
{"lineNum":"  879","line":""},
{"lineNum":"  880","line":"  enum {"},
{"lineNum":"  881","line":"    col = (UnrollCount-1) / DstXprType::RowsAtCompileTime,"},
{"lineNum":"  882","line":"    row = (UnrollCount-1) % DstXprType::RowsAtCompileTime"},
{"lineNum":"  883","line":"  };"},
{"lineNum":"  884","line":""},
{"lineNum":"  885","line":"  typedef typename Kernel::Scalar Scalar;"},
{"lineNum":"  886","line":""},
{"lineNum":"  887","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  888","line":"  static inline void run(Kernel &kernel)"},
{"lineNum":"  889","line":"  {"},
{"lineNum":"  890","line":"    triangular_assignment_loop<Kernel, Mode, UnrollCount-1, SetOpposite>::run(kernel);"},
{"lineNum":"  891","line":""},
{"lineNum":"  892","line":"    if(row==col)"},
{"lineNum":"  893","line":"      kernel.assignDiagonalCoeff(row);"},
{"lineNum":"  894","line":"    else if( ((Mode&Lower) && row>col) || ((Mode&Upper) && row<col) )"},
{"lineNum":"  895","line":"      kernel.assignCoeff(row,col);"},
{"lineNum":"  896","line":"    else if(SetOpposite)"},
{"lineNum":"  897","line":"      kernel.assignOppositeCoeff(row,col);"},
{"lineNum":"  898","line":"  }"},
{"lineNum":"  899","line":"};"},
{"lineNum":"  900","line":""},
{"lineNum":"  901","line":"// prevent buggy user code from causing an infinite recursion"},
{"lineNum":"  902","line":"template<typename Kernel, unsigned int Mode, bool SetOpposite>"},
{"lineNum":"  903","line":"struct triangular_assignment_loop<Kernel, Mode, 0, SetOpposite>"},
{"lineNum":"  904","line":"{"},
{"lineNum":"  905","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  906","line":"  static inline void run(Kernel &) {}"},
{"lineNum":"  907","line":"};"},
{"lineNum":"  908","line":""},
{"lineNum":"  909","line":""},
{"lineNum":"  910","line":""},
{"lineNum":"  911","line":"// TODO: experiment with a recursive assignment procedure splitting the current"},
{"lineNum":"  912","line":"//       triangular part into one rectangular and two triangular parts."},
{"lineNum":"  913","line":""},
{"lineNum":"  914","line":""},
{"lineNum":"  915","line":"template<typename Kernel, unsigned int Mode, bool SetOpposite>"},
{"lineNum":"  916","line":"struct triangular_assignment_loop<Kernel, Mode, Dynamic, SetOpposite>"},
{"lineNum":"  917","line":"{"},
{"lineNum":"  918","line":"  typedef typename Kernel::Scalar Scalar;"},
{"lineNum":"  919","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  920","line":"  static inline void run(Kernel &kernel)"},
{"lineNum":"  921","line":"  {"},
{"lineNum":"  922","line":"    for(Index j = 0; j < kernel.cols(); ++j)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  923","line":"    {"},
{"lineNum":"  924","line":"      Index maxi = numext::mini(j, kernel.rows());"},
{"lineNum":"  925","line":"      Index i = 0;"},
{"lineNum":"  926","line":"      if (((Mode&Lower) && SetOpposite) || (Mode&Upper))"},
{"lineNum":"  927","line":"      {"},
{"lineNum":"  928","line":"        for(; i < maxi; ++i)","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  929","line":"          if(Mode&Upper) kernel.assignCoeff(i, j);"},
{"lineNum":"  930","line":"          else           kernel.assignOppositeCoeff(i, j);"},
{"lineNum":"  931","line":"      }"},
{"lineNum":"  932","line":"      else"},
{"lineNum":"  933","line":"        i = maxi;"},
{"lineNum":"  934","line":""},
{"lineNum":"  935","line":"      if(i<kernel.rows()) // then i==j","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  936","line":"        kernel.assignDiagonalCoeff(i++);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  937","line":""},
{"lineNum":"  938","line":"      if (((Mode&Upper) && SetOpposite) || (Mode&Lower))"},
{"lineNum":"  939","line":"      {"},
{"lineNum":"  940","line":"        for(; i < kernel.rows(); ++i)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  941","line":"          if(Mode&Lower) kernel.assignCoeff(i, j);"},
{"lineNum":"  942","line":"          else           kernel.assignOppositeCoeff(i, j);"},
{"lineNum":"  943","line":"      }"},
{"lineNum":"  944","line":"    }"},
{"lineNum":"  945","line":"  }"},
{"lineNum":"  946","line":"};"},
{"lineNum":"  947","line":""},
{"lineNum":"  948","line":"} // end namespace internal"},
{"lineNum":"  949","line":""},
{"lineNum":"  950","line":"/** Assigns a triangular or selfadjoint matrix to a dense matrix."},
{"lineNum":"  951","line":"  * If the matrix is triangular, the opposite part is set to zero. */"},
{"lineNum":"  952","line":"template<typename Derived>"},
{"lineNum":"  953","line":"template<typename DenseDerived>"},
{"lineNum":"  954","line":"EIGEN_DEVICE_FUNC void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const"},
{"lineNum":"  955","line":"{"},
{"lineNum":"  956","line":"  other.derived().resize(this->rows(), this->cols());"},
{"lineNum":"  957","line":"  internal::call_triangular_assignment_loop<Derived::Mode, (int(Derived::Mode) & int(SelfAdjoint)) == 0 /* SetOpposite */>(other.derived(), derived().nestedExpression());"},
{"lineNum":"  958","line":"}"},
{"lineNum":"  959","line":""},
{"lineNum":"  960","line":"namespace internal {"},
{"lineNum":"  961","line":""},
{"lineNum":"  962","line":"// Triangular = Product"},
{"lineNum":"  963","line":"template< typename DstXprType, typename Lhs, typename Rhs, typename Scalar>"},
{"lineNum":"  964","line":"struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>"},
{"lineNum":"  965","line":"{"},
{"lineNum":"  966","line":"  typedef Product<Lhs,Rhs,DefaultProduct> SrcXprType;"},
{"lineNum":"  967","line":"  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,typename SrcXprType::Scalar> &)"},
{"lineNum":"  968","line":"  {"},
{"lineNum":"  969","line":"    Index dstRows = src.rows();"},
{"lineNum":"  970","line":"    Index dstCols = src.cols();"},
{"lineNum":"  971","line":"    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))"},
{"lineNum":"  972","line":"      dst.resize(dstRows, dstCols);"},
{"lineNum":"  973","line":""},
{"lineNum":"  974","line":"    dst._assignProduct(src, Scalar(1), false);"},
{"lineNum":"  975","line":"  }"},
{"lineNum":"  976","line":"};"},
{"lineNum":"  977","line":""},
{"lineNum":"  978","line":"// Triangular += Product"},
{"lineNum":"  979","line":"template< typename DstXprType, typename Lhs, typename Rhs, typename Scalar>"},
{"lineNum":"  980","line":"struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::add_assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>"},
{"lineNum":"  981","line":"{"},
{"lineNum":"  982","line":"  typedef Product<Lhs,Rhs,DefaultProduct> SrcXprType;"},
{"lineNum":"  983","line":"  static void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,typename SrcXprType::Scalar> &)"},
{"lineNum":"  984","line":"  {"},
{"lineNum":"  985","line":"    dst._assignProduct(src, Scalar(1), true);"},
{"lineNum":"  986","line":"  }"},
{"lineNum":"  987","line":"};"},
{"lineNum":"  988","line":""},
{"lineNum":"  989","line":"// Triangular -= Product"},
{"lineNum":"  990","line":"template< typename DstXprType, typename Lhs, typename Rhs, typename Scalar>"},
{"lineNum":"  991","line":"struct Assignment<DstXprType, Product<Lhs,Rhs,DefaultProduct>, internal::sub_assign_op<Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, Dense2Triangular>"},
{"lineNum":"  992","line":"{"},
{"lineNum":"  993","line":"  typedef Product<Lhs,Rhs,DefaultProduct> SrcXprType;"},
{"lineNum":"  994","line":"  static void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,typename SrcXprType::Scalar> &)"},
{"lineNum":"  995","line":"  {"},
{"lineNum":"  996","line":"    dst._assignProduct(src, Scalar(-1), true);"},
{"lineNum":"  997","line":"  }"},
{"lineNum":"  998","line":"};"},
{"lineNum":"  999","line":""},
{"lineNum":" 1000","line":"} // end namespace internal"},
{"lineNum":" 1001","line":""},
{"lineNum":" 1002","line":"} // end namespace Eigen"},
{"lineNum":" 1003","line":""},
{"lineNum":" 1004","line":"#endif // EIGEN_TRIANGULARMATRIX_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 8, "covered" : 0,};
var merged_data = [];
