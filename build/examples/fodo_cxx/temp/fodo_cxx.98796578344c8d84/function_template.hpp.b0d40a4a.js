var data = {lines:[
{"lineNum":"    1","line":"// Boost.Function library"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"//  Copyright Douglas Gregor 2001-2006"},
{"lineNum":"    4","line":"//  Copyright Emil Dotchevski 2007"},
{"lineNum":"    5","line":"//  Use, modification and distribution is subject to the Boost Software License, Version 1.0."},
{"lineNum":"    6","line":"//  (See accompanying file LICENSE_1_0.txt or copy at"},
{"lineNum":"    7","line":"//  http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"// For more information, see http://www.boost.org"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"// Note: this header is a header template and must NOT have multiple-inclusion"},
{"lineNum":"   12","line":"// protection."},
{"lineNum":"   13","line":"#include <boost/function/detail/prologue.hpp>"},
{"lineNum":"   14","line":"#include <boost/core/no_exceptions_support.hpp>"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"#if defined(BOOST_MSVC)"},
{"lineNum":"   17","line":"#   pragma warning( push )"},
{"lineNum":"   18","line":"#   pragma warning( disable : 4127 ) // \"conditional expression is constant\""},
{"lineNum":"   19","line":"#endif"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"#define BOOST_FUNCTION_TEMPLATE_PARMS BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS, typename T)"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"#define BOOST_FUNCTION_TEMPLATE_ARGS BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS, T)"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"#define BOOST_FUNCTION_PARM(J,I,D) BOOST_PP_CAT(T,I) BOOST_PP_CAT(a,I)"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"#define BOOST_FUNCTION_PARMS BOOST_PP_ENUM(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_PARM,BOOST_PP_EMPTY)"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"#ifdef BOOST_NO_CXX11_RVALUE_REFERENCES"},
{"lineNum":"   30","line":"#   define BOOST_FUNCTION_ARGS BOOST_PP_ENUM_PARAMS(BOOST_FUNCTION_NUM_ARGS, a)"},
{"lineNum":"   31","line":"#else"},
{"lineNum":"   32","line":"#   define BOOST_FUNCTION_ARG(J,I,D) static_cast<BOOST_PP_CAT(T,I)&&>(BOOST_PP_CAT(a,I))"},
{"lineNum":"   33","line":"#   define BOOST_FUNCTION_ARGS BOOST_PP_ENUM(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_ARG,BOOST_PP_EMPTY)"},
{"lineNum":"   34","line":"#endif"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"#define BOOST_FUNCTION_ARG_TYPE(J,I,D) \\"},
{"lineNum":"   37","line":"  typedef BOOST_PP_CAT(T,I) BOOST_PP_CAT(BOOST_PP_CAT(arg, BOOST_PP_INC(I)),_type);"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"#define BOOST_FUNCTION_ARG_TYPES BOOST_PP_REPEAT(BOOST_FUNCTION_NUM_ARGS,BOOST_FUNCTION_ARG_TYPE,BOOST_PP_EMPTY)"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"// Comma if nonzero number of arguments"},
{"lineNum":"   42","line":"#if BOOST_FUNCTION_NUM_ARGS == 0"},
{"lineNum":"   43","line":"#  define BOOST_FUNCTION_COMMA"},
{"lineNum":"   44","line":"#else"},
{"lineNum":"   45","line":"#  define BOOST_FUNCTION_COMMA ,"},
{"lineNum":"   46","line":"#endif // BOOST_FUNCTION_NUM_ARGS > 0"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"// Class names used in this version of the code"},
{"lineNum":"   49","line":"#define BOOST_FUNCTION_FUNCTION BOOST_JOIN(function,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   50","line":"#define BOOST_FUNCTION_FUNCTION_INVOKER \\"},
{"lineNum":"   51","line":"  BOOST_JOIN(function_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   52","line":"#define BOOST_FUNCTION_VOID_FUNCTION_INVOKER \\"},
{"lineNum":"   53","line":"  BOOST_JOIN(void_function_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   54","line":"#define BOOST_FUNCTION_FUNCTION_OBJ_INVOKER \\"},
{"lineNum":"   55","line":"  BOOST_JOIN(function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   56","line":"#define BOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKER \\"},
{"lineNum":"   57","line":"  BOOST_JOIN(void_function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   58","line":"#define BOOST_FUNCTION_FUNCTION_REF_INVOKER \\"},
{"lineNum":"   59","line":"  BOOST_JOIN(function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   60","line":"#define BOOST_FUNCTION_VOID_FUNCTION_REF_INVOKER \\"},
{"lineNum":"   61","line":"  BOOST_JOIN(void_function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   62","line":"#define BOOST_FUNCTION_MEMBER_INVOKER \\"},
{"lineNum":"   63","line":"  BOOST_JOIN(function_mem_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   64","line":"#define BOOST_FUNCTION_VOID_MEMBER_INVOKER \\"},
{"lineNum":"   65","line":"  BOOST_JOIN(function_void_mem_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   66","line":"#define BOOST_FUNCTION_GET_FUNCTION_INVOKER \\"},
{"lineNum":"   67","line":"  BOOST_JOIN(get_function_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   68","line":"#define BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER \\"},
{"lineNum":"   69","line":"  BOOST_JOIN(get_function_obj_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   70","line":"#define BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER \\"},
{"lineNum":"   71","line":"  BOOST_JOIN(get_function_ref_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   72","line":"#define BOOST_FUNCTION_GET_MEMBER_INVOKER \\"},
{"lineNum":"   73","line":"  BOOST_JOIN(get_member_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   74","line":"#define BOOST_FUNCTION_GET_INVOKER \\"},
{"lineNum":"   75","line":"  BOOST_JOIN(get_invoker,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   76","line":"#define BOOST_FUNCTION_VTABLE BOOST_JOIN(basic_vtable,BOOST_FUNCTION_NUM_ARGS)"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"#ifndef BOOST_NO_VOID_RETURNS"},
{"lineNum":"   79","line":"#  define BOOST_FUNCTION_VOID_RETURN_TYPE void"},
{"lineNum":"   80","line":"#  define BOOST_FUNCTION_RETURN(X) X"},
{"lineNum":"   81","line":"#else"},
{"lineNum":"   82","line":"#  define BOOST_FUNCTION_VOID_RETURN_TYPE boost::detail::function::unusable"},
{"lineNum":"   83","line":"#  define BOOST_FUNCTION_RETURN(X) X; return BOOST_FUNCTION_VOID_RETURN_TYPE ()"},
{"lineNum":"   84","line":"#endif"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"namespace boost {"},
{"lineNum":"   87","line":"  namespace detail {"},
{"lineNum":"   88","line":"    namespace function {"},
{"lineNum":"   89","line":"      template<"},
{"lineNum":"   90","line":"        typename FunctionPtr,"},
{"lineNum":"   91","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"   92","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"   93","line":"        >"},
{"lineNum":"   94","line":"      struct BOOST_FUNCTION_FUNCTION_INVOKER"},
{"lineNum":"   95","line":"      {"},
{"lineNum":"   96","line":"        static R invoke(function_buffer& function_ptr BOOST_FUNCTION_COMMA"},
{"lineNum":"   97","line":"                        BOOST_FUNCTION_PARMS)"},
{"lineNum":"   98","line":"        {"},
{"lineNum":"   99","line":"          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.members.func_ptr);"},
{"lineNum":"  100","line":"          return f(BOOST_FUNCTION_ARGS);"},
{"lineNum":"  101","line":"        }"},
{"lineNum":"  102","line":"      };"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"      template<"},
{"lineNum":"  105","line":"        typename FunctionPtr,"},
{"lineNum":"  106","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  107","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  108","line":"        >"},
{"lineNum":"  109","line":"      struct BOOST_FUNCTION_VOID_FUNCTION_INVOKER"},
{"lineNum":"  110","line":"      {"},
{"lineNum":"  111","line":"        static BOOST_FUNCTION_VOID_RETURN_TYPE"},
{"lineNum":"  112","line":"        invoke(function_buffer& function_ptr BOOST_FUNCTION_COMMA"},
{"lineNum":"  113","line":"               BOOST_FUNCTION_PARMS)"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"        {"},
{"lineNum":"  116","line":"          FunctionPtr f = reinterpret_cast<FunctionPtr>(function_ptr.members.func_ptr);"},
{"lineNum":"  117","line":"          BOOST_FUNCTION_RETURN(f(BOOST_FUNCTION_ARGS));"},
{"lineNum":"  118","line":"        }"},
{"lineNum":"  119","line":"      };"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"      template<"},
{"lineNum":"  122","line":"        typename FunctionObj,"},
{"lineNum":"  123","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  124","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  125","line":"      >"},
{"lineNum":"  126","line":"      struct BOOST_FUNCTION_FUNCTION_OBJ_INVOKER"},
{"lineNum":"  127","line":"      {"},
{"lineNum":"  128","line":"        static R invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA"},
{"lineNum":"  129","line":"                        BOOST_FUNCTION_PARMS)"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  132","line":"          FunctionObj* f;"},
{"lineNum":"  133","line":"          if (function_allows_small_object_optimization<FunctionObj>::value)"},
{"lineNum":"  134","line":"            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.data);"},
{"lineNum":"  135","line":"          else"},
{"lineNum":"  136","line":"            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  137","line":"          return (*f)(BOOST_FUNCTION_ARGS);","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  138","line":"        }"},
{"lineNum":"  139","line":"      };"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"      template<"},
{"lineNum":"  142","line":"        typename FunctionObj,"},
{"lineNum":"  143","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  144","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  145","line":"      >"},
{"lineNum":"  146","line":"      struct BOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKER"},
{"lineNum":"  147","line":"      {"},
{"lineNum":"  148","line":"        static BOOST_FUNCTION_VOID_RETURN_TYPE"},
{"lineNum":"  149","line":"        invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA"},
{"lineNum":"  150","line":"               BOOST_FUNCTION_PARMS)"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"        {"},
{"lineNum":"  153","line":"          FunctionObj* f;"},
{"lineNum":"  154","line":"          if (function_allows_small_object_optimization<FunctionObj>::value)"},
{"lineNum":"  155","line":"            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.data);"},
{"lineNum":"  156","line":"          else"},
{"lineNum":"  157","line":"            f = reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);"},
{"lineNum":"  158","line":"          BOOST_FUNCTION_RETURN((*f)(BOOST_FUNCTION_ARGS));"},
{"lineNum":"  159","line":"        }"},
{"lineNum":"  160","line":"      };"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"      template<"},
{"lineNum":"  163","line":"        typename FunctionObj,"},
{"lineNum":"  164","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  165","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  166","line":"      >"},
{"lineNum":"  167","line":"      struct BOOST_FUNCTION_FUNCTION_REF_INVOKER"},
{"lineNum":"  168","line":"      {"},
{"lineNum":"  169","line":"        static R invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA"},
{"lineNum":"  170","line":"                        BOOST_FUNCTION_PARMS)"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"        {"},
{"lineNum":"  173","line":"          FunctionObj* f ="},
{"lineNum":"  174","line":"            reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);"},
{"lineNum":"  175","line":"          return (*f)(BOOST_FUNCTION_ARGS);"},
{"lineNum":"  176","line":"        }"},
{"lineNum":"  177","line":"      };"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"      template<"},
{"lineNum":"  180","line":"        typename FunctionObj,"},
{"lineNum":"  181","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  182","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  183","line":"      >"},
{"lineNum":"  184","line":"      struct BOOST_FUNCTION_VOID_FUNCTION_REF_INVOKER"},
{"lineNum":"  185","line":"      {"},
{"lineNum":"  186","line":"        static BOOST_FUNCTION_VOID_RETURN_TYPE"},
{"lineNum":"  187","line":"        invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA"},
{"lineNum":"  188","line":"               BOOST_FUNCTION_PARMS)"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"        {"},
{"lineNum":"  191","line":"          FunctionObj* f ="},
{"lineNum":"  192","line":"            reinterpret_cast<FunctionObj*>(function_obj_ptr.members.obj_ptr);"},
{"lineNum":"  193","line":"          BOOST_FUNCTION_RETURN((*f)(BOOST_FUNCTION_ARGS));"},
{"lineNum":"  194","line":"        }"},
{"lineNum":"  195","line":"      };"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"#if BOOST_FUNCTION_NUM_ARGS > 0"},
{"lineNum":"  198","line":"      /* Handle invocation of member pointers. */"},
{"lineNum":"  199","line":"      template<"},
{"lineNum":"  200","line":"        typename MemberPtr,"},
{"lineNum":"  201","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  202","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  203","line":"      >"},
{"lineNum":"  204","line":"      struct BOOST_FUNCTION_MEMBER_INVOKER"},
{"lineNum":"  205","line":"      {"},
{"lineNum":"  206","line":"        static R invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA"},
{"lineNum":"  207","line":"                        BOOST_FUNCTION_PARMS)"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"        {"},
{"lineNum":"  210","line":"          MemberPtr* f ="},
{"lineNum":"  211","line":"            reinterpret_cast<MemberPtr*>(function_obj_ptr.data);"},
{"lineNum":"  212","line":"          return boost::mem_fn(*f)(BOOST_FUNCTION_ARGS);"},
{"lineNum":"  213","line":"        }"},
{"lineNum":"  214","line":"      };"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"      template<"},
{"lineNum":"  217","line":"        typename MemberPtr,"},
{"lineNum":"  218","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  219","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  220","line":"      >"},
{"lineNum":"  221","line":"      struct BOOST_FUNCTION_VOID_MEMBER_INVOKER"},
{"lineNum":"  222","line":"      {"},
{"lineNum":"  223","line":"        static BOOST_FUNCTION_VOID_RETURN_TYPE"},
{"lineNum":"  224","line":"        invoke(function_buffer& function_obj_ptr BOOST_FUNCTION_COMMA"},
{"lineNum":"  225","line":"               BOOST_FUNCTION_PARMS)"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"        {"},
{"lineNum":"  228","line":"          MemberPtr* f ="},
{"lineNum":"  229","line":"            reinterpret_cast<MemberPtr*>(function_obj_ptr.data);"},
{"lineNum":"  230","line":"          BOOST_FUNCTION_RETURN(boost::mem_fn(*f)(BOOST_FUNCTION_ARGS));"},
{"lineNum":"  231","line":"        }"},
{"lineNum":"  232","line":"      };"},
{"lineNum":"  233","line":"#endif"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"      template<"},
{"lineNum":"  236","line":"        typename FunctionPtr,"},
{"lineNum":"  237","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  238","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  239","line":"      >"},
{"lineNum":"  240","line":"      struct BOOST_FUNCTION_GET_FUNCTION_INVOKER"},
{"lineNum":"  241","line":"      {"},
{"lineNum":"  242","line":"        typedef typename conditional<(is_void<R>::value),"},
{"lineNum":"  243","line":"                            BOOST_FUNCTION_VOID_FUNCTION_INVOKER<"},
{"lineNum":"  244","line":"                            FunctionPtr,"},
{"lineNum":"  245","line":"                            R BOOST_FUNCTION_COMMA"},
{"lineNum":"  246","line":"                            BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  247","line":"                          >,"},
{"lineNum":"  248","line":"                          BOOST_FUNCTION_FUNCTION_INVOKER<"},
{"lineNum":"  249","line":"                            FunctionPtr,"},
{"lineNum":"  250","line":"                            R BOOST_FUNCTION_COMMA"},
{"lineNum":"  251","line":"                            BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  252","line":"                          >"},
{"lineNum":"  253","line":"                       >::type type;"},
{"lineNum":"  254","line":"      };"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"      template<"},
{"lineNum":"  257","line":"        typename FunctionObj,"},
{"lineNum":"  258","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  259","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  260","line":"       >"},
{"lineNum":"  261","line":"      struct BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER"},
{"lineNum":"  262","line":"      {"},
{"lineNum":"  263","line":"        typedef typename conditional<(is_void<R>::value),"},
{"lineNum":"  264","line":"                            BOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKER<"},
{"lineNum":"  265","line":"                            FunctionObj,"},
{"lineNum":"  266","line":"                            R BOOST_FUNCTION_COMMA"},
{"lineNum":"  267","line":"                            BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  268","line":"                          >,"},
{"lineNum":"  269","line":"                          BOOST_FUNCTION_FUNCTION_OBJ_INVOKER<"},
{"lineNum":"  270","line":"                            FunctionObj,"},
{"lineNum":"  271","line":"                            R BOOST_FUNCTION_COMMA"},
{"lineNum":"  272","line":"                            BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  273","line":"                          >"},
{"lineNum":"  274","line":"                       >::type type;"},
{"lineNum":"  275","line":"      };"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"      template<"},
{"lineNum":"  278","line":"        typename FunctionObj,"},
{"lineNum":"  279","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  280","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  281","line":"       >"},
{"lineNum":"  282","line":"      struct BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER"},
{"lineNum":"  283","line":"      {"},
{"lineNum":"  284","line":"        typedef typename conditional<(is_void<R>::value),"},
{"lineNum":"  285","line":"                            BOOST_FUNCTION_VOID_FUNCTION_REF_INVOKER<"},
{"lineNum":"  286","line":"                            FunctionObj,"},
{"lineNum":"  287","line":"                            R BOOST_FUNCTION_COMMA"},
{"lineNum":"  288","line":"                            BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  289","line":"                          >,"},
{"lineNum":"  290","line":"                          BOOST_FUNCTION_FUNCTION_REF_INVOKER<"},
{"lineNum":"  291","line":"                            FunctionObj,"},
{"lineNum":"  292","line":"                            R BOOST_FUNCTION_COMMA"},
{"lineNum":"  293","line":"                            BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  294","line":"                          >"},
{"lineNum":"  295","line":"                       >::type type;"},
{"lineNum":"  296","line":"      };"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"#if BOOST_FUNCTION_NUM_ARGS > 0"},
{"lineNum":"  299","line":"      /* Retrieve the appropriate invoker for a member pointer.  */"},
{"lineNum":"  300","line":"      template<"},
{"lineNum":"  301","line":"        typename MemberPtr,"},
{"lineNum":"  302","line":"        typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  303","line":"        BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  304","line":"       >"},
{"lineNum":"  305","line":"      struct BOOST_FUNCTION_GET_MEMBER_INVOKER"},
{"lineNum":"  306","line":"      {"},
{"lineNum":"  307","line":"        typedef typename conditional<(is_void<R>::value),"},
{"lineNum":"  308","line":"                            BOOST_FUNCTION_VOID_MEMBER_INVOKER<"},
{"lineNum":"  309","line":"                            MemberPtr,"},
{"lineNum":"  310","line":"                            R BOOST_FUNCTION_COMMA"},
{"lineNum":"  311","line":"                            BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  312","line":"                          >,"},
{"lineNum":"  313","line":"                          BOOST_FUNCTION_MEMBER_INVOKER<"},
{"lineNum":"  314","line":"                            MemberPtr,"},
{"lineNum":"  315","line":"                            R BOOST_FUNCTION_COMMA"},
{"lineNum":"  316","line":"                            BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  317","line":"                          >"},
{"lineNum":"  318","line":"                       >::type type;"},
{"lineNum":"  319","line":"      };"},
{"lineNum":"  320","line":"#endif"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"      /* Given the tag returned by get_function_tag, retrieve the"},
{"lineNum":"  323","line":"         actual invoker that will be used for the given function"},
{"lineNum":"  324","line":"         object."},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"         Each specialization contains an \"apply\" nested class template"},
{"lineNum":"  327","line":"         that accepts the function object, return type, function"},
{"lineNum":"  328","line":"         argument types, and allocator. The resulting \"apply\" class"},
{"lineNum":"  329","line":"         contains two typedefs, \"invoker_type\" and \"manager_type\","},
{"lineNum":"  330","line":"         which correspond to the invoker and manager types. */"},
{"lineNum":"  331","line":"      template<typename Tag>"},
{"lineNum":"  332","line":"      struct BOOST_FUNCTION_GET_INVOKER { };"},
{"lineNum":"  333","line":""},
{"lineNum":"  334","line":"      /* Retrieve the invoker for a function pointer. */"},
{"lineNum":"  335","line":"      template<>"},
{"lineNum":"  336","line":"      struct BOOST_FUNCTION_GET_INVOKER<function_ptr_tag>"},
{"lineNum":"  337","line":"      {"},
{"lineNum":"  338","line":"        template<typename FunctionPtr,"},
{"lineNum":"  339","line":"                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  340","line":"        struct apply"},
{"lineNum":"  341","line":"        {"},
{"lineNum":"  342","line":"          typedef typename BOOST_FUNCTION_GET_FUNCTION_INVOKER<"},
{"lineNum":"  343","line":"                             FunctionPtr,"},
{"lineNum":"  344","line":"                             R BOOST_FUNCTION_COMMA"},
{"lineNum":"  345","line":"                             BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  346","line":"                           >::type"},
{"lineNum":"  347","line":"            invoker_type;"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"          typedef functor_manager<FunctionPtr> manager_type;"},
{"lineNum":"  350","line":"        };"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"        template<typename FunctionPtr, typename Allocator,"},
{"lineNum":"  353","line":"                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  354","line":"        struct apply_a"},
{"lineNum":"  355","line":"        {"},
{"lineNum":"  356","line":"          typedef typename BOOST_FUNCTION_GET_FUNCTION_INVOKER<"},
{"lineNum":"  357","line":"                             FunctionPtr,"},
{"lineNum":"  358","line":"                             R BOOST_FUNCTION_COMMA"},
{"lineNum":"  359","line":"                             BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  360","line":"                           >::type"},
{"lineNum":"  361","line":"            invoker_type;"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"          typedef functor_manager<FunctionPtr> manager_type;"},
{"lineNum":"  364","line":"        };"},
{"lineNum":"  365","line":"      };"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"#if BOOST_FUNCTION_NUM_ARGS > 0"},
{"lineNum":"  368","line":"      /* Retrieve the invoker for a member pointer. */"},
{"lineNum":"  369","line":"      template<>"},
{"lineNum":"  370","line":"      struct BOOST_FUNCTION_GET_INVOKER<member_ptr_tag>"},
{"lineNum":"  371","line":"      {"},
{"lineNum":"  372","line":"        template<typename MemberPtr,"},
{"lineNum":"  373","line":"                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  374","line":"        struct apply"},
{"lineNum":"  375","line":"        {"},
{"lineNum":"  376","line":"          typedef typename BOOST_FUNCTION_GET_MEMBER_INVOKER<"},
{"lineNum":"  377","line":"                             MemberPtr,"},
{"lineNum":"  378","line":"                             R BOOST_FUNCTION_COMMA"},
{"lineNum":"  379","line":"                             BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  380","line":"                           >::type"},
{"lineNum":"  381","line":"            invoker_type;"},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"          typedef functor_manager<MemberPtr> manager_type;"},
{"lineNum":"  384","line":"        };"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"        template<typename MemberPtr, typename Allocator,"},
{"lineNum":"  387","line":"                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  388","line":"        struct apply_a"},
{"lineNum":"  389","line":"        {"},
{"lineNum":"  390","line":"          typedef typename BOOST_FUNCTION_GET_MEMBER_INVOKER<"},
{"lineNum":"  391","line":"                             MemberPtr,"},
{"lineNum":"  392","line":"                             R BOOST_FUNCTION_COMMA"},
{"lineNum":"  393","line":"                             BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  394","line":"                           >::type"},
{"lineNum":"  395","line":"            invoker_type;"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"          typedef functor_manager<MemberPtr> manager_type;"},
{"lineNum":"  398","line":"        };"},
{"lineNum":"  399","line":"      };"},
{"lineNum":"  400","line":"#endif"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"      /* Retrieve the invoker for a function object. */"},
{"lineNum":"  403","line":"      template<>"},
{"lineNum":"  404","line":"      struct BOOST_FUNCTION_GET_INVOKER<function_obj_tag>"},
{"lineNum":"  405","line":"      {"},
{"lineNum":"  406","line":"        template<typename FunctionObj,"},
{"lineNum":"  407","line":"                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  408","line":"        struct apply"},
{"lineNum":"  409","line":"        {"},
{"lineNum":"  410","line":"          typedef typename BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER<"},
{"lineNum":"  411","line":"                             FunctionObj,"},
{"lineNum":"  412","line":"                             R BOOST_FUNCTION_COMMA"},
{"lineNum":"  413","line":"                             BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  414","line":"                           >::type"},
{"lineNum":"  415","line":"            invoker_type;"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"          typedef functor_manager<FunctionObj> manager_type;"},
{"lineNum":"  418","line":"        };"},
{"lineNum":"  419","line":""},
{"lineNum":"  420","line":"        template<typename FunctionObj, typename Allocator,"},
{"lineNum":"  421","line":"                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  422","line":"        struct apply_a"},
{"lineNum":"  423","line":"        {"},
{"lineNum":"  424","line":"          typedef typename BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER<"},
{"lineNum":"  425","line":"                             FunctionObj,"},
{"lineNum":"  426","line":"                             R BOOST_FUNCTION_COMMA"},
{"lineNum":"  427","line":"                             BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  428","line":"                           >::type"},
{"lineNum":"  429","line":"            invoker_type;"},
{"lineNum":"  430","line":""},
{"lineNum":"  431","line":"          typedef functor_manager_a<FunctionObj, Allocator> manager_type;"},
{"lineNum":"  432","line":"        };"},
{"lineNum":"  433","line":"      };"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"      /* Retrieve the invoker for a reference to a function object. */"},
{"lineNum":"  436","line":"      template<>"},
{"lineNum":"  437","line":"      struct BOOST_FUNCTION_GET_INVOKER<function_obj_ref_tag>"},
{"lineNum":"  438","line":"      {"},
{"lineNum":"  439","line":"        template<typename RefWrapper,"},
{"lineNum":"  440","line":"                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  441","line":"        struct apply"},
{"lineNum":"  442","line":"        {"},
{"lineNum":"  443","line":"          typedef typename BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER<"},
{"lineNum":"  444","line":"                             typename RefWrapper::type,"},
{"lineNum":"  445","line":"                             R BOOST_FUNCTION_COMMA"},
{"lineNum":"  446","line":"                             BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  447","line":"                           >::type"},
{"lineNum":"  448","line":"            invoker_type;"},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"          typedef reference_manager<typename RefWrapper::type> manager_type;"},
{"lineNum":"  451","line":"        };"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"        template<typename RefWrapper, typename Allocator,"},
{"lineNum":"  454","line":"                 typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  455","line":"        struct apply_a"},
{"lineNum":"  456","line":"        {"},
{"lineNum":"  457","line":"          typedef typename BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER<"},
{"lineNum":"  458","line":"                             typename RefWrapper::type,"},
{"lineNum":"  459","line":"                             R BOOST_FUNCTION_COMMA"},
{"lineNum":"  460","line":"                             BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":"  461","line":"                           >::type"},
{"lineNum":"  462","line":"            invoker_type;"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"          typedef reference_manager<typename RefWrapper::type> manager_type;"},
{"lineNum":"  465","line":"        };"},
{"lineNum":"  466","line":"      };"},
{"lineNum":"  467","line":""},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"      /**"},
{"lineNum":"  470","line":"       * vtable for a specific boost::function instance. This"},
{"lineNum":"  471","line":"       * structure must be an aggregate so that we can use static"},
{"lineNum":"  472","line":"       * initialization in boost::function\'s assign_to and assign_to_a"},
{"lineNum":"  473","line":"       * members. It therefore cannot have any constructors,"},
{"lineNum":"  474","line":"       * destructors, base classes, etc."},
{"lineNum":"  475","line":"       */"},
{"lineNum":"  476","line":"      template<typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":"  477","line":"      struct BOOST_FUNCTION_VTABLE"},
{"lineNum":"  478","line":"      {"},
{"lineNum":"  479","line":"#ifndef BOOST_NO_VOID_RETURNS"},
{"lineNum":"  480","line":"        typedef R         result_type;"},
{"lineNum":"  481","line":"#else"},
{"lineNum":"  482","line":"        typedef typename function_return_type<R>::type result_type;"},
{"lineNum":"  483","line":"#endif // BOOST_NO_VOID_RETURNS"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"        typedef result_type (*invoker_type)(function_buffer&"},
{"lineNum":"  486","line":"                                            BOOST_FUNCTION_COMMA"},
{"lineNum":"  487","line":"                                            BOOST_FUNCTION_TEMPLATE_ARGS);"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"        template<typename F>"},
{"lineNum":"  490","line":"        bool assign_to(F f, function_buffer& functor) const"},
{"lineNum":"  491","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  492","line":"          typedef typename get_function_tag<F>::type tag;"},
{"lineNum":"  493","line":"          return assign_to(f, functor, tag());","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  494","line":"        }"},
{"lineNum":"  495","line":"        template<typename F,typename Allocator>"},
{"lineNum":"  496","line":"        bool assign_to_a(F f, function_buffer& functor, Allocator a) const"},
{"lineNum":"  497","line":"        {"},
{"lineNum":"  498","line":"          typedef typename get_function_tag<F>::type tag;"},
{"lineNum":"  499","line":"          return assign_to_a(f, functor, a, tag());"},
{"lineNum":"  500","line":"        }"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"        void clear(function_buffer& functor) const"},
{"lineNum":"  503","line":"        {"},
{"lineNum":"  504","line":"          if (base.manager)","class":"lineNoCov","hits":"0","possible_hits":"131",},
{"lineNum":"  505","line":"            base.manager(functor, functor, destroy_functor_tag);","class":"lineNoCov","hits":"0","possible_hits":"131",},
{"lineNum":"  506","line":"        }"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"      private:"},
{"lineNum":"  509","line":"        // Function pointers"},
{"lineNum":"  510","line":"        template<typename FunctionPtr>"},
{"lineNum":"  511","line":"        bool"},
{"lineNum":"  512","line":"        assign_to(FunctionPtr f, function_buffer& functor, function_ptr_tag) const"},
{"lineNum":"  513","line":"        {"},
{"lineNum":"  514","line":"          this->clear(functor);"},
{"lineNum":"  515","line":"          if (f) {"},
{"lineNum":"  516","line":"            // should be a reinterpret cast, but some compilers insist"},
{"lineNum":"  517","line":"            // on giving cv-qualifiers to free functions"},
{"lineNum":"  518","line":"            functor.members.func_ptr = reinterpret_cast<void (*)()>(f);"},
{"lineNum":"  519","line":"            return true;"},
{"lineNum":"  520","line":"          } else {"},
{"lineNum":"  521","line":"            return false;"},
{"lineNum":"  522","line":"          }"},
{"lineNum":"  523","line":"        }"},
{"lineNum":"  524","line":"        template<typename FunctionPtr,typename Allocator>"},
{"lineNum":"  525","line":"        bool"},
{"lineNum":"  526","line":"        assign_to_a(FunctionPtr f, function_buffer& functor, Allocator, function_ptr_tag) const"},
{"lineNum":"  527","line":"        {"},
{"lineNum":"  528","line":"          return assign_to(f,functor,function_ptr_tag());"},
{"lineNum":"  529","line":"        }"},
{"lineNum":"  530","line":""},
{"lineNum":"  531","line":"        // Member pointers"},
{"lineNum":"  532","line":"#if BOOST_FUNCTION_NUM_ARGS > 0"},
{"lineNum":"  533","line":"        template<typename MemberPtr>"},
{"lineNum":"  534","line":"        bool assign_to(MemberPtr f, function_buffer& functor, member_ptr_tag) const"},
{"lineNum":"  535","line":"        {"},
{"lineNum":"  536","line":"          // DPG TBD: Add explicit support for member function"},
{"lineNum":"  537","line":"          // objects, so we invoke through mem_fn() but we retain the"},
{"lineNum":"  538","line":"          // right target_type() values."},
{"lineNum":"  539","line":"          if (f) {"},
{"lineNum":"  540","line":"            this->assign_to(boost::mem_fn(f), functor);"},
{"lineNum":"  541","line":"            return true;"},
{"lineNum":"  542","line":"          } else {"},
{"lineNum":"  543","line":"            return false;"},
{"lineNum":"  544","line":"          }"},
{"lineNum":"  545","line":"        }"},
{"lineNum":"  546","line":"        template<typename MemberPtr,typename Allocator>"},
{"lineNum":"  547","line":"        bool assign_to_a(MemberPtr f, function_buffer& functor, Allocator a, member_ptr_tag) const"},
{"lineNum":"  548","line":"        {"},
{"lineNum":"  549","line":"          // DPG TBD: Add explicit support for member function"},
{"lineNum":"  550","line":"          // objects, so we invoke through mem_fn() but we retain the"},
{"lineNum":"  551","line":"          // right target_type() values."},
{"lineNum":"  552","line":"          if (f) {"},
{"lineNum":"  553","line":"            this->assign_to_a(boost::mem_fn(f), functor, a);"},
{"lineNum":"  554","line":"            return true;"},
{"lineNum":"  555","line":"          } else {"},
{"lineNum":"  556","line":"            return false;"},
{"lineNum":"  557","line":"          }"},
{"lineNum":"  558","line":"        }"},
{"lineNum":"  559","line":"#endif // BOOST_FUNCTION_NUM_ARGS > 0"},
{"lineNum":"  560","line":""},
{"lineNum":"  561","line":"        // Function objects"},
{"lineNum":"  562","line":"        // Assign to a function object using the small object optimization"},
{"lineNum":"  563","line":"        template<typename FunctionObj>"},
{"lineNum":"  564","line":"        void"},
{"lineNum":"  565","line":"        assign_functor(FunctionObj f, function_buffer& functor, true_type) const"},
{"lineNum":"  566","line":"        {"},
{"lineNum":"  567","line":"          new (reinterpret_cast<void*>(functor.data)) FunctionObj(f);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  568","line":"        }"},
{"lineNum":"  569","line":"        template<typename FunctionObj,typename Allocator>"},
{"lineNum":"  570","line":"        void"},
{"lineNum":"  571","line":"        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator, true_type) const"},
{"lineNum":"  572","line":"        {"},
{"lineNum":"  573","line":"          assign_functor(f,functor,true_type());"},
{"lineNum":"  574","line":"        }"},
{"lineNum":"  575","line":""},
{"lineNum":"  576","line":"        // Assign to a function object allocated on the heap."},
{"lineNum":"  577","line":"        template<typename FunctionObj>"},
{"lineNum":"  578","line":"        void"},
{"lineNum":"  579","line":"        assign_functor(FunctionObj f, function_buffer& functor, false_type) const"},
{"lineNum":"  580","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  581","line":"          functor.members.obj_ptr = new FunctionObj(f);","class":"lineNoCov","hits":"0","possible_hits":"45",},
{"lineNum":"  582","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  583","line":"        template<typename FunctionObj,typename Allocator>"},
{"lineNum":"  584","line":"        void"},
{"lineNum":"  585","line":"        assign_functor_a(FunctionObj f, function_buffer& functor, Allocator a, false_type) const"},
{"lineNum":"  586","line":"        {"},
{"lineNum":"  587","line":"          typedef functor_wrapper<FunctionObj,Allocator> functor_wrapper_type;"},
{"lineNum":"  588","line":"#if defined(BOOST_NO_CXX11_ALLOCATOR)"},
{"lineNum":"  589","line":"          typedef typename Allocator::template rebind<functor_wrapper_type>::other"},
{"lineNum":"  590","line":"            wrapper_allocator_type;"},
{"lineNum":"  591","line":"          typedef typename wrapper_allocator_type::pointer wrapper_allocator_pointer_type;"},
{"lineNum":"  592","line":"#else"},
{"lineNum":"  593","line":"          using wrapper_allocator_type = typename std::allocator_traits<Allocator>::template rebind_alloc<functor_wrapper_type>;"},
{"lineNum":"  594","line":"          using wrapper_allocator_pointer_type = typename std::allocator_traits<wrapper_allocator_type>::pointer;"},
{"lineNum":"  595","line":"#endif"},
{"lineNum":"  596","line":"          wrapper_allocator_type wrapper_allocator(a);"},
{"lineNum":"  597","line":"          wrapper_allocator_pointer_type copy = wrapper_allocator.allocate(1);"},
{"lineNum":"  598","line":"#if defined(BOOST_NO_CXX11_ALLOCATOR)"},
{"lineNum":"  599","line":"          wrapper_allocator.construct(copy, functor_wrapper_type(f,a));"},
{"lineNum":"  600","line":"#else"},
{"lineNum":"  601","line":"          std::allocator_traits<wrapper_allocator_type>::construct(wrapper_allocator, copy, functor_wrapper_type(f,a));"},
{"lineNum":"  602","line":"#endif"},
{"lineNum":"  603","line":"          functor_wrapper_type* new_f = static_cast<functor_wrapper_type*>(copy);"},
{"lineNum":"  604","line":"          functor.members.obj_ptr = new_f;"},
{"lineNum":"  605","line":"        }"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"        template<typename FunctionObj>"},
{"lineNum":"  608","line":"        bool"},
{"lineNum":"  609","line":"        assign_to(FunctionObj f, function_buffer& functor, function_obj_tag) const"},
{"lineNum":"  610","line":"        {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  611","line":"          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {"},
{"lineNum":"  612","line":"            assign_functor(f, functor,","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  613","line":"                           integral_constant<bool, (function_allows_small_object_optimization<FunctionObj>::value)>());"},
{"lineNum":"  614","line":"            return true;"},
{"lineNum":"  615","line":"          } else {"},
{"lineNum":"  616","line":"            return false;"},
{"lineNum":"  617","line":"          }"},
{"lineNum":"  618","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  619","line":"        template<typename FunctionObj,typename Allocator>"},
{"lineNum":"  620","line":"        bool"},
{"lineNum":"  621","line":"        assign_to_a(FunctionObj f, function_buffer& functor, Allocator a, function_obj_tag) const"},
{"lineNum":"  622","line":"        {"},
{"lineNum":"  623","line":"          if (!boost::detail::function::has_empty_target(boost::addressof(f))) {"},
{"lineNum":"  624","line":"            assign_functor_a(f, functor, a,"},
{"lineNum":"  625","line":"                           integral_constant<bool, (function_allows_small_object_optimization<FunctionObj>::value)>());"},
{"lineNum":"  626","line":"            return true;"},
{"lineNum":"  627","line":"          } else {"},
{"lineNum":"  628","line":"            return false;"},
{"lineNum":"  629","line":"          }"},
{"lineNum":"  630","line":"        }"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":"        // Reference to a function object"},
{"lineNum":"  633","line":"        template<typename FunctionObj>"},
{"lineNum":"  634","line":"        bool"},
{"lineNum":"  635","line":"        assign_to(const reference_wrapper<FunctionObj>& f,"},
{"lineNum":"  636","line":"                  function_buffer& functor, function_obj_ref_tag) const"},
{"lineNum":"  637","line":"        {"},
{"lineNum":"  638","line":"          functor.members.obj_ref.obj_ptr = (void *)(f.get_pointer());"},
{"lineNum":"  639","line":"          functor.members.obj_ref.is_const_qualified = is_const<FunctionObj>::value;"},
{"lineNum":"  640","line":"          functor.members.obj_ref.is_volatile_qualified = is_volatile<FunctionObj>::value;"},
{"lineNum":"  641","line":"          return true;"},
{"lineNum":"  642","line":"        }"},
{"lineNum":"  643","line":"        template<typename FunctionObj,typename Allocator>"},
{"lineNum":"  644","line":"        bool"},
{"lineNum":"  645","line":"        assign_to_a(const reference_wrapper<FunctionObj>& f,"},
{"lineNum":"  646","line":"                  function_buffer& functor, Allocator, function_obj_ref_tag) const"},
{"lineNum":"  647","line":"        {"},
{"lineNum":"  648","line":"          return assign_to(f,functor,function_obj_ref_tag());"},
{"lineNum":"  649","line":"        }"},
{"lineNum":"  650","line":""},
{"lineNum":"  651","line":"      public:"},
{"lineNum":"  652","line":"        vtable_base base;"},
{"lineNum":"  653","line":"        invoker_type invoker;"},
{"lineNum":"  654","line":"      };"},
{"lineNum":"  655","line":"    } // end namespace function"},
{"lineNum":"  656","line":"  } // end namespace detail"},
{"lineNum":"  657","line":""},
{"lineNum":"  658","line":"  template<"},
{"lineNum":"  659","line":"    typename R BOOST_FUNCTION_COMMA"},
{"lineNum":"  660","line":"    BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":"  661","line":"  >"},
{"lineNum":"  662","line":"  class BOOST_FUNCTION_FUNCTION : public function_base"},
{"lineNum":"  663","line":"  {"},
{"lineNum":"  664","line":"  public:"},
{"lineNum":"  665","line":"#ifndef BOOST_NO_VOID_RETURNS"},
{"lineNum":"  666","line":"    typedef R         result_type;"},
{"lineNum":"  667","line":"#else"},
{"lineNum":"  668","line":"    typedef  typename boost::detail::function::function_return_type<R>::type"},
{"lineNum":"  669","line":"      result_type;"},
{"lineNum":"  670","line":"#endif // BOOST_NO_VOID_RETURNS"},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":"  private:"},
{"lineNum":"  673","line":"    typedef boost::detail::function::BOOST_FUNCTION_VTABLE<"},
{"lineNum":"  674","line":"              R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_ARGS>"},
{"lineNum":"  675","line":"      vtable_type;"},
{"lineNum":"  676","line":""},
{"lineNum":"  677","line":"    vtable_type* get_vtable() const {"},
{"lineNum":"  678","line":"      return reinterpret_cast<vtable_type*>("},
{"lineNum":"  679","line":"               reinterpret_cast<std::size_t>(vtable) & ~static_cast<std::size_t>(0x01));","class":"lineNoCov","hits":"0","possible_hits":"243",},
{"lineNum":"  680","line":"    }"},
{"lineNum":"  681","line":""},
{"lineNum":"  682","line":"    struct clear_type {};"},
{"lineNum":"  683","line":""},
{"lineNum":"  684","line":"  public:"},
{"lineNum":"  685","line":"    BOOST_STATIC_CONSTANT(int, args = BOOST_FUNCTION_NUM_ARGS);"},
{"lineNum":"  686","line":""},
{"lineNum":"  687","line":"    // add signature for boost::lambda"},
{"lineNum":"  688","line":"    template<typename Args>"},
{"lineNum":"  689","line":"    struct sig"},
{"lineNum":"  690","line":"    {"},
{"lineNum":"  691","line":"      typedef result_type type;"},
{"lineNum":"  692","line":"    };"},
{"lineNum":"  693","line":""},
{"lineNum":"  694","line":"#if BOOST_FUNCTION_NUM_ARGS == 1"},
{"lineNum":"  695","line":"    typedef T0 argument_type;"},
{"lineNum":"  696","line":"#elif BOOST_FUNCTION_NUM_ARGS == 2"},
{"lineNum":"  697","line":"    typedef T0 first_argument_type;"},
{"lineNum":"  698","line":"    typedef T1 second_argument_type;"},
{"lineNum":"  699","line":"#endif"},
{"lineNum":"  700","line":""},
{"lineNum":"  701","line":"    BOOST_STATIC_CONSTANT(int, arity = BOOST_FUNCTION_NUM_ARGS);"},
{"lineNum":"  702","line":"    BOOST_FUNCTION_ARG_TYPES"},
{"lineNum":"  703","line":""},
{"lineNum":"  704","line":"    typedef BOOST_FUNCTION_FUNCTION self_type;"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":"    BOOST_DEFAULTED_FUNCTION(BOOST_FUNCTION_FUNCTION(), : function_base() {})"},
{"lineNum":"  707","line":""},
{"lineNum":"  708","line":"    // MSVC chokes if the following two constructors are collapsed into"},
{"lineNum":"  709","line":"    // one with a default parameter."},
{"lineNum":"  710","line":"    template<typename Functor>"},
{"lineNum":"  711","line":"    BOOST_FUNCTION_FUNCTION(Functor BOOST_FUNCTION_TARGET_FIX(const &) f","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  712","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":"  713","line":"                            ,typename boost::enable_if_<"},
{"lineNum":"  714","line":"                             !(is_integral<Functor>::value),"},
{"lineNum":"  715","line":"                                        int>::type = 0"},
{"lineNum":"  716","line":"#endif // BOOST_NO_SFINAE"},
{"lineNum":"  717","line":"                            ) :"},
{"lineNum":"  718","line":"      function_base()"},
{"lineNum":"  719","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  720","line":"      this->assign_to(f);","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  721","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  722","line":"    template<typename Functor,typename Allocator>"},
{"lineNum":"  723","line":"    BOOST_FUNCTION_FUNCTION(Functor BOOST_FUNCTION_TARGET_FIX(const &) f, Allocator a"},
{"lineNum":"  724","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":"  725","line":"                            ,typename boost::enable_if_<"},
{"lineNum":"  726","line":"                              !(is_integral<Functor>::value),"},
{"lineNum":"  727","line":"                                        int>::type = 0"},
{"lineNum":"  728","line":"#endif // BOOST_NO_SFINAE"},
{"lineNum":"  729","line":"                            ) :"},
{"lineNum":"  730","line":"      function_base()"},
{"lineNum":"  731","line":"    {"},
{"lineNum":"  732","line":"      this->assign_to_a(f,a);"},
{"lineNum":"  733","line":"    }"},
{"lineNum":"  734","line":""},
{"lineNum":"  735","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":"  736","line":"    BOOST_FUNCTION_FUNCTION(clear_type*) : function_base() { }"},
{"lineNum":"  737","line":"#else"},
{"lineNum":"  738","line":"    BOOST_FUNCTION_FUNCTION(int zero) : function_base()"},
{"lineNum":"  739","line":"    {"},
{"lineNum":"  740","line":"      BOOST_ASSERT(zero == 0);"},
{"lineNum":"  741","line":"    }"},
{"lineNum":"  742","line":"#endif"},
{"lineNum":"  743","line":""},
{"lineNum":"  744","line":"    BOOST_FUNCTION_FUNCTION(const BOOST_FUNCTION_FUNCTION& f) : function_base()"},
{"lineNum":"  745","line":"    {"},
{"lineNum":"  746","line":"      this->assign_to_own(f);"},
{"lineNum":"  747","line":"    }"},
{"lineNum":"  748","line":""},
{"lineNum":"  749","line":"#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES"},
{"lineNum":"  750","line":"    BOOST_FUNCTION_FUNCTION(BOOST_FUNCTION_FUNCTION&& f) : function_base()"},
{"lineNum":"  751","line":"    {"},
{"lineNum":"  752","line":"      this->move_assign(f);"},
{"lineNum":"  753","line":"    }"},
{"lineNum":"  754","line":"#endif"},
{"lineNum":"  755","line":""},
{"lineNum":"  756","line":"    ~BOOST_FUNCTION_FUNCTION() { clear(); }","class":"lineNoCov","hits":"0","possible_hits":"123",},
{"lineNum":"  757","line":""},
{"lineNum":"  758","line":"    result_type operator()(BOOST_FUNCTION_PARMS) const"},
{"lineNum":"  759","line":"    {"},
{"lineNum":"  760","line":"      if (this->empty())","class":"lineNoCov","hits":"0","possible_hits":"93",},
{"lineNum":"  761","line":"        boost::throw_exception(bad_function_call());","class":"lineNoCov","hits":"0","possible_hits":"104",},
{"lineNum":"  762","line":""},
{"lineNum":"  763","line":"      return get_vtable()->invoker","class":"lineNoCov","hits":"0","possible_hits":"93",},
{"lineNum":"  764","line":"               (this->functor BOOST_FUNCTION_COMMA BOOST_FUNCTION_ARGS);","class":"lineNoCov","hits":"0","possible_hits":"93",},
{"lineNum":"  765","line":"    }"},
{"lineNum":"  766","line":""},
{"lineNum":"  767","line":"    // The distinction between when to use BOOST_FUNCTION_FUNCTION and"},
{"lineNum":"  768","line":"    // when to use self_type is obnoxious. MSVC cannot handle self_type as"},
{"lineNum":"  769","line":"    // the return type of these assignment operators, but Borland C++ cannot"},
{"lineNum":"  770","line":"    // handle BOOST_FUNCTION_FUNCTION as the type of the temporary to"},
{"lineNum":"  771","line":"    // construct."},
{"lineNum":"  772","line":"    template<typename Functor>"},
{"lineNum":"  773","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":"  774","line":"    typename boost::enable_if_<"},
{"lineNum":"  775","line":"                  !(is_integral<Functor>::value),"},
{"lineNum":"  776","line":"               BOOST_FUNCTION_FUNCTION&>::type"},
{"lineNum":"  777","line":"#else"},
{"lineNum":"  778","line":"    BOOST_FUNCTION_FUNCTION&"},
{"lineNum":"  779","line":"#endif"},
{"lineNum":"  780","line":"    operator=(Functor BOOST_FUNCTION_TARGET_FIX(const &) f)"},
{"lineNum":"  781","line":"    {"},
{"lineNum":"  782","line":"      this->clear();"},
{"lineNum":"  783","line":"      BOOST_TRY  {"},
{"lineNum":"  784","line":"        this->assign_to(f);"},
{"lineNum":"  785","line":"      } BOOST_CATCH (...) {"},
{"lineNum":"  786","line":"        vtable = 0;"},
{"lineNum":"  787","line":"        BOOST_RETHROW;"},
{"lineNum":"  788","line":"      }"},
{"lineNum":"  789","line":"      BOOST_CATCH_END"},
{"lineNum":"  790","line":"      return *this;"},
{"lineNum":"  791","line":"    }"},
{"lineNum":"  792","line":"    template<typename Functor,typename Allocator>"},
{"lineNum":"  793","line":"    void assign(Functor BOOST_FUNCTION_TARGET_FIX(const &) f, Allocator a)"},
{"lineNum":"  794","line":"    {"},
{"lineNum":"  795","line":"      this->clear();"},
{"lineNum":"  796","line":"      BOOST_TRY{"},
{"lineNum":"  797","line":"        this->assign_to_a(f,a);"},
{"lineNum":"  798","line":"      } BOOST_CATCH (...) {"},
{"lineNum":"  799","line":"        vtable = 0;"},
{"lineNum":"  800","line":"        BOOST_RETHROW;"},
{"lineNum":"  801","line":"      }"},
{"lineNum":"  802","line":"      BOOST_CATCH_END"},
{"lineNum":"  803","line":"    }"},
{"lineNum":"  804","line":""},
{"lineNum":"  805","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":"  806","line":"    BOOST_FUNCTION_FUNCTION& operator=(clear_type*)"},
{"lineNum":"  807","line":"    {"},
{"lineNum":"  808","line":"      this->clear();"},
{"lineNum":"  809","line":"      return *this;"},
{"lineNum":"  810","line":"    }"},
{"lineNum":"  811","line":"#else"},
{"lineNum":"  812","line":"    BOOST_FUNCTION_FUNCTION& operator=(int zero)"},
{"lineNum":"  813","line":"    {"},
{"lineNum":"  814","line":"      BOOST_ASSERT(zero == 0);"},
{"lineNum":"  815","line":"      this->clear();"},
{"lineNum":"  816","line":"      return *this;"},
{"lineNum":"  817","line":"    }"},
{"lineNum":"  818","line":"#endif"},
{"lineNum":"  819","line":""},
{"lineNum":"  820","line":"    // Assignment from another BOOST_FUNCTION_FUNCTION"},
{"lineNum":"  821","line":"    BOOST_FUNCTION_FUNCTION& operator=(const BOOST_FUNCTION_FUNCTION& f)"},
{"lineNum":"  822","line":"    {"},
{"lineNum":"  823","line":"      if (&f == this)"},
{"lineNum":"  824","line":"        return *this;"},
{"lineNum":"  825","line":""},
{"lineNum":"  826","line":"      this->clear();"},
{"lineNum":"  827","line":"      BOOST_TRY {"},
{"lineNum":"  828","line":"        this->assign_to_own(f);"},
{"lineNum":"  829","line":"      } BOOST_CATCH (...) {"},
{"lineNum":"  830","line":"        vtable = 0;"},
{"lineNum":"  831","line":"        BOOST_RETHROW;"},
{"lineNum":"  832","line":"      }"},
{"lineNum":"  833","line":"      BOOST_CATCH_END"},
{"lineNum":"  834","line":"      return *this;"},
{"lineNum":"  835","line":"    }"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES"},
{"lineNum":"  838","line":"    // Move assignment from another BOOST_FUNCTION_FUNCTION"},
{"lineNum":"  839","line":"    BOOST_FUNCTION_FUNCTION& operator=(BOOST_FUNCTION_FUNCTION&& f)"},
{"lineNum":"  840","line":"    {"},
{"lineNum":"  841","line":"      if (&f == this)"},
{"lineNum":"  842","line":"        return *this;"},
{"lineNum":"  843","line":""},
{"lineNum":"  844","line":"      this->clear();"},
{"lineNum":"  845","line":"      BOOST_TRY {"},
{"lineNum":"  846","line":"        this->move_assign(f);"},
{"lineNum":"  847","line":"      } BOOST_CATCH (...) {"},
{"lineNum":"  848","line":"        vtable = 0;"},
{"lineNum":"  849","line":"        BOOST_RETHROW;"},
{"lineNum":"  850","line":"      }"},
{"lineNum":"  851","line":"      BOOST_CATCH_END"},
{"lineNum":"  852","line":"      return *this;"},
{"lineNum":"  853","line":"    }"},
{"lineNum":"  854","line":"#endif"},
{"lineNum":"  855","line":""},
{"lineNum":"  856","line":"    void swap(BOOST_FUNCTION_FUNCTION& other)"},
{"lineNum":"  857","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  858","line":"      if (&other == this)","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  859","line":"        return;"},
{"lineNum":"  860","line":""},
{"lineNum":"  861","line":"      BOOST_FUNCTION_FUNCTION tmp;"},
{"lineNum":"  862","line":"      tmp.move_assign(*this);","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  863","line":"      this->move_assign(other);","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  864","line":"      other.move_assign(tmp);","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  865","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"38",},
{"lineNum":"  866","line":""},
{"lineNum":"  867","line":"    // Clear out a target, if there is one"},
{"lineNum":"  868","line":"    void clear()"},
{"lineNum":"  869","line":"    {"},
{"lineNum":"  870","line":"      if (vtable) {","class":"lineNoCov","hits":"0","possible_hits":"131",},
{"lineNum":"  871","line":"        if (!this->has_trivial_copy_and_destroy())","class":"lineNoCov","hits":"0","possible_hits":"131",},
{"lineNum":"  872","line":"          get_vtable()->clear(this->functor);"},
{"lineNum":"  873","line":"        vtable = 0;","class":"lineNoCov","hits":"0","possible_hits":"62",},
{"lineNum":"  874","line":"      }"},
{"lineNum":"  875","line":"    }"},
{"lineNum":"  876","line":""},
{"lineNum":"  877","line":"#if (defined __SUNPRO_CC) && (__SUNPRO_CC <= 0x530) && !(defined BOOST_NO_COMPILER_CONFIG)"},
{"lineNum":"  878","line":"    // Sun C++ 5.3 can\'t handle the safe_bool idiom, so don\'t use it"},
{"lineNum":"  879","line":"    operator bool () const { return !this->empty(); }"},
{"lineNum":"  880","line":"#else"},
{"lineNum":"  881","line":"  private:"},
{"lineNum":"  882","line":"    struct dummy {"},
{"lineNum":"  883","line":"      void nonnull() {}","class":"lineNoCov","hits":"0","possible_hits":"38",},
{"lineNum":"  884","line":"    };"},
{"lineNum":"  885","line":""},
{"lineNum":"  886","line":"    typedef void (dummy::*safe_bool)();"},
{"lineNum":"  887","line":""},
{"lineNum":"  888","line":"  public:"},
{"lineNum":"  889","line":"    operator safe_bool () const"},
{"lineNum":"  890","line":"      { return (this->empty())? 0 : &dummy::nonnull; }","class":"lineNoCov","hits":"0","possible_hits":"93",},
{"lineNum":"  891","line":""},
{"lineNum":"  892","line":"    bool operator!() const"},
{"lineNum":"  893","line":"      { return this->empty(); }"},
{"lineNum":"  894","line":"#endif"},
{"lineNum":"  895","line":""},
{"lineNum":"  896","line":"  private:"},
{"lineNum":"  897","line":"    void assign_to_own(const BOOST_FUNCTION_FUNCTION& f)"},
{"lineNum":"  898","line":"    {"},
{"lineNum":"  899","line":"      if (!f.empty()) {"},
{"lineNum":"  900","line":"        this->vtable = f.vtable;"},
{"lineNum":"  901","line":"        if (this->has_trivial_copy_and_destroy())"},
{"lineNum":"  902","line":"          // Don\'t operate on storage directly since union type doesn\'t relax"},
{"lineNum":"  903","line":"          // strict aliasing rules, despite of having member char type."},
{"lineNum":"  904","line":"          std::memcpy(this->functor.data, f.functor.data, sizeof(boost::detail::function::function_buffer));"},
{"lineNum":"  905","line":"        else"},
{"lineNum":"  906","line":"          get_vtable()->base.manager(f.functor, this->functor,"},
{"lineNum":"  907","line":"                                     boost::detail::function::clone_functor_tag);"},
{"lineNum":"  908","line":"      }"},
{"lineNum":"  909","line":"    }"},
{"lineNum":"  910","line":""},
{"lineNum":"  911","line":"    template<typename Functor>"},
{"lineNum":"  912","line":"    void assign_to(Functor f)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  913","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  914","line":"      using boost::detail::function::vtable_base;"},
{"lineNum":"  915","line":""},
{"lineNum":"  916","line":"      typedef typename boost::detail::function::get_function_tag<Functor>::type tag;"},
{"lineNum":"  917","line":"      typedef boost::detail::function::BOOST_FUNCTION_GET_INVOKER<tag> get_invoker;"},
{"lineNum":"  918","line":"      typedef typename get_invoker::"},
{"lineNum":"  919","line":"                         template apply<Functor, R BOOST_FUNCTION_COMMA"},
{"lineNum":"  920","line":"                        BOOST_FUNCTION_TEMPLATE_ARGS>"},
{"lineNum":"  921","line":"        handler_type;"},
{"lineNum":"  922","line":""},
{"lineNum":"  923","line":"      typedef typename handler_type::invoker_type invoker_type;"},
{"lineNum":"  924","line":"      typedef typename handler_type::manager_type manager_type;"},
{"lineNum":"  925","line":""},
{"lineNum":"  926","line":"      // Note: it is extremely important that this initialization use"},
{"lineNum":"  927","line":"      // static initialization. Otherwise, we will have a race"},
{"lineNum":"  928","line":"      // condition here in multi-threaded code. See"},
{"lineNum":"  929","line":"      // http://thread.gmane.org/gmane.comp.lib.boost.devel/164902/."},
{"lineNum":"  930","line":"      static const vtable_type stored_vtable ="},
{"lineNum":"  931","line":"        { { &manager_type::manage }, &invoker_type::invoke };"},
{"lineNum":"  932","line":""},
{"lineNum":"  933","line":"      if (stored_vtable.assign_to(f, functor)) {","class":"lineNoCov","hits":"0","possible_hits":"30",},
{"lineNum":"  934","line":"        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);"},
{"lineNum":"  935","line":"        // coverity[pointless_expression]: suppress coverity warnings on apparant if(const)."},
{"lineNum":"  936","line":"        if (boost::has_trivial_copy_constructor<Functor>::value &&"},
{"lineNum":"  937","line":"            boost::has_trivial_destructor<Functor>::value &&"},
{"lineNum":"  938","line":"            boost::detail::function::function_allows_small_object_optimization<Functor>::value)"},
{"lineNum":"  939","line":"          value |= static_cast<std::size_t>(0x01);"},
{"lineNum":"  940","line":"        vtable = reinterpret_cast<boost::detail::function::vtable_base *>(value);","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  941","line":"      } else"},
{"lineNum":"  942","line":"        vtable = 0;"},
{"lineNum":"  943","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  944","line":""},
{"lineNum":"  945","line":"    template<typename Functor,typename Allocator>"},
{"lineNum":"  946","line":"    void assign_to_a(Functor f,Allocator a)"},
{"lineNum":"  947","line":"    {"},
{"lineNum":"  948","line":"      using boost::detail::function::vtable_base;"},
{"lineNum":"  949","line":""},
{"lineNum":"  950","line":"      typedef typename boost::detail::function::get_function_tag<Functor>::type tag;"},
{"lineNum":"  951","line":"      typedef boost::detail::function::BOOST_FUNCTION_GET_INVOKER<tag> get_invoker;"},
{"lineNum":"  952","line":"      typedef typename get_invoker::"},
{"lineNum":"  953","line":"                         template apply_a<Functor, Allocator, R BOOST_FUNCTION_COMMA"},
{"lineNum":"  954","line":"                         BOOST_FUNCTION_TEMPLATE_ARGS>"},
{"lineNum":"  955","line":"        handler_type;"},
{"lineNum":"  956","line":""},
{"lineNum":"  957","line":"      typedef typename handler_type::invoker_type invoker_type;"},
{"lineNum":"  958","line":"      typedef typename handler_type::manager_type manager_type;"},
{"lineNum":"  959","line":""},
{"lineNum":"  960","line":"      // Note: it is extremely important that this initialization use"},
{"lineNum":"  961","line":"      // static initialization. Otherwise, we will have a race"},
{"lineNum":"  962","line":"      // condition here in multi-threaded code. See"},
{"lineNum":"  963","line":"      // http://thread.gmane.org/gmane.comp.lib.boost.devel/164902/."},
{"lineNum":"  964","line":"      static const vtable_type stored_vtable ="},
{"lineNum":"  965","line":"        { { &manager_type::manage }, &invoker_type::invoke };"},
{"lineNum":"  966","line":""},
{"lineNum":"  967","line":"      if (stored_vtable.assign_to_a(f, functor, a)) {"},
{"lineNum":"  968","line":"        std::size_t value = reinterpret_cast<std::size_t>(&stored_vtable.base);"},
{"lineNum":"  969","line":"        // coverity[pointless_expression]: suppress coverity warnings on apparant if(const)."},
{"lineNum":"  970","line":"        if (boost::has_trivial_copy_constructor<Functor>::value &&"},
{"lineNum":"  971","line":"            boost::has_trivial_destructor<Functor>::value &&"},
{"lineNum":"  972","line":"            boost::detail::function::function_allows_small_object_optimization<Functor>::value)"},
{"lineNum":"  973","line":"          value |= static_cast<std::size_t>(0x01);"},
{"lineNum":"  974","line":"        vtable = reinterpret_cast<boost::detail::function::vtable_base *>(value);"},
{"lineNum":"  975","line":"      } else"},
{"lineNum":"  976","line":"        vtable = 0;"},
{"lineNum":"  977","line":"    }"},
{"lineNum":"  978","line":""},
{"lineNum":"  979","line":"    // Moves the value from the specified argument to *this. If the argument"},
{"lineNum":"  980","line":"    // has its function object allocated on the heap, move_assign will pass"},
{"lineNum":"  981","line":"    // its buffer to *this, and set the argument\'s buffer pointer to NULL."},
{"lineNum":"  982","line":"    void move_assign(BOOST_FUNCTION_FUNCTION& f)"},
{"lineNum":"  983","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  984","line":"      if (&f == this)","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  985","line":"        return;"},
{"lineNum":"  986","line":""},
{"lineNum":"  987","line":"      BOOST_TRY {"},
{"lineNum":"  988","line":"        if (!f.empty()) {","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  989","line":"          this->vtable = f.vtable;","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  990","line":"          if (this->has_trivial_copy_and_destroy())","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  991","line":"            // Don\'t operate on storage directly since union type doesn\'t relax"},
{"lineNum":"  992","line":"            // strict aliasing rules, despite of having member char type."},
{"lineNum":"  993","line":"            std::memcpy(this->functor.data, f.functor.data, sizeof(this->functor.data));","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  994","line":"          else"},
{"lineNum":"  995","line":"            get_vtable()->base.manager(f.functor, this->functor,","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  996","line":"                                     boost::detail::function::move_functor_tag);"},
{"lineNum":"  997","line":"          f.vtable = 0;"},
{"lineNum":"  998","line":"        } else {"},
{"lineNum":"  999","line":"          clear();"},
{"lineNum":" 1000","line":"        }"},
{"lineNum":" 1001","line":"      } BOOST_CATCH (...) {","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":" 1002","line":"        vtable = 0;","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":" 1003","line":"        BOOST_RETHROW;","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":" 1004","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":" 1005","line":"      BOOST_CATCH_END"},
{"lineNum":" 1006","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":" 1007","line":"  };"},
{"lineNum":" 1008","line":""},
{"lineNum":" 1009","line":"  template<typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":" 1010","line":"  inline void swap(BOOST_FUNCTION_FUNCTION<"},
{"lineNum":" 1011","line":"                     R BOOST_FUNCTION_COMMA"},
{"lineNum":" 1012","line":"                     BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":" 1013","line":"                   >& f1,"},
{"lineNum":" 1014","line":"                   BOOST_FUNCTION_FUNCTION<"},
{"lineNum":" 1015","line":"                     R BOOST_FUNCTION_COMMA"},
{"lineNum":" 1016","line":"                     BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":" 1017","line":"                   >& f2)"},
{"lineNum":" 1018","line":"  {"},
{"lineNum":" 1019","line":"    f1.swap(f2);"},
{"lineNum":" 1020","line":"  }"},
{"lineNum":" 1021","line":""},
{"lineNum":" 1022","line":"// Poison comparisons between boost::function objects of the same type."},
{"lineNum":" 1023","line":"template<typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":" 1024","line":"  void operator==(const BOOST_FUNCTION_FUNCTION<"},
{"lineNum":" 1025","line":"                          R BOOST_FUNCTION_COMMA"},
{"lineNum":" 1026","line":"                          BOOST_FUNCTION_TEMPLATE_ARGS>&,"},
{"lineNum":" 1027","line":"                  const BOOST_FUNCTION_FUNCTION<"},
{"lineNum":" 1028","line":"                          R BOOST_FUNCTION_COMMA"},
{"lineNum":" 1029","line":"                          BOOST_FUNCTION_TEMPLATE_ARGS>&);"},
{"lineNum":" 1030","line":"template<typename R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":" 1031","line":"  void operator!=(const BOOST_FUNCTION_FUNCTION<"},
{"lineNum":" 1032","line":"                          R BOOST_FUNCTION_COMMA"},
{"lineNum":" 1033","line":"                          BOOST_FUNCTION_TEMPLATE_ARGS>&,"},
{"lineNum":" 1034","line":"                  const BOOST_FUNCTION_FUNCTION<"},
{"lineNum":" 1035","line":"                          R BOOST_FUNCTION_COMMA"},
{"lineNum":" 1036","line":"                          BOOST_FUNCTION_TEMPLATE_ARGS>& );"},
{"lineNum":" 1037","line":""},
{"lineNum":" 1038","line":"#if !defined(BOOST_FUNCTION_NO_FUNCTION_TYPE_SYNTAX)"},
{"lineNum":" 1039","line":""},
{"lineNum":" 1040","line":"#if BOOST_FUNCTION_NUM_ARGS == 0"},
{"lineNum":" 1041","line":"#define BOOST_FUNCTION_PARTIAL_SPEC R (void)"},
{"lineNum":" 1042","line":"#else"},
{"lineNum":" 1043","line":"#define BOOST_FUNCTION_PARTIAL_SPEC R (BOOST_FUNCTION_TEMPLATE_ARGS)"},
{"lineNum":" 1044","line":"#endif"},
{"lineNum":" 1045","line":""},
{"lineNum":" 1046","line":"template<typename R BOOST_FUNCTION_COMMA"},
{"lineNum":" 1047","line":"         BOOST_FUNCTION_TEMPLATE_PARMS>"},
{"lineNum":" 1048","line":"class function<BOOST_FUNCTION_PARTIAL_SPEC>"},
{"lineNum":" 1049","line":"  : public BOOST_FUNCTION_FUNCTION<R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_ARGS>"},
{"lineNum":" 1050","line":"{"},
{"lineNum":" 1051","line":"  typedef BOOST_FUNCTION_FUNCTION<R BOOST_FUNCTION_COMMA BOOST_FUNCTION_TEMPLATE_ARGS> base_type;"},
{"lineNum":" 1052","line":"  typedef function self_type;"},
{"lineNum":" 1053","line":""},
{"lineNum":" 1054","line":"  struct clear_type {};"},
{"lineNum":" 1055","line":""},
{"lineNum":" 1056","line":"public:"},
{"lineNum":" 1057","line":""},
{"lineNum":" 1058","line":"  BOOST_DEFAULTED_FUNCTION(function(), : base_type() {})"},
{"lineNum":" 1059","line":""},
{"lineNum":" 1060","line":"  template<typename Functor>"},
{"lineNum":" 1061","line":"  function(Functor f"},
{"lineNum":" 1062","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":" 1063","line":"           ,typename boost::enable_if_<"},
{"lineNum":" 1064","line":"                          !(is_integral<Functor>::value),"},
{"lineNum":" 1065","line":"                       int>::type = 0"},
{"lineNum":" 1066","line":"#endif"},
{"lineNum":" 1067","line":"           ) :"},
{"lineNum":" 1068","line":"    base_type(f)","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":" 1069","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":" 1070","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":" 1071","line":"  template<typename Functor,typename Allocator>"},
{"lineNum":" 1072","line":"  function(Functor f, Allocator a"},
{"lineNum":" 1073","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":" 1074","line":"           ,typename boost::enable_if_<"},
{"lineNum":" 1075","line":"                           !(is_integral<Functor>::value),"},
{"lineNum":" 1076","line":"                       int>::type = 0"},
{"lineNum":" 1077","line":"#endif"},
{"lineNum":" 1078","line":"           ) :"},
{"lineNum":" 1079","line":"    base_type(f,a)"},
{"lineNum":" 1080","line":"  {"},
{"lineNum":" 1081","line":"  }"},
{"lineNum":" 1082","line":""},
{"lineNum":" 1083","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":" 1084","line":"  function(clear_type*) : base_type() {}"},
{"lineNum":" 1085","line":"#endif"},
{"lineNum":" 1086","line":""},
{"lineNum":" 1087","line":"  function(const self_type& f) : base_type(static_cast<const base_type&>(f)){}"},
{"lineNum":" 1088","line":""},
{"lineNum":" 1089","line":"  function(const base_type& f) : base_type(static_cast<const base_type&>(f)){}"},
{"lineNum":" 1090","line":""},
{"lineNum":" 1091","line":"#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES"},
{"lineNum":" 1092","line":"  // Move constructors"},
{"lineNum":" 1093","line":"  function(self_type&& f): base_type(static_cast<base_type&&>(f)){}"},
{"lineNum":" 1094","line":"  function(base_type&& f): base_type(static_cast<base_type&&>(f)){}"},
{"lineNum":" 1095","line":"#endif"},
{"lineNum":" 1096","line":""},
{"lineNum":" 1097","line":"  self_type& operator=(const self_type& f)"},
{"lineNum":" 1098","line":"  {"},
{"lineNum":" 1099","line":"    self_type(f).swap(*this);"},
{"lineNum":" 1100","line":"    return *this;"},
{"lineNum":" 1101","line":"  }"},
{"lineNum":" 1102","line":""},
{"lineNum":" 1103","line":"#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES"},
{"lineNum":" 1104","line":"  self_type& operator=(self_type&& f)"},
{"lineNum":" 1105","line":"  {"},
{"lineNum":" 1106","line":"    self_type(static_cast<self_type&&>(f)).swap(*this);"},
{"lineNum":" 1107","line":"    return *this;"},
{"lineNum":" 1108","line":"  }"},
{"lineNum":" 1109","line":"#endif"},
{"lineNum":" 1110","line":""},
{"lineNum":" 1111","line":"  template<typename Functor>"},
{"lineNum":" 1112","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":" 1113","line":"  typename boost::enable_if_<"},
{"lineNum":" 1114","line":"                         !(is_integral<Functor>::value),"},
{"lineNum":" 1115","line":"                      self_type&>::type"},
{"lineNum":" 1116","line":"#else"},
{"lineNum":" 1117","line":"  self_type&"},
{"lineNum":" 1118","line":"#endif"},
{"lineNum":" 1119","line":"  operator=(Functor f)"},
{"lineNum":" 1120","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":" 1121","line":"    self_type(f).swap(*this);","class":"lineNoCov","hits":"0","possible_hits":"42",},
{"lineNum":" 1122","line":"    return *this;","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":" 1123","line":"  }"},
{"lineNum":" 1124","line":""},
{"lineNum":" 1125","line":"#ifndef BOOST_NO_SFINAE"},
{"lineNum":" 1126","line":"  self_type& operator=(clear_type*)"},
{"lineNum":" 1127","line":"  {"},
{"lineNum":" 1128","line":"    this->clear();"},
{"lineNum":" 1129","line":"    return *this;"},
{"lineNum":" 1130","line":"  }"},
{"lineNum":" 1131","line":"#endif"},
{"lineNum":" 1132","line":""},
{"lineNum":" 1133","line":"  self_type& operator=(const base_type& f)"},
{"lineNum":" 1134","line":"  {"},
{"lineNum":" 1135","line":"    self_type(f).swap(*this);"},
{"lineNum":" 1136","line":"    return *this;"},
{"lineNum":" 1137","line":"  }"},
{"lineNum":" 1138","line":""},
{"lineNum":" 1139","line":"#ifndef BOOST_NO_CXX11_RVALUE_REFERENCES"},
{"lineNum":" 1140","line":"  self_type& operator=(base_type&& f)"},
{"lineNum":" 1141","line":"  {"},
{"lineNum":" 1142","line":"    self_type(static_cast<base_type&&>(f)).swap(*this);"},
{"lineNum":" 1143","line":"    return *this;"},
{"lineNum":" 1144","line":"  }"},
{"lineNum":" 1145","line":"#endif"},
{"lineNum":" 1146","line":"};"},
{"lineNum":" 1147","line":""},
{"lineNum":" 1148","line":"#undef BOOST_FUNCTION_PARTIAL_SPEC"},
{"lineNum":" 1149","line":"#endif // have partial specialization"},
{"lineNum":" 1150","line":""},
{"lineNum":" 1151","line":"} // end namespace boost"},
{"lineNum":" 1152","line":""},
{"lineNum":" 1153","line":"// Cleanup after ourselves..."},
{"lineNum":" 1154","line":"#undef BOOST_FUNCTION_VTABLE"},
{"lineNum":" 1155","line":"#undef BOOST_FUNCTION_COMMA"},
{"lineNum":" 1156","line":"#undef BOOST_FUNCTION_FUNCTION"},
{"lineNum":" 1157","line":"#undef BOOST_FUNCTION_FUNCTION_INVOKER"},
{"lineNum":" 1158","line":"#undef BOOST_FUNCTION_VOID_FUNCTION_INVOKER"},
{"lineNum":" 1159","line":"#undef BOOST_FUNCTION_FUNCTION_OBJ_INVOKER"},
{"lineNum":" 1160","line":"#undef BOOST_FUNCTION_VOID_FUNCTION_OBJ_INVOKER"},
{"lineNum":" 1161","line":"#undef BOOST_FUNCTION_FUNCTION_REF_INVOKER"},
{"lineNum":" 1162","line":"#undef BOOST_FUNCTION_VOID_FUNCTION_REF_INVOKER"},
{"lineNum":" 1163","line":"#undef BOOST_FUNCTION_MEMBER_INVOKER"},
{"lineNum":" 1164","line":"#undef BOOST_FUNCTION_VOID_MEMBER_INVOKER"},
{"lineNum":" 1165","line":"#undef BOOST_FUNCTION_GET_FUNCTION_INVOKER"},
{"lineNum":" 1166","line":"#undef BOOST_FUNCTION_GET_FUNCTION_OBJ_INVOKER"},
{"lineNum":" 1167","line":"#undef BOOST_FUNCTION_GET_FUNCTION_REF_INVOKER"},
{"lineNum":" 1168","line":"#undef BOOST_FUNCTION_GET_MEM_FUNCTION_INVOKER"},
{"lineNum":" 1169","line":"#undef BOOST_FUNCTION_GET_INVOKER"},
{"lineNum":" 1170","line":"#undef BOOST_FUNCTION_TEMPLATE_PARMS"},
{"lineNum":" 1171","line":"#undef BOOST_FUNCTION_TEMPLATE_ARGS"},
{"lineNum":" 1172","line":"#undef BOOST_FUNCTION_PARMS"},
{"lineNum":" 1173","line":"#undef BOOST_FUNCTION_PARM"},
{"lineNum":" 1174","line":"#ifdef BOOST_FUNCTION_ARG"},
{"lineNum":" 1175","line":"#   undef BOOST_FUNCTION_ARG"},
{"lineNum":" 1176","line":"#endif"},
{"lineNum":" 1177","line":"#undef BOOST_FUNCTION_ARGS"},
{"lineNum":" 1178","line":"#undef BOOST_FUNCTION_ARG_TYPE"},
{"lineNum":" 1179","line":"#undef BOOST_FUNCTION_ARG_TYPES"},
{"lineNum":" 1180","line":"#undef BOOST_FUNCTION_VOID_RETURN_TYPE"},
{"lineNum":" 1181","line":"#undef BOOST_FUNCTION_RETURN"},
{"lineNum":" 1182","line":""},
{"lineNum":" 1183","line":"#if defined(BOOST_MSVC)"},
{"lineNum":" 1184","line":"#   pragma warning( pop )"},
{"lineNum":" 1185","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 58, "covered" : 0,};
var merged_data = [];
