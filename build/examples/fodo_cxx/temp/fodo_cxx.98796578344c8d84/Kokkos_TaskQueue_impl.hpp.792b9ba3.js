var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_IMPL_TASKQUEUE_IMPL_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_IMPL_TASKQUEUE_IMPL_HPP"},
{"lineNum":"   47","line":"#include <Kokkos_Macros.hpp>"},
{"lineNum":"   48","line":"#if defined(KOKKOS_ENABLE_TASKDAG)"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"#define KOKKOS_IMPL_DEBUG_TASKDAG_SCHEDULING 0"},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"namespace Kokkos {"},
{"lineNum":"   53","line":"namespace Impl {"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"   58","line":"void TaskQueue<ExecSpace, MemorySpace>::Destroy::destroy_shared_allocation() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   59","line":"  m_queue->~TaskQueue();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   60","line":"}"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"   65","line":"TaskQueue<ExecSpace, MemorySpace>::TaskQueue("},
{"lineNum":"   66","line":"    typename TaskQueue<ExecSpace, MemorySpace>::memory_pool const"},
{"lineNum":"   67","line":"        &arg_memory_pool)"},
{"lineNum":"   68","line":"    : m_memory(arg_memory_pool),"},
{"lineNum":"   69","line":"      m_ready()"},
{"lineNum":"   70","line":"      //, m_accum_alloc(0)"},
{"lineNum":"   71","line":"      //, m_count_alloc(0)"},
{"lineNum":"   72","line":"      //, m_max_alloc(0)"},
{"lineNum":"   73","line":"      ,"},
{"lineNum":"   74","line":"      m_ready_count(0) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   75","line":"  for (int i = 0; i < NumQueue; ++i) {"},
{"lineNum":"   76","line":"    m_ready[i][0] = (task_root_type *)task_root_type::EndTag;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   77","line":"    m_ready[i][1] = (task_root_type *)task_root_type::EndTag;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   78","line":"  }"},
{"lineNum":"   79","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"//----------------------------------------------------------------------------"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"   84","line":"TaskQueue<ExecSpace, MemorySpace>::~TaskQueue() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   85","line":"  // Verify that queues are empty and ready count is zero"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"  for (int i = 0; i < NumQueue; ++i) {"},
{"lineNum":"   88","line":"    for (int j = 0; j < 2; ++j) {"},
{"lineNum":"   89","line":"      if (m_ready[i][j] != (task_root_type *)task_root_type::EndTag) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   90","line":"        Kokkos::abort(\"TaskQueue::~TaskQueue ERROR: has ready tasks\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   91","line":"      }"},
{"lineNum":"   92","line":"    }"},
{"lineNum":"   93","line":"  }"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"  if (0 != m_ready_count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   96","line":"    Kokkos::abort(\"TaskQueue::~TaskQueue ERROR: has ready or executing tasks\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   97","line":"  }"},
{"lineNum":"   98","line":"}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  103","line":"KOKKOS_FUNCTION void TaskQueue<ExecSpace, MemorySpace>::decrement("},
{"lineNum":"  104","line":"    TaskQueue<ExecSpace, MemorySpace>::task_root_type *task) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  105","line":"  task_root_type volatile &t = *task;"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"  const int count = Kokkos::atomic_fetch_add(&(t.m_ref_count), -1);"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"#if KOKKOS_IMPL_DEBUG_TASKDAG_SCHEDULING"},
{"lineNum":"  110","line":"  if (1 == count) {"},
{"lineNum":"  111","line":"    printf(\"decrement-destroy( 0x%lx { 0x%lx %d %d } )\\n\", uintptr_t(task),"},
{"lineNum":"  112","line":"           uintptr_t(task->m_next), int(task->m_task_type),"},
{"lineNum":"  113","line":"           int(task->m_ref_count));"},
{"lineNum":"  114","line":"  }"},
{"lineNum":"  115","line":"#endif"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"  if ((1 == count) && (t.m_next == (task_root_type *)task_root_type::LockTag)) {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  118","line":"    // Reference count is zero and task is complete, deallocate."},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"    // TaskQueue< ExecSpace, MemorySpace> * const queue ="},
{"lineNum":"  121","line":"    //  static_cast<scheduler_type const *>( t.m_scheduler )->m_queue;"},
{"lineNum":"  122","line":"    auto *const volatile queue = static_cast<TaskQueue *>(t.m_queue);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"    // TODO @tasking @minor DSH this should call the destructor for a"},
{"lineNum":"  125","line":"    // non-trivially destructible type (possibly just ignore this in the old"},
{"lineNum":"  126","line":"    // version, though?) (Can\'t just do this; it needs to be queued since it\'s"},
{"lineNum":"  127","line":"    // device code if(task->m_destroy) task->m_destroy(task);"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    queue->deallocate(task, t.m_alloc_size);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  130","line":"  } else if (count <= 1) {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  131","line":"    Kokkos::abort(","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  132","line":"        \"TaskScheduler task has negative reference count or is incomplete\");"},
{"lineNum":"  133","line":"  }"},
{"lineNum":"  134","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  139","line":"KOKKOS_FUNCTION size_t"},
{"lineNum":"  140","line":"TaskQueue<ExecSpace, MemorySpace>::allocate_block_size(size_t n) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  141","line":"  return m_memory.allocate_block_size(n);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  142","line":"}"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  145","line":"KOKKOS_FUNCTION void *TaskQueue<ExecSpace, MemorySpace>::allocate(size_t n) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  146","line":"  void *const p = m_memory.allocate(n);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"  if (p) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  149","line":"    // Kokkos::atomic_increment( & m_accum_alloc );"},
{"lineNum":"  150","line":"    Kokkos::atomic_increment(&m_count_alloc);"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"    // if ( m_max_alloc < m_count_alloc ) m_max_alloc = m_count_alloc ;"},
{"lineNum":"  153","line":"  }"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"  return p;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  156","line":"}"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  159","line":"KOKKOS_FUNCTION void TaskQueue<ExecSpace, MemorySpace>::deallocate(void *p,"},
{"lineNum":"  160","line":"                                                                   size_t n) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  161","line":"  m_memory.deallocate(p, n);"},
{"lineNum":"  162","line":"  Kokkos::atomic_decrement(&m_count_alloc);"},
{"lineNum":"  163","line":"}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  168","line":"KOKKOS_FUNCTION bool TaskQueue<ExecSpace, MemorySpace>::push_task("},
{"lineNum":"  169","line":"    TaskQueue<ExecSpace, MemorySpace>::task_root_type *volatile *const queue,"},
{"lineNum":"  170","line":"    TaskQueue<ExecSpace, MemorySpace>::task_root_type *const task) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  171","line":"  // Push task into a concurrently pushed and popped queue."},
{"lineNum":"  172","line":"  // The queue can be either a ready task queue or a waiting task queue."},
{"lineNum":"  173","line":"  // The queue is a linked list where \'task->m_next\' form the links."},
{"lineNum":"  174","line":"  // Fail the push attempt if the queue is locked;"},
{"lineNum":"  175","line":"  // otherwise retry until the push succeeds."},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"#if KOKKOS_IMPL_DEBUG_TASKDAG_SCHEDULING"},
{"lineNum":"  178","line":"  printf(\"push_task( 0x%lx { 0x%lx } 0x%lx { 0x%lx 0x%lx %d %d %d } )\\n\","},
{"lineNum":"  179","line":"         uintptr_t(queue), uintptr_t(*queue), uintptr_t(task),"},
{"lineNum":"  180","line":"         uintptr_t(task->m_wait), uintptr_t(task->m_next), task->m_task_type,"},
{"lineNum":"  181","line":"         task->m_priority, task->m_ref_count);"},
{"lineNum":"  182","line":"#endif"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"  task_root_type *const zero = nullptr;"},
{"lineNum":"  185","line":"  task_root_type *const lock = (task_root_type *)task_root_type::LockTag;"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"  task_root_type *volatile &next = task->m_next;"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"  if (zero != next) {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  190","line":"    Kokkos::abort(","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  191","line":"        \"TaskQueue::push_task ERROR: already a member of another queue\");"},
{"lineNum":"  192","line":"  }"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"  // store the head of the queue"},
{"lineNum":"  195","line":"  task_root_type *old_head = *queue;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"  while (old_head != lock) {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  198","line":"    // set task->next to the head of the queue"},
{"lineNum":"  199","line":"    next = old_head;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"    // Do not proceed until \'next\' has been stored."},
{"lineNum":"  202","line":"    Kokkos::memory_fence();"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    // store the old head"},
{"lineNum":"  205","line":"    task_root_type *const old_head_tmp = old_head;"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"    // attempt to swap task with the old head of the queue"},
{"lineNum":"  208","line":"    // as if this were done atomically:"},
{"lineNum":"  209","line":"    //   if(*queue == old_head) {"},
{"lineNum":"  210","line":"    //     *queue = task;"},
{"lineNum":"  211","line":"    //   }"},
{"lineNum":"  212","line":"    //   old_head = *queue;"},
{"lineNum":"  213","line":"    old_head = Kokkos::atomic_compare_exchange(queue, old_head, task);"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"    if (old_head_tmp == old_head) return true;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  216","line":"  }"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"  // Failed, replace \'task->m_next\' value since \'task\' remains"},
{"lineNum":"  219","line":"  // not a member of a queue."},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"  next = zero;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"  // Do not proceed until \'next\' has been stored."},
{"lineNum":"  224","line":"  Kokkos::memory_fence();"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"  return false;"},
{"lineNum":"  227","line":"}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  232","line":"KOKKOS_FUNCTION typename TaskQueue<ExecSpace, MemorySpace>::task_root_type *"},
{"lineNum":"  233","line":"TaskQueue<ExecSpace, MemorySpace>::pop_ready_task("},
{"lineNum":"  234","line":"    TaskQueue<ExecSpace, MemorySpace>::task_root_type *volatile *const queue) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  235","line":"  // Pop task from a concurrently pushed and popped ready task queue."},
{"lineNum":"  236","line":"  // The queue is a linked list where \'task->m_next\' form the links."},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"  task_root_type *const lock = (task_root_type *)task_root_type::LockTag;"},
{"lineNum":"  239","line":"  task_root_type *const end  = (task_root_type *)task_root_type::EndTag;"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"  // *queue is"},
{"lineNum":"  242","line":"  //   end   => an empty queue"},
{"lineNum":"  243","line":"  //   lock  => a locked queue"},
{"lineNum":"  244","line":"  //   valid"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"  // Retry until the lock is acquired or the queue is empty."},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"  task_root_type *task = *queue;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"  while (end != task) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  251","line":"    // The only possible values for the queue are"},
{"lineNum":"  252","line":"    // (1) lock, (2) end, or (3) a valid task."},
{"lineNum":"  253","line":"    // Thus zero will never appear in the queue."},
{"lineNum":"  254","line":"    //"},
{"lineNum":"  255","line":"    // If queue is locked then just read by guaranteeing the CAS will fail."},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"    if (lock == task) task = nullptr;"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"    task_root_type *const x = task;"},
{"lineNum":"  260","line":""},
{"lineNum":"  261","line":"    task = Kokkos::atomic_compare_exchange(queue, x, lock);"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"    if (x == task) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  264","line":"      // CAS succeeded and queue is locked"},
{"lineNum":"  265","line":"      //"},
{"lineNum":"  266","line":"      // This thread has locked the queue and removed \'task\' from the queue."},
{"lineNum":"  267","line":"      // Extract the next entry of the queue from \'task->m_next\'"},
{"lineNum":"  268","line":"      // and mark \'task\' as popped from a queue by setting"},
{"lineNum":"  269","line":"      // \'task->m_next = lock\'."},
{"lineNum":"  270","line":"      //"},
{"lineNum":"  271","line":"      // Place the next entry in the head of the queue,"},
{"lineNum":"  272","line":"      // which also unlocks the queue."},
{"lineNum":"  273","line":"      //"},
{"lineNum":"  274","line":"      // This thread has exclusive access to"},
{"lineNum":"  275","line":"      // the queue and the popped task\'s m_next."},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"      task_root_type *volatile &next = task->m_next;"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"      // This algorithm is not lockfree because a adversarial scheduler could"},
{"lineNum":"  280","line":"      // context switch this thread at this point and the rest of the threads"},
{"lineNum":"  281","line":"      // calling this method would never make forward progress"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"      *queue = next;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  284","line":"      next   = lock;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"      Kokkos::memory_fence();"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"#if KOKKOS_IMPL_DEBUG_TASKDAG_SCHEDULING"},
{"lineNum":"  289","line":"      printf(\"pop_ready_task( 0x%lx 0x%lx { 0x%lx 0x%lx %d %d %d } )\\n\","},
{"lineNum":"  290","line":"             uintptr_t(queue), uintptr_t(task), uintptr_t(task->m_wait),"},
{"lineNum":"  291","line":"             uintptr_t(task->m_next), int(task->m_task_type),"},
{"lineNum":"  292","line":"             int(task->m_priority), int(task->m_ref_count));"},
{"lineNum":"  293","line":"#endif"},
{"lineNum":"  294","line":""},
{"lineNum":"  295","line":"      return task;"},
{"lineNum":"  296","line":"    }"},
{"lineNum":"  297","line":"  }"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"  return end;"},
{"lineNum":"  300","line":"}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  305","line":"KOKKOS_FUNCTION void TaskQueue<ExecSpace, MemorySpace>::schedule_runnable("},
{"lineNum":"  306","line":"    TaskQueue<ExecSpace, MemorySpace>::task_root_type *const task) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  307","line":"  // Schedule a runnable task upon construction / spawn"},
{"lineNum":"  308","line":"  // and upon completion of other tasks that \'task\' is waiting on."},
{"lineNum":"  309","line":"  //"},
{"lineNum":"  310","line":"  // Precondition:"},
{"lineNum":"  311","line":"  // - called by a single thread for the input task"},
{"lineNum":"  312","line":"  // - calling thread has exclusive access to the task"},
{"lineNum":"  313","line":"  // - task is not a member of a queue"},
{"lineNum":"  314","line":"  // - if runnable then task is either constructing or respawning"},
{"lineNum":"  315","line":"  //"},
{"lineNum":"  316","line":"  //   Constructing state:"},
{"lineNum":"  317","line":"  //     task->m_wait == 0"},
{"lineNum":"  318","line":"  //     task->m_next == dependence or 0"},
{"lineNum":"  319","line":"  //   Respawn state:"},
{"lineNum":"  320","line":"  //     task->m_wait == head of linked list: \'end\' or valid task"},
{"lineNum":"  321","line":"  //     task->m_next == dependence or 0"},
{"lineNum":"  322","line":"  //"},
{"lineNum":"  323","line":"  //  Task state transition:"},
{"lineNum":"  324","line":"  //     Constructing ->  Waiting"},
{"lineNum":"  325","line":"  //     Respawn      ->  Waiting"},
{"lineNum":"  326","line":"  //"},
{"lineNum":"  327","line":"  //  Postcondition on task state:"},
{"lineNum":"  328","line":"  //     task->m_wait == head of linked list (queue)"},
{"lineNum":"  329","line":"  //     task->m_next == member of linked list (queue)"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"#if KOKKOS_IMPL_DEBUG_TASKDAG_SCHEDULING"},
{"lineNum":"  332","line":"  printf(\"schedule_runnable( 0x%lx { 0x%lx 0x%lx %d %d %d }\\n\", uintptr_t(task),"},
{"lineNum":"  333","line":"         uintptr_t(task->m_wait), uintptr_t(task->m_next), task->m_task_type,"},
{"lineNum":"  334","line":"         task->m_priority, task->m_ref_count);"},
{"lineNum":"  335","line":"#endif"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"  task_root_type *const zero = nullptr;"},
{"lineNum":"  338","line":"  task_root_type *const lock = (task_root_type *)task_root_type::LockTag;"},
{"lineNum":"  339","line":"  task_root_type *const end  = (task_root_type *)task_root_type::EndTag;"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"  task_root_type volatile &t = *task;"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"  bool respawn = false;"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"  //----------------------------------------"},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"  if (zero == t.m_wait) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  348","line":"    // Task in Constructing state"},
{"lineNum":"  349","line":"    // - Transition to Waiting state"},
{"lineNum":"  350","line":"    // Preconditions:"},
{"lineNum":"  351","line":"    // - call occurs exclusively within a single thread"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"    t.m_wait = end;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  354","line":"    // Task in Waiting state"},
{"lineNum":"  355","line":"  } else if (lock != t.m_wait) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  356","line":"    // Task in Executing state with Respawn request"},
{"lineNum":"  357","line":"    // - Update dependence"},
{"lineNum":"  358","line":"    // - Transition to Waiting state"},
{"lineNum":"  359","line":"    respawn = true;"},
{"lineNum":"  360","line":"  } else {"},
{"lineNum":"  361","line":"    // Task in Complete state"},
{"lineNum":"  362","line":"    Kokkos::abort(\"TaskQueue::schedule_runnable ERROR: task is complete\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  363","line":"  }"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"  //----------------------------------------"},
{"lineNum":"  366","line":"  // Scheduling a runnable task which may have a depencency \'dep\'."},
{"lineNum":"  367","line":"  // Extract dependence, if any, from task->m_next."},
{"lineNum":"  368","line":"  // If \'dep\' is not null then attempt to push \'task\'"},
{"lineNum":"  369","line":"  // into the wait queue of \'dep\'."},
{"lineNum":"  370","line":"  // If the push succeeds then \'task\' may be"},
{"lineNum":"  371","line":"  // processed or executed by another thread at any time."},
{"lineNum":"  372","line":"  // If the push fails then \'dep\' is complete and \'task\'"},
{"lineNum":"  373","line":"  // is ready to execute."},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"  // Exclusive access so don\'t need an atomic exchange"},
{"lineNum":"  376","line":"  // task_root_type * dep = Kokkos::atomic_exchange( & task->m_next , zero );"},
{"lineNum":"  377","line":"  task_root_type *dep = t.m_next;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  378","line":"  t.m_next            = zero;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":"  Kokkos::memory_fence();"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"  // If we don\'t have a dependency, or if pushing onto the wait queue of that"},
{"lineNum":"  383","line":"  // dependency failed (since the only time that queue should be locked is when"},
{"lineNum":"  384","line":"  // the task is transitioning to complete?)"},
{"lineNum":"  385","line":"  const bool is_ready = (nullptr == dep) || (!push_task(&dep->m_wait, task));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  386","line":""},
{"lineNum":"  387","line":"  if ((nullptr != dep) && respawn) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  388","line":"    // Reference count for dep was incremented when"},
{"lineNum":"  389","line":"    // respawn assigned dependency to task->m_next"},
{"lineNum":"  390","line":"    // so that if dep completed prior to the"},
{"lineNum":"  391","line":"    // above push_task dep would not be destroyed."},
{"lineNum":"  392","line":"    // dep reference count can now be decremented,"},
{"lineNum":"  393","line":"    // which may deallocate the task."},
{"lineNum":"  394","line":"    TaskQueue::assign(&dep, nullptr);"},
{"lineNum":"  395","line":"  }"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"  if (is_ready) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  398","line":"    // No dependence or \'dep\' is complete so push task into ready queue."},
{"lineNum":"  399","line":"    // Increment the ready count before pushing into ready queue"},
{"lineNum":"  400","line":"    // to track number of ready + executing tasks."},
{"lineNum":"  401","line":"    // The ready count will be decremented when the task is complete."},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"    Kokkos::atomic_increment(&m_ready_count);"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"    task_root_type *volatile *const ready_queue ="},
{"lineNum":"  406","line":"        &m_ready[t.m_priority][t.m_task_type];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"    // A push_task fails if the ready queue is locked."},
{"lineNum":"  409","line":"    // A ready queue is only locked during a push or pop;"},
{"lineNum":"  410","line":"    // i.e., it is never permanently locked."},
{"lineNum":"  411","line":"    // Retry push to ready queue until it succeeds."},
{"lineNum":"  412","line":"    // When the push succeeds then \'task\' may be"},
{"lineNum":"  413","line":"    // processed or executed by another thread at any time."},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"    while (!push_task(ready_queue, task))"},
{"lineNum":"  416","line":"      ;"},
{"lineNum":"  417","line":"  }"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"  //----------------------------------------"},
{"lineNum":"  420","line":"  // Postcondition:"},
{"lineNum":"  421","line":"  // - A runnable \'task\' was pushed into a wait or ready queue."},
{"lineNum":"  422","line":"  // - Concurrent execution may have already popped \'task\'"},
{"lineNum":"  423","line":"  //   from a queue and processed it as appropriate."},
{"lineNum":"  424","line":"}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  427","line":"KOKKOS_FUNCTION void TaskQueue<ExecSpace, MemorySpace>::schedule_aggregate("},
{"lineNum":"  428","line":"    TaskQueue<ExecSpace, MemorySpace>::task_root_type *const task) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  429","line":"  // Schedule an aggregate task upon construction"},
{"lineNum":"  430","line":"  // and upon completion of other tasks that \'task\' is waiting on."},
{"lineNum":"  431","line":"  //"},
{"lineNum":"  432","line":"  // Precondition:"},
{"lineNum":"  433","line":"  // - called by a single thread for the input task"},
{"lineNum":"  434","line":"  // - calling thread has exclusive access to the task"},
{"lineNum":"  435","line":"  // - task is not a member of a queue"},
{"lineNum":"  436","line":"  //"},
{"lineNum":"  437","line":"  //   Constructing state:"},
{"lineNum":"  438","line":"  //     task->m_wait == 0"},
{"lineNum":"  439","line":"  //     task->m_next == dependence or 0"},
{"lineNum":"  440","line":"  //"},
{"lineNum":"  441","line":"  //  Task state transition:"},
{"lineNum":"  442","line":"  //     Constructing ->  Waiting"},
{"lineNum":"  443","line":"  //"},
{"lineNum":"  444","line":"  //  Postcondition on task state:"},
{"lineNum":"  445","line":"  //     task->m_wait == head of linked list (queue)"},
{"lineNum":"  446","line":"  //     task->m_next == member of linked list (queue)"},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"#if KOKKOS_IMPL_DEBUG_TASKDAG_SCHEDULING"},
{"lineNum":"  449","line":"  printf(\"schedule_aggregate( 0x%lx { 0x%lx 0x%lx %d %d %d %d }\\n\","},
{"lineNum":"  450","line":"         uintptr_t(task), uintptr_t(task->m_wait), uintptr_t(task->m_next),"},
{"lineNum":"  451","line":"         task->m_dep_count, task->m_task_type, task->m_priority,"},
{"lineNum":"  452","line":"         task->m_ref_count);"},
{"lineNum":"  453","line":"#endif"},
{"lineNum":"  454","line":""},
{"lineNum":"  455","line":"  task_root_type *const zero = nullptr;"},
{"lineNum":"  456","line":"  task_root_type *const lock = (task_root_type *)task_root_type::LockTag;"},
{"lineNum":"  457","line":"  task_root_type *const end  = (task_root_type *)task_root_type::EndTag;"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"  task_root_type volatile &t = *task;"},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":"  //----------------------------------------"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"  if (zero == t.m_wait) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  464","line":"    // Task in Constructing state"},
{"lineNum":"  465","line":"    // - Transition to Waiting state"},
{"lineNum":"  466","line":"    // Preconditions:"},
{"lineNum":"  467","line":"    // - call occurs exclusively within a single thread"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"    t.m_wait = end;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  470","line":"    // Task in Waiting state"},
{"lineNum":"  471","line":"  } else if (lock == t.m_wait) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  472","line":"    // Task in Complete state"},
{"lineNum":"  473","line":"    Kokkos::abort(\"TaskQueue::schedule_aggregate ERROR: task is complete\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  474","line":"  }"},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"  //----------------------------------------"},
{"lineNum":"  477","line":"  // Scheduling a \'when_all\' task with multiple dependences."},
{"lineNum":"  478","line":"  // This scheduling may be called when the \'when_all\' is"},
{"lineNum":"  479","line":"  // (1) created or"},
{"lineNum":"  480","line":"  // (2) being removed from a completed task\'s wait list."},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"  task_root_type *volatile *const aggr = t.aggregate_dependences();"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"  // Assume the \'when_all\' is complete until a dependence is"},
{"lineNum":"  485","line":"  // found that is not complete."},
{"lineNum":"  486","line":""},
{"lineNum":"  487","line":"  bool is_complete = true;"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"  for (int i = t.m_dep_count; 0 < i && is_complete;) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  490","line":"    --i;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"    // Loop dependences looking for an incomplete task."},
{"lineNum":"  493","line":"    // Add this task to the incomplete task\'s wait queue."},
{"lineNum":"  494","line":""},
{"lineNum":"  495","line":"    // Remove a task \'x\' from the dependence list."},
{"lineNum":"  496","line":"    // The reference count of \'x\' was incremented when"},
{"lineNum":"  497","line":"    // it was assigned into the dependence list."},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"    // Exclusive access so don\'t need an atomic exchange"},
{"lineNum":"  500","line":"    // task_root_type * x = Kokkos::atomic_exchange( aggr + i , zero );"},
{"lineNum":"  501","line":"    task_root_type *x = aggr[i];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  502","line":"    aggr[i]           = zero;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"    if (x) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  505","line":"      // If x->m_wait is not locked then push succeeds"},
{"lineNum":"  506","line":"      // and the aggregate is not complete."},
{"lineNum":"  507","line":"      // If the push succeeds then this when_all \'task\' may be"},
{"lineNum":"  508","line":"      // processed by another thread at any time."},
{"lineNum":"  509","line":"      // For example, \'x\' may be completeed by another"},
{"lineNum":"  510","line":"      // thread and then re-schedule this when_all \'task\'."},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"      is_complete = !push_task(&x->m_wait, task);"},
{"lineNum":"  513","line":""},
{"lineNum":"  514","line":"      // Decrement reference count which had been incremented"},
{"lineNum":"  515","line":"      // when \'x\' was added to the dependence list."},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"      TaskQueue::assign(&x, zero);"},
{"lineNum":"  518","line":"    }"},
{"lineNum":"  519","line":"  }"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"  if (is_complete) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  522","line":"    // The when_all \'task\' was not added to a wait queue because"},
{"lineNum":"  523","line":"    // all dependences were complete so this aggregate is complete."},
{"lineNum":"  524","line":"    // Complete the when_all \'task\' to schedule other tasks"},
{"lineNum":"  525","line":"    // that are waiting for the when_all \'task\' to complete."},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"    t.m_next = lock;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"    complete(task);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  530","line":""},
{"lineNum":"  531","line":"    // \'*task\' may have been deleted upon completion"},
{"lineNum":"  532","line":"  }"},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":"  //----------------------------------------"},
{"lineNum":"  535","line":"  // Postcondition:"},
{"lineNum":"  536","line":"  // - An aggregate \'task\' was either pushed to a wait queue or completed."},
{"lineNum":"  537","line":"  // - Concurrent execution may have already popped \'task\'"},
{"lineNum":"  538","line":"  //   from a queue and processed it as appropriate."},
{"lineNum":"  539","line":"}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  540","line":""},
{"lineNum":"  541","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  544","line":"KOKKOS_FUNCTION void TaskQueue<ExecSpace, MemorySpace>::reschedule("},
{"lineNum":"  545","line":"    task_root_type *task) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  546","line":"  // Precondition:"},
{"lineNum":"  547","line":"  //   task is in Executing state"},
{"lineNum":"  548","line":"  //   task->m_next == LockTag"},
{"lineNum":"  549","line":"  //"},
{"lineNum":"  550","line":"  // Postcondition:"},
{"lineNum":"  551","line":"  //   task is in Executing-Respawn state"},
{"lineNum":"  552","line":"  //   task->m_next == 0 (no dependence)"},
{"lineNum":"  553","line":""},
{"lineNum":"  554","line":"  task_root_type *const zero = nullptr;"},
{"lineNum":"  555","line":"  task_root_type *const lock = (task_root_type *)task_root_type::LockTag;"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"  if (lock != Kokkos::atomic_exchange(&task->m_next, zero)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  558","line":"    Kokkos::abort(\"TaskScheduler::respawn ERROR: already respawned\");","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  559","line":"  }"},
{"lineNum":"  560","line":"}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"template <typename ExecSpace, typename MemorySpace>"},
{"lineNum":"  565","line":"KOKKOS_FUNCTION void TaskQueue<ExecSpace, MemorySpace>::complete("},
{"lineNum":"  566","line":"    TaskQueue<ExecSpace, MemorySpace>::task_root_type *task) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  567","line":"  // Complete a runnable task that has finished executing"},
{"lineNum":"  568","line":"  // or a when_all task when all of its dependeneces are complete."},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"  task_root_type *const zero = nullptr;"},
{"lineNum":"  571","line":"  task_root_type *const lock = (task_root_type *)task_root_type::LockTag;"},
{"lineNum":"  572","line":"  task_root_type *const end  = (task_root_type *)task_root_type::EndTag;"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"#if KOKKOS_IMPL_DEBUG_TASKDAG_SCHEDULING"},
{"lineNum":"  575","line":"  printf(\"complete( 0x%lx { 0x%lx 0x%lx %d %d %d }\\n\", uintptr_t(task),"},
{"lineNum":"  576","line":"         uintptr_t(task->m_wait), uintptr_t(task->m_next), task->m_task_type,"},
{"lineNum":"  577","line":"         task->m_priority, task->m_ref_count);"},
{"lineNum":"  578","line":"#endif"},
{"lineNum":"  579","line":""},
{"lineNum":"  580","line":"  task_root_type volatile &t = *task;"},
{"lineNum":"  581","line":""},
{"lineNum":"  582","line":"  const bool runnable = task_root_type::Aggregate != t.m_task_type;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  583","line":""},
{"lineNum":"  584","line":"  //----------------------------------------"},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"  if (runnable && lock != t.m_next) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  587","line":"    // Is a runnable task has finished executing and requested respawn."},
{"lineNum":"  588","line":"    // Schedule the task for subsequent execution."},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":"    schedule_runnable(task);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  591","line":"  }"},
{"lineNum":"  592","line":"  //----------------------------------------"},
{"lineNum":"  593","line":"  else {"},
{"lineNum":"  594","line":"    // Is either an aggregate or a runnable task that executed"},
{"lineNum":"  595","line":"    // and did not respawn.  Transition this task to complete."},
{"lineNum":"  596","line":""},
{"lineNum":"  597","line":"    // If \'task\' is an aggregate then any of the runnable tasks that"},
{"lineNum":"  598","line":"    // it depends upon may be attempting to complete this \'task\'."},
{"lineNum":"  599","line":"    // Must only transition a task once to complete status."},
{"lineNum":"  600","line":"    // This is controlled by atomically locking the wait queue."},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"    // Stop other tasks from adding themselves to this task\'s wait queue"},
{"lineNum":"  603","line":"    // by locking the head of this task\'s wait queue."},
{"lineNum":"  604","line":""},
{"lineNum":"  605","line":"    task_root_type *x = Kokkos::atomic_exchange(&t.m_wait, lock);"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"    if (x != (task_root_type *)lock) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  608","line":"      // This thread has transitioned this \'task\' to complete."},
{"lineNum":"  609","line":"      // \'task\' is no longer in a queue and is not executing"},
{"lineNum":"  610","line":"      // so decrement the reference count from \'task\'s creation."},
{"lineNum":"  611","line":"      // If no other references to this \'task\' then it will be deleted."},
{"lineNum":"  612","line":""},
{"lineNum":"  613","line":"      TaskQueue::assign(&task, zero);"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"      // This thread has exclusive access to the wait list so"},
{"lineNum":"  616","line":"      // the concurrency-safe pop_ready_task function is not needed."},
{"lineNum":"  617","line":"      // Schedule the tasks that have been waiting on the input \'task\',"},
{"lineNum":"  618","line":"      // which may have been deleted."},
{"lineNum":"  619","line":""},
{"lineNum":"  620","line":"      while (x != end) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  621","line":"        // Have exclusive access to \'x\' until it is scheduled"},
{"lineNum":"  622","line":"        // Set x->m_next = zero  <=  no dependence, not a respawn"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"        task_root_type volatile &vx = *x;"},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"        task_root_type *const next = vx.m_next;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  627","line":"        vx.m_next                  = nullptr;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"        Kokkos::memory_fence();"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"        if (task_root_type::Aggregate != vx.m_task_type) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  632","line":"          schedule_runnable(x);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  633","line":"        } else {"},
{"lineNum":"  634","line":"#if !defined(__HIP_DEVICE_COMPILE__)"},
{"lineNum":"  635","line":"          schedule_aggregate(x);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  636","line":"#endif"},
{"lineNum":"  637","line":"        }"},
{"lineNum":"  638","line":""},
{"lineNum":"  639","line":"        x = next;"},
{"lineNum":"  640","line":"      }"},
{"lineNum":"  641","line":"    }"},
{"lineNum":"  642","line":"  }"},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":"  if (runnable) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  645","line":"    // A runnable task was popped from a ready queue and executed."},
{"lineNum":"  646","line":"    // If respawned into a ready queue then the ready count was incremented"},
{"lineNum":"  647","line":"    // so decrement whether respawned or not."},
{"lineNum":"  648","line":"    Kokkos::atomic_decrement(&m_ready_count);"},
{"lineNum":"  649","line":"  }"},
{"lineNum":"  650","line":"}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  651","line":""},
{"lineNum":"  652","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  653","line":""},
{"lineNum":"  654","line":"} /* namespace Impl */"},
{"lineNum":"  655","line":"} /* namespace Kokkos */"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"#endif /* #if defined( KOKKOS_ENABLE_TASKDAG ) */"},
{"lineNum":"  658","line":"#endif /* #ifndef KOKKOS_IMPL_TASKQUEUE_IMPL_HPP */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 86, "covered" : 0,};
var merged_data = [];
