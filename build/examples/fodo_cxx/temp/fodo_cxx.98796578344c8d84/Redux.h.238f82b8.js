var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_REDUX_H"},
{"lineNum":"   12","line":"#define EIGEN_REDUX_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"// TODO"},
{"lineNum":"   21","line":"//  * implement other kind of vectorization"},
{"lineNum":"   22","line":"//  * factorize code"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"/***************************************************************************"},
{"lineNum":"   25","line":"* Part 1 : the logic deciding a strategy for vectorization and unrolling"},
{"lineNum":"   26","line":"***************************************************************************/"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"template<typename Func, typename Evaluator>"},
{"lineNum":"   29","line":"struct redux_traits"},
{"lineNum":"   30","line":"{"},
{"lineNum":"   31","line":"public:"},
{"lineNum":"   32","line":"    typedef typename find_best_packet<typename Evaluator::Scalar,Evaluator::SizeAtCompileTime>::type PacketType;"},
{"lineNum":"   33","line":"  enum {"},
{"lineNum":"   34","line":"    PacketSize = unpacket_traits<PacketType>::size,"},
{"lineNum":"   35","line":"    InnerMaxSize = int(Evaluator::IsRowMajor)"},
{"lineNum":"   36","line":"                 ? Evaluator::MaxColsAtCompileTime"},
{"lineNum":"   37","line":"                 : Evaluator::MaxRowsAtCompileTime,"},
{"lineNum":"   38","line":"    OuterMaxSize = int(Evaluator::IsRowMajor)"},
{"lineNum":"   39","line":"                 ? Evaluator::MaxRowsAtCompileTime"},
{"lineNum":"   40","line":"                 : Evaluator::MaxColsAtCompileTime,"},
{"lineNum":"   41","line":"    SliceVectorizedWork = int(InnerMaxSize)==Dynamic ? Dynamic"},
{"lineNum":"   42","line":"                        : int(OuterMaxSize)==Dynamic ? (int(InnerMaxSize)>=int(PacketSize) ? Dynamic : 0)"},
{"lineNum":"   43","line":"                        : (int(InnerMaxSize)/int(PacketSize)) * int(OuterMaxSize)"},
{"lineNum":"   44","line":"  };"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"  enum {"},
{"lineNum":"   47","line":"    MightVectorize = (int(Evaluator::Flags)&ActualPacketAccessBit)"},
{"lineNum":"   48","line":"                  && (functor_traits<Func>::PacketAccess),"},
{"lineNum":"   49","line":"    MayLinearVectorize = bool(MightVectorize) && (int(Evaluator::Flags)&LinearAccessBit),"},
{"lineNum":"   50","line":"    MaySliceVectorize  = bool(MightVectorize) && (int(SliceVectorizedWork)==Dynamic || int(SliceVectorizedWork)>=3)"},
{"lineNum":"   51","line":"  };"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"public:"},
{"lineNum":"   54","line":"  enum {"},
{"lineNum":"   55","line":"    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)"},
{"lineNum":"   56","line":"              : int(MaySliceVectorize)  ? int(SliceVectorizedTraversal)"},
{"lineNum":"   57","line":"                                        : int(DefaultTraversal)"},
{"lineNum":"   58","line":"  };"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"public:"},
{"lineNum":"   61","line":"  enum {"},
{"lineNum":"   62","line":"    Cost = Evaluator::SizeAtCompileTime == Dynamic ? HugeCost"},
{"lineNum":"   63","line":"         : int(Evaluator::SizeAtCompileTime) * int(Evaluator::CoeffReadCost) + (Evaluator::SizeAtCompileTime-1) * functor_traits<Func>::Cost,"},
{"lineNum":"   64","line":"    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))"},
{"lineNum":"   65","line":"  };"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"public:"},
{"lineNum":"   68","line":"  enum {"},
{"lineNum":"   69","line":"    Unrolling = Cost <= UnrollingLimit ? CompleteUnrolling : NoUnrolling"},
{"lineNum":"   70","line":"  };"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"#ifdef EIGEN_DEBUG_ASSIGN"},
{"lineNum":"   73","line":"  static void debug()"},
{"lineNum":"   74","line":"  {"},
{"lineNum":"   75","line":"    std::cerr << \"Xpr: \" << typeid(typename Evaluator::XprType).name() << std::endl;"},
{"lineNum":"   76","line":"    std::cerr.setf(std::ios::hex, std::ios::basefield);"},
{"lineNum":"   77","line":"    EIGEN_DEBUG_VAR(Evaluator::Flags)"},
{"lineNum":"   78","line":"    std::cerr.unsetf(std::ios::hex);"},
{"lineNum":"   79","line":"    EIGEN_DEBUG_VAR(InnerMaxSize)"},
{"lineNum":"   80","line":"    EIGEN_DEBUG_VAR(OuterMaxSize)"},
{"lineNum":"   81","line":"    EIGEN_DEBUG_VAR(SliceVectorizedWork)"},
{"lineNum":"   82","line":"    EIGEN_DEBUG_VAR(PacketSize)"},
{"lineNum":"   83","line":"    EIGEN_DEBUG_VAR(MightVectorize)"},
{"lineNum":"   84","line":"    EIGEN_DEBUG_VAR(MayLinearVectorize)"},
{"lineNum":"   85","line":"    EIGEN_DEBUG_VAR(MaySliceVectorize)"},
{"lineNum":"   86","line":"    std::cerr << \"Traversal\" << \" = \" << Traversal << \" (\" << demangle_traversal(Traversal) << \")\" << std::endl;"},
{"lineNum":"   87","line":"    EIGEN_DEBUG_VAR(UnrollingLimit)"},
{"lineNum":"   88","line":"    std::cerr << \"Unrolling\" << \" = \" << Unrolling << \" (\" << demangle_unrolling(Unrolling) << \")\" << std::endl;"},
{"lineNum":"   89","line":"    std::cerr << std::endl;"},
{"lineNum":"   90","line":"  }"},
{"lineNum":"   91","line":"#endif"},
{"lineNum":"   92","line":"};"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"/***************************************************************************"},
{"lineNum":"   95","line":"* Part 2 : unrollers"},
{"lineNum":"   96","line":"***************************************************************************/"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"/*** no vectorization ***/"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"template<typename Func, typename Evaluator, int Start, int Length>"},
{"lineNum":"  101","line":"struct redux_novec_unroller"},
{"lineNum":"  102","line":"{"},
{"lineNum":"  103","line":"  enum {"},
{"lineNum":"  104","line":"    HalfLength = Length/2"},
{"lineNum":"  105","line":"  };"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  110","line":"  static EIGEN_STRONG_INLINE Scalar run(const Evaluator &eval, const Func& func)"},
{"lineNum":"  111","line":"  {"},
{"lineNum":"  112","line":"    return func(redux_novec_unroller<Func, Evaluator, Start, HalfLength>::run(eval,func),"},
{"lineNum":"  113","line":"                redux_novec_unroller<Func, Evaluator, Start+HalfLength, Length-HalfLength>::run(eval,func));"},
{"lineNum":"  114","line":"  }"},
{"lineNum":"  115","line":"};"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"template<typename Func, typename Evaluator, int Start>"},
{"lineNum":"  118","line":"struct redux_novec_unroller<Func, Evaluator, Start, 1>"},
{"lineNum":"  119","line":"{"},
{"lineNum":"  120","line":"  enum {"},
{"lineNum":"  121","line":"    outer = Start / Evaluator::InnerSizeAtCompileTime,"},
{"lineNum":"  122","line":"    inner = Start % Evaluator::InnerSizeAtCompileTime"},
{"lineNum":"  123","line":"  };"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  128","line":"  static EIGEN_STRONG_INLINE Scalar run(const Evaluator &eval, const Func&)"},
{"lineNum":"  129","line":"  {"},
{"lineNum":"  130","line":"    return eval.coeffByOuterInner(outer, inner);"},
{"lineNum":"  131","line":"  }"},
{"lineNum":"  132","line":"};"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"// This is actually dead code and will never be called. It is required"},
{"lineNum":"  135","line":"// to prevent false warnings regarding failed inlining though"},
{"lineNum":"  136","line":"// for 0 length run() will never be called at all."},
{"lineNum":"  137","line":"template<typename Func, typename Evaluator, int Start>"},
{"lineNum":"  138","line":"struct redux_novec_unroller<Func, Evaluator, Start, 0>"},
{"lineNum":"  139","line":"{"},
{"lineNum":"  140","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  141","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  142","line":"  static EIGEN_STRONG_INLINE Scalar run(const Evaluator&, const Func&) { return Scalar(); }"},
{"lineNum":"  143","line":"};"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"/*** vectorization ***/"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"template<typename Func, typename Evaluator, int Start, int Length>"},
{"lineNum":"  148","line":"struct redux_vec_unroller"},
{"lineNum":"  149","line":"{"},
{"lineNum":"  150","line":"  template<typename PacketType>"},
{"lineNum":"  151","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  152","line":"  static EIGEN_STRONG_INLINE PacketType run(const Evaluator &eval, const Func& func)"},
{"lineNum":"  153","line":"  {"},
{"lineNum":"  154","line":"    enum {"},
{"lineNum":"  155","line":"      PacketSize = unpacket_traits<PacketType>::size,"},
{"lineNum":"  156","line":"      HalfLength = Length/2"},
{"lineNum":"  157","line":"    };"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    return func.packetOp("},
{"lineNum":"  160","line":"            redux_vec_unroller<Func, Evaluator, Start, HalfLength>::template run<PacketType>(eval,func),"},
{"lineNum":"  161","line":"            redux_vec_unroller<Func, Evaluator, Start+HalfLength, Length-HalfLength>::template run<PacketType>(eval,func) );"},
{"lineNum":"  162","line":"  }"},
{"lineNum":"  163","line":"};"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"template<typename Func, typename Evaluator, int Start>"},
{"lineNum":"  166","line":"struct redux_vec_unroller<Func, Evaluator, Start, 1>"},
{"lineNum":"  167","line":"{"},
{"lineNum":"  168","line":"  template<typename PacketType>"},
{"lineNum":"  169","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  170","line":"  static EIGEN_STRONG_INLINE PacketType run(const Evaluator &eval, const Func&)"},
{"lineNum":"  171","line":"  {"},
{"lineNum":"  172","line":"    enum {"},
{"lineNum":"  173","line":"      PacketSize = unpacket_traits<PacketType>::size,"},
{"lineNum":"  174","line":"      index = Start * PacketSize,"},
{"lineNum":"  175","line":"      outer = index / int(Evaluator::InnerSizeAtCompileTime),"},
{"lineNum":"  176","line":"      inner = index % int(Evaluator::InnerSizeAtCompileTime),"},
{"lineNum":"  177","line":"      alignment = Evaluator::Alignment"},
{"lineNum":"  178","line":"    };"},
{"lineNum":"  179","line":"    return eval.template packetByOuterInner<alignment,PacketType>(outer, inner);"},
{"lineNum":"  180","line":"  }"},
{"lineNum":"  181","line":"};"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"/***************************************************************************"},
{"lineNum":"  184","line":"* Part 3 : implementation of all cases"},
{"lineNum":"  185","line":"***************************************************************************/"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"template<typename Func, typename Evaluator,"},
{"lineNum":"  188","line":"         int Traversal = redux_traits<Func, Evaluator>::Traversal,"},
{"lineNum":"  189","line":"         int Unrolling = redux_traits<Func, Evaluator>::Unrolling"},
{"lineNum":"  190","line":">"},
{"lineNum":"  191","line":"struct redux_impl;"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"template<typename Func, typename Evaluator>"},
{"lineNum":"  194","line":"struct redux_impl<Func, Evaluator, DefaultTraversal, NoUnrolling>"},
{"lineNum":"  195","line":"{"},
{"lineNum":"  196","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"  template<typename XprType>"},
{"lineNum":"  199","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE"},
{"lineNum":"  200","line":"  Scalar run(const Evaluator &eval, const Func& func, const XprType& xpr)"},
{"lineNum":"  201","line":"  {"},
{"lineNum":"  202","line":"    eigen_assert(xpr.rows()>0 && xpr.cols()>0 && \"you are using an empty matrix\");"},
{"lineNum":"  203","line":"    Scalar res;"},
{"lineNum":"  204","line":"    res = eval.coeffByOuterInner(0, 0);"},
{"lineNum":"  205","line":"    for(Index i = 1; i < xpr.innerSize(); ++i)","class":"lineNoCov","hits":"0","possible_hits":"207",},
{"lineNum":"  206","line":"      res = func(res, eval.coeffByOuterInner(0, i));"},
{"lineNum":"  207","line":"    for(Index i = 1; i < xpr.outerSize(); ++i)"},
{"lineNum":"  208","line":"      for(Index j = 0; j < xpr.innerSize(); ++j)"},
{"lineNum":"  209","line":"        res = func(res, eval.coeffByOuterInner(i, j));"},
{"lineNum":"  210","line":"    return res;"},
{"lineNum":"  211","line":"  }"},
{"lineNum":"  212","line":"};"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"template<typename Func, typename Evaluator>"},
{"lineNum":"  215","line":"struct redux_impl<Func,Evaluator, DefaultTraversal, CompleteUnrolling>"},
{"lineNum":"  216","line":"  : redux_novec_unroller<Func,Evaluator, 0, Evaluator::SizeAtCompileTime>"},
{"lineNum":"  217","line":"{"},
{"lineNum":"  218","line":"  typedef redux_novec_unroller<Func,Evaluator, 0, Evaluator::SizeAtCompileTime> Base;"},
{"lineNum":"  219","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  220","line":"  template<typename XprType>"},
{"lineNum":"  221","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE"},
{"lineNum":"  222","line":"  Scalar run(const Evaluator &eval, const Func& func, const XprType& /*xpr*/)"},
{"lineNum":"  223","line":"  {"},
{"lineNum":"  224","line":"    return Base::run(eval,func);"},
{"lineNum":"  225","line":"  }"},
{"lineNum":"  226","line":"};"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"template<typename Func, typename Evaluator>"},
{"lineNum":"  229","line":"struct redux_impl<Func, Evaluator, LinearVectorizedTraversal, NoUnrolling>"},
{"lineNum":"  230","line":"{"},
{"lineNum":"  231","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  232","line":"  typedef typename redux_traits<Func, Evaluator>::PacketType PacketScalar;"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"  template<typename XprType>"},
{"lineNum":"  235","line":"  static Scalar run(const Evaluator &eval, const Func& func, const XprType& xpr)"},
{"lineNum":"  236","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  237","line":"    const Index size = xpr.size();"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"    const Index packetSize = redux_traits<Func, Evaluator>::PacketSize;"},
{"lineNum":"  240","line":"    const int packetAlignment = unpacket_traits<PacketScalar>::alignment;"},
{"lineNum":"  241","line":"    enum {"},
{"lineNum":"  242","line":"      alignment0 = (bool(Evaluator::Flags & DirectAccessBit) && bool(packet_traits<Scalar>::AlignedOnScalar)) ? int(packetAlignment) : int(Unaligned),"},
{"lineNum":"  243","line":"      alignment = EIGEN_PLAIN_ENUM_MAX(alignment0, Evaluator::Alignment)"},
{"lineNum":"  244","line":"    };"},
{"lineNum":"  245","line":"    const Index alignedStart = internal::first_default_aligned(xpr);"},
{"lineNum":"  246","line":"    const Index alignedSize2 = ((size-alignedStart)/(2*packetSize))*(2*packetSize);","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  247","line":"    const Index alignedSize = ((size-alignedStart)/(packetSize))*(packetSize);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  248","line":"    const Index alignedEnd2 = alignedStart + alignedSize2;"},
{"lineNum":"  249","line":"    const Index alignedEnd  = alignedStart + alignedSize;"},
{"lineNum":"  250","line":"    Scalar res;"},
{"lineNum":"  251","line":"    if(alignedSize)","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  252","line":"    {"},
{"lineNum":"  253","line":"      PacketScalar packet_res0 = eval.template packet<alignment,PacketScalar>(alignedStart);"},
{"lineNum":"  254","line":"      if(alignedSize>packetSize) // we have at least two packets to partly unroll the loop","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  255","line":"      {"},
{"lineNum":"  256","line":"        PacketScalar packet_res1 = eval.template packet<alignment,PacketScalar>(alignedStart+packetSize);"},
{"lineNum":"  257","line":"        for(Index index = alignedStart + 2*packetSize; index < alignedEnd2; index += 2*packetSize)","class":"lineNoCov","hits":"0","possible_hits":"28",},
{"lineNum":"  258","line":"        {"},
{"lineNum":"  259","line":"          packet_res0 = func.packetOp(packet_res0, eval.template packet<alignment,PacketScalar>(index));"},
{"lineNum":"  260","line":"          packet_res1 = func.packetOp(packet_res1, eval.template packet<alignment,PacketScalar>(index+packetSize));"},
{"lineNum":"  261","line":"        }"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"        packet_res0 = func.packetOp(packet_res0,packet_res1);"},
{"lineNum":"  264","line":"        if(alignedEnd>alignedEnd2)","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  265","line":"          packet_res0 = func.packetOp(packet_res0, eval.template packet<alignment,PacketScalar>(alignedEnd2));"},
{"lineNum":"  266","line":"      }"},
{"lineNum":"  267","line":"      res = func.predux(packet_res0);"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"      for(Index index = 0; index < alignedStart; ++index)"},
{"lineNum":"  270","line":"        res = func(res,eval.coeff(index));"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"      for(Index index = alignedEnd; index < size; ++index)","class":"lineNoCov","hits":"0","possible_hits":"53",},
{"lineNum":"  273","line":"        res = func(res,eval.coeff(index));"},
{"lineNum":"  274","line":"    }"},
{"lineNum":"  275","line":"    else // too small to vectorize anything."},
{"lineNum":"  276","line":"         // since this is dynamic-size hence inefficient anyway for such small sizes, don\'t try to optimize."},
{"lineNum":"  277","line":"    {"},
{"lineNum":"  278","line":"      res = eval.coeff(0);"},
{"lineNum":"  279","line":"      for(Index index = 1; index < size; ++index)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  280","line":"        res = func(res,eval.coeff(index));"},
{"lineNum":"  281","line":"    }"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"    return res;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  284","line":"  }"},
{"lineNum":"  285","line":"};"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"// NOTE: for SliceVectorizedTraversal we simply bypass unrolling"},
{"lineNum":"  288","line":"template<typename Func, typename Evaluator, int Unrolling>"},
{"lineNum":"  289","line":"struct redux_impl<Func, Evaluator, SliceVectorizedTraversal, Unrolling>"},
{"lineNum":"  290","line":"{"},
{"lineNum":"  291","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  292","line":"  typedef typename redux_traits<Func, Evaluator>::PacketType PacketType;"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"  template<typename XprType>"},
{"lineNum":"  295","line":"  EIGEN_DEVICE_FUNC static Scalar run(const Evaluator &eval, const Func& func, const XprType& xpr)"},
{"lineNum":"  296","line":"  {"},
{"lineNum":"  297","line":"    eigen_assert(xpr.rows()>0 && xpr.cols()>0 && \"you are using an empty matrix\");"},
{"lineNum":"  298","line":"    const Index innerSize = xpr.innerSize();"},
{"lineNum":"  299","line":"    const Index outerSize = xpr.outerSize();"},
{"lineNum":"  300","line":"    enum {"},
{"lineNum":"  301","line":"      packetSize = redux_traits<Func, Evaluator>::PacketSize"},
{"lineNum":"  302","line":"    };"},
{"lineNum":"  303","line":"    const Index packetedInnerSize = ((innerSize)/packetSize)*packetSize;"},
{"lineNum":"  304","line":"    Scalar res;"},
{"lineNum":"  305","line":"    if(packetedInnerSize)"},
{"lineNum":"  306","line":"    {"},
{"lineNum":"  307","line":"      PacketType packet_res = eval.template packet<Unaligned,PacketType>(0,0);"},
{"lineNum":"  308","line":"      for(Index j=0; j<outerSize; ++j)"},
{"lineNum":"  309","line":"        for(Index i=(j==0?packetSize:0); i<packetedInnerSize; i+=Index(packetSize))"},
{"lineNum":"  310","line":"          packet_res = func.packetOp(packet_res, eval.template packetByOuterInner<Unaligned,PacketType>(j,i));"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"      res = func.predux(packet_res);"},
{"lineNum":"  313","line":"      for(Index j=0; j<outerSize; ++j)"},
{"lineNum":"  314","line":"        for(Index i=packetedInnerSize; i<innerSize; ++i)"},
{"lineNum":"  315","line":"          res = func(res, eval.coeffByOuterInner(j,i));"},
{"lineNum":"  316","line":"    }"},
{"lineNum":"  317","line":"    else // too small to vectorize anything."},
{"lineNum":"  318","line":"         // since this is dynamic-size hence inefficient anyway for such small sizes, don\'t try to optimize."},
{"lineNum":"  319","line":"    {"},
{"lineNum":"  320","line":"      res = redux_impl<Func, Evaluator, DefaultTraversal, NoUnrolling>::run(eval, func, xpr);"},
{"lineNum":"  321","line":"    }"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"    return res;"},
{"lineNum":"  324","line":"  }"},
{"lineNum":"  325","line":"};"},
{"lineNum":"  326","line":""},
{"lineNum":"  327","line":"template<typename Func, typename Evaluator>"},
{"lineNum":"  328","line":"struct redux_impl<Func, Evaluator, LinearVectorizedTraversal, CompleteUnrolling>"},
{"lineNum":"  329","line":"{"},
{"lineNum":"  330","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"  typedef typename redux_traits<Func, Evaluator>::PacketType PacketType;"},
{"lineNum":"  333","line":"  enum {"},
{"lineNum":"  334","line":"    PacketSize = redux_traits<Func, Evaluator>::PacketSize,"},
{"lineNum":"  335","line":"    Size = Evaluator::SizeAtCompileTime,"},
{"lineNum":"  336","line":"    VectorizedSize = (int(Size) / int(PacketSize)) * int(PacketSize)"},
{"lineNum":"  337","line":"  };"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"  template<typename XprType>"},
{"lineNum":"  340","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE"},
{"lineNum":"  341","line":"  Scalar run(const Evaluator &eval, const Func& func, const XprType &xpr)"},
{"lineNum":"  342","line":"  {"},
{"lineNum":"  343","line":"    EIGEN_ONLY_USED_FOR_DEBUG(xpr)"},
{"lineNum":"  344","line":"    eigen_assert(xpr.rows()>0 && xpr.cols()>0 && \"you are using an empty matrix\");"},
{"lineNum":"  345","line":"    if (VectorizedSize > 0) {"},
{"lineNum":"  346","line":"      Scalar res = func.predux(redux_vec_unroller<Func, Evaluator, 0, Size / PacketSize>::template run<PacketType>(eval,func));"},
{"lineNum":"  347","line":"      if (VectorizedSize != Size)"},
{"lineNum":"  348","line":"        res = func(res,redux_novec_unroller<Func, Evaluator, VectorizedSize, Size-VectorizedSize>::run(eval,func));"},
{"lineNum":"  349","line":"      return res;"},
{"lineNum":"  350","line":"    }"},
{"lineNum":"  351","line":"    else {"},
{"lineNum":"  352","line":"      return redux_novec_unroller<Func, Evaluator, 0, Size>::run(eval,func);"},
{"lineNum":"  353","line":"    }"},
{"lineNum":"  354","line":"  }"},
{"lineNum":"  355","line":"};"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"// evaluator adaptor"},
{"lineNum":"  358","line":"template<typename XprType_>"},
{"lineNum":"  359","line":"class redux_evaluator : public internal::evaluator<XprType_>"},
{"lineNum":"  360","line":"{"},
{"lineNum":"  361","line":"  typedef internal::evaluator<XprType_> Base;"},
{"lineNum":"  362","line":"public:"},
{"lineNum":"  363","line":"  typedef XprType_ XprType;"},
{"lineNum":"  364","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  365","line":"  explicit redux_evaluator(const XprType &xpr) : Base(xpr) {}"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"  typedef typename XprType::Scalar Scalar;"},
{"lineNum":"  368","line":"  typedef typename XprType::CoeffReturnType CoeffReturnType;"},
{"lineNum":"  369","line":"  typedef typename XprType::PacketScalar PacketScalar;"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"  enum {"},
{"lineNum":"  372","line":"    MaxRowsAtCompileTime = XprType::MaxRowsAtCompileTime,"},
{"lineNum":"  373","line":"    MaxColsAtCompileTime = XprType::MaxColsAtCompileTime,"},
{"lineNum":"  374","line":"    // TODO we should not remove DirectAccessBit and rather find an elegant way to query the alignment offset at runtime from the evaluator"},
{"lineNum":"  375","line":"    Flags = Base::Flags & ~DirectAccessBit,"},
{"lineNum":"  376","line":"    IsRowMajor = XprType::IsRowMajor,"},
{"lineNum":"  377","line":"    SizeAtCompileTime = XprType::SizeAtCompileTime,"},
{"lineNum":"  378","line":"    InnerSizeAtCompileTime = XprType::InnerSizeAtCompileTime"},
{"lineNum":"  379","line":"  };"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  382","line":"  CoeffReturnType coeffByOuterInner(Index outer, Index inner) const"},
{"lineNum":"  383","line":"  { return Base::coeff(IsRowMajor ? outer : inner, IsRowMajor ? inner : outer); }"},
{"lineNum":"  384","line":""},
{"lineNum":"  385","line":"  template<int LoadMode, typename PacketType>"},
{"lineNum":"  386","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  387","line":"  PacketType packetByOuterInner(Index outer, Index inner) const"},
{"lineNum":"  388","line":"  { return Base::template packet<LoadMode,PacketType>(IsRowMajor ? outer : inner, IsRowMajor ? inner : outer); }"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"};"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"} // end namespace internal"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"/***************************************************************************"},
{"lineNum":"  395","line":"* Part 4 : public API"},
{"lineNum":"  396","line":"***************************************************************************/"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"/** \\returns the result of a full redux operation on the whole matrix or vector using \\a func"},
{"lineNum":"  400","line":"  *"},
{"lineNum":"  401","line":"  * The template parameter \\a BinaryOp is the type of the functor \\a func which must be"},
{"lineNum":"  402","line":"  * an associative operator. Both current C++98 and C++11 functor styles are handled."},
{"lineNum":"  403","line":"  *"},
{"lineNum":"  404","line":"  * \\warning the matrix must be not empty, otherwise an assertion is triggered."},
{"lineNum":"  405","line":"  *"},
{"lineNum":"  406","line":"  * \\sa DenseBase::sum(), DenseBase::minCoeff(), DenseBase::maxCoeff(), MatrixBase::colwise(), MatrixBase::rowwise()"},
{"lineNum":"  407","line":"  */"},
{"lineNum":"  408","line":"template<typename Derived>"},
{"lineNum":"  409","line":"template<typename Func>"},
{"lineNum":"  410","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar"},
{"lineNum":"  411","line":"DenseBase<Derived>::redux(const Func& func) const"},
{"lineNum":"  412","line":"{"},
{"lineNum":"  413","line":"  eigen_assert(this->rows()>0 && this->cols()>0 && \"you are using an empty matrix\");"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"  typedef typename internal::redux_evaluator<Derived> ThisEvaluator;"},
{"lineNum":"  416","line":"  ThisEvaluator thisEval(derived());"},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"  // The initial expression is passed to the reducer as an additional argument instead of"},
{"lineNum":"  419","line":"  // passing it as a member of redux_evaluator to help"},
{"lineNum":"  420","line":"  return internal::redux_impl<Func, ThisEvaluator>::run(thisEval, func, derived());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  421","line":"}"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"/** \\returns the minimum of all coefficients of \\c *this."},
{"lineNum":"  424","line":"  * In case \\c *this contains NaN, NaNPropagation determines the behavior:"},
{"lineNum":"  425","line":"  *   NaNPropagation == PropagateFast : undefined"},
{"lineNum":"  426","line":"  *   NaNPropagation == PropagateNaN : result is NaN"},
{"lineNum":"  427","line":"  *   NaNPropagation == PropagateNumbers : result is minimum of elements that are not NaN"},
{"lineNum":"  428","line":"  * \\warning the matrix must be not empty, otherwise an assertion is triggered."},
{"lineNum":"  429","line":"  */"},
{"lineNum":"  430","line":"template<typename Derived>"},
{"lineNum":"  431","line":"template<int NaNPropagation>"},
{"lineNum":"  432","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar"},
{"lineNum":"  433","line":"DenseBase<Derived>::minCoeff() const"},
{"lineNum":"  434","line":"{"},
{"lineNum":"  435","line":"  return derived().redux(Eigen::internal::scalar_min_op<Scalar,Scalar, NaNPropagation>());"},
{"lineNum":"  436","line":"}"},
{"lineNum":"  437","line":""},
{"lineNum":"  438","line":"/** \\returns the maximum of all coefficients of \\c *this."},
{"lineNum":"  439","line":"  * In case \\c *this contains NaN, NaNPropagation determines the behavior:"},
{"lineNum":"  440","line":"  *   NaNPropagation == PropagateFast : undefined"},
{"lineNum":"  441","line":"  *   NaNPropagation == PropagateNaN : result is NaN"},
{"lineNum":"  442","line":"  *   NaNPropagation == PropagateNumbers : result is maximum of elements that are not NaN"},
{"lineNum":"  443","line":"  * \\warning the matrix must be not empty, otherwise an assertion is triggered."},
{"lineNum":"  444","line":"  */"},
{"lineNum":"  445","line":"template<typename Derived>"},
{"lineNum":"  446","line":"template<int NaNPropagation>"},
{"lineNum":"  447","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar"},
{"lineNum":"  448","line":"DenseBase<Derived>::maxCoeff() const"},
{"lineNum":"  449","line":"{"},
{"lineNum":"  450","line":"  return derived().redux(Eigen::internal::scalar_max_op<Scalar,Scalar, NaNPropagation>());"},
{"lineNum":"  451","line":"}"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"/** \\returns the sum of all coefficients of \\c *this"},
{"lineNum":"  454","line":"  *"},
{"lineNum":"  455","line":"  * If \\c *this is empty, then the value 0 is returned."},
{"lineNum":"  456","line":"  *"},
{"lineNum":"  457","line":"  * \\sa trace(), prod(), mean()"},
{"lineNum":"  458","line":"  */"},
{"lineNum":"  459","line":"template<typename Derived>"},
{"lineNum":"  460","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar"},
{"lineNum":"  461","line":"DenseBase<Derived>::sum() const"},
{"lineNum":"  462","line":"{"},
{"lineNum":"  463","line":"  if(SizeAtCompileTime==0 || (SizeAtCompileTime==Dynamic && size()==0))","class":"lineNoCov","hits":"0","possible_hits":"69",},
{"lineNum":"  464","line":"    return Scalar(0);"},
{"lineNum":"  465","line":"  return derived().redux(Eigen::internal::scalar_sum_op<Scalar,Scalar>());"},
{"lineNum":"  466","line":"}"},
{"lineNum":"  467","line":""},
{"lineNum":"  468","line":"/** \\returns the mean of all coefficients of *this"},
{"lineNum":"  469","line":"*"},
{"lineNum":"  470","line":"* \\sa trace(), prod(), sum()"},
{"lineNum":"  471","line":"*/"},
{"lineNum":"  472","line":"template<typename Derived>"},
{"lineNum":"  473","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar"},
{"lineNum":"  474","line":"DenseBase<Derived>::mean() const"},
{"lineNum":"  475","line":"{"},
{"lineNum":"  476","line":"#ifdef __INTEL_COMPILER"},
{"lineNum":"  477","line":"  #pragma warning push"},
{"lineNum":"  478","line":"  #pragma warning ( disable : 2259 )"},
{"lineNum":"  479","line":"#endif"},
{"lineNum":"  480","line":"  return Scalar(derived().redux(Eigen::internal::scalar_sum_op<Scalar,Scalar>())) / Scalar(this->size());"},
{"lineNum":"  481","line":"#ifdef __INTEL_COMPILER"},
{"lineNum":"  482","line":"  #pragma warning pop"},
{"lineNum":"  483","line":"#endif"},
{"lineNum":"  484","line":"}"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"/** \\returns the product of all coefficients of *this"},
{"lineNum":"  487","line":"  *"},
{"lineNum":"  488","line":"  * Example: \\include MatrixBase_prod.cpp"},
{"lineNum":"  489","line":"  * Output: \\verbinclude MatrixBase_prod.out"},
{"lineNum":"  490","line":"  *"},
{"lineNum":"  491","line":"  * \\sa sum(), mean(), trace()"},
{"lineNum":"  492","line":"  */"},
{"lineNum":"  493","line":"template<typename Derived>"},
{"lineNum":"  494","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar"},
{"lineNum":"  495","line":"DenseBase<Derived>::prod() const"},
{"lineNum":"  496","line":"{"},
{"lineNum":"  497","line":"  if(SizeAtCompileTime==0 || (SizeAtCompileTime==Dynamic && size()==0))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  498","line":"    return Scalar(1);"},
{"lineNum":"  499","line":"  return derived().redux(Eigen::internal::scalar_product_op<Scalar>());"},
{"lineNum":"  500","line":"}"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"/** \\returns the trace of \\c *this, i.e. the sum of the coefficients on the main diagonal."},
{"lineNum":"  503","line":"  *"},
{"lineNum":"  504","line":"  * \\c *this can be any matrix, not necessarily square."},
{"lineNum":"  505","line":"  *"},
{"lineNum":"  506","line":"  * \\sa diagonal(), sum()"},
{"lineNum":"  507","line":"  */"},
{"lineNum":"  508","line":"template<typename Derived>"},
{"lineNum":"  509","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE typename internal::traits<Derived>::Scalar"},
{"lineNum":"  510","line":"MatrixBase<Derived>::trace() const"},
{"lineNum":"  511","line":"{"},
{"lineNum":"  512","line":"  return derived().diagonal().sum();"},
{"lineNum":"  513","line":"}"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"} // end namespace Eigen"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"#endif // EIGEN_REDUX_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 14, "covered" : 0,};
var merged_data = [];
