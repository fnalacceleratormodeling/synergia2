var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2007-2010 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_FORWARDDECLARATIONS_H"},
{"lineNum":"   12","line":"#define EIGEN_FORWARDDECLARATIONS_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"../InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"template<typename T> struct traits;"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"// here we say once and for all that traits<const T> == traits<T>"},
{"lineNum":"   22","line":"// When constness must affect traits, it has to be constness on template parameters on which T itself depends."},
{"lineNum":"   23","line":"// For example, traits<Map<const T> > != traits<Map<T> >, but"},
{"lineNum":"   24","line":"//              traits<const Map<T> > == traits<Map<T> >"},
{"lineNum":"   25","line":"template<typename T> struct traits<const T> : traits<T> {};"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"template<typename Derived> struct has_direct_access"},
{"lineNum":"   28","line":"{"},
{"lineNum":"   29","line":"  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };"},
{"lineNum":"   30","line":"};"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"template<typename Derived> struct accessors_level"},
{"lineNum":"   33","line":"{"},
{"lineNum":"   34","line":"  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,"},
{"lineNum":"   35","line":"         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,"},
{"lineNum":"   36","line":"         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)"},
{"lineNum":"   37","line":"                                   : (has_write_access ? WriteAccessors       : ReadOnlyAccessors)"},
{"lineNum":"   38","line":"  };"},
{"lineNum":"   39","line":"};"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"template<typename T> struct evaluator_traits;"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"template< typename T> struct evaluator;"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"} // end namespace internal"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"template<typename T> struct NumTraits;"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"template<typename Derived> struct EigenBase;"},
{"lineNum":"   50","line":"template<typename Derived> class DenseBase;"},
{"lineNum":"   51","line":"template<typename Derived> class PlainObjectBase;"},
{"lineNum":"   52","line":"template<typename Derived, int Level> class DenseCoeffsBase;"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"template<typename Scalar_, int Rows_, int Cols_,"},
{"lineNum":"   55","line":"         int Options_ = AutoAlign |"},
{"lineNum":"   56","line":"#if EIGEN_GNUC_AT(3,4)"},
{"lineNum":"   57","line":"    // workaround a bug in at least gcc 3.4.6"},
{"lineNum":"   58","line":"    // the innermost ?: ternary operator is misparsed. We write it slightly"},
{"lineNum":"   59","line":"    // differently and this makes gcc 3.4.6 happy, but it\'s ugly."},
{"lineNum":"   60","line":"    // The error would only show up with EIGEN_DEFAULT_TO_ROW_MAJOR is defined"},
{"lineNum":"   61","line":"    // (when EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION is RowMajor)"},
{"lineNum":"   62","line":"                          ( (Rows_==1 && Cols_!=1) ? Eigen::RowMajor"},
{"lineNum":"   63","line":"                          : !(Cols_==1 && Rows_!=1) ?  EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION"},
{"lineNum":"   64","line":"                          : Eigen::ColMajor ),"},
{"lineNum":"   65","line":"#else"},
{"lineNum":"   66","line":"                          ( (Rows_==1 && Cols_!=1) ? Eigen::RowMajor"},
{"lineNum":"   67","line":"                          : (Cols_==1 && Rows_!=1) ? Eigen::ColMajor"},
{"lineNum":"   68","line":"                          : EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION ),"},
{"lineNum":"   69","line":"#endif"},
{"lineNum":"   70","line":"         int MaxRows_ = Rows_,"},
{"lineNum":"   71","line":"         int MaxCols_ = Cols_"},
{"lineNum":"   72","line":"> class Matrix;"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"template<typename Derived> class MatrixBase;"},
{"lineNum":"   75","line":"template<typename Derived> class ArrayBase;"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged;"},
{"lineNum":"   78","line":"template<typename ExpressionType, template <typename> class StorageBase > class NoAlias;"},
{"lineNum":"   79","line":"template<typename ExpressionType> class NestByValue;"},
{"lineNum":"   80","line":"template<typename ExpressionType> class ForceAlignedAccess;"},
{"lineNum":"   81","line":"template<typename ExpressionType> class SwapWrapper;"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"template<typename XprType, int BlockRows=Dynamic, int BlockCols=Dynamic, bool InnerPanel = false> class Block;"},
{"lineNum":"   84","line":"template<typename XprType, typename RowIndices, typename ColIndices> class IndexedView;"},
{"lineNum":"   85","line":"template<typename XprType, int Rows=Dynamic, int Cols=Dynamic, int Order=0> class Reshaped;"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"template<typename MatrixType, int Size=Dynamic> class VectorBlock;"},
{"lineNum":"   88","line":"template<typename MatrixType> class Transpose;"},
{"lineNum":"   89","line":"template<typename MatrixType> class Conjugate;"},
{"lineNum":"   90","line":"template<typename NullaryOp, typename MatrixType>         class CwiseNullaryOp;","class":"lineNoCov","hits":"0","possible_hits":"29",},
{"lineNum":"   91","line":"template<typename UnaryOp,   typename MatrixType>         class CwiseUnaryOp;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   92","line":"template<typename ViewOp,    typename MatrixType>         class CwiseUnaryView;"},
{"lineNum":"   93","line":"template<typename BinaryOp,  typename Lhs, typename Rhs>  class CwiseBinaryOp;","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"   94","line":"template<typename TernaryOp, typename Arg1, typename Arg2, typename Arg3>  class CwiseTernaryOp;"},
{"lineNum":"   95","line":"template<typename Decomposition, typename Rhstype>        class Solve;"},
{"lineNum":"   96","line":"template<typename XprType>                                class Inverse;"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"template<typename Lhs, typename Rhs, int Option = DefaultProduct> class Product;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"template<typename Derived> class DiagonalBase;"},
{"lineNum":"  101","line":"template<typename _DiagonalVectorType> class DiagonalWrapper;"},
{"lineNum":"  102","line":"template<typename Scalar_, int SizeAtCompileTime, int MaxSizeAtCompileTime=SizeAtCompileTime> class DiagonalMatrix;"},
{"lineNum":"  103","line":"template<typename MatrixType, typename DiagonalType, int ProductOrder> class DiagonalProduct;"},
{"lineNum":"  104","line":"template<typename MatrixType, int Index = 0> class Diagonal;"},
{"lineNum":"  105","line":"template<int SizeAtCompileTime, int MaxSizeAtCompileTime = SizeAtCompileTime, typename IndexType=int> class PermutationMatrix;"},
{"lineNum":"  106","line":"template<int SizeAtCompileTime, int MaxSizeAtCompileTime = SizeAtCompileTime, typename IndexType=int> class Transpositions;"},
{"lineNum":"  107","line":"template<typename Derived> class PermutationBase;"},
{"lineNum":"  108","line":"template<typename Derived> class TranspositionsBase;"},
{"lineNum":"  109","line":"template<typename IndicesType_> class PermutationWrapper;"},
{"lineNum":"  110","line":"template<typename IndicesType_> class TranspositionsWrapper;"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"template<typename Derived,"},
{"lineNum":"  113","line":"         int Level = internal::accessors_level<Derived>::has_write_access ? WriteAccessors : ReadOnlyAccessors"},
{"lineNum":"  114","line":"> class MapBase;"},
{"lineNum":"  115","line":"template<int OuterStrideAtCompileTime, int InnerStrideAtCompileTime> class Stride;"},
{"lineNum":"  116","line":"template<int Value = Dynamic> class InnerStride;"},
{"lineNum":"  117","line":"template<int Value = Dynamic> class OuterStride;"},
{"lineNum":"  118","line":"template<typename MatrixType, int MapOptions=Unaligned, typename StrideType = Stride<0,0> > class Map;"},
{"lineNum":"  119","line":"template<typename Derived> class RefBase;"},
{"lineNum":"  120","line":"template<typename PlainObjectType, int Options = 0,"},
{"lineNum":"  121","line":"         typename StrideType = typename internal::conditional<PlainObjectType::IsVectorAtCompileTime,InnerStride<1>,OuterStride<> >::type > class Ref;"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"template<typename Derived> class TriangularBase;"},
{"lineNum":"  124","line":"template<typename MatrixType, unsigned int Mode> class TriangularView;"},
{"lineNum":"  125","line":"template<typename MatrixType, unsigned int Mode> class SelfAdjointView;"},
{"lineNum":"  126","line":"template<typename MatrixType> class SparseView;"},
{"lineNum":"  127","line":"template<typename ExpressionType> class WithFormat;"},
{"lineNum":"  128","line":"template<typename MatrixType> struct CommaInitializer;"},
{"lineNum":"  129","line":"template<typename Derived> class ReturnByValue;"},
{"lineNum":"  130","line":"template<typename ExpressionType> class ArrayWrapper;"},
{"lineNum":"  131","line":"template<typename ExpressionType> class MatrixWrapper;"},
{"lineNum":"  132","line":"template<typename Derived> class SolverBase;"},
{"lineNum":"  133","line":"template<typename XprType> class InnerIterator;"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"namespace internal {"},
{"lineNum":"  136","line":"template<typename XprType> class generic_randaccess_stl_iterator;"},
{"lineNum":"  137","line":"template<typename XprType> class pointer_based_stl_iterator;"},
{"lineNum":"  138","line":"template<typename XprType, DirectionType Direction> class subvector_stl_iterator;"},
{"lineNum":"  139","line":"template<typename XprType, DirectionType Direction> class subvector_stl_reverse_iterator;"},
{"lineNum":"  140","line":"template<typename DecompositionType> struct kernel_retval_base;"},
{"lineNum":"  141","line":"template<typename DecompositionType> struct kernel_retval;"},
{"lineNum":"  142","line":"template<typename DecompositionType> struct image_retval_base;"},
{"lineNum":"  143","line":"template<typename DecompositionType> struct image_retval;"},
{"lineNum":"  144","line":"} // end namespace internal"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"namespace internal {"},
{"lineNum":"  147","line":"template<typename Scalar_, int Rows=Dynamic, int Cols=Dynamic, int Supers=Dynamic, int Subs=Dynamic, int Options=0> class BandMatrix;"},
{"lineNum":"  148","line":"}"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"namespace internal {"},
{"lineNum":"  151","line":"template<typename Lhs, typename Rhs> struct product_type;"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"template<bool> struct EnableIf;"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"/** \\internal"},
{"lineNum":"  156","line":"  * \\class product_evaluator"},
{"lineNum":"  157","line":"  * Products need their own evaluator with more template arguments allowing for"},
{"lineNum":"  158","line":"  * easier partial template specializations."},
{"lineNum":"  159","line":"  */"},
{"lineNum":"  160","line":"template< typename T,"},
{"lineNum":"  161","line":"          int ProductTag = internal::product_type<typename T::Lhs,typename T::Rhs>::ret,"},
{"lineNum":"  162","line":"          typename LhsShape = typename evaluator_traits<typename T::Lhs>::Shape,"},
{"lineNum":"  163","line":"          typename RhsShape = typename evaluator_traits<typename T::Rhs>::Shape,"},
{"lineNum":"  164","line":"          typename LhsScalar = typename traits<typename T::Lhs>::Scalar,"},
{"lineNum":"  165","line":"          typename RhsScalar = typename traits<typename T::Rhs>::Scalar"},
{"lineNum":"  166","line":"        > struct product_evaluator;"},
{"lineNum":"  167","line":"}"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"template<typename Lhs, typename Rhs,"},
{"lineNum":"  170","line":"         int ProductType = internal::product_type<Lhs,Rhs>::value>"},
{"lineNum":"  171","line":"struct ProductReturnType;"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"// this is a workaround for sun CC"},
{"lineNum":"  174","line":"template<typename Lhs, typename Rhs> struct LazyProductReturnType;"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"namespace internal {"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"// Provides scalar/packet-wise product and product with accumulation"},
{"lineNum":"  179","line":"// with optional conjugation of the arguments."},
{"lineNum":"  180","line":"template<typename LhsScalar, typename RhsScalar, bool ConjLhs=false, bool ConjRhs=false> struct conj_helper;"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_sum_op;"},
{"lineNum":"  183","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_difference_op;"},
{"lineNum":"  184","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_conj_product_op;"},
{"lineNum":"  185","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar, int NaNPropagation=PropagateFast> struct scalar_min_op;"},
{"lineNum":"  186","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar, int NaNPropagation=PropagateFast> struct scalar_max_op;"},
{"lineNum":"  187","line":"template<typename Scalar> struct scalar_opposite_op;"},
{"lineNum":"  188","line":"template<typename Scalar> struct scalar_conjugate_op;"},
{"lineNum":"  189","line":"template<typename Scalar> struct scalar_real_op;"},
{"lineNum":"  190","line":"template<typename Scalar> struct scalar_imag_op;"},
{"lineNum":"  191","line":"template<typename Scalar> struct scalar_abs_op;"},
{"lineNum":"  192","line":"template<typename Scalar> struct scalar_abs2_op;"},
{"lineNum":"  193","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_absolute_difference_op;"},
{"lineNum":"  194","line":"template<typename Scalar> struct scalar_sqrt_op;"},
{"lineNum":"  195","line":"template<typename Scalar> struct scalar_rsqrt_op;"},
{"lineNum":"  196","line":"template<typename Scalar> struct scalar_exp_op;"},
{"lineNum":"  197","line":"template<typename Scalar> struct scalar_log_op;"},
{"lineNum":"  198","line":"template<typename Scalar> struct scalar_cos_op;"},
{"lineNum":"  199","line":"template<typename Scalar> struct scalar_sin_op;"},
{"lineNum":"  200","line":"template<typename Scalar> struct scalar_acos_op;"},
{"lineNum":"  201","line":"template<typename Scalar> struct scalar_asin_op;"},
{"lineNum":"  202","line":"template<typename Scalar> struct scalar_tan_op;"},
{"lineNum":"  203","line":"template<typename Scalar> struct scalar_inverse_op;"},
{"lineNum":"  204","line":"template<typename Scalar> struct scalar_square_op;"},
{"lineNum":"  205","line":"template<typename Scalar> struct scalar_cube_op;"},
{"lineNum":"  206","line":"template<typename Scalar, typename NewType> struct scalar_cast_op;"},
{"lineNum":"  207","line":"template<typename Scalar> struct scalar_random_op;"},
{"lineNum":"  208","line":"template<typename Scalar> struct scalar_constant_op;"},
{"lineNum":"  209","line":"template<typename Scalar> struct scalar_identity_op;"},
{"lineNum":"  210","line":"template<typename Scalar,bool is_complex, bool is_integer> struct scalar_sign_op;"},
{"lineNum":"  211","line":"template<typename Scalar,typename ScalarExponent> struct scalar_pow_op;"},
{"lineNum":"  212","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_hypot_op;"},
{"lineNum":"  213","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_product_op;"},
{"lineNum":"  214","line":"template<typename LhsScalar,typename RhsScalar=LhsScalar> struct scalar_quotient_op;"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"// SpecialFunctions module"},
{"lineNum":"  217","line":"template<typename Scalar> struct scalar_lgamma_op;"},
{"lineNum":"  218","line":"template<typename Scalar> struct scalar_digamma_op;"},
{"lineNum":"  219","line":"template<typename Scalar> struct scalar_erf_op;"},
{"lineNum":"  220","line":"template<typename Scalar> struct scalar_erfc_op;"},
{"lineNum":"  221","line":"template<typename Scalar> struct scalar_ndtri_op;"},
{"lineNum":"  222","line":"template<typename Scalar> struct scalar_igamma_op;"},
{"lineNum":"  223","line":"template<typename Scalar> struct scalar_igammac_op;"},
{"lineNum":"  224","line":"template<typename Scalar> struct scalar_zeta_op;"},
{"lineNum":"  225","line":"template<typename Scalar> struct scalar_betainc_op;"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"// Bessel functions in SpecialFunctions module"},
{"lineNum":"  228","line":"template<typename Scalar> struct scalar_bessel_i0_op;"},
{"lineNum":"  229","line":"template<typename Scalar> struct scalar_bessel_i0e_op;"},
{"lineNum":"  230","line":"template<typename Scalar> struct scalar_bessel_i1_op;"},
{"lineNum":"  231","line":"template<typename Scalar> struct scalar_bessel_i1e_op;"},
{"lineNum":"  232","line":"template<typename Scalar> struct scalar_bessel_j0_op;"},
{"lineNum":"  233","line":"template<typename Scalar> struct scalar_bessel_y0_op;"},
{"lineNum":"  234","line":"template<typename Scalar> struct scalar_bessel_j1_op;"},
{"lineNum":"  235","line":"template<typename Scalar> struct scalar_bessel_y1_op;"},
{"lineNum":"  236","line":"template<typename Scalar> struct scalar_bessel_k0_op;"},
{"lineNum":"  237","line":"template<typename Scalar> struct scalar_bessel_k0e_op;"},
{"lineNum":"  238","line":"template<typename Scalar> struct scalar_bessel_k1_op;"},
{"lineNum":"  239","line":"template<typename Scalar> struct scalar_bessel_k1e_op;"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"} // end namespace internal"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"struct IOFormat;"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"// Array module"},
{"lineNum":"  247","line":"template<typename Scalar_, int Rows_, int Cols_,"},
{"lineNum":"  248","line":"         int Options_ = AutoAlign |"},
{"lineNum":"  249","line":"#if EIGEN_GNUC_AT(3,4)"},
{"lineNum":"  250","line":"    // workaround a bug in at least gcc 3.4.6"},
{"lineNum":"  251","line":"    // the innermost ?: ternary operator is misparsed. We write it slightly"},
{"lineNum":"  252","line":"    // differently and this makes gcc 3.4.6 happy, but it\'s ugly."},
{"lineNum":"  253","line":"    // The error would only show up with EIGEN_DEFAULT_TO_ROW_MAJOR is defined"},
{"lineNum":"  254","line":"    // (when EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION is RowMajor)"},
{"lineNum":"  255","line":"                          ( (Rows_==1 && Cols_!=1) ? Eigen::RowMajor"},
{"lineNum":"  256","line":"                          : !(Cols_==1 && Rows_!=1) ?  EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION"},
{"lineNum":"  257","line":"                          : Eigen::ColMajor ),"},
{"lineNum":"  258","line":"#else"},
{"lineNum":"  259","line":"                          ( (Rows_==1 && Cols_!=1) ? Eigen::RowMajor"},
{"lineNum":"  260","line":"                          : (Cols_==1 && Rows_!=1) ? Eigen::ColMajor"},
{"lineNum":"  261","line":"                          : EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION ),"},
{"lineNum":"  262","line":"#endif"},
{"lineNum":"  263","line":"         int MaxRows_ = Rows_, int MaxCols_ = Cols_> class Array;"},
{"lineNum":"  264","line":"template<typename ConditionMatrixType, typename ThenMatrixType, typename ElseMatrixType> class Select;"},
{"lineNum":"  265","line":"template<typename MatrixType, typename BinaryOp, int Direction> class PartialReduxExpr;"},
{"lineNum":"  266","line":"template<typename ExpressionType, int Direction> class VectorwiseOp;"},
{"lineNum":"  267","line":"template<typename MatrixType,int RowFactor,int ColFactor> class Replicate;"},
{"lineNum":"  268","line":"template<typename MatrixType, int Direction = BothDirections> class Reverse;"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"template<typename MatrixType> class FullPivLU;"},
{"lineNum":"  271","line":"template<typename MatrixType> class PartialPivLU;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  272","line":"namespace internal {"},
{"lineNum":"  273","line":"template<typename MatrixType> struct inverse_impl;"},
{"lineNum":"  274","line":"}"},
{"lineNum":"  275","line":"template<typename MatrixType> class HouseholderQR;"},
{"lineNum":"  276","line":"template<typename MatrixType> class ColPivHouseholderQR;"},
{"lineNum":"  277","line":"template<typename MatrixType> class FullPivHouseholderQR;"},
{"lineNum":"  278","line":"template<typename MatrixType> class CompleteOrthogonalDecomposition;"},
{"lineNum":"  279","line":"template<typename MatrixType> class SVDBase;"},
{"lineNum":"  280","line":"template<typename MatrixType, int QRPreconditioner = ColPivHouseholderQRPreconditioner> class JacobiSVD;"},
{"lineNum":"  281","line":"template<typename MatrixType> class BDCSVD;"},
{"lineNum":"  282","line":"template<typename MatrixType, int UpLo = Lower> class LLT;"},
{"lineNum":"  283","line":"template<typename MatrixType, int UpLo = Lower> class LDLT;"},
{"lineNum":"  284","line":"template<typename VectorsType, typename CoeffsType, int Side=OnTheLeft> class HouseholderSequence;"},
{"lineNum":"  285","line":"template<typename Scalar>     class JacobiRotation;"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"// Geometry module:"},
{"lineNum":"  288","line":"template<typename Derived, int Dim_> class RotationBase;"},
{"lineNum":"  289","line":"template<typename Lhs, typename Rhs> class Cross;"},
{"lineNum":"  290","line":"template<typename Derived> class QuaternionBase;"},
{"lineNum":"  291","line":"template<typename Scalar> class Rotation2D;"},
{"lineNum":"  292","line":"template<typename Scalar> class AngleAxis;"},
{"lineNum":"  293","line":"template<typename Scalar,int Dim> class Translation;"},
{"lineNum":"  294","line":"template<typename Scalar,int Dim> class AlignedBox;"},
{"lineNum":"  295","line":"template<typename Scalar, int Options = AutoAlign> class Quaternion;"},
{"lineNum":"  296","line":"template<typename Scalar,int Dim,int Mode,int Options_=AutoAlign> class Transform;"},
{"lineNum":"  297","line":"template <typename Scalar_, int _AmbientDim, int Options=AutoAlign> class ParametrizedLine;"},
{"lineNum":"  298","line":"template <typename Scalar_, int _AmbientDim, int Options=AutoAlign> class Hyperplane;"},
{"lineNum":"  299","line":"template<typename Scalar> class UniformScaling;"},
{"lineNum":"  300","line":"template<typename MatrixType,int Direction> class Homogeneous;"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"// Sparse module:"},
{"lineNum":"  303","line":"template<typename Derived> class SparseMatrixBase;"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"// MatrixFunctions module"},
{"lineNum":"  306","line":"template<typename Derived> struct MatrixExponentialReturnValue;"},
{"lineNum":"  307","line":"template<typename Derived> class MatrixFunctionReturnValue;"},
{"lineNum":"  308","line":"template<typename Derived> class MatrixSquareRootReturnValue;"},
{"lineNum":"  309","line":"template<typename Derived> class MatrixLogarithmReturnValue;"},
{"lineNum":"  310","line":"template<typename Derived> class MatrixPowerReturnValue;"},
{"lineNum":"  311","line":"template<typename Derived> class MatrixComplexPowerReturnValue;"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"namespace internal {"},
{"lineNum":"  314","line":"template <typename Scalar>"},
{"lineNum":"  315","line":"struct stem_function"},
{"lineNum":"  316","line":"{"},
{"lineNum":"  317","line":"  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;"},
{"lineNum":"  318","line":"  typedef ComplexScalar type(ComplexScalar, int);"},
{"lineNum":"  319","line":"};"},
{"lineNum":"  320","line":"}"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"} // end namespace Eigen"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"#endif // EIGEN_FORWARDDECLARATIONS_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 5, "covered" : 0,};
var merged_data = [];
