var data = {lines:[
{"lineNum":"    1","line":"#ifndef BOOST_CORE_REF_HPP"},
{"lineNum":"    2","line":"#define BOOST_CORE_REF_HPP"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"// MS compatible compilers support #pragma once"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"#if defined(_MSC_VER) && (_MSC_VER >= 1020)"},
{"lineNum":"    7","line":"# pragma once"},
{"lineNum":"    8","line":"#endif"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#include <boost/config.hpp>"},
{"lineNum":"   11","line":"#include <boost/config/workaround.hpp>"},
{"lineNum":"   12","line":"#include <boost/core/addressof.hpp>"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"//"},
{"lineNum":"   15","line":"//  ref.hpp - ref/cref, useful helper functions"},
{"lineNum":"   16","line":"//"},
{"lineNum":"   17","line":"//  Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)"},
{"lineNum":"   18","line":"//  Copyright (C) 2001, 2002 Peter Dimov"},
{"lineNum":"   19","line":"//  Copyright (C) 2002 David Abrahams"},
{"lineNum":"   20","line":"//"},
{"lineNum":"   21","line":"//  Copyright (C) 2014 Glen Joseph Fernandes"},
{"lineNum":"   22","line":"//  (glenjofe@gmail.com)"},
{"lineNum":"   23","line":"//"},
{"lineNum":"   24","line":"//  Copyright (C) 2014 Agustin Berge"},
{"lineNum":"   25","line":"//"},
{"lineNum":"   26","line":"// Distributed under the Boost Software License, Version 1.0. (See"},
{"lineNum":"   27","line":"// accompanying file LICENSE_1_0.txt or copy at"},
{"lineNum":"   28","line":"// http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"   29","line":"//"},
{"lineNum":"   30","line":"//  See http://www.boost.org/libs/core/doc/html/core/ref.html for documentation."},
{"lineNum":"   31","line":"//"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"/**"},
{"lineNum":"   34","line":" @file"},
{"lineNum":"   35","line":"*/"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"/**"},
{"lineNum":"   38","line":" Boost namespace."},
{"lineNum":"   39","line":"*/"},
{"lineNum":"   40","line":"namespace boost"},
{"lineNum":"   41","line":"{"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"#if defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, == 1600 )"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"    struct ref_workaround_tag {};"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"#endif"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"// reference_wrapper"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"/**"},
{"lineNum":"   52","line":" @brief Contains a reference to an object of type `T`."},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":" `reference_wrapper` is primarily used to \"feed\" references to"},
{"lineNum":"   55","line":" function templates (algorithms) that take their parameter by"},
{"lineNum":"   56","line":" value. It provides an implicit conversion to `T&`, which"},
{"lineNum":"   57","line":" usually allows the function templates to work on references"},
{"lineNum":"   58","line":" unmodified."},
{"lineNum":"   59","line":"*/"},
{"lineNum":"   60","line":"template<class T> class reference_wrapper"},
{"lineNum":"   61","line":"{"},
{"lineNum":"   62","line":"public:"},
{"lineNum":"   63","line":"    /**"},
{"lineNum":"   64","line":"     Type `T`."},
{"lineNum":"   65","line":"    */"},
{"lineNum":"   66","line":"    typedef T type;"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"    /**"},
{"lineNum":"   69","line":"     Constructs a `reference_wrapper` object that stores a"},
{"lineNum":"   70","line":"     reference to `t`."},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"     @remark Does not throw."},
{"lineNum":"   73","line":"    */"},
{"lineNum":"   74","line":"    BOOST_FORCEINLINE explicit reference_wrapper(T& t): t_(boost::addressof(t)) {}"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"#if defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, == 1600 )"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"    BOOST_FORCEINLINE explicit reference_wrapper( T & t, ref_workaround_tag ): t_( boost::addressof( t ) ) {}"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"#endif"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)"},
{"lineNum":"   83","line":"    /**"},
{"lineNum":"   84","line":"     @remark Construction from a temporary object is disabled."},
{"lineNum":"   85","line":"    */"},
{"lineNum":"   86","line":"    BOOST_DELETED_FUNCTION(reference_wrapper(T&& t))"},
{"lineNum":"   87","line":"public:"},
{"lineNum":"   88","line":"#endif"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"    /**"},
{"lineNum":"   91","line":"     @return The stored reference."},
{"lineNum":"   92","line":"     @remark Does not throw."},
{"lineNum":"   93","line":"    */"},
{"lineNum":"   94","line":"    BOOST_FORCEINLINE operator T& () const { return *t_; }"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"    /**"},
{"lineNum":"   97","line":"     @return The stored reference."},
{"lineNum":"   98","line":"     @remark Does not throw."},
{"lineNum":"   99","line":"    */"},
{"lineNum":"  100","line":"    BOOST_FORCEINLINE T& get() const { return *t_; }","class":"lineNoCov","hits":"0","possible_hits":"91",},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    /**"},
{"lineNum":"  103","line":"     @return A pointer to the object referenced by the stored"},
{"lineNum":"  104","line":"       reference."},
{"lineNum":"  105","line":"     @remark Does not throw."},
{"lineNum":"  106","line":"    */"},
{"lineNum":"  107","line":"    BOOST_FORCEINLINE T* get_pointer() const { return t_; }"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"private:"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"    T* t_;"},
{"lineNum":"  112","line":"};"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"// ref"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"/**"},
{"lineNum":"  117","line":" @cond"},
{"lineNum":"  118","line":"*/"},
{"lineNum":"  119","line":"#if defined( __BORLANDC__ ) && BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x581) )"},
{"lineNum":"  120","line":"#  define BOOST_REF_CONST"},
{"lineNum":"  121","line":"#else"},
{"lineNum":"  122","line":"#  define BOOST_REF_CONST const"},
{"lineNum":"  123","line":"#endif"},
{"lineNum":"  124","line":"/**"},
{"lineNum":"  125","line":" @endcond"},
{"lineNum":"  126","line":"*/"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"/**"},
{"lineNum":"  129","line":" @return `reference_wrapper<T>(t)`"},
{"lineNum":"  130","line":" @remark Does not throw."},
{"lineNum":"  131","line":"*/"},
{"lineNum":"  132","line":"template<class T> BOOST_FORCEINLINE reference_wrapper<T> BOOST_REF_CONST ref( T & t )"},
{"lineNum":"  133","line":"{"},
{"lineNum":"  134","line":"#if defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, == 1600 )"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"    return reference_wrapper<T>( t, ref_workaround_tag() );"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"#else"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"    return reference_wrapper<T>( t );"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"#endif"},
{"lineNum":"  143","line":"}"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"// cref"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"/**"},
{"lineNum":"  148","line":" @return `reference_wrapper<T const>(t)`"},
{"lineNum":"  149","line":" @remark Does not throw."},
{"lineNum":"  150","line":"*/"},
{"lineNum":"  151","line":"template<class T> BOOST_FORCEINLINE reference_wrapper<T const> BOOST_REF_CONST cref( T const & t )"},
{"lineNum":"  152","line":"{"},
{"lineNum":"  153","line":"    return reference_wrapper<T const>(t);"},
{"lineNum":"  154","line":"}"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"#undef BOOST_REF_CONST"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"/**"},
{"lineNum":"  161","line":" @cond"},
{"lineNum":"  162","line":"*/"},
{"lineNum":"  163","line":"#if defined(BOOST_NO_CXX11_DELETED_FUNCTIONS)"},
{"lineNum":"  164","line":"#  define BOOST_REF_DELETE"},
{"lineNum":"  165","line":"#else"},
{"lineNum":"  166","line":"#  define BOOST_REF_DELETE = delete"},
{"lineNum":"  167","line":"#endif"},
{"lineNum":"  168","line":"/**"},
{"lineNum":"  169","line":" @endcond"},
{"lineNum":"  170","line":"*/"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"/**"},
{"lineNum":"  173","line":" @remark Construction from a temporary object is disabled."},
{"lineNum":"  174","line":"*/"},
{"lineNum":"  175","line":"template<class T> void ref(T const&&) BOOST_REF_DELETE;"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"/**"},
{"lineNum":"  178","line":" @remark Construction from a temporary object is disabled."},
{"lineNum":"  179","line":"*/"},
{"lineNum":"  180","line":"template<class T> void cref(T const&&) BOOST_REF_DELETE;"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"#undef BOOST_REF_DELETE"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"#endif"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"// is_reference_wrapper"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"/**"},
{"lineNum":"  189","line":" @brief Determine if a type `T` is an instantiation of"},
{"lineNum":"  190","line":" `reference_wrapper`."},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":" The value static constant will be true if the type `T` is a"},
{"lineNum":"  193","line":" specialization of `reference_wrapper`."},
{"lineNum":"  194","line":"*/"},
{"lineNum":"  195","line":"template<typename T> struct is_reference_wrapper"},
{"lineNum":"  196","line":"{"},
{"lineNum":"  197","line":"    BOOST_STATIC_CONSTANT( bool, value = false );"},
{"lineNum":"  198","line":"};"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"/**"},
{"lineNum":"  201","line":" @cond"},
{"lineNum":"  202","line":"*/"},
{"lineNum":"  203","line":"template<typename T> struct is_reference_wrapper< reference_wrapper<T> >"},
{"lineNum":"  204","line":"{"},
{"lineNum":"  205","line":"    BOOST_STATIC_CONSTANT( bool, value = true );"},
{"lineNum":"  206","line":"};"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"#if !defined(BOOST_NO_CV_SPECIALIZATIONS)"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"template<typename T> struct is_reference_wrapper< reference_wrapper<T> const >"},
{"lineNum":"  211","line":"{"},
{"lineNum":"  212","line":"    BOOST_STATIC_CONSTANT( bool, value = true );"},
{"lineNum":"  213","line":"};"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"template<typename T> struct is_reference_wrapper< reference_wrapper<T> volatile >"},
{"lineNum":"  216","line":"{"},
{"lineNum":"  217","line":"    BOOST_STATIC_CONSTANT( bool, value = true );"},
{"lineNum":"  218","line":"};"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"template<typename T> struct is_reference_wrapper< reference_wrapper<T> const volatile >"},
{"lineNum":"  221","line":"{"},
{"lineNum":"  222","line":"    BOOST_STATIC_CONSTANT( bool, value = true );"},
{"lineNum":"  223","line":"};"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"#endif // !defined(BOOST_NO_CV_SPECIALIZATIONS)"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"/**"},
{"lineNum":"  228","line":" @endcond"},
{"lineNum":"  229","line":"*/"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"// unwrap_reference"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"/**"},
{"lineNum":"  235","line":" @brief Find the type in a `reference_wrapper`."},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":" The `typedef` type is `T::type` if `T` is a"},
{"lineNum":"  238","line":" `reference_wrapper`, `T` otherwise."},
{"lineNum":"  239","line":"*/"},
{"lineNum":"  240","line":"template<typename T> struct unwrap_reference"},
{"lineNum":"  241","line":"{"},
{"lineNum":"  242","line":"    typedef T type;"},
{"lineNum":"  243","line":"};"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"/**"},
{"lineNum":"  246","line":" @cond"},
{"lineNum":"  247","line":"*/"},
{"lineNum":"  248","line":"template<typename T> struct unwrap_reference< reference_wrapper<T> >"},
{"lineNum":"  249","line":"{"},
{"lineNum":"  250","line":"    typedef T type;"},
{"lineNum":"  251","line":"};"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"#if !defined(BOOST_NO_CV_SPECIALIZATIONS)"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"template<typename T> struct unwrap_reference< reference_wrapper<T> const >"},
{"lineNum":"  256","line":"{"},
{"lineNum":"  257","line":"    typedef T type;"},
{"lineNum":"  258","line":"};"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"template<typename T> struct unwrap_reference< reference_wrapper<T> volatile >"},
{"lineNum":"  261","line":"{"},
{"lineNum":"  262","line":"    typedef T type;"},
{"lineNum":"  263","line":"};"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"template<typename T> struct unwrap_reference< reference_wrapper<T> const volatile >"},
{"lineNum":"  266","line":"{"},
{"lineNum":"  267","line":"    typedef T type;"},
{"lineNum":"  268","line":"};"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"#endif // !defined(BOOST_NO_CV_SPECIALIZATIONS)"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"/**"},
{"lineNum":"  273","line":" @endcond"},
{"lineNum":"  274","line":"*/"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"// unwrap_ref"},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"/**"},
{"lineNum":"  279","line":" @return `unwrap_reference<T>::type&(t)`"},
{"lineNum":"  280","line":" @remark Does not throw."},
{"lineNum":"  281","line":"*/"},
{"lineNum":"  282","line":"template<class T> BOOST_FORCEINLINE typename unwrap_reference<T>::type& unwrap_ref( T & t )"},
{"lineNum":"  283","line":"{"},
{"lineNum":"  284","line":"    return t;"},
{"lineNum":"  285","line":"}"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"// get_pointer"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"/**"},
{"lineNum":"  290","line":" @cond"},
{"lineNum":"  291","line":"*/"},
{"lineNum":"  292","line":"template<class T> BOOST_FORCEINLINE T* get_pointer( reference_wrapper<T> const & r )"},
{"lineNum":"  293","line":"{"},
{"lineNum":"  294","line":"    return r.get_pointer();"},
{"lineNum":"  295","line":"}"},
{"lineNum":"  296","line":"/**"},
{"lineNum":"  297","line":" @endcond"},
{"lineNum":"  298","line":"*/"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"} // namespace boost"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"#endif // #ifndef BOOST_CORE_REF_HPP"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
