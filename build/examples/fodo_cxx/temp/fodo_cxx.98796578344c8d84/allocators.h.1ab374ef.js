var data = {lines:[
{"lineNum":"    1","line":"// Tencent is pleased to support the open source community by making RapidJSON available."},
{"lineNum":"    2","line":"//"},
{"lineNum":"    3","line":"// Copyright (C) 2015 THL A29 Limited, a Tencent company, and Milo Yip. All rights reserved."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// Licensed under the MIT License (the \"License\"); you may not use this file except"},
{"lineNum":"    6","line":"// in compliance with the License. You may obtain a copy of the License at"},
{"lineNum":"    7","line":"//"},
{"lineNum":"    8","line":"// http://opensource.org/licenses/MIT"},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// Unless required by applicable law or agreed to in writing, software distributed"},
{"lineNum":"   11","line":"// under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR"},
{"lineNum":"   12","line":"// CONDITIONS OF ANY KIND, either express or implied. See the License for the"},
{"lineNum":"   13","line":"// specific language governing permissions and limitations under the License."},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"#ifndef CEREAL_RAPIDJSON_ALLOCATORS_H_"},
{"lineNum":"   16","line":"#define CEREAL_RAPIDJSON_ALLOCATORS_H_"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"#include \"rapidjson.h\""},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"CEREAL_RAPIDJSON_NAMESPACE_BEGIN"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"   23","line":"// Allocator"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"/*! \\class rapidjson::Allocator"},
{"lineNum":"   26","line":"    \\brief Concept for allocating, resizing and freeing memory block."},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"    Note that Malloc() and Realloc() are non-static but Free() is static."},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"    So if an allocator need to support Free(), it needs to put its pointer in"},
{"lineNum":"   31","line":"    the header of memory block."},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"\\code"},
{"lineNum":"   34","line":"concept Allocator {"},
{"lineNum":"   35","line":"    static const bool kNeedFree;    //!< Whether this allocator needs to call Free()."},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"    // Allocate a memory block."},
{"lineNum":"   38","line":"    // \\param size of the memory block in bytes."},
{"lineNum":"   39","line":"    // \\returns pointer to the memory block."},
{"lineNum":"   40","line":"    void* Malloc(size_t size);"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"    // Resize a memory block."},
{"lineNum":"   43","line":"    // \\param originalPtr The pointer to current memory block. Null pointer is permitted."},
{"lineNum":"   44","line":"    // \\param originalSize The current size in bytes. (Design issue: since some allocator may not book-keep this, explicitly pass to it can save memory.)"},
{"lineNum":"   45","line":"    // \\param newSize the new size in bytes."},
{"lineNum":"   46","line":"    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize);"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"    // Free a memory block."},
{"lineNum":"   49","line":"    // \\param pointer to the memory block. Null pointer is permitted."},
{"lineNum":"   50","line":"    static void Free(void *ptr);"},
{"lineNum":"   51","line":"};"},
{"lineNum":"   52","line":"\\endcode"},
{"lineNum":"   53","line":"*/"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"/*! \\def CEREAL_RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY"},
{"lineNum":"   57","line":"    \\ingroup CEREAL_RAPIDJSON_CONFIG"},
{"lineNum":"   58","line":"    \\brief User-defined kDefaultChunkCapacity definition."},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"    User can define this as any \\c size that is a power of 2."},
{"lineNum":"   61","line":"*/"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"#ifndef CEREAL_RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY"},
{"lineNum":"   64","line":"#define CEREAL_RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY (64 * 1024)"},
{"lineNum":"   65","line":"#endif"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"   69","line":"// CrtAllocator"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"//! C-runtime library allocator."},
{"lineNum":"   72","line":"/*! This class is just wrapper for standard C library memory routines."},
{"lineNum":"   73","line":"    \\note implements Allocator concept"},
{"lineNum":"   74","line":"*/"},
{"lineNum":"   75","line":"class CrtAllocator {"},
{"lineNum":"   76","line":"public:"},
{"lineNum":"   77","line":"    static const bool kNeedFree = true;"},
{"lineNum":"   78","line":"    void* Malloc(size_t size) {"},
{"lineNum":"   79","line":"        if (size) //  behavior of malloc(0) is implementation defined.","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   80","line":"            return std::malloc(size);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   81","line":"        else"},
{"lineNum":"   82","line":"            return NULL; // standardize to returning NULL."},
{"lineNum":"   83","line":"    }"},
{"lineNum":"   84","line":"    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) {"},
{"lineNum":"   85","line":"        (void)originalSize;"},
{"lineNum":"   86","line":"        if (newSize == 0) {","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"   87","line":"            std::free(originalPtr);","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"   88","line":"            return NULL;"},
{"lineNum":"   89","line":"        }"},
{"lineNum":"   90","line":"        return std::realloc(originalPtr, newSize);","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"   91","line":"    }"},
{"lineNum":"   92","line":"    static void Free(void *ptr) { std::free(ptr); }","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"   93","line":"};"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"   96","line":"// MemoryPoolAllocator"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"//! Default memory allocator used by the parser and DOM."},
{"lineNum":"   99","line":"/*! This allocator allocate memory blocks from pre-allocated memory chunks."},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"    It does not free memory blocks. And Realloc() only allocate new memory."},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"    The memory chunks are allocated by BaseAllocator, which is CrtAllocator by default."},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"    User may also supply a buffer as the first chunk."},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"    If the user-buffer is full then additional chunks are allocated by BaseAllocator."},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    The user-buffer is not deallocated by this allocator."},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"    \\tparam BaseAllocator the allocator type for allocating memory chunks. Default is CrtAllocator."},
{"lineNum":"  112","line":"    \\note implements Allocator concept"},
{"lineNum":"  113","line":"*/"},
{"lineNum":"  114","line":"template <typename BaseAllocator = CrtAllocator>"},
{"lineNum":"  115","line":"class MemoryPoolAllocator {"},
{"lineNum":"  116","line":"public:"},
{"lineNum":"  117","line":"    static const bool kNeedFree = false;    //!< Tell users that no need to call Free() with this allocator. (concept Allocator)"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    //! Constructor with chunkSize."},
{"lineNum":"  120","line":"    /*! \\param chunkSize The size of memory chunk. The default is kDefaultChunkSize."},
{"lineNum":"  121","line":"        \\param baseAllocator The allocator for allocating memory chunks."},
{"lineNum":"  122","line":"    */"},
{"lineNum":"  123","line":"    MemoryPoolAllocator(size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) :"},
{"lineNum":"  124","line":"        chunkHead_(0), chunk_capacity_(chunkSize), userBuffer_(0), baseAllocator_(baseAllocator), ownBaseAllocator_(0)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  125","line":"    {"},
{"lineNum":"  126","line":"    }"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"    //! Constructor with user-supplied buffer."},
{"lineNum":"  129","line":"    /*! The user buffer will be used firstly. When it is full, memory pool allocates new chunk with chunk size."},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"        The user buffer will not be deallocated when this allocator is destructed."},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"        \\param buffer User supplied buffer."},
{"lineNum":"  134","line":"        \\param size Size of the buffer in bytes. It must at least larger than sizeof(ChunkHeader)."},
{"lineNum":"  135","line":"        \\param chunkSize The size of memory chunk. The default is kDefaultChunkSize."},
{"lineNum":"  136","line":"        \\param baseAllocator The allocator for allocating memory chunks."},
{"lineNum":"  137","line":"    */"},
{"lineNum":"  138","line":"    MemoryPoolAllocator(void *buffer, size_t size, size_t chunkSize = kDefaultChunkCapacity, BaseAllocator* baseAllocator = 0) :"},
{"lineNum":"  139","line":"        chunkHead_(0), chunk_capacity_(chunkSize), userBuffer_(buffer), baseAllocator_(baseAllocator), ownBaseAllocator_(0)"},
{"lineNum":"  140","line":"    {"},
{"lineNum":"  141","line":"        CEREAL_RAPIDJSON_ASSERT(buffer != 0);"},
{"lineNum":"  142","line":"        CEREAL_RAPIDJSON_ASSERT(size > sizeof(ChunkHeader));"},
{"lineNum":"  143","line":"        chunkHead_ = reinterpret_cast<ChunkHeader*>(buffer);"},
{"lineNum":"  144","line":"        chunkHead_->capacity = size - sizeof(ChunkHeader);"},
{"lineNum":"  145","line":"        chunkHead_->size = 0;"},
{"lineNum":"  146","line":"        chunkHead_->next = 0;"},
{"lineNum":"  147","line":"    }"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"    //! Destructor."},
{"lineNum":"  150","line":"    /*! This deallocates all memory chunks, excluding the user-supplied buffer."},
{"lineNum":"  151","line":"    */"},
{"lineNum":"  152","line":"    ~MemoryPoolAllocator() {"},
{"lineNum":"  153","line":"        Clear();"},
{"lineNum":"  154","line":"        CEREAL_RAPIDJSON_DELETE(ownBaseAllocator_);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  155","line":"    }"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"    //! Deallocates all memory chunks, excluding the user-supplied buffer."},
{"lineNum":"  158","line":"    void Clear() {"},
{"lineNum":"  159","line":"        while (chunkHead_ && chunkHead_ != userBuffer_) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  160","line":"            ChunkHeader* next = chunkHead_->next;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  161","line":"            baseAllocator_->Free(chunkHead_);"},
{"lineNum":"  162","line":"            chunkHead_ = next;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  163","line":"        }"},
{"lineNum":"  164","line":"        if (chunkHead_ && chunkHead_ == userBuffer_)"},
{"lineNum":"  165","line":"            chunkHead_->size = 0; // Clear user buffer","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  166","line":"    }"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"    //! Computes the total capacity of allocated memory chunks."},
{"lineNum":"  169","line":"    /*! \\return total capacity in bytes."},
{"lineNum":"  170","line":"    */"},
{"lineNum":"  171","line":"    size_t Capacity() const {"},
{"lineNum":"  172","line":"        size_t capacity = 0;"},
{"lineNum":"  173","line":"        for (ChunkHeader* c = chunkHead_; c != 0; c = c->next)"},
{"lineNum":"  174","line":"            capacity += c->capacity;"},
{"lineNum":"  175","line":"        return capacity;"},
{"lineNum":"  176","line":"    }"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"    //! Computes the memory blocks allocated."},
{"lineNum":"  179","line":"    /*! \\return total used bytes."},
{"lineNum":"  180","line":"    */"},
{"lineNum":"  181","line":"    size_t Size() const {"},
{"lineNum":"  182","line":"        size_t size = 0;"},
{"lineNum":"  183","line":"        for (ChunkHeader* c = chunkHead_; c != 0; c = c->next)"},
{"lineNum":"  184","line":"            size += c->size;"},
{"lineNum":"  185","line":"        return size;"},
{"lineNum":"  186","line":"    }"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"    //! Allocates a memory block. (concept Allocator)"},
{"lineNum":"  189","line":"    void* Malloc(size_t size) {"},
{"lineNum":"  190","line":"        if (!size)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  191","line":"            return NULL;"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"        size = CEREAL_RAPIDJSON_ALIGN(size);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  194","line":"        if (chunkHead_ == 0 || chunkHead_->size + size > chunkHead_->capacity)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  195","line":"            if (!AddChunk(chunk_capacity_ > size ? chunk_capacity_ : size))","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  196","line":"                return NULL;"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"        void *buffer = reinterpret_cast<char *>(chunkHead_) + CEREAL_RAPIDJSON_ALIGN(sizeof(ChunkHeader)) + chunkHead_->size;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  199","line":"        chunkHead_->size += size;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  200","line":"        return buffer;"},
{"lineNum":"  201","line":"    }"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"    //! Resizes a memory block (concept Allocator)"},
{"lineNum":"  204","line":"    void* Realloc(void* originalPtr, size_t originalSize, size_t newSize) {"},
{"lineNum":"  205","line":"        if (originalPtr == 0)"},
{"lineNum":"  206","line":"            return Malloc(newSize);"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"        if (newSize == 0)"},
{"lineNum":"  209","line":"            return NULL;"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"        originalSize = CEREAL_RAPIDJSON_ALIGN(originalSize);"},
{"lineNum":"  212","line":"        newSize = CEREAL_RAPIDJSON_ALIGN(newSize);"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"        // Do not shrink if new size is smaller than original"},
{"lineNum":"  215","line":"        if (originalSize >= newSize)"},
{"lineNum":"  216","line":"            return originalPtr;"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"        // Simply expand it if it is the last allocation and there is sufficient space"},
{"lineNum":"  219","line":"        if (originalPtr == reinterpret_cast<char *>(chunkHead_) + CEREAL_RAPIDJSON_ALIGN(sizeof(ChunkHeader)) + chunkHead_->size - originalSize) {"},
{"lineNum":"  220","line":"            size_t increment = static_cast<size_t>(newSize - originalSize);"},
{"lineNum":"  221","line":"            if (chunkHead_->size + increment <= chunkHead_->capacity) {"},
{"lineNum":"  222","line":"                chunkHead_->size += increment;"},
{"lineNum":"  223","line":"                return originalPtr;"},
{"lineNum":"  224","line":"            }"},
{"lineNum":"  225","line":"        }"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"        // Realloc process: allocate and copy memory, do not free original buffer."},
{"lineNum":"  228","line":"        if (void* newBuffer = Malloc(newSize)) {"},
{"lineNum":"  229","line":"            if (originalSize)"},
{"lineNum":"  230","line":"                std::memcpy(newBuffer, originalPtr, originalSize);"},
{"lineNum":"  231","line":"            return newBuffer;"},
{"lineNum":"  232","line":"        }"},
{"lineNum":"  233","line":"        else"},
{"lineNum":"  234","line":"            return NULL;"},
{"lineNum":"  235","line":"    }"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"    //! Frees a memory block (concept Allocator)"},
{"lineNum":"  238","line":"    static void Free(void *ptr) { (void)ptr; } // Do nothing"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"private:"},
{"lineNum":"  241","line":"    //! Copy constructor is not permitted."},
{"lineNum":"  242","line":"    MemoryPoolAllocator(const MemoryPoolAllocator& rhs) /* = delete */;"},
{"lineNum":"  243","line":"    //! Copy assignment operator is not permitted."},
{"lineNum":"  244","line":"    MemoryPoolAllocator& operator=(const MemoryPoolAllocator& rhs) /* = delete */;"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"    //! Creates a new chunk."},
{"lineNum":"  247","line":"    /*! \\param capacity Capacity of the chunk in bytes."},
{"lineNum":"  248","line":"        \\return true if success."},
{"lineNum":"  249","line":"    */"},
{"lineNum":"  250","line":"    bool AddChunk(size_t capacity) {"},
{"lineNum":"  251","line":"        if (!baseAllocator_)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  252","line":"            ownBaseAllocator_ = baseAllocator_ = CEREAL_RAPIDJSON_NEW(BaseAllocator)();","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  253","line":"        if (ChunkHeader* chunk = reinterpret_cast<ChunkHeader*>(baseAllocator_->Malloc(CEREAL_RAPIDJSON_ALIGN(sizeof(ChunkHeader)) + capacity))) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  254","line":"            chunk->capacity = capacity;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  255","line":"            chunk->size = 0;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  256","line":"            chunk->next = chunkHead_;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  257","line":"            chunkHead_ =  chunk;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  258","line":"            return true;"},
{"lineNum":"  259","line":"        }"},
{"lineNum":"  260","line":"        else"},
{"lineNum":"  261","line":"            return false;"},
{"lineNum":"  262","line":"    }"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"    static const int kDefaultChunkCapacity = CEREAL_RAPIDJSON_ALLOCATOR_DEFAULT_CHUNK_CAPACITY; //!< Default chunk capacity."},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"    //! Chunk header for perpending to each chunk."},
{"lineNum":"  267","line":"    /*! Chunks are stored as a singly linked list."},
{"lineNum":"  268","line":"    */"},
{"lineNum":"  269","line":"    struct ChunkHeader {"},
{"lineNum":"  270","line":"        size_t capacity;    //!< Capacity of the chunk in bytes (excluding the header itself)."},
{"lineNum":"  271","line":"        size_t size;        //!< Current size of allocated memory in bytes."},
{"lineNum":"  272","line":"        ChunkHeader *next;  //!< Next chunk in the linked list."},
{"lineNum":"  273","line":"    };"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"    ChunkHeader *chunkHead_;    //!< Head of the chunk linked-list. Only the head chunk serves allocation."},
{"lineNum":"  276","line":"    size_t chunk_capacity_;     //!< The minimum capacity of chunk when they are allocated."},
{"lineNum":"  277","line":"    void *userBuffer_;          //!< User supplied buffer."},
{"lineNum":"  278","line":"    BaseAllocator* baseAllocator_;  //!< base allocator for allocating memory chunks."},
{"lineNum":"  279","line":"    BaseAllocator* ownBaseAllocator_;   //!< base allocator created by this object."},
{"lineNum":"  280","line":"};"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"CEREAL_RAPIDJSON_NAMESPACE_END"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"#endif // CEREAL_RAPIDJSON_ENCODINGS_H_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 25, "covered" : 0,};
var merged_data = [];
