var data = {lines:[
{"lineNum":"    1","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"    2","line":"/// \\file proto_fwd.hpp"},
{"lineNum":"    3","line":"/// Forward declarations of all of proto\'s public types and functions."},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//  Copyright 2008 Eric Niebler. Distributed under the Boost"},
{"lineNum":"    6","line":"//  Software License, Version 1.0. (See accompanying file"},
{"lineNum":"    7","line":"//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"#ifndef BOOST_PROTO_FWD_HPP_EAN_04_01_2005"},
{"lineNum":"   10","line":"#define BOOST_PROTO_FWD_HPP_EAN_04_01_2005"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"#include <cstddef>"},
{"lineNum":"   13","line":"#include <climits>"},
{"lineNum":"   14","line":"#include <boost/config.hpp>"},
{"lineNum":"   15","line":"#include <boost/detail/workaround.hpp>"},
{"lineNum":"   16","line":"#include <boost/preprocessor/cat.hpp>"},
{"lineNum":"   17","line":"#include <boost/preprocessor/arithmetic/inc.hpp>"},
{"lineNum":"   18","line":"#include <boost/preprocessor/punctuation/comma.hpp>"},
{"lineNum":"   19","line":"#include <boost/preprocessor/repetition/enum_params.hpp>"},
{"lineNum":"   20","line":"#include <boost/preprocessor/repetition/enum_params_with_a_default.hpp>"},
{"lineNum":"   21","line":"#include <boost/preprocessor/repetition/enum_trailing_binary_params.hpp>"},
{"lineNum":"   22","line":"#include <boost/preprocessor/repetition/repeat_from_to.hpp>"},
{"lineNum":"   23","line":"#include <boost/ref.hpp>"},
{"lineNum":"   24","line":"#include <boost/mpl/long.hpp>"},
{"lineNum":"   25","line":"#include <boost/type_traits/remove_const.hpp>"},
{"lineNum":"   26","line":"#include <boost/type_traits/remove_reference.hpp>"},
{"lineNum":"   27","line":"#include <boost/mpl/aux_/config/ttp.hpp>"},
{"lineNum":"   28","line":"#include <boost/utility/result_of.hpp>"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"#ifndef BOOST_PROTO_MAX_ARITY"},
{"lineNum":"   31","line":"# define BOOST_PROTO_MAX_ARITY 10"},
{"lineNum":"   32","line":"#endif"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"#ifndef BOOST_PROTO_MAX_LOGICAL_ARITY"},
{"lineNum":"   35","line":"# define BOOST_PROTO_MAX_LOGICAL_ARITY 10"},
{"lineNum":"   36","line":"#endif"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"#ifndef BOOST_PROTO_MAX_FUNCTION_CALL_ARITY"},
{"lineNum":"   39","line":"# define BOOST_PROTO_MAX_FUNCTION_CALL_ARITY BOOST_PROTO_MAX_ARITY"},
{"lineNum":"   40","line":"#endif"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"#if BOOST_PROTO_MAX_ARITY < 3"},
{"lineNum":"   43","line":"# error BOOST_PROTO_MAX_ARITY must be at least 3"},
{"lineNum":"   44","line":"#endif"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"#if BOOST_PROTO_MAX_FUNCTION_CALL_ARITY > BOOST_PROTO_MAX_ARITY"},
{"lineNum":"   47","line":"# error BOOST_PROTO_MAX_FUNCTION_CALL_ARITY cannot be larger than BOOST_PROTO_MAX_ARITY"},
{"lineNum":"   48","line":"#endif"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"#ifndef BOOST_PROTO_DONT_USE_PREPROCESSED_FILES"},
{"lineNum":"   51","line":"  #if 10 < BOOST_PROTO_MAX_ARITY ||                                                                 \\"},
{"lineNum":"   52","line":"      10 < BOOST_PROTO_MAX_LOGICAL_ARITY ||                                                         \\"},
{"lineNum":"   53","line":"      10 < BOOST_PROTO_MAX_FUNCTION_CALL_ARITY"},
{"lineNum":"   54","line":"    #define BOOST_PROTO_DONT_USE_PREPROCESSED_FILES"},
{"lineNum":"   55","line":"  #endif"},
{"lineNum":"   56","line":"#endif"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"#ifndef BOOST_PROTO_BROKEN_CONST_OVERLOADS"},
{"lineNum":"   59","line":"# if BOOST_WORKAROUND(__GNUC__, == 3) \\"},
{"lineNum":"   60","line":"  || BOOST_WORKAROUND(__EDG_VERSION__, BOOST_TESTED_AT(310))"},
{"lineNum":"   61","line":"#  define BOOST_PROTO_BROKEN_CONST_OVERLOADS"},
{"lineNum":"   62","line":"# endif"},
{"lineNum":"   63","line":"#endif"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"#ifndef BOOST_PROTO_BROKEN_CONST_QUALIFIED_FUNCTIONS"},
{"lineNum":"   66","line":"# if BOOST_WORKAROUND(__GNUC__, == 3) \\"},
{"lineNum":"   67","line":"  || BOOST_WORKAROUND(__EDG_VERSION__, BOOST_TESTED_AT(310))"},
{"lineNum":"   68","line":"#  define BOOST_PROTO_BROKEN_CONST_QUALIFIED_FUNCTIONS"},
{"lineNum":"   69","line":"# endif"},
{"lineNum":"   70","line":"#endif"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"#ifdef BOOST_PROTO_BROKEN_CONST_OVERLOADS"},
{"lineNum":"   73","line":"# include <boost/utility/enable_if.hpp>"},
{"lineNum":"   74","line":"# include <boost/type_traits/is_const.hpp>"},
{"lineNum":"   75","line":"# define BOOST_PROTO_DISABLE_IF_IS_CONST(T)\\"},
{"lineNum":"   76","line":"    , typename boost::disable_if_c<boost::is_const<T>::value, boost::proto::detail::undefined>::type * = 0"},
{"lineNum":"   77","line":"#else"},
{"lineNum":"   78","line":"# define BOOST_PROTO_DISABLE_IF_IS_CONST(T)"},
{"lineNum":"   79","line":"#endif"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"#ifdef BOOST_PROTO_BROKEN_CONST_QUALIFIED_FUNCTIONS"},
{"lineNum":"   82","line":"# include <boost/utility/enable_if.hpp>"},
{"lineNum":"   83","line":"# include <boost/type_traits/is_function.hpp>"},
{"lineNum":"   84","line":"# define BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T)\\"},
{"lineNum":"   85","line":"    , typename boost::disable_if_c<boost::is_function<T>::value, boost::proto::detail::undefined>::type * = 0"},
{"lineNum":"   86","line":"#else"},
{"lineNum":"   87","line":"# define BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T)"},
{"lineNum":"   88","line":"#endif"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"#ifndef BOOST_PROTO_BROKEN_PTS"},
{"lineNum":"   91","line":"# if BOOST_WORKAROUND(BOOST_MSVC, <= 1400)"},
{"lineNum":"   92","line":"#  define BOOST_PROTO_BROKEN_PTS"},
{"lineNum":"   93","line":"# endif"},
{"lineNum":"   94","line":"#endif"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"#ifdef BOOST_NO_CXX11_DECLTYPE_N3276"},
{"lineNum":"   97","line":"# // Proto can only use the decltype-based result_of if N3276 has been"},
{"lineNum":"   98","line":"# // implemented by the compiler."},
{"lineNum":"   99","line":"# // See http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2011/n3276.pdf"},
{"lineNum":"  100","line":"# ifndef BOOST_PROTO_USE_NORMAL_RESULT_OF"},
{"lineNum":"  101","line":"#  define BOOST_PROTO_USE_NORMAL_RESULT_OF"},
{"lineNum":"  102","line":"# endif"},
{"lineNum":"  103","line":"#endif"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"// Unless compiler support is there, use tr1_result_of instead of"},
{"lineNum":"  106","line":"// result_of to avoid the problems addressed by N3276."},
{"lineNum":"  107","line":"#ifdef BOOST_PROTO_USE_NORMAL_RESULT_OF"},
{"lineNum":"  108","line":"# define BOOST_PROTO_RESULT_OF boost::result_of"},
{"lineNum":"  109","line":"#else"},
{"lineNum":"  110","line":"# define BOOST_PROTO_RESULT_OF boost::tr1_result_of"},
{"lineNum":"  111","line":"#endif"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"// If we\'re using the decltype-based result_of, we need to be a bit"},
{"lineNum":"  114","line":"// stricter about the return types of some functions."},
{"lineNum":"  115","line":"#if defined(BOOST_RESULT_OF_USE_DECLTYPE) && defined(BOOST_PROTO_USE_NORMAL_RESULT_OF)"},
{"lineNum":"  116","line":"# define BOOST_PROTO_STRICT_RESULT_OF"},
{"lineNum":"  117","line":"# define BOOST_PROTO_RETURN_TYPE_STRICT_LOOSE(X, Y) X"},
{"lineNum":"  118","line":"#else"},
{"lineNum":"  119","line":"# define BOOST_PROTO_RETURN_TYPE_STRICT_LOOSE(X, Y) Y"},
{"lineNum":"  120","line":"#endif"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"#ifdef BOOST_MPL_CFG_EXTENDED_TEMPLATE_PARAMETERS_MATCHING"},
{"lineNum":"  123","line":"# define BOOST_PROTO_EXTENDED_TEMPLATE_PARAMETERS_MATCHING"},
{"lineNum":"  124","line":"#endif"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"#if defined(_MSC_VER)"},
{"lineNum":"  127","line":"# define BOOST_PROTO_DISABLE_MSVC_C4522 __pragma(warning(disable : 4522))  // \'class\' : multiple assignment operators specified"},
{"lineNum":"  128","line":"# define BOOST_PROTO_DISABLE_MSVC_C4714 __pragma(warning(disable : 4714))  // function \'xxx\' marked as __forceinline not inlined"},
{"lineNum":"  129","line":"#else"},
{"lineNum":"  130","line":"# define BOOST_PROTO_DISABLE_MSVC_C4522"},
{"lineNum":"  131","line":"# define BOOST_PROTO_DISABLE_MSVC_C4714"},
{"lineNum":"  132","line":"#endif"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"namespace boost { namespace proto"},
{"lineNum":"  135","line":"{"},
{"lineNum":"  136","line":"    namespace detail"},
{"lineNum":"  137","line":"    {"},
{"lineNum":"  138","line":"        typedef char yes_type;"},
{"lineNum":"  139","line":"        typedef char (&no_type)[2];"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"        template<int N>"},
{"lineNum":"  142","line":"        struct sized_type"},
{"lineNum":"  143","line":"        {"},
{"lineNum":"  144","line":"            typedef char (&type)[N];"},
{"lineNum":"  145","line":"        };"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"        struct dont_care;"},
{"lineNum":"  148","line":"        struct undefined; // leave this undefined"},
{"lineNum":"  149","line":"        struct not_a_valid_type;"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"        struct private_type_"},
{"lineNum":"  152","line":"        {"},
{"lineNum":"  153","line":"            private_type_ operator ,(int) const;"},
{"lineNum":"  154","line":"        };"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"        template<typename T>"},
{"lineNum":"  157","line":"        struct uncvref"},
{"lineNum":"  158","line":"        {"},
{"lineNum":"  159","line":"            typedef T type;"},
{"lineNum":"  160","line":"        };"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"        template<typename T>"},
{"lineNum":"  163","line":"        struct uncvref<T const>"},
{"lineNum":"  164","line":"        {"},
{"lineNum":"  165","line":"            typedef T type;"},
{"lineNum":"  166","line":"        };"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"        template<typename T>"},
{"lineNum":"  169","line":"        struct uncvref<T &>"},
{"lineNum":"  170","line":"        {"},
{"lineNum":"  171","line":"            typedef T type;"},
{"lineNum":"  172","line":"        };"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"        template<typename T>"},
{"lineNum":"  175","line":"        struct uncvref<T const &>"},
{"lineNum":"  176","line":"        {"},
{"lineNum":"  177","line":"            typedef T type;"},
{"lineNum":"  178","line":"        };"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"        template<typename T, std::size_t N>"},
{"lineNum":"  181","line":"        struct uncvref<T const[N]>"},
{"lineNum":"  182","line":"        {"},
{"lineNum":"  183","line":"            typedef T type[N];"},
{"lineNum":"  184","line":"        };"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"        template<typename T, std::size_t N>"},
{"lineNum":"  187","line":"        struct uncvref<T (&)[N]>"},
{"lineNum":"  188","line":"        {"},
{"lineNum":"  189","line":"            typedef T type[N];"},
{"lineNum":"  190","line":"        };"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"        template<typename T, std::size_t N>"},
{"lineNum":"  193","line":"        struct uncvref<T const (&)[N]>"},
{"lineNum":"  194","line":"        {"},
{"lineNum":"  195","line":"            typedef T type[N];"},
{"lineNum":"  196","line":"        };"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"        struct ignore"},
{"lineNum":"  199","line":"        {"},
{"lineNum":"  200","line":"            ignore()"},
{"lineNum":"  201","line":"            {}"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"            template<typename T>"},
{"lineNum":"  204","line":"            ignore(T const &)"},
{"lineNum":"  205","line":"            {}"},
{"lineNum":"  206","line":"        };"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"        /// INTERNAL ONLY"},
{"lineNum":"  209","line":"        ///"},
{"lineNum":"  210","line":"        #define BOOST_PROTO_UNCVREF(X)                                                              \\"},
{"lineNum":"  211","line":"            typename boost::proto::detail::uncvref<X>::type                                         \\"},
{"lineNum":"  212","line":"            /**/"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"        struct _default;"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"        struct not_a_domain;"},
{"lineNum":"  217","line":"        struct not_a_grammar;"},
{"lineNum":"  218","line":"        struct not_a_generator;"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"        template<typename T, typename Void = void>"},
{"lineNum":"  221","line":"        struct is_transform_;"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"        template<typename T, typename Void = void>"},
{"lineNum":"  224","line":"        struct is_aggregate_;"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"        template<typename Expr>"},
{"lineNum":"  227","line":"        struct flat_view;"},
{"lineNum":"  228","line":"    }"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    typedef detail::ignore const ignore;"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"    namespace argsns_"},
{"lineNum":"  233","line":"    {"},
{"lineNum":"  234","line":"        template<typename Arg0>"},
{"lineNum":"  235","line":"        struct term;"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"        #define M0(Z, N, DATA)                                                                      \\"},
{"lineNum":"  238","line":"        template<BOOST_PP_ENUM_PARAMS_Z(Z, N, typename Arg)> struct BOOST_PP_CAT(list, N);          \\"},
{"lineNum":"  239","line":"        /**/"},
{"lineNum":"  240","line":"        BOOST_PP_REPEAT_FROM_TO(1, BOOST_PP_INC(BOOST_PROTO_MAX_ARITY), M0, ~)"},
{"lineNum":"  241","line":"        #undef M0"},
{"lineNum":"  242","line":"    }"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"    using namespace argsns_;"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"    ///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  247","line":"    // Operator tags"},
{"lineNum":"  248","line":"    namespace tagns_"},
{"lineNum":"  249","line":"    {"},
{"lineNum":"  250","line":"        namespace tag"},
{"lineNum":"  251","line":"        {"},
{"lineNum":"  252","line":"            struct terminal;"},
{"lineNum":"  253","line":"            struct unary_plus;"},
{"lineNum":"  254","line":"            struct negate;"},
{"lineNum":"  255","line":"            struct dereference;"},
{"lineNum":"  256","line":"            struct complement;"},
{"lineNum":"  257","line":"            struct address_of;"},
{"lineNum":"  258","line":"            struct logical_not;"},
{"lineNum":"  259","line":"            struct pre_inc;"},
{"lineNum":"  260","line":"            struct pre_dec;"},
{"lineNum":"  261","line":"            struct post_inc;"},
{"lineNum":"  262","line":"            struct post_dec;"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"            struct shift_left;"},
{"lineNum":"  265","line":"            struct shift_right;"},
{"lineNum":"  266","line":"            struct multiplies;"},
{"lineNum":"  267","line":"            struct divides;"},
{"lineNum":"  268","line":"            struct modulus;"},
{"lineNum":"  269","line":"            struct plus;"},
{"lineNum":"  270","line":"            struct minus;"},
{"lineNum":"  271","line":"            struct less;"},
{"lineNum":"  272","line":"            struct greater;"},
{"lineNum":"  273","line":"            struct less_equal;"},
{"lineNum":"  274","line":"            struct greater_equal;"},
{"lineNum":"  275","line":"            struct equal_to;"},
{"lineNum":"  276","line":"            struct not_equal_to;"},
{"lineNum":"  277","line":"            struct logical_or;"},
{"lineNum":"  278","line":"            struct logical_and;"},
{"lineNum":"  279","line":"            struct bitwise_and;"},
{"lineNum":"  280","line":"            struct bitwise_or;"},
{"lineNum":"  281","line":"            struct bitwise_xor;"},
{"lineNum":"  282","line":"            struct comma;"},
{"lineNum":"  283","line":"            struct mem_ptr;"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"            struct assign;"},
{"lineNum":"  286","line":"            struct shift_left_assign;"},
{"lineNum":"  287","line":"            struct shift_right_assign;"},
{"lineNum":"  288","line":"            struct multiplies_assign;"},
{"lineNum":"  289","line":"            struct divides_assign;"},
{"lineNum":"  290","line":"            struct modulus_assign;"},
{"lineNum":"  291","line":"            struct plus_assign;"},
{"lineNum":"  292","line":"            struct minus_assign;"},
{"lineNum":"  293","line":"            struct bitwise_and_assign;"},
{"lineNum":"  294","line":"            struct bitwise_or_assign;"},
{"lineNum":"  295","line":"            struct bitwise_xor_assign;"},
{"lineNum":"  296","line":"            struct subscript;"},
{"lineNum":"  297","line":"            struct member;"},
{"lineNum":"  298","line":"            struct if_else_;"},
{"lineNum":"  299","line":"            struct function;"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"            // Fusion tags"},
{"lineNum":"  302","line":"            template<typename Tag, typename Domain> struct proto_expr;"},
{"lineNum":"  303","line":"            template<typename Tag, typename Domain> struct proto_expr_iterator;"},
{"lineNum":"  304","line":"            template<typename Tag, typename Domain> struct proto_flat_view;"},
{"lineNum":"  305","line":"        }"},
{"lineNum":"  306","line":"    }"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"    using namespace tagns_;"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"    template<typename Expr>"},
{"lineNum":"  311","line":"    struct tag_of;"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"    ////////////////////////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  314","line":"    struct _;"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"    ////////////////////////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  317","line":"    struct default_generator;"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"    struct basic_default_generator;"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"    template<template<typename> class Extends>"},
{"lineNum":"  322","line":"    struct generator;"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"    template<template<typename> class Extends>"},
{"lineNum":"  325","line":"    struct pod_generator;"},
{"lineNum":"  326","line":""},
{"lineNum":"  327","line":"    struct by_value_generator;"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"    template<typename First, typename Second>"},
{"lineNum":"  330","line":"    struct compose_generators;"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"    template<typename Generator, typename Void = void>"},
{"lineNum":"  333","line":"    struct wants_basic_expr;"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"    template<typename Generator>"},
{"lineNum":"  336","line":"    struct use_basic_expr;"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"    ////////////////////////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  339","line":"    namespace domainns_"},
{"lineNum":"  340","line":"    {"},
{"lineNum":"  341","line":"        typedef detail::not_a_domain no_super_domain;"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"        template<"},
{"lineNum":"  344","line":"            typename Generator  = default_generator"},
{"lineNum":"  345","line":"          , typename Grammar    = proto::_"},
{"lineNum":"  346","line":"          , typename Super      = no_super_domain"},
{"lineNum":"  347","line":"        >"},
{"lineNum":"  348","line":"        struct domain;"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"        struct default_domain;"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"        struct basic_default_domain;"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"        struct deduce_domain;"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"        template<typename Domain, typename Tag, typename Args, bool WantsBasicExpr = wants_basic_expr<typename Domain::proto_generator>::value>"},
{"lineNum":"  357","line":"        struct base_expr;"},
{"lineNum":"  358","line":"    }"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"    using namespace domainns_;"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"    ////////////////////////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  363","line":"    namespace exprns_"},
{"lineNum":"  364","line":"    {"},
{"lineNum":"  365","line":"        template<typename Tag, typename Args, long Arity = Args::arity>"},
{"lineNum":"  366","line":"        struct basic_expr;","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  367","line":""},
{"lineNum":"  368","line":"        template<typename Tag, typename Args, long Arity = Args::arity>"},
{"lineNum":"  369","line":"        struct expr;"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"        template<"},
{"lineNum":"  372","line":"            typename Expr"},
{"lineNum":"  373","line":"          , typename Derived"},
{"lineNum":"  374","line":"          , typename Domain = default_domain"},
{"lineNum":"  375","line":"          , long Arity = Expr::proto_arity_c"},
{"lineNum":"  376","line":"        >"},
{"lineNum":"  377","line":"        struct extends;"},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"        template<typename This, typename Fun, typename Domain>"},
{"lineNum":"  380","line":"        struct virtual_member;"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"        struct is_proto_expr;"},
{"lineNum":"  383","line":"    }"},
{"lineNum":"  384","line":"    ////////////////////////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"    using exprns_::expr;"},
{"lineNum":"  387","line":"    using exprns_::basic_expr;"},
{"lineNum":"  388","line":"    using exprns_::extends;"},
{"lineNum":"  389","line":"    using exprns_::is_proto_expr;"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"    template<BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(BOOST_PROTO_MAX_LOGICAL_ARITY, typename G, void)>"},
{"lineNum":"  392","line":"    struct or_;"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"    template<BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(BOOST_PROTO_MAX_LOGICAL_ARITY, typename G, void)>"},
{"lineNum":"  395","line":"    struct and_;"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"    template<typename Grammar>"},
{"lineNum":"  398","line":"    struct not_;"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"    template<typename Condition, typename Then = _, typename Else = not_<_> >"},
{"lineNum":"  401","line":"    struct if_;"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"    template<typename Cases, typename Transform = tag_of<_>()>"},
{"lineNum":"  404","line":"    struct switch_;"},
{"lineNum":"  405","line":""},
{"lineNum":"  406","line":"    template<typename T>"},
{"lineNum":"  407","line":"    struct exact;"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"    template<typename T>"},
{"lineNum":"  410","line":"    struct convertible_to;"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":"    template<typename Grammar>"},
{"lineNum":"  413","line":"    struct vararg;"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"    struct pack;"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"    // Boost bug https://svn.boost.org/trac/boost/ticket/4602"},
{"lineNum":"  418","line":"    //int const N = INT_MAX;"},
{"lineNum":"  419","line":"    int const N = (INT_MAX >> 10);"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"    namespace context"},
{"lineNum":"  422","line":"    {"},
{"lineNum":"  423","line":"        struct null_context;"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"        template<typename Expr, typename Context, long Arity = Expr::proto_arity_c>"},
{"lineNum":"  426","line":"        struct null_eval;"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"        struct default_context;"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"        template<typename Expr, typename Context, typename Tag = typename Expr::proto_tag, long Arity = Expr::proto_arity_c>"},
{"lineNum":"  431","line":"        struct default_eval;"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"        template<typename Derived, typename DefaultCtx = default_context>"},
{"lineNum":"  434","line":"        struct callable_context;"},
{"lineNum":"  435","line":""},
{"lineNum":"  436","line":"        template<typename Expr, typename Context, long Arity = Expr::proto_arity_c>"},
{"lineNum":"  437","line":"        struct callable_eval;"},
{"lineNum":"  438","line":"    }"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"    using context::null_context;"},
{"lineNum":"  441","line":"    using context::null_eval;"},
{"lineNum":"  442","line":"    using context::default_context;"},
{"lineNum":"  443","line":"    using context::default_eval;"},
{"lineNum":"  444","line":"    using context::callable_context;"},
{"lineNum":"  445","line":"    using context::callable_eval;"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"    namespace utility"},
{"lineNum":"  448","line":"    {"},
{"lineNum":"  449","line":"        template<typename T, typename Domain = default_domain>"},
{"lineNum":"  450","line":"        struct literal;"},
{"lineNum":"  451","line":"    }"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"    using utility::literal;"},
{"lineNum":"  454","line":""},
{"lineNum":"  455","line":"    namespace result_of"},
{"lineNum":"  456","line":"    {"},
{"lineNum":"  457","line":"        template<typename T, typename Domain = default_domain>"},
{"lineNum":"  458","line":"        struct as_expr;"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"        template<typename T, typename Domain = default_domain>"},
{"lineNum":"  461","line":"        struct as_child;"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"        template<typename Expr, typename N = mpl::long_<0> >"},
{"lineNum":"  464","line":"        struct child;"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"        template<typename Expr, long N>"},
{"lineNum":"  467","line":"        struct child_c;"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"        template<typename Expr>"},
{"lineNum":"  470","line":"        struct left;"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"        template<typename Expr>"},
{"lineNum":"  473","line":"        struct right;"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"        template<typename Expr>"},
{"lineNum":"  476","line":"        struct deep_copy;"},
{"lineNum":"  477","line":""},
{"lineNum":"  478","line":"        template<typename Expr, typename Context>"},
{"lineNum":"  479","line":"        struct eval;"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"        template<"},
{"lineNum":"  482","line":"            typename Tag"},
{"lineNum":"  483","line":"          , typename DomainOrA0"},
{"lineNum":"  484","line":"            BOOST_PP_ENUM_TRAILING_BINARY_PARAMS("},
{"lineNum":"  485","line":"                BOOST_PROTO_MAX_ARITY"},
{"lineNum":"  486","line":"              , typename A"},
{"lineNum":"  487","line":"              , = void BOOST_PP_INTERCEPT"},
{"lineNum":"  488","line":"            )"},
{"lineNum":"  489","line":"          , typename Void = void"},
{"lineNum":"  490","line":"        >"},
{"lineNum":"  491","line":"        struct make_expr;"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"        template<typename Tag, typename DomainOrSequence, typename SequenceOrVoid = void, typename Void = void>"},
{"lineNum":"  494","line":"        struct unpack_expr;"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"        template<typename T>"},
{"lineNum":"  497","line":"        struct as_env;"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"        template<typename Env, typename Tag>"},
{"lineNum":"  500","line":"        struct has_env_var;"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"        template<typename Env, typename Tag>"},
{"lineNum":"  503","line":"        struct env_var;"},
{"lineNum":"  504","line":"    }"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"    template<typename T, typename Void = void>"},
{"lineNum":"  507","line":"    struct is_expr;"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"    template<typename T, typename Void = void>"},
{"lineNum":"  510","line":"    struct is_domain;"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":"    template<typename SubDomain, typename SuperDomain>"},
{"lineNum":"  513","line":"    struct is_sub_domain_of;"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"    template<typename T, typename Void = void>"},
{"lineNum":"  516","line":"    struct is_env;"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"    template<typename Expr>"},
{"lineNum":"  519","line":"    struct arity_of;"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"    template<typename T, typename Void = void>"},
{"lineNum":"  522","line":"    struct domain_of;"},
{"lineNum":"  523","line":""},
{"lineNum":"  524","line":"    template<typename Expr, typename Grammar>"},
{"lineNum":"  525","line":"    struct matches;"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"    // Generic expression metafunctions and"},
{"lineNum":"  528","line":"    // grammar elements"},
{"lineNum":"  529","line":"    template<typename Tag, typename Arg>"},
{"lineNum":"  530","line":"    struct unary_expr;"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"    template<typename Tag, typename Left, typename Right>"},
{"lineNum":"  533","line":"    struct binary_expr;"},
{"lineNum":"  534","line":""},
{"lineNum":"  535","line":"    template<typename Tag, BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(BOOST_PROTO_MAX_ARITY, typename A, void)>"},
{"lineNum":"  536","line":"    struct nary_expr;"},
{"lineNum":"  537","line":""},
{"lineNum":"  538","line":"    // Specific expression metafunctions and"},
{"lineNum":"  539","line":"    // grammar elements, for convenience"},
{"lineNum":"  540","line":"    template<typename T> struct terminal;"},
{"lineNum":"  541","line":"    template<typename T> struct unary_plus;"},
{"lineNum":"  542","line":"    template<typename T> struct negate;"},
{"lineNum":"  543","line":"    template<typename T> struct dereference;"},
{"lineNum":"  544","line":"    template<typename T> struct complement;"},
{"lineNum":"  545","line":"    template<typename T> struct address_of;"},
{"lineNum":"  546","line":"    template<typename T> struct logical_not;"},
{"lineNum":"  547","line":"    template<typename T> struct pre_inc;"},
{"lineNum":"  548","line":"    template<typename T> struct pre_dec;"},
{"lineNum":"  549","line":"    template<typename T> struct post_inc;"},
{"lineNum":"  550","line":"    template<typename T> struct post_dec;"},
{"lineNum":"  551","line":""},
{"lineNum":"  552","line":"    template<typename T, typename U> struct shift_left;"},
{"lineNum":"  553","line":"    template<typename T, typename U> struct shift_right;"},
{"lineNum":"  554","line":"    template<typename T, typename U> struct multiplies;"},
{"lineNum":"  555","line":"    template<typename T, typename U> struct divides;"},
{"lineNum":"  556","line":"    template<typename T, typename U> struct modulus;"},
{"lineNum":"  557","line":"    template<typename T, typename U> struct plus;"},
{"lineNum":"  558","line":"    template<typename T, typename U> struct minus;"},
{"lineNum":"  559","line":"    template<typename T, typename U> struct less;"},
{"lineNum":"  560","line":"    template<typename T, typename U> struct greater;"},
{"lineNum":"  561","line":"    template<typename T, typename U> struct less_equal;"},
{"lineNum":"  562","line":"    template<typename T, typename U> struct greater_equal;"},
{"lineNum":"  563","line":"    template<typename T, typename U> struct equal_to;"},
{"lineNum":"  564","line":"    template<typename T, typename U> struct not_equal_to;"},
{"lineNum":"  565","line":"    template<typename T, typename U> struct logical_or;"},
{"lineNum":"  566","line":"    template<typename T, typename U> struct logical_and;"},
{"lineNum":"  567","line":"    template<typename T, typename U> struct bitwise_and;"},
{"lineNum":"  568","line":"    template<typename T, typename U> struct bitwise_or;"},
{"lineNum":"  569","line":"    template<typename T, typename U> struct bitwise_xor;"},
{"lineNum":"  570","line":"    template<typename T, typename U> struct comma;"},
{"lineNum":"  571","line":"    template<typename T, typename U> struct mem_ptr;"},
{"lineNum":"  572","line":""},
{"lineNum":"  573","line":"    template<typename T, typename U> struct assign;"},
{"lineNum":"  574","line":"    template<typename T, typename U> struct shift_left_assign;"},
{"lineNum":"  575","line":"    template<typename T, typename U> struct shift_right_assign;"},
{"lineNum":"  576","line":"    template<typename T, typename U> struct multiplies_assign;"},
{"lineNum":"  577","line":"    template<typename T, typename U> struct divides_assign;"},
{"lineNum":"  578","line":"    template<typename T, typename U> struct modulus_assign;"},
{"lineNum":"  579","line":"    template<typename T, typename U> struct plus_assign;"},
{"lineNum":"  580","line":"    template<typename T, typename U> struct minus_assign;"},
{"lineNum":"  581","line":"    template<typename T, typename U> struct bitwise_and_assign;"},
{"lineNum":"  582","line":"    template<typename T, typename U> struct bitwise_or_assign;"},
{"lineNum":"  583","line":"    template<typename T, typename U> struct bitwise_xor_assign;"},
{"lineNum":"  584","line":"    template<typename T, typename U> struct subscript;"},
{"lineNum":"  585","line":"    template<typename T, typename U> struct member;"},
{"lineNum":"  586","line":"    template<typename T, typename U, typename V> struct if_else_;"},
{"lineNum":"  587","line":""},
{"lineNum":"  588","line":"    template<BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT(BOOST_PROTO_MAX_ARITY, typename A, void)>"},
{"lineNum":"  589","line":"    struct function;"},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"    namespace functional"},
{"lineNum":"  592","line":"    {"},
{"lineNum":"  593","line":"        struct left;"},
{"lineNum":"  594","line":"        struct right;"},
{"lineNum":"  595","line":"        struct eval;"},
{"lineNum":"  596","line":"        struct deep_copy;"},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"        template<typename Domain = default_domain>"},
{"lineNum":"  599","line":"        struct as_expr;"},
{"lineNum":"  600","line":""},
{"lineNum":"  601","line":"        template<typename Domain = default_domain>"},
{"lineNum":"  602","line":"        struct as_child;"},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"        template<typename N = mpl::long_<0> >"},
{"lineNum":"  605","line":"        struct child;"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"        template<long N>"},
{"lineNum":"  608","line":"        struct child_c;"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":"        struct as_env;"},
{"lineNum":"  611","line":""},
{"lineNum":"  612","line":"        template<typename Tag>"},
{"lineNum":"  613","line":"        struct has_env_var;"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"        template<typename Tag>"},
{"lineNum":"  616","line":"        struct env_var;"},
{"lineNum":"  617","line":""},
{"lineNum":"  618","line":"        template<typename Tag, typename Domain = deduce_domain>"},
{"lineNum":"  619","line":"        struct make_expr;"},
{"lineNum":"  620","line":""},
{"lineNum":"  621","line":"        template<typename Tag, typename Domain = deduce_domain>"},
{"lineNum":"  622","line":"        struct unpack_expr;"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"        typedef make_expr<tag::terminal>            make_terminal;"},
{"lineNum":"  625","line":"        typedef make_expr<tag::unary_plus>          make_unary_plus;"},
{"lineNum":"  626","line":"        typedef make_expr<tag::negate>              make_negate;"},
{"lineNum":"  627","line":"        typedef make_expr<tag::dereference>         make_dereference;"},
{"lineNum":"  628","line":"        typedef make_expr<tag::complement>          make_complement;"},
{"lineNum":"  629","line":"        typedef make_expr<tag::address_of>          make_address_of;"},
{"lineNum":"  630","line":"        typedef make_expr<tag::logical_not>         make_logical_not;"},
{"lineNum":"  631","line":"        typedef make_expr<tag::pre_inc>             make_pre_inc;"},
{"lineNum":"  632","line":"        typedef make_expr<tag::pre_dec>             make_pre_dec;"},
{"lineNum":"  633","line":"        typedef make_expr<tag::post_inc>            make_post_inc;"},
{"lineNum":"  634","line":"        typedef make_expr<tag::post_dec>            make_post_dec;"},
{"lineNum":"  635","line":"        typedef make_expr<tag::shift_left>          make_shift_left;"},
{"lineNum":"  636","line":"        typedef make_expr<tag::shift_right>         make_shift_right;"},
{"lineNum":"  637","line":"        typedef make_expr<tag::multiplies>          make_multiplies;"},
{"lineNum":"  638","line":"        typedef make_expr<tag::divides>             make_divides;"},
{"lineNum":"  639","line":"        typedef make_expr<tag::modulus>             make_modulus;"},
{"lineNum":"  640","line":"        typedef make_expr<tag::plus>                make_plus;"},
{"lineNum":"  641","line":"        typedef make_expr<tag::minus>               make_minus;"},
{"lineNum":"  642","line":"        typedef make_expr<tag::less>                make_less;"},
{"lineNum":"  643","line":"        typedef make_expr<tag::greater>             make_greater;"},
{"lineNum":"  644","line":"        typedef make_expr<tag::less_equal>          make_less_equal;"},
{"lineNum":"  645","line":"        typedef make_expr<tag::greater_equal>       make_greater_equal;"},
{"lineNum":"  646","line":"        typedef make_expr<tag::equal_to>            make_equal_to;"},
{"lineNum":"  647","line":"        typedef make_expr<tag::not_equal_to>        make_not_equal_to;"},
{"lineNum":"  648","line":"        typedef make_expr<tag::logical_or>          make_logical_or;"},
{"lineNum":"  649","line":"        typedef make_expr<tag::logical_and>         make_logical_and;"},
{"lineNum":"  650","line":"        typedef make_expr<tag::bitwise_and>         make_bitwise_and;"},
{"lineNum":"  651","line":"        typedef make_expr<tag::bitwise_or>          make_bitwise_or;"},
{"lineNum":"  652","line":"        typedef make_expr<tag::bitwise_xor>         make_bitwise_xor;"},
{"lineNum":"  653","line":"        typedef make_expr<tag::comma>               make_comma;"},
{"lineNum":"  654","line":"        typedef make_expr<tag::mem_ptr>             make_mem_ptr;"},
{"lineNum":"  655","line":"        typedef make_expr<tag::assign>              make_assign;"},
{"lineNum":"  656","line":"        typedef make_expr<tag::shift_left_assign>   make_shift_left_assign;"},
{"lineNum":"  657","line":"        typedef make_expr<tag::shift_right_assign>  make_shift_right_assign;"},
{"lineNum":"  658","line":"        typedef make_expr<tag::multiplies_assign>   make_multiplies_assign;"},
{"lineNum":"  659","line":"        typedef make_expr<tag::divides_assign>      make_divides_assign;"},
{"lineNum":"  660","line":"        typedef make_expr<tag::modulus_assign>      make_modulus_assign;"},
{"lineNum":"  661","line":"        typedef make_expr<tag::plus_assign>         make_plus_assign;"},
{"lineNum":"  662","line":"        typedef make_expr<tag::minus_assign>        make_minus_assign;"},
{"lineNum":"  663","line":"        typedef make_expr<tag::bitwise_and_assign>  make_bitwise_and_assign;"},
{"lineNum":"  664","line":"        typedef make_expr<tag::bitwise_or_assign>   make_bitwise_or_assign;"},
{"lineNum":"  665","line":"        typedef make_expr<tag::bitwise_xor_assign>  make_bitwise_xor_assign;"},
{"lineNum":"  666","line":"        typedef make_expr<tag::subscript>           make_subscript;"},
{"lineNum":"  667","line":"        typedef make_expr<tag::if_else_>            make_if_else;"},
{"lineNum":"  668","line":"        typedef make_expr<tag::function>            make_function;"},
{"lineNum":"  669","line":""},
{"lineNum":"  670","line":"        struct flatten;"},
{"lineNum":"  671","line":"        struct make_pair;"},
{"lineNum":"  672","line":"        struct first;"},
{"lineNum":"  673","line":"        struct second;"},
{"lineNum":"  674","line":"        struct at;"},
{"lineNum":"  675","line":"        struct pop_front;"},
{"lineNum":"  676","line":"        struct push_front;"},
{"lineNum":"  677","line":"        struct pop_back;"},
{"lineNum":"  678","line":"        struct push_back;"},
{"lineNum":"  679","line":"        struct reverse;"},
{"lineNum":"  680","line":"    }"},
{"lineNum":"  681","line":""},
{"lineNum":"  682","line":"    typedef functional::flatten     _flatten;"},
{"lineNum":"  683","line":"    typedef functional::make_pair   _make_pair;"},
{"lineNum":"  684","line":"    typedef functional::first       _first;"},
{"lineNum":"  685","line":"    typedef functional::second      _second;"},
{"lineNum":"  686","line":"    typedef functional::pop_front   _at;"},
{"lineNum":"  687","line":"    typedef functional::pop_front   _pop_front;"},
{"lineNum":"  688","line":"    typedef functional::push_front  _push_front;"},
{"lineNum":"  689","line":"    typedef functional::pop_back    _pop_back;"},
{"lineNum":"  690","line":"    typedef functional::push_back   _push_back;"},
{"lineNum":"  691","line":"    typedef functional::reverse     _reverse;"},
{"lineNum":"  692","line":"    typedef functional::eval        _eval;"},
{"lineNum":"  693","line":"    struct _deep_copy;"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"    typedef functional::make_expr<tag::terminal>           _make_terminal;"},
{"lineNum":"  696","line":"    typedef functional::make_expr<tag::unary_plus>         _make_unary_plus;"},
{"lineNum":"  697","line":"    typedef functional::make_expr<tag::negate>             _make_negate;"},
{"lineNum":"  698","line":"    typedef functional::make_expr<tag::dereference>        _make_dereference;"},
{"lineNum":"  699","line":"    typedef functional::make_expr<tag::complement>         _make_complement;"},
{"lineNum":"  700","line":"    typedef functional::make_expr<tag::address_of>         _make_address_of;"},
{"lineNum":"  701","line":"    typedef functional::make_expr<tag::logical_not>        _make_logical_not;"},
{"lineNum":"  702","line":"    typedef functional::make_expr<tag::pre_inc>            _make_pre_inc;"},
{"lineNum":"  703","line":"    typedef functional::make_expr<tag::pre_dec>            _make_pre_dec;"},
{"lineNum":"  704","line":"    typedef functional::make_expr<tag::post_inc>           _make_post_inc;"},
{"lineNum":"  705","line":"    typedef functional::make_expr<tag::post_dec>           _make_post_dec;"},
{"lineNum":"  706","line":"    typedef functional::make_expr<tag::shift_left>         _make_shift_left;"},
{"lineNum":"  707","line":"    typedef functional::make_expr<tag::shift_right>        _make_shift_right;"},
{"lineNum":"  708","line":"    typedef functional::make_expr<tag::multiplies>         _make_multiplies;"},
{"lineNum":"  709","line":"    typedef functional::make_expr<tag::divides>            _make_divides;"},
{"lineNum":"  710","line":"    typedef functional::make_expr<tag::modulus>            _make_modulus;"},
{"lineNum":"  711","line":"    typedef functional::make_expr<tag::plus>               _make_plus;"},
{"lineNum":"  712","line":"    typedef functional::make_expr<tag::minus>              _make_minus;"},
{"lineNum":"  713","line":"    typedef functional::make_expr<tag::less>               _make_less;"},
{"lineNum":"  714","line":"    typedef functional::make_expr<tag::greater>            _make_greater;"},
{"lineNum":"  715","line":"    typedef functional::make_expr<tag::less_equal>         _make_less_equal;"},
{"lineNum":"  716","line":"    typedef functional::make_expr<tag::greater_equal>      _make_greater_equal;"},
{"lineNum":"  717","line":"    typedef functional::make_expr<tag::equal_to>           _make_equal_to;"},
{"lineNum":"  718","line":"    typedef functional::make_expr<tag::not_equal_to>       _make_not_equal_to;"},
{"lineNum":"  719","line":"    typedef functional::make_expr<tag::logical_or>         _make_logical_or;"},
{"lineNum":"  720","line":"    typedef functional::make_expr<tag::logical_and>        _make_logical_and;"},
{"lineNum":"  721","line":"    typedef functional::make_expr<tag::bitwise_and>        _make_bitwise_and;"},
{"lineNum":"  722","line":"    typedef functional::make_expr<tag::bitwise_or>         _make_bitwise_or;"},
{"lineNum":"  723","line":"    typedef functional::make_expr<tag::bitwise_xor>        _make_bitwise_xor;"},
{"lineNum":"  724","line":"    typedef functional::make_expr<tag::comma>              _make_comma;"},
{"lineNum":"  725","line":"    typedef functional::make_expr<tag::mem_ptr>            _make_mem_ptr;"},
{"lineNum":"  726","line":"    typedef functional::make_expr<tag::assign>             _make_assign;"},
{"lineNum":"  727","line":"    typedef functional::make_expr<tag::shift_left_assign>  _make_shift_left_assign;"},
{"lineNum":"  728","line":"    typedef functional::make_expr<tag::shift_right_assign> _make_shift_right_assign;"},
{"lineNum":"  729","line":"    typedef functional::make_expr<tag::multiplies_assign>  _make_multiplies_assign;"},
{"lineNum":"  730","line":"    typedef functional::make_expr<tag::divides_assign>     _make_divides_assign;"},
{"lineNum":"  731","line":"    typedef functional::make_expr<tag::modulus_assign>     _make_modulus_assign;"},
{"lineNum":"  732","line":"    typedef functional::make_expr<tag::plus_assign>        _make_plus_assign;"},
{"lineNum":"  733","line":"    typedef functional::make_expr<tag::minus_assign>       _make_minus_assign;"},
{"lineNum":"  734","line":"    typedef functional::make_expr<tag::bitwise_and_assign> _make_bitwise_and_assign;"},
{"lineNum":"  735","line":"    typedef functional::make_expr<tag::bitwise_or_assign>  _make_bitwise_or_assign;"},
{"lineNum":"  736","line":"    typedef functional::make_expr<tag::bitwise_xor_assign> _make_bitwise_xor_assign;"},
{"lineNum":"  737","line":"    typedef functional::make_expr<tag::subscript>          _make_subscript;"},
{"lineNum":"  738","line":"    typedef functional::make_expr<tag::if_else_>           _make_if_else;"},
{"lineNum":"  739","line":"    typedef functional::make_expr<tag::function>           _make_function;"},
{"lineNum":"  740","line":""},
{"lineNum":"  741","line":"    template<typename T>"},
{"lineNum":"  742","line":"    struct is_callable;"},
{"lineNum":"  743","line":""},
{"lineNum":"  744","line":"    template<typename T>"},
{"lineNum":"  745","line":"    struct is_transform;"},
{"lineNum":"  746","line":""},
{"lineNum":"  747","line":"    template<typename T>"},
{"lineNum":"  748","line":"    struct is_aggregate;"},
{"lineNum":"  749","line":""},
{"lineNum":"  750","line":"    #define BOOST_PROTO_UNEXPR() typedef int proto_is_expr_;"},
{"lineNum":"  751","line":"    #define BOOST_PROTO_CALLABLE() typedef void proto_is_callable_;"},
{"lineNum":"  752","line":"    #define BOOST_PROTO_AGGREGATE() typedef void proto_is_aggregate_;"},
{"lineNum":"  753","line":"    #define BOOST_PROTO_USE_BASIC_EXPR() typedef void proto_use_basic_expr_;"},
{"lineNum":"  754","line":""},
{"lineNum":"  755","line":"    struct callable"},
{"lineNum":"  756","line":"    {"},
{"lineNum":"  757","line":"        BOOST_PROTO_CALLABLE()"},
{"lineNum":"  758","line":"    };"},
{"lineNum":"  759","line":""},
{"lineNum":"  760","line":"    namespace envns_"},
{"lineNum":"  761","line":"    {"},
{"lineNum":"  762","line":"        struct key_not_found;"},
{"lineNum":"  763","line":""},
{"lineNum":"  764","line":"        struct empty_env;"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"        typedef int empty_state;"},
{"lineNum":"  767","line":""},
{"lineNum":"  768","line":"        template<typename Tag, typename Value, typename Base = empty_env>"},
{"lineNum":"  769","line":"        struct env;"},
{"lineNum":"  770","line":""},
{"lineNum":"  771","line":"        struct data_type;"},
{"lineNum":"  772","line":""},
{"lineNum":"  773","line":"        struct transforms_type;"},
{"lineNum":"  774","line":"    }"},
{"lineNum":"  775","line":""},
{"lineNum":"  776","line":"    using envns_::key_not_found;"},
{"lineNum":"  777","line":"    using envns_::empty_env;"},
{"lineNum":"  778","line":"    using envns_::empty_state;"},
{"lineNum":"  779","line":"    using envns_::env;"},
{"lineNum":"  780","line":"    using envns_::data_type;"},
{"lineNum":"  781","line":"    using envns_::transforms_type;"},
{"lineNum":"  782","line":""},
{"lineNum":"  783","line":"    struct external_transform;"},
{"lineNum":"  784","line":""},
{"lineNum":"  785","line":"    template<typename PrimitiveTransform = void, typename X = void>"},
{"lineNum":"  786","line":"    struct transform;"},
{"lineNum":"  787","line":""},
{"lineNum":"  788","line":"    template<typename Grammar, typename Fun = Grammar>"},
{"lineNum":"  789","line":"    struct when;"},
{"lineNum":"  790","line":""},
{"lineNum":"  791","line":"    template<typename Fun>"},
{"lineNum":"  792","line":"    struct otherwise;"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"    template<typename Fun>"},
{"lineNum":"  795","line":"    struct call;"},
{"lineNum":"  796","line":""},
{"lineNum":"  797","line":"    template<typename Fun>"},
{"lineNum":"  798","line":"    struct make;"},
{"lineNum":"  799","line":""},
{"lineNum":"  800","line":"    template<typename PrimitiveTransform>"},
{"lineNum":"  801","line":"    struct protect;"},
{"lineNum":"  802","line":""},
{"lineNum":"  803","line":"    template<typename T>"},
{"lineNum":"  804","line":"    struct noinvoke;"},
{"lineNum":"  805","line":""},
{"lineNum":"  806","line":"    template<typename Fun>"},
{"lineNum":"  807","line":"    struct lazy;"},
{"lineNum":"  808","line":""},
{"lineNum":"  809","line":"    template<typename Sequence, typename State, typename Fun>"},
{"lineNum":"  810","line":"    struct fold;"},
{"lineNum":"  811","line":""},
{"lineNum":"  812","line":"    template<typename Sequence, typename State, typename Fun>"},
{"lineNum":"  813","line":"    struct reverse_fold;"},
{"lineNum":"  814","line":""},
{"lineNum":"  815","line":"    // Q: can we replace fold_tree with fold<flatten(_), state, fun> ?"},
{"lineNum":"  816","line":"    // A: once segmented Fusion works well."},
{"lineNum":"  817","line":"    template<typename Sequence, typename State, typename Fun>"},
{"lineNum":"  818","line":"    struct fold_tree;"},
{"lineNum":"  819","line":""},
{"lineNum":"  820","line":"    template<typename Sequence, typename State, typename Fun>"},
{"lineNum":"  821","line":"    struct reverse_fold_tree;"},
{"lineNum":"  822","line":""},
{"lineNum":"  823","line":"    template<typename Grammar, typename Domain = deduce_domain>"},
{"lineNum":"  824","line":"    struct pass_through;"},
{"lineNum":"  825","line":""},
{"lineNum":"  826","line":"    template<typename Grammar = detail::_default>"},
{"lineNum":"  827","line":"    struct _default;"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"    struct _expr;"},
{"lineNum":"  830","line":"    struct _state;"},
{"lineNum":"  831","line":"    struct _data;"},
{"lineNum":"  832","line":""},
{"lineNum":"  833","line":"    struct _value;"},
{"lineNum":"  834","line":""},
{"lineNum":"  835","line":"    struct _void;"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"    template<typename T, T I>"},
{"lineNum":"  838","line":"    struct integral_c;"},
{"lineNum":"  839","line":""},
{"lineNum":"  840","line":"    template<char I>"},
{"lineNum":"  841","line":"    struct char_;"},
{"lineNum":"  842","line":""},
{"lineNum":"  843","line":"    template<int I>"},
{"lineNum":"  844","line":"    struct int_;"},
{"lineNum":"  845","line":""},
{"lineNum":"  846","line":"    template<long I>"},
{"lineNum":"  847","line":"    struct long_;"},
{"lineNum":"  848","line":""},
{"lineNum":"  849","line":"    template<std::size_t I>"},
{"lineNum":"  850","line":"    struct size_t;"},
{"lineNum":"  851","line":""},
{"lineNum":"  852","line":"    template<int I>"},
{"lineNum":"  853","line":"    struct _child_c;"},
{"lineNum":"  854","line":""},
{"lineNum":"  855","line":"    typedef _child_c<0> _child0;"},
{"lineNum":"  856","line":"    typedef _child_c<1> _child1;"},
{"lineNum":"  857","line":"    typedef _child0     _child;"},
{"lineNum":"  858","line":"    typedef _child0     _left;"},
{"lineNum":"  859","line":"    typedef _child1     _right;"},
{"lineNum":"  860","line":""},
{"lineNum":"  861","line":"    // _child2, _child3, _child4, ..."},
{"lineNum":"  862","line":"    #define M0(Z, N, DATA) typedef _child_c<N> BOOST_PP_CAT(_child, N);"},
{"lineNum":"  863","line":"    BOOST_PP_REPEAT_FROM_TO("},
{"lineNum":"  864","line":"        2"},
{"lineNum":"  865","line":"      , BOOST_PP_DEC(BOOST_PROTO_MAX_ARITY)"},
{"lineNum":"  866","line":"      , M0"},
{"lineNum":"  867","line":"      , ~"},
{"lineNum":"  868","line":"    )"},
{"lineNum":"  869","line":"    #undef M0"},
{"lineNum":"  870","line":""},
{"lineNum":"  871","line":"    struct _byref;"},
{"lineNum":"  872","line":"    struct _byval;"},
{"lineNum":"  873","line":""},
{"lineNum":"  874","line":"    template<typename Tag>"},
{"lineNum":"  875","line":"    struct _env_var;"},
{"lineNum":"  876","line":""},
{"lineNum":"  877","line":"    struct _env;"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"    template<typename T>"},
{"lineNum":"  880","line":"    struct is_extension;"},
{"lineNum":"  881","line":""},
{"lineNum":"  882","line":"    namespace exops = exprns_;"},
{"lineNum":"  883","line":""},
{"lineNum":"  884","line":"}} // namespace boost::proto"},
{"lineNum":"  885","line":""},
{"lineNum":"  886","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
