var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_PACKET_MATH_SSE_H"},
{"lineNum":"   11","line":"#define EIGEN_PACKET_MATH_SSE_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"../../InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"#ifndef EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD"},
{"lineNum":"   20","line":"#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD 8"},
{"lineNum":"   21","line":"#endif"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"#if !defined(EIGEN_VECTORIZE_AVX) && !defined(EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS)"},
{"lineNum":"   24","line":"// 32 bits =>  8 registers"},
{"lineNum":"   25","line":"// 64 bits => 16 registers"},
{"lineNum":"   26","line":"#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS (2*sizeof(void*))"},
{"lineNum":"   27","line":"#endif"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"#ifdef EIGEN_VECTORIZE_FMA"},
{"lineNum":"   30","line":"#ifndef EIGEN_HAS_SINGLE_INSTRUCTION_MADD"},
{"lineNum":"   31","line":"#define EIGEN_HAS_SINGLE_INSTRUCTION_MADD"},
{"lineNum":"   32","line":"#endif"},
{"lineNum":"   33","line":"#endif"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"#if ((defined EIGEN_VECTORIZE_AVX) && (EIGEN_COMP_GNUC_STRICT || EIGEN_COMP_MINGW) && (__GXX_ABI_VERSION < 1004)) || EIGEN_OS_QNX"},
{"lineNum":"   36","line":"// With GCC\'s default ABI version, a __m128 or __m256 are the same types and therefore we cannot"},
{"lineNum":"   37","line":"// have overloads for both types without linking error."},
{"lineNum":"   38","line":"// One solution is to increase ABI version using -fabi-version=4 (or greater)."},
{"lineNum":"   39","line":"// Otherwise, we workaround this inconvenience by wrapping 128bit types into the following helper"},
{"lineNum":"   40","line":"// structure:"},
{"lineNum":"   41","line":"typedef eigen_packet_wrapper<__m128>  Packet4f;"},
{"lineNum":"   42","line":"typedef eigen_packet_wrapper<__m128d> Packet2d;"},
{"lineNum":"   43","line":"#else"},
{"lineNum":"   44","line":"typedef __m128  Packet4f;"},
{"lineNum":"   45","line":"typedef __m128d Packet2d;"},
{"lineNum":"   46","line":"#endif"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"typedef eigen_packet_wrapper<__m128i, 0> Packet4i;"},
{"lineNum":"   49","line":"typedef eigen_packet_wrapper<__m128i, 1> Packet16b;"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"template<> struct is_arithmetic<__m128>  { enum { value = true }; };"},
{"lineNum":"   52","line":"template<> struct is_arithmetic<__m128i> { enum { value = true }; };"},
{"lineNum":"   53","line":"template<> struct is_arithmetic<__m128d> { enum { value = true }; };"},
{"lineNum":"   54","line":"template<> struct is_arithmetic<Packet4i>  { enum { value = true }; };"},
{"lineNum":"   55","line":"template<> struct is_arithmetic<Packet16b>  { enum { value = true }; };"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"template<int p, int q, int r, int s>"},
{"lineNum":"   58","line":"struct shuffle_mask{"},
{"lineNum":"   59","line":" enum { mask = (s)<<6|(r)<<4|(q)<<2|(p) };"},
{"lineNum":"   60","line":"};"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"// TODO: change the implementation of all swizzle* ops from macro to template,"},
{"lineNum":"   63","line":"#define vec4f_swizzle1(v,p,q,r,s) \\"},
{"lineNum":"   64","line":"  Packet4f(_mm_castsi128_ps(_mm_shuffle_epi32( _mm_castps_si128(v), (shuffle_mask<p,q,r,s>::mask))))"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"#define vec4i_swizzle1(v,p,q,r,s) \\"},
{"lineNum":"   67","line":"  Packet4i(_mm_shuffle_epi32( v, (shuffle_mask<p,q,r,s>::mask)))"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"#define vec2d_swizzle1(v,p,q) \\"},
{"lineNum":"   70","line":"  Packet2d(_mm_castsi128_pd(_mm_shuffle_epi32( _mm_castpd_si128(v), (shuffle_mask<2*p,2*p+1,2*q,2*q+1>::mask))))"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"#define vec4f_swizzle2(a,b,p,q,r,s) \\"},
{"lineNum":"   73","line":"  Packet4f(_mm_shuffle_ps( (a), (b), (shuffle_mask<p,q,r,s>::mask)))"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"#define vec4i_swizzle2(a,b,p,q,r,s) \\"},
{"lineNum":"   76","line":"  Packet4i(_mm_castps_si128( (_mm_shuffle_ps( _mm_castsi128_ps(a), _mm_castsi128_ps(b), (shuffle_mask<p,q,r,s>::mask)))))"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"EIGEN_STRONG_INLINE Packet4f vec4f_movelh(const Packet4f& a, const Packet4f& b)"},
{"lineNum":"   79","line":"{"},
{"lineNum":"   80","line":"  return Packet4f(_mm_movelh_ps(a,b));"},
{"lineNum":"   81","line":"}"},
{"lineNum":"   82","line":"EIGEN_STRONG_INLINE Packet4f vec4f_movehl(const Packet4f& a, const Packet4f& b)"},
{"lineNum":"   83","line":"{"},
{"lineNum":"   84","line":"  return Packet4f(_mm_movehl_ps(a,b));"},
{"lineNum":"   85","line":"}"},
{"lineNum":"   86","line":"EIGEN_STRONG_INLINE Packet4f vec4f_unpacklo(const Packet4f& a, const Packet4f& b)"},
{"lineNum":"   87","line":"{"},
{"lineNum":"   88","line":"  return Packet4f(_mm_unpacklo_ps(a,b));"},
{"lineNum":"   89","line":"}"},
{"lineNum":"   90","line":"EIGEN_STRONG_INLINE Packet4f vec4f_unpackhi(const Packet4f& a, const Packet4f& b)"},
{"lineNum":"   91","line":"{"},
{"lineNum":"   92","line":"  return Packet4f(_mm_unpackhi_ps(a,b));"},
{"lineNum":"   93","line":"}"},
{"lineNum":"   94","line":"#define vec4f_duplane(a,p) \\"},
{"lineNum":"   95","line":"  vec4f_swizzle2(a,a,p,p,p,p)"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"#define vec2d_swizzle2(a,b,mask) \\"},
{"lineNum":"   98","line":"  Packet2d(_mm_shuffle_pd(a,b,mask))"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"EIGEN_STRONG_INLINE Packet2d vec2d_unpacklo(const Packet2d& a, const Packet2d& b)"},
{"lineNum":"  101","line":"{"},
{"lineNum":"  102","line":"  return Packet2d(_mm_unpacklo_pd(a,b));"},
{"lineNum":"  103","line":"}"},
{"lineNum":"  104","line":"EIGEN_STRONG_INLINE Packet2d vec2d_unpackhi(const Packet2d& a, const Packet2d& b)"},
{"lineNum":"  105","line":"{"},
{"lineNum":"  106","line":"  return Packet2d(_mm_unpackhi_pd(a,b));"},
{"lineNum":"  107","line":"}"},
{"lineNum":"  108","line":"#define vec2d_duplane(a,p) \\"},
{"lineNum":"  109","line":"  vec2d_swizzle2(a,a,(p<<1)|p)"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"#define _EIGEN_DECLARE_CONST_Packet4f(NAME,X) \\"},
{"lineNum":"  112","line":"  const Packet4f p4f_##NAME = pset1<Packet4f>(X)"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"#define _EIGEN_DECLARE_CONST_Packet2d(NAME,X) \\"},
{"lineNum":"  115","line":"  const Packet2d p2d_##NAME = pset1<Packet2d>(X)"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(NAME,X) \\"},
{"lineNum":"  118","line":"  const Packet4f p4f_##NAME = pset1frombits<Packet4f>(X)"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"#define _EIGEN_DECLARE_CONST_Packet4i(NAME,X) \\"},
{"lineNum":"  121","line":"  const Packet4i p4i_##NAME = pset1<Packet4i>(X)"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"// Use the packet_traits defined in AVX/PacketMath.h instead if we\'re going"},
{"lineNum":"  125","line":"// to leverage AVX instructions."},
{"lineNum":"  126","line":"#ifndef EIGEN_VECTORIZE_AVX"},
{"lineNum":"  127","line":"template <>"},
{"lineNum":"  128","line":"struct packet_traits<float> : default_packet_traits {"},
{"lineNum":"  129","line":"  typedef Packet4f type;"},
{"lineNum":"  130","line":"  typedef Packet4f half;"},
{"lineNum":"  131","line":"  enum {"},
{"lineNum":"  132","line":"    Vectorizable = 1,"},
{"lineNum":"  133","line":"    AlignedOnScalar = 1,"},
{"lineNum":"  134","line":"    size = 4,"},
{"lineNum":"  135","line":"    HasHalfPacket = 0,"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"    HasCmp  = 1,"},
{"lineNum":"  138","line":"    HasDiv = 1,"},
{"lineNum":"  139","line":"    HasSin = EIGEN_FAST_MATH,"},
{"lineNum":"  140","line":"    HasCos = EIGEN_FAST_MATH,"},
{"lineNum":"  141","line":"    HasLog = 1,"},
{"lineNum":"  142","line":"    HasLog1p = 1,"},
{"lineNum":"  143","line":"    HasExpm1 = 1,"},
{"lineNum":"  144","line":"    HasNdtri = 1,"},
{"lineNum":"  145","line":"    HasExp = 1,"},
{"lineNum":"  146","line":"    HasBessel = 1,"},
{"lineNum":"  147","line":"    HasSqrt = 1,"},
{"lineNum":"  148","line":"    HasRsqrt = 1,"},
{"lineNum":"  149","line":"    HasTanh = EIGEN_FAST_MATH,"},
{"lineNum":"  150","line":"    HasErf = EIGEN_FAST_MATH,"},
{"lineNum":"  151","line":"    HasBlend = 1,"},
{"lineNum":"  152","line":"    HasCeil = 1,"},
{"lineNum":"  153","line":"    HasFloor = 1,"},
{"lineNum":"  154","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":"  155","line":"    HasRound = 1,"},
{"lineNum":"  156","line":"#endif"},
{"lineNum":"  157","line":"    HasRint = 1"},
{"lineNum":"  158","line":"  };"},
{"lineNum":"  159","line":"};"},
{"lineNum":"  160","line":"template <>"},
{"lineNum":"  161","line":"struct packet_traits<double> : default_packet_traits {"},
{"lineNum":"  162","line":"  typedef Packet2d type;"},
{"lineNum":"  163","line":"  typedef Packet2d half;"},
{"lineNum":"  164","line":"  enum {"},
{"lineNum":"  165","line":"    Vectorizable = 1,"},
{"lineNum":"  166","line":"    AlignedOnScalar = 1,"},
{"lineNum":"  167","line":"    size=2,"},
{"lineNum":"  168","line":"    HasHalfPacket = 0,"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"    HasCmp  = 1,"},
{"lineNum":"  171","line":"    HasDiv  = 1,"},
{"lineNum":"  172","line":"    HasLog  = 1,"},
{"lineNum":"  173","line":"    HasExp  = 1,"},
{"lineNum":"  174","line":"    HasSqrt = 1,"},
{"lineNum":"  175","line":"    HasRsqrt = 1,"},
{"lineNum":"  176","line":"    HasBlend = 1,"},
{"lineNum":"  177","line":"    HasFloor = 1,"},
{"lineNum":"  178","line":"    HasCeil = 1,"},
{"lineNum":"  179","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":"  180","line":"    HasRound = 1,"},
{"lineNum":"  181","line":"#endif"},
{"lineNum":"  182","line":"    HasRint = 1"},
{"lineNum":"  183","line":"  };"},
{"lineNum":"  184","line":"};"},
{"lineNum":"  185","line":"template<> struct packet_traits<int>    : default_packet_traits"},
{"lineNum":"  186","line":"{"},
{"lineNum":"  187","line":"  typedef Packet4i type;"},
{"lineNum":"  188","line":"  typedef Packet4i half;"},
{"lineNum":"  189","line":"  enum {"},
{"lineNum":"  190","line":"    Vectorizable = 1,"},
{"lineNum":"  191","line":"    AlignedOnScalar = 1,"},
{"lineNum":"  192","line":"    size=4,"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"    HasShift = 1,"},
{"lineNum":"  195","line":"    HasBlend = 1"},
{"lineNum":"  196","line":"  };"},
{"lineNum":"  197","line":"};"},
{"lineNum":"  198","line":"#endif"},
{"lineNum":"  199","line":"template<> struct packet_traits<bool> : default_packet_traits"},
{"lineNum":"  200","line":"{"},
{"lineNum":"  201","line":"  typedef Packet16b type;"},
{"lineNum":"  202","line":"  typedef Packet16b half;"},
{"lineNum":"  203","line":"  enum {"},
{"lineNum":"  204","line":"    Vectorizable = 1,"},
{"lineNum":"  205","line":"    AlignedOnScalar = 1,"},
{"lineNum":"  206","line":"    HasHalfPacket = 0,"},
{"lineNum":"  207","line":"    size=16,"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"    HasAdd       = 1,"},
{"lineNum":"  210","line":"    HasSub       = 1,"},
{"lineNum":"  211","line":"    HasShift     = 0,"},
{"lineNum":"  212","line":"    HasMul       = 1,"},
{"lineNum":"  213","line":"    HasNegate    = 1,"},
{"lineNum":"  214","line":"    HasAbs       = 0,"},
{"lineNum":"  215","line":"    HasAbs2      = 0,"},
{"lineNum":"  216","line":"    HasMin       = 0,"},
{"lineNum":"  217","line":"    HasMax       = 0,"},
{"lineNum":"  218","line":"    HasConj      = 0,"},
{"lineNum":"  219","line":"    HasSqrt      = 1"},
{"lineNum":"  220","line":"  };"},
{"lineNum":"  221","line":"};"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"template<> struct unpacket_traits<Packet4f> {"},
{"lineNum":"  224","line":"  typedef float     type;"},
{"lineNum":"  225","line":"  typedef Packet4f  half;"},
{"lineNum":"  226","line":"  typedef Packet4i  integer_packet;"},
{"lineNum":"  227","line":"  enum {size=4, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false};"},
{"lineNum":"  228","line":"};"},
{"lineNum":"  229","line":"template<> struct unpacket_traits<Packet2d> {"},
{"lineNum":"  230","line":"  typedef double    type;"},
{"lineNum":"  231","line":"  typedef Packet2d  half;"},
{"lineNum":"  232","line":"  enum {size=2, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false};"},
{"lineNum":"  233","line":"};"},
{"lineNum":"  234","line":"template<> struct unpacket_traits<Packet4i> {"},
{"lineNum":"  235","line":"  typedef int       type;"},
{"lineNum":"  236","line":"  typedef Packet4i  half;"},
{"lineNum":"  237","line":"  enum {size=4, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false};"},
{"lineNum":"  238","line":"};"},
{"lineNum":"  239","line":"template<> struct unpacket_traits<Packet16b> {"},
{"lineNum":"  240","line":"  typedef bool       type;"},
{"lineNum":"  241","line":"  typedef Packet16b  half;"},
{"lineNum":"  242","line":"  enum {size=16, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false};"},
{"lineNum":"  243","line":"};"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"#ifndef EIGEN_VECTORIZE_AVX"},
{"lineNum":"  246","line":"template<> struct scalar_div_cost<float,true> { enum { value = 7 }; };"},
{"lineNum":"  247","line":"template<> struct scalar_div_cost<double,true> { enum { value = 8 }; };"},
{"lineNum":"  248","line":"#endif"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"#if EIGEN_COMP_MSVC==1500"},
{"lineNum":"  251","line":"// Workaround MSVC 9 internal compiler error."},
{"lineNum":"  252","line":"// TODO: It has been detected with win64 builds (amd64), so let\'s check whether it also happens in 32bits+SSE mode"},
{"lineNum":"  253","line":"// TODO: let\'s check whether there does not exist a better fix, like adding a pset0() function. (it crashed on pset1(0))."},
{"lineNum":"  254","line":"template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }"},
{"lineNum":"  255","line":"template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }"},
{"lineNum":"  256","line":"template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }"},
{"lineNum":"  257","line":"#else"},
{"lineNum":"  258","line":"template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps1(from); }"},
{"lineNum":"  259","line":"template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }","class":"lineNoCov","hits":"0","possible_hits":"146",},
{"lineNum":"  260","line":"template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }"},
{"lineNum":"  261","line":"#endif"},
{"lineNum":"  262","line":"template<> EIGEN_STRONG_INLINE Packet16b pset1<Packet16b>(const bool&    from) { return _mm_set1_epi8(static_cast<char>(from)); }"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"template<> EIGEN_STRONG_INLINE Packet4f pset1frombits<Packet4f>(unsigned int from) { return _mm_castsi128_ps(pset1<Packet4i>(from)); }"},
{"lineNum":"  265","line":"template<> EIGEN_STRONG_INLINE Packet2d pset1frombits<Packet2d>(uint64_t from) { return _mm_castsi128_pd(_mm_set1_epi64x(from)); }"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"template<> EIGEN_STRONG_INLINE Packet4f peven_mask(const Packet4f& /*a*/) { return _mm_castsi128_ps(_mm_set_epi32(0, -1, 0, -1)); }"},
{"lineNum":"  268","line":"template<> EIGEN_STRONG_INLINE Packet4i peven_mask(const Packet4i& /*a*/) { return _mm_set_epi32(0, -1, 0, -1); }"},
{"lineNum":"  269","line":"template<> EIGEN_STRONG_INLINE Packet2d peven_mask(const Packet2d& /*a*/) { return _mm_castsi128_pd(_mm_set_epi32(0, 0, -1, -1)); }"},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"template<> EIGEN_STRONG_INLINE Packet4f pzero(const Packet4f& /*a*/) { return _mm_setzero_ps(); }"},
{"lineNum":"  272","line":"template<> EIGEN_STRONG_INLINE Packet2d pzero(const Packet2d& /*a*/) { return _mm_setzero_pd(); }"},
{"lineNum":"  273","line":"template<> EIGEN_STRONG_INLINE Packet4i pzero(const Packet4i& /*a*/) { return _mm_setzero_si128(); }"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"// GCC generates a shufps instruction for _mm_set1_ps/_mm_load1_ps instead of the more efficient pshufd instruction."},
{"lineNum":"  276","line":"// However, using inrinsics for pset1 makes gcc to generate crappy code in some cases (see bug 203)"},
{"lineNum":"  277","line":"// Using inline assembly is also not an option because then gcc fails to reorder properly the instructions."},
{"lineNum":"  278","line":"// Therefore, we introduced the pload1 functions to be used in product kernels for which bug 203 does not apply."},
{"lineNum":"  279","line":"// Also note that with AVX, we want it to generate a vbroadcastss."},
{"lineNum":"  280","line":"#if EIGEN_COMP_GNUC_STRICT && (!defined __AVX__)"},
{"lineNum":"  281","line":"template<> EIGEN_STRONG_INLINE Packet4f pload1<Packet4f>(const float *from) {"},
{"lineNum":"  282","line":"  return vec4f_swizzle1(_mm_load_ss(from),0,0,0,0);"},
{"lineNum":"  283","line":"}"},
{"lineNum":"  284","line":"#endif"},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"template<> EIGEN_STRONG_INLINE Packet4f plset<Packet4f>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }"},
{"lineNum":"  287","line":"template<> EIGEN_STRONG_INLINE Packet2d plset<Packet2d>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }"},
{"lineNum":"  288","line":"template<> EIGEN_STRONG_INLINE Packet4i plset<Packet4i>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }"},
{"lineNum":"  291","line":"template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }","class":"lineNoCov","hits":"0","possible_hits":"659",},
{"lineNum":"  292","line":"template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"template<> EIGEN_STRONG_INLINE Packet16b padd<Packet16b>(const Packet16b& a, const Packet16b& b) { return _mm_or_si128(a,b); }"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }"},
{"lineNum":"  297","line":"template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }","class":"lineNoCov","hits":"0","possible_hits":"31",},
{"lineNum":"  298","line":"template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }"},
{"lineNum":"  299","line":"template<> EIGEN_STRONG_INLINE Packet16b psub<Packet16b>(const Packet16b& a, const Packet16b& b) { return _mm_xor_si128(a,b); }"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b);"},
{"lineNum":"  302","line":"template<> EIGEN_STRONG_INLINE Packet4f paddsub<Packet4f>(const Packet4f& a, const Packet4f& b)"},
{"lineNum":"  303","line":"{"},
{"lineNum":"  304","line":"#ifdef EIGEN_VECTORIZE_SSE3"},
{"lineNum":"  305","line":"  return _mm_addsub_ps(a,b);"},
{"lineNum":"  306","line":"#else"},
{"lineNum":"  307","line":"  const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x0,0x80000000,0x0));"},
{"lineNum":"  308","line":"  return padd(a, pxor(mask, b));"},
{"lineNum":"  309","line":"#endif"},
{"lineNum":"  310","line":"}"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& , const Packet2d& );"},
{"lineNum":"  313","line":"template<> EIGEN_STRONG_INLINE Packet2d paddsub<Packet2d>(const Packet2d& a, const Packet2d& b)"},
{"lineNum":"  314","line":"{"},
{"lineNum":"  315","line":"#ifdef EIGEN_VECTORIZE_SSE3"},
{"lineNum":"  316","line":"  return _mm_addsub_pd(a,b);"},
{"lineNum":"  317","line":"#else"},
{"lineNum":"  318","line":"  const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0x0,0x80000000,0x0,0x0));"},
{"lineNum":"  319","line":"  return padd(a, pxor(mask, b));"},
{"lineNum":"  320","line":"#endif"},
{"lineNum":"  321","line":"}"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)"},
{"lineNum":"  324","line":"{"},
{"lineNum":"  325","line":"  const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x80000000,0x80000000,0x80000000,0x80000000));"},
{"lineNum":"  326","line":"  return _mm_xor_ps(a,mask);"},
{"lineNum":"  327","line":"}"},
{"lineNum":"  328","line":"template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)"},
{"lineNum":"  329","line":"{"},
{"lineNum":"  330","line":"  const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0x0,0x80000000,0x0,0x80000000));"},
{"lineNum":"  331","line":"  return _mm_xor_pd(a,mask);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  332","line":"}"},
{"lineNum":"  333","line":"template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)"},
{"lineNum":"  334","line":"{"},
{"lineNum":"  335","line":"  return psub(Packet4i(_mm_setr_epi32(0,0,0,0)), a);"},
{"lineNum":"  336","line":"}"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"template<> EIGEN_STRONG_INLINE Packet16b pnegate(const Packet16b& a)"},
{"lineNum":"  339","line":"{"},
{"lineNum":"  340","line":"  return psub(pset1<Packet16b>(false), a);"},
{"lineNum":"  341","line":"}"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }"},
{"lineNum":"  344","line":"template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }"},
{"lineNum":"  345","line":"template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }"},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }"},
{"lineNum":"  348","line":"template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }","class":"lineNoCov","hits":"0","possible_hits":"646",},
{"lineNum":"  349","line":"template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)"},
{"lineNum":"  350","line":"{"},
{"lineNum":"  351","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":"  352","line":"  return _mm_mullo_epi32(a,b);"},
{"lineNum":"  353","line":"#else"},
{"lineNum":"  354","line":"  // this version is slightly faster than 4 scalar products"},
{"lineNum":"  355","line":"  return vec4i_swizzle1("},
{"lineNum":"  356","line":"            vec4i_swizzle2("},
{"lineNum":"  357","line":"              _mm_mul_epu32(a,b),"},
{"lineNum":"  358","line":"              _mm_mul_epu32(vec4i_swizzle1(a,1,0,3,2),"},
{"lineNum":"  359","line":"                            vec4i_swizzle1(b,1,0,3,2)),"},
{"lineNum":"  360","line":"              0,2,0,2),"},
{"lineNum":"  361","line":"            0,2,1,3);"},
{"lineNum":"  362","line":"#endif"},
{"lineNum":"  363","line":"}"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"template<> EIGEN_STRONG_INLINE Packet16b pmul<Packet16b>(const Packet16b& a, const Packet16b& b) { return _mm_and_si128(a,b); }"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }"},
{"lineNum":"  368","line":"template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }","class":"lineNoCov","hits":"0","possible_hits":"30",},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"// for some weird raisons, it has to be overloaded for packet of integers"},
{"lineNum":"  371","line":"template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }"},
{"lineNum":"  372","line":"#ifdef EIGEN_VECTORIZE_FMA"},
{"lineNum":"  373","line":"template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return _mm_fmadd_ps(a,b,c); }"},
{"lineNum":"  374","line":"template<> EIGEN_STRONG_INLINE Packet2d pmadd(const Packet2d& a, const Packet2d& b, const Packet2d& c) { return _mm_fmadd_pd(a,b,c); }"},
{"lineNum":"  375","line":"#endif"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":"  378","line":"template<> EIGEN_DEVICE_FUNC inline Packet4f pselect(const Packet4f& mask, const Packet4f& a, const Packet4f& b) {"},
{"lineNum":"  379","line":"  return _mm_blendv_ps(b,a,mask);"},
{"lineNum":"  380","line":"}"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"template<> EIGEN_DEVICE_FUNC inline Packet4i pselect(const Packet4i& mask, const Packet4i& a, const Packet4i& b) {"},
{"lineNum":"  383","line":"  return _mm_castps_si128(_mm_blendv_ps(_mm_castsi128_ps(b),_mm_castsi128_ps(a),_mm_castsi128_ps(mask)));"},
{"lineNum":"  384","line":"}"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"template<> EIGEN_DEVICE_FUNC inline Packet2d pselect(const Packet2d& mask, const Packet2d& a, const Packet2d& b) {  return _mm_blendv_pd(b,a,mask); }"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"template<> EIGEN_DEVICE_FUNC inline Packet16b pselect(const Packet16b& mask, const Packet16b& a, const Packet16b& b) {"},
{"lineNum":"  389","line":"  return _mm_blendv_epi8(b,a,mask);"},
{"lineNum":"  390","line":"}"},
{"lineNum":"  391","line":"#else"},
{"lineNum":"  392","line":"template<> EIGEN_DEVICE_FUNC inline Packet16b pselect(const Packet16b& mask, const Packet16b& a, const Packet16b& b) {"},
{"lineNum":"  393","line":"  Packet16b a_part = _mm_and_si128(mask, a);"},
{"lineNum":"  394","line":"  Packet16b b_part = _mm_andnot_si128(mask, b);"},
{"lineNum":"  395","line":"  return _mm_or_si128(a_part, b_part);"},
{"lineNum":"  396","line":"}"},
{"lineNum":"  397","line":"#endif"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"template<> EIGEN_STRONG_INLINE Packet4i ptrue<Packet4i>(const Packet4i& a) { return _mm_cmpeq_epi32(a, a); }"},
{"lineNum":"  400","line":"template<> EIGEN_STRONG_INLINE Packet16b ptrue<Packet16b>(const Packet16b& a) { return _mm_cmpeq_epi8(a, a); }"},
{"lineNum":"  401","line":"template<> EIGEN_STRONG_INLINE Packet4f"},
{"lineNum":"  402","line":"ptrue<Packet4f>(const Packet4f& a) {"},
{"lineNum":"  403","line":"  Packet4i b = _mm_castps_si128(a);"},
{"lineNum":"  404","line":"  return _mm_castsi128_ps(_mm_cmpeq_epi32(b, b));"},
{"lineNum":"  405","line":"}"},
{"lineNum":"  406","line":"template<> EIGEN_STRONG_INLINE Packet2d"},
{"lineNum":"  407","line":"ptrue<Packet2d>(const Packet2d& a) {"},
{"lineNum":"  408","line":"  Packet4i b = _mm_castpd_si128(a);"},
{"lineNum":"  409","line":"  return _mm_castsi128_pd(_mm_cmpeq_epi32(b, b));"},
{"lineNum":"  410","line":"}"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }"},
{"lineNum":"  414","line":"template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }"},
{"lineNum":"  415","line":"template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }"},
{"lineNum":"  416","line":"template<> EIGEN_STRONG_INLINE Packet16b pand<Packet16b>(const Packet16b& a, const Packet16b& b) { return _mm_and_si128(a,b); }"},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }"},
{"lineNum":"  419","line":"template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }"},
{"lineNum":"  420","line":"template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }"},
{"lineNum":"  421","line":"template<> EIGEN_STRONG_INLINE Packet16b por<Packet16b>(const Packet16b& a, const Packet16b& b) { return _mm_or_si128(a,b); }"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }"},
{"lineNum":"  424","line":"template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }"},
{"lineNum":"  425","line":"template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }"},
{"lineNum":"  426","line":"template<> EIGEN_STRONG_INLINE Packet16b pxor<Packet16b>(const Packet16b& a, const Packet16b& b) { return _mm_xor_si128(a,b); }"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(b,a); }"},
{"lineNum":"  429","line":"template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(b,a); }"},
{"lineNum":"  430","line":"template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(b,a); }"},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"template<> EIGEN_STRONG_INLINE Packet4f pcmp_le(const Packet4f& a, const Packet4f& b) { return _mm_cmple_ps(a,b); }"},
{"lineNum":"  433","line":"template<> EIGEN_STRONG_INLINE Packet4f pcmp_lt(const Packet4f& a, const Packet4f& b) { return _mm_cmplt_ps(a,b); }"},
{"lineNum":"  434","line":"template<> EIGEN_STRONG_INLINE Packet4f pcmp_lt_or_nan(const Packet4f& a, const Packet4f& b) { return _mm_cmpnge_ps(a,b); }"},
{"lineNum":"  435","line":"template<> EIGEN_STRONG_INLINE Packet4f pcmp_eq(const Packet4f& a, const Packet4f& b) { return _mm_cmpeq_ps(a,b); }"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"template<> EIGEN_STRONG_INLINE Packet2d pcmp_le(const Packet2d& a, const Packet2d& b) { return _mm_cmple_pd(a,b); }"},
{"lineNum":"  438","line":"template<> EIGEN_STRONG_INLINE Packet2d pcmp_lt(const Packet2d& a, const Packet2d& b) { return _mm_cmplt_pd(a,b); }"},
{"lineNum":"  439","line":"template<> EIGEN_STRONG_INLINE Packet2d pcmp_lt_or_nan(const Packet2d& a, const Packet2d& b) { return _mm_cmpnge_pd(a,b); }"},
{"lineNum":"  440","line":"template<> EIGEN_STRONG_INLINE Packet2d pcmp_eq(const Packet2d& a, const Packet2d& b) { return _mm_cmpeq_pd(a,b); }"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"template<> EIGEN_STRONG_INLINE Packet4i pcmp_lt(const Packet4i& a, const Packet4i& b) { return _mm_cmplt_epi32(a,b); }"},
{"lineNum":"  443","line":"template<> EIGEN_STRONG_INLINE Packet4i pcmp_eq(const Packet4i& a, const Packet4i& b) { return _mm_cmpeq_epi32(a,b); }"},
{"lineNum":"  444","line":"template<> EIGEN_STRONG_INLINE Packet16b pcmp_eq(const Packet16b& a, const Packet16b& b) { return _mm_cmpeq_epi8(a,b); }"},
{"lineNum":"  445","line":"template<> EIGEN_STRONG_INLINE Packet4i pcmp_le(const Packet4i& a, const Packet4i& b) { return por(pcmp_lt(a,b), pcmp_eq(a,b)); }"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) {"},
{"lineNum":"  448","line":"#if EIGEN_COMP_GNUC && EIGEN_COMP_GNUC < 63"},
{"lineNum":"  449","line":"  // There appears to be a bug in GCC, by which the optimizer may"},
{"lineNum":"  450","line":"  // flip the argument order in calls to _mm_min_ps, so we have to"},
{"lineNum":"  451","line":"  // resort to inline ASM here. This is supposed to be fixed in gcc6.3,"},
{"lineNum":"  452","line":"  // see also: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=72867"},
{"lineNum":"  453","line":"  #ifdef EIGEN_VECTORIZE_AVX"},
{"lineNum":"  454","line":"  Packet4f res;"},
{"lineNum":"  455","line":"  asm(\"vminps %[a], %[b], %[res]\" : [res] \"=x\" (res) : [a] \"x\" (a), [b] \"x\" (b));"},
{"lineNum":"  456","line":"  #else"},
{"lineNum":"  457","line":"  Packet4f res = b;"},
{"lineNum":"  458","line":"  asm(\"minps %[a], %[res]\" : [res] \"+x\" (res) : [a] \"x\" (a));"},
{"lineNum":"  459","line":"  #endif"},
{"lineNum":"  460","line":"  return res;"},
{"lineNum":"  461","line":"#else"},
{"lineNum":"  462","line":"  // Arguments are reversed to match NaN propagation behavior of std::min."},
{"lineNum":"  463","line":"  return _mm_min_ps(b, a);"},
{"lineNum":"  464","line":"#endif"},
{"lineNum":"  465","line":"}"},
{"lineNum":"  466","line":"template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) {"},
{"lineNum":"  467","line":"#if EIGEN_COMP_GNUC && EIGEN_COMP_GNUC < 63"},
{"lineNum":"  468","line":"  // There appears to be a bug in GCC, by which the optimizer may"},
{"lineNum":"  469","line":"  // flip the argument order in calls to _mm_min_pd, so we have to"},
{"lineNum":"  470","line":"  // resort to inline ASM here. This is supposed to be fixed in gcc6.3,"},
{"lineNum":"  471","line":"  // see also: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=72867"},
{"lineNum":"  472","line":"  #ifdef EIGEN_VECTORIZE_AVX"},
{"lineNum":"  473","line":"  Packet2d res;"},
{"lineNum":"  474","line":"  asm(\"vminpd %[a], %[b], %[res]\" : [res] \"=x\" (res) : [a] \"x\" (a), [b] \"x\" (b));"},
{"lineNum":"  475","line":"  #else"},
{"lineNum":"  476","line":"  Packet2d res = b;"},
{"lineNum":"  477","line":"  asm(\"minpd %[a], %[res]\" : [res] \"+x\" (res) : [a] \"x\" (a));"},
{"lineNum":"  478","line":"  #endif"},
{"lineNum":"  479","line":"  return res;"},
{"lineNum":"  480","line":"#else"},
{"lineNum":"  481","line":"  // Arguments are reversed to match NaN propagation behavior of std::min."},
{"lineNum":"  482","line":"  return _mm_min_pd(b, a);"},
{"lineNum":"  483","line":"#endif"},
{"lineNum":"  484","line":"}"},
{"lineNum":"  485","line":"template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)"},
{"lineNum":"  486","line":"{"},
{"lineNum":"  487","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":"  488","line":"  return _mm_min_epi32(a,b);"},
{"lineNum":"  489","line":"#else"},
{"lineNum":"  490","line":"  // after some bench, this version *is* faster than a scalar implementation"},
{"lineNum":"  491","line":"  Packet4i mask = _mm_cmplt_epi32(a,b);"},
{"lineNum":"  492","line":"  return _mm_or_si128(_mm_and_si128(mask,a),_mm_andnot_si128(mask,b));"},
{"lineNum":"  493","line":"#endif"},
{"lineNum":"  494","line":"}"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) {"},
{"lineNum":"  498","line":"#if EIGEN_COMP_GNUC && EIGEN_COMP_GNUC < 63"},
{"lineNum":"  499","line":"  // There appears to be a bug in GCC, by which the optimizer may"},
{"lineNum":"  500","line":"  // flip the argument order in calls to _mm_max_ps, so we have to"},
{"lineNum":"  501","line":"  // resort to inline ASM here. This is supposed to be fixed in gcc6.3,"},
{"lineNum":"  502","line":"  // see also: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=72867"},
{"lineNum":"  503","line":"  #ifdef EIGEN_VECTORIZE_AVX"},
{"lineNum":"  504","line":"  Packet4f res;"},
{"lineNum":"  505","line":"  asm(\"vmaxps %[a], %[b], %[res]\" : [res] \"=x\" (res) : [a] \"x\" (a), [b] \"x\" (b));"},
{"lineNum":"  506","line":"  #else"},
{"lineNum":"  507","line":"  Packet4f res = b;"},
{"lineNum":"  508","line":"  asm(\"maxps %[a], %[res]\" : [res] \"+x\" (res) : [a] \"x\" (a));"},
{"lineNum":"  509","line":"  #endif"},
{"lineNum":"  510","line":"  return res;"},
{"lineNum":"  511","line":"#else"},
{"lineNum":"  512","line":"  // Arguments are reversed to match NaN propagation behavior of std::max."},
{"lineNum":"  513","line":"  return _mm_max_ps(b, a);"},
{"lineNum":"  514","line":"#endif"},
{"lineNum":"  515","line":"}"},
{"lineNum":"  516","line":"template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) {"},
{"lineNum":"  517","line":"#if EIGEN_COMP_GNUC && EIGEN_COMP_GNUC < 63"},
{"lineNum":"  518","line":"  // There appears to be a bug in GCC, by which the optimizer may"},
{"lineNum":"  519","line":"  // flip the argument order in calls to _mm_max_pd, so we have to"},
{"lineNum":"  520","line":"  // resort to inline ASM here. This is supposed to be fixed in gcc6.3,"},
{"lineNum":"  521","line":"  // see also: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=72867"},
{"lineNum":"  522","line":"  #ifdef EIGEN_VECTORIZE_AVX"},
{"lineNum":"  523","line":"  Packet2d res;"},
{"lineNum":"  524","line":"  asm(\"vmaxpd %[a], %[b], %[res]\" : [res] \"=x\" (res) : [a] \"x\" (a), [b] \"x\" (b));"},
{"lineNum":"  525","line":"  #else"},
{"lineNum":"  526","line":"  Packet2d res = b;"},
{"lineNum":"  527","line":"  asm(\"maxpd %[a], %[res]\" : [res] \"+x\" (res) : [a] \"x\" (a));","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  528","line":"  #endif"},
{"lineNum":"  529","line":"  return res;"},
{"lineNum":"  530","line":"#else"},
{"lineNum":"  531","line":"  // Arguments are reversed to match NaN propagation behavior of std::max."},
{"lineNum":"  532","line":"  return _mm_max_pd(b, a);"},
{"lineNum":"  533","line":"#endif"},
{"lineNum":"  534","line":"}"},
{"lineNum":"  535","line":"template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)"},
{"lineNum":"  536","line":"{"},
{"lineNum":"  537","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":"  538","line":"  return _mm_max_epi32(a,b);"},
{"lineNum":"  539","line":"#else"},
{"lineNum":"  540","line":"  // after some bench, this version *is* faster than a scalar implementation"},
{"lineNum":"  541","line":"  Packet4i mask = _mm_cmpgt_epi32(a,b);"},
{"lineNum":"  542","line":"  return _mm_or_si128(_mm_and_si128(mask,a),_mm_andnot_si128(mask,b));"},
{"lineNum":"  543","line":"#endif"},
{"lineNum":"  544","line":"}"},
{"lineNum":"  545","line":""},
{"lineNum":"  546","line":"template <typename Packet, typename Op>"},
{"lineNum":"  547","line":"EIGEN_STRONG_INLINE Packet pminmax_propagate_numbers(const Packet& a, const Packet& b, Op op) {"},
{"lineNum":"  548","line":"  // In this implementation, we take advantage of the fact that pmin/pmax for SSE"},
{"lineNum":"  549","line":"  // always return a if either a or b is NaN."},
{"lineNum":"  550","line":"  Packet not_nan_mask_a = pcmp_eq(a, a);"},
{"lineNum":"  551","line":"  Packet m = op(a, b);"},
{"lineNum":"  552","line":"  return pselect<Packet>(not_nan_mask_a, m, b);"},
{"lineNum":"  553","line":"}"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"template <typename Packet, typename Op>"},
{"lineNum":"  556","line":"EIGEN_STRONG_INLINE Packet pminmax_propagate_nan(const Packet& a, const Packet& b, Op op) {"},
{"lineNum":"  557","line":"  // In this implementation, we take advantage of the fact that pmin/pmax for SSE"},
{"lineNum":"  558","line":"  // always return a if either a or b is NaN."},
{"lineNum":"  559","line":"  Packet not_nan_mask_a = pcmp_eq(a, a);"},
{"lineNum":"  560","line":"  Packet m = op(b, a);"},
{"lineNum":"  561","line":"  return pselect<Packet>(not_nan_mask_a, m, a);"},
{"lineNum":"  562","line":"}"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"// Add specializations for min/max with prescribed NaN progation."},
{"lineNum":"  565","line":"template<>"},
{"lineNum":"  566","line":"EIGEN_STRONG_INLINE Packet4f pmin<PropagateNumbers, Packet4f>(const Packet4f& a, const Packet4f& b) {"},
{"lineNum":"  567","line":"  return pminmax_propagate_numbers(a, b, pmin<Packet4f>);"},
{"lineNum":"  568","line":"}"},
{"lineNum":"  569","line":"template<>"},
{"lineNum":"  570","line":"EIGEN_STRONG_INLINE Packet2d pmin<PropagateNumbers, Packet2d>(const Packet2d& a, const Packet2d& b) {"},
{"lineNum":"  571","line":"  return pminmax_propagate_numbers(a, b, pmin<Packet2d>);"},
{"lineNum":"  572","line":"}"},
{"lineNum":"  573","line":"template<>"},
{"lineNum":"  574","line":"EIGEN_STRONG_INLINE Packet4f pmax<PropagateNumbers, Packet4f>(const Packet4f& a, const Packet4f& b) {"},
{"lineNum":"  575","line":"  return pminmax_propagate_numbers(a, b, pmax<Packet4f>);"},
{"lineNum":"  576","line":"}"},
{"lineNum":"  577","line":"template<>"},
{"lineNum":"  578","line":"EIGEN_STRONG_INLINE Packet2d pmax<PropagateNumbers, Packet2d>(const Packet2d& a, const Packet2d& b) {"},
{"lineNum":"  579","line":"  return pminmax_propagate_numbers(a, b, pmax<Packet2d>);"},
{"lineNum":"  580","line":"}"},
{"lineNum":"  581","line":"template<>"},
{"lineNum":"  582","line":"EIGEN_STRONG_INLINE Packet4f pmin<PropagateNaN, Packet4f>(const Packet4f& a, const Packet4f& b) {"},
{"lineNum":"  583","line":"  return pminmax_propagate_nan(a, b, pmin<Packet4f>);"},
{"lineNum":"  584","line":"}"},
{"lineNum":"  585","line":"template<>"},
{"lineNum":"  586","line":"EIGEN_STRONG_INLINE Packet2d pmin<PropagateNaN, Packet2d>(const Packet2d& a, const Packet2d& b) {"},
{"lineNum":"  587","line":"  return pminmax_propagate_nan(a, b, pmin<Packet2d>);"},
{"lineNum":"  588","line":"}"},
{"lineNum":"  589","line":"template<>"},
{"lineNum":"  590","line":"EIGEN_STRONG_INLINE Packet4f pmax<PropagateNaN, Packet4f>(const Packet4f& a, const Packet4f& b) {"},
{"lineNum":"  591","line":"  return pminmax_propagate_nan(a, b, pmax<Packet4f>);"},
{"lineNum":"  592","line":"}"},
{"lineNum":"  593","line":"template<>"},
{"lineNum":"  594","line":"EIGEN_STRONG_INLINE Packet2d pmax<PropagateNaN, Packet2d>(const Packet2d& a, const Packet2d& b) {"},
{"lineNum":"  595","line":"  return pminmax_propagate_nan(a, b, pmax<Packet2d>);"},
{"lineNum":"  596","line":"}"},
{"lineNum":"  597","line":""},
{"lineNum":"  598","line":"template<int N> EIGEN_STRONG_INLINE Packet4i parithmetic_shift_right(const Packet4i& a) { return _mm_srai_epi32(a,N); }"},
{"lineNum":"  599","line":"template<int N> EIGEN_STRONG_INLINE Packet4i plogical_shift_right   (const Packet4i& a) { return _mm_srli_epi32(a,N); }"},
{"lineNum":"  600","line":"template<int N> EIGEN_STRONG_INLINE Packet4i plogical_shift_left    (const Packet4i& a) { return _mm_slli_epi32(a,N); }"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)"},
{"lineNum":"  603","line":"{"},
{"lineNum":"  604","line":"  const Packet4f mask = _mm_castsi128_ps(_mm_setr_epi32(0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF,0x7FFFFFFF));"},
{"lineNum":"  605","line":"  return _mm_and_ps(a,mask);"},
{"lineNum":"  606","line":"}"},
{"lineNum":"  607","line":"template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)"},
{"lineNum":"  608","line":"{"},
{"lineNum":"  609","line":"  const Packet2d mask = _mm_castsi128_pd(_mm_setr_epi32(0xFFFFFFFF,0x7FFFFFFF,0xFFFFFFFF,0x7FFFFFFF));"},
{"lineNum":"  610","line":"  return _mm_and_pd(a,mask);","class":"lineNoCov","hits":"0","possible_hits":"114",},
{"lineNum":"  611","line":"}"},
{"lineNum":"  612","line":"template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)"},
{"lineNum":"  613","line":"{"},
{"lineNum":"  614","line":"  #ifdef EIGEN_VECTORIZE_SSSE3"},
{"lineNum":"  615","line":"  return _mm_abs_epi32(a);"},
{"lineNum":"  616","line":"  #else"},
{"lineNum":"  617","line":"  Packet4i aux = _mm_srai_epi32(a,31);"},
{"lineNum":"  618","line":"  return _mm_sub_epi32(_mm_xor_si128(a,aux),aux);"},
{"lineNum":"  619","line":"  #endif"},
{"lineNum":"  620","line":"}"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":"  623","line":"template<> EIGEN_STRONG_INLINE Packet4f pround<Packet4f>(const Packet4f& a)"},
{"lineNum":"  624","line":"{"},
{"lineNum":"  625","line":"  // Unfortunately _mm_round_ps doesn\'t have a rounding mode to implement numext::round."},
{"lineNum":"  626","line":"  const Packet4f mask = pset1frombits<Packet4f>(0x80000000u);"},
{"lineNum":"  627","line":"  const Packet4f prev0dot5 = pset1frombits<Packet4f>(0x3EFFFFFFu);"},
{"lineNum":"  628","line":"  return _mm_round_ps(padd(por(pand(a, mask), prev0dot5), a), _MM_FROUND_TO_ZERO);"},
{"lineNum":"  629","line":"}"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"template<> EIGEN_STRONG_INLINE Packet2d pround<Packet2d>(const Packet2d& a)"},
{"lineNum":"  632","line":"{"},
{"lineNum":"  633","line":"  const Packet2d mask = _mm_castsi128_pd(_mm_set_epi64x(0x8000000000000000ull, 0x8000000000000000ull));"},
{"lineNum":"  634","line":"  const Packet2d prev0dot5 = _mm_castsi128_pd(_mm_set_epi64x(0x3FDFFFFFFFFFFFFFull, 0x3FDFFFFFFFFFFFFFull));"},
{"lineNum":"  635","line":"  return _mm_round_pd(padd(por(pand(a, mask), prev0dot5), a), _MM_FROUND_TO_ZERO);"},
{"lineNum":"  636","line":"}"},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"template<> EIGEN_STRONG_INLINE Packet4f print<Packet4f>(const Packet4f& a) { return _mm_round_ps(a, _MM_FROUND_CUR_DIRECTION); }"},
{"lineNum":"  639","line":"template<> EIGEN_STRONG_INLINE Packet2d print<Packet2d>(const Packet2d& a) { return _mm_round_pd(a, _MM_FROUND_CUR_DIRECTION); }"},
{"lineNum":"  640","line":""},
{"lineNum":"  641","line":"template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const Packet4f& a) { return _mm_ceil_ps(a); }"},
{"lineNum":"  642","line":"template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const Packet2d& a) { return _mm_ceil_pd(a); }"},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":"template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a) { return _mm_floor_ps(a); }"},
{"lineNum":"  645","line":"template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a) { return _mm_floor_pd(a); }"},
{"lineNum":"  646","line":"#else"},
{"lineNum":"  647","line":"template<> EIGEN_STRONG_INLINE Packet4f print(const Packet4f& a) {"},
{"lineNum":"  648","line":"  // Adds and subtracts signum(a) * 2^23 to force rounding."},
{"lineNum":"  649","line":"  const Packet4f limit = pset1<Packet4f>(static_cast<float>(1<<23));"},
{"lineNum":"  650","line":"  const Packet4f abs_a = pabs(a);"},
{"lineNum":"  651","line":"  Packet4f r = padd(abs_a, limit);"},
{"lineNum":"  652","line":"  // Don\'t compile-away addition and subtraction."},
{"lineNum":"  653","line":"  EIGEN_OPTIMIZATION_BARRIER(r);"},
{"lineNum":"  654","line":"  r = psub(r, limit);"},
{"lineNum":"  655","line":"  // If greater than limit, simply return a.  Otherwise, account for sign."},
{"lineNum":"  656","line":"  r = pselect(pcmp_lt(abs_a, limit),"},
{"lineNum":"  657","line":"              pselect(pcmp_lt(a, pzero(a)), pnegate(r), r), a);"},
{"lineNum":"  658","line":"  return r;"},
{"lineNum":"  659","line":"}"},
{"lineNum":"  660","line":""},
{"lineNum":"  661","line":"template<> EIGEN_STRONG_INLINE Packet2d print(const Packet2d& a) {"},
{"lineNum":"  662","line":"  // Adds and subtracts signum(a) * 2^52 to force rounding."},
{"lineNum":"  663","line":"  const Packet2d limit = pset1<Packet2d>(static_cast<double>(1ull<<52));"},
{"lineNum":"  664","line":"  const Packet2d abs_a = pabs(a);"},
{"lineNum":"  665","line":"  Packet2d r = padd(abs_a, limit);"},
{"lineNum":"  666","line":"  // Don\'t compile-away addition and subtraction."},
{"lineNum":"  667","line":"  EIGEN_OPTIMIZATION_BARRIER(r);"},
{"lineNum":"  668","line":"  r = psub(r, limit);"},
{"lineNum":"  669","line":"  // If greater than limit, simply return a.  Otherwise, account for sign."},
{"lineNum":"  670","line":"  r = pselect(pcmp_lt(abs_a, limit),"},
{"lineNum":"  671","line":"              pselect(pcmp_lt(a, pzero(a)), pnegate(r), r), a);"},
{"lineNum":"  672","line":"  return r;"},
{"lineNum":"  673","line":"}"},
{"lineNum":"  674","line":""},
{"lineNum":"  675","line":"template<> EIGEN_STRONG_INLINE Packet4f pfloor<Packet4f>(const Packet4f& a)"},
{"lineNum":"  676","line":"{"},
{"lineNum":"  677","line":"  const Packet4f cst_1 = pset1<Packet4f>(1.0f);"},
{"lineNum":"  678","line":"  Packet4f tmp  = print<Packet4f>(a);"},
{"lineNum":"  679","line":"  // If greater, subtract one."},
{"lineNum":"  680","line":"  Packet4f mask = _mm_cmpgt_ps(tmp, a);"},
{"lineNum":"  681","line":"  mask = pand(mask, cst_1);"},
{"lineNum":"  682","line":"  return psub(tmp, mask);"},
{"lineNum":"  683","line":"}"},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"template<> EIGEN_STRONG_INLINE Packet2d pfloor<Packet2d>(const Packet2d& a)"},
{"lineNum":"  686","line":"{"},
{"lineNum":"  687","line":"  const Packet2d cst_1 = pset1<Packet2d>(1.0);"},
{"lineNum":"  688","line":"  Packet2d tmp  = print<Packet2d>(a);"},
{"lineNum":"  689","line":"  // If greater, subtract one."},
{"lineNum":"  690","line":"  Packet2d mask = _mm_cmpgt_pd(tmp, a);"},
{"lineNum":"  691","line":"  mask = pand(mask, cst_1);"},
{"lineNum":"  692","line":"  return psub(tmp, mask);"},
{"lineNum":"  693","line":"}"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"template<> EIGEN_STRONG_INLINE Packet4f pceil<Packet4f>(const Packet4f& a)"},
{"lineNum":"  696","line":"{"},
{"lineNum":"  697","line":"  const Packet4f cst_1 = pset1<Packet4f>(1.0f);"},
{"lineNum":"  698","line":"  Packet4f tmp  = print<Packet4f>(a);"},
{"lineNum":"  699","line":"  // If smaller, add one."},
{"lineNum":"  700","line":"  Packet4f mask = _mm_cmplt_ps(tmp, a);"},
{"lineNum":"  701","line":"  mask = pand(mask, cst_1);"},
{"lineNum":"  702","line":"  return padd(tmp, mask);"},
{"lineNum":"  703","line":"}"},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"template<> EIGEN_STRONG_INLINE Packet2d pceil<Packet2d>(const Packet2d& a)"},
{"lineNum":"  706","line":"{"},
{"lineNum":"  707","line":"  const Packet2d cst_1 = pset1<Packet2d>(1.0);"},
{"lineNum":"  708","line":"  Packet2d tmp  = print<Packet2d>(a);"},
{"lineNum":"  709","line":"  // If smaller, add one."},
{"lineNum":"  710","line":"  Packet2d mask = _mm_cmplt_pd(tmp, a);"},
{"lineNum":"  711","line":"  mask = pand(mask, cst_1);"},
{"lineNum":"  712","line":"  return padd(tmp, mask);"},
{"lineNum":"  713","line":"}"},
{"lineNum":"  714","line":"#endif"},
{"lineNum":"  715","line":""},
{"lineNum":"  716","line":"template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }"},
{"lineNum":"  717","line":"template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }","class":"lineNoCov","hits":"0","possible_hits":"188",},
{"lineNum":"  718","line":"template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const __m128i*>(from)); }"},
{"lineNum":"  719","line":"template<> EIGEN_STRONG_INLINE Packet16b pload<Packet16b>(const bool*     from) { EIGEN_DEBUG_ALIGNED_LOAD return  _mm_load_si128(reinterpret_cast<const __m128i*>(from)); }"},
{"lineNum":"  720","line":""},
{"lineNum":"  721","line":"#if EIGEN_COMP_MSVC"},
{"lineNum":"  722","line":"  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {"},
{"lineNum":"  723","line":"    EIGEN_DEBUG_UNALIGNED_LOAD"},
{"lineNum":"  724","line":"    #if (EIGEN_COMP_MSVC==1600)"},
{"lineNum":"  725","line":"    // NOTE Some version of MSVC10 generates bad code when using _mm_loadu_ps"},
{"lineNum":"  726","line":"    // (i.e., it does not generate an unaligned load!!"},
{"lineNum":"  727","line":"    __m128 res = _mm_loadl_pi(_mm_set1_ps(0.0f), (const __m64*)(from));"},
{"lineNum":"  728","line":"    res = _mm_loadh_pi(res, (const __m64*)(from+2));"},
{"lineNum":"  729","line":"    return res;"},
{"lineNum":"  730","line":"    #else"},
{"lineNum":"  731","line":"    return _mm_loadu_ps(from);"},
{"lineNum":"  732","line":"    #endif"},
{"lineNum":"  733","line":"  }"},
{"lineNum":"  734","line":"#else"},
{"lineNum":"  735","line":"// NOTE: with the code below, MSVC\'s compiler crashes!"},
{"lineNum":"  736","line":""},
{"lineNum":"  737","line":"template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)"},
{"lineNum":"  738","line":"{"},
{"lineNum":"  739","line":"  EIGEN_DEBUG_UNALIGNED_LOAD"},
{"lineNum":"  740","line":"  return _mm_loadu_ps(from);"},
{"lineNum":"  741","line":"}"},
{"lineNum":"  742","line":"#endif"},
{"lineNum":"  743","line":""},
{"lineNum":"  744","line":"template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)"},
{"lineNum":"  745","line":"{"},
{"lineNum":"  746","line":"  EIGEN_DEBUG_UNALIGNED_LOAD"},
{"lineNum":"  747","line":"  return _mm_loadu_pd(from);","class":"lineNoCov","hits":"0","possible_hits":"510",},
{"lineNum":"  748","line":"}"},
{"lineNum":"  749","line":"template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)"},
{"lineNum":"  750","line":"{"},
{"lineNum":"  751","line":"  EIGEN_DEBUG_UNALIGNED_LOAD"},
{"lineNum":"  752","line":"  return _mm_loadu_si128(reinterpret_cast<const __m128i*>(from));"},
{"lineNum":"  753","line":"}"},
{"lineNum":"  754","line":"template<> EIGEN_STRONG_INLINE Packet16b ploadu<Packet16b>(const bool*     from) {"},
{"lineNum":"  755","line":"  EIGEN_DEBUG_UNALIGNED_LOAD"},
{"lineNum":"  756","line":"  return _mm_loadu_si128(reinterpret_cast<const __m128i*>(from));"},
{"lineNum":"  757","line":"}"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":""},
{"lineNum":"  760","line":"template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)"},
{"lineNum":"  761","line":"{"},
{"lineNum":"  762","line":"  return vec4f_swizzle1(_mm_castpd_ps(_mm_load_sd(reinterpret_cast<const double*>(from))), 0, 0, 1, 1);"},
{"lineNum":"  763","line":"}"},
{"lineNum":"  764","line":"template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)"},
{"lineNum":"  765","line":"{ return pset1<Packet2d>(from[0]); }"},
{"lineNum":"  766","line":"template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)"},
{"lineNum":"  767","line":"{"},
{"lineNum":"  768","line":"  Packet4i tmp;"},
{"lineNum":"  769","line":"  tmp = _mm_loadl_epi64(reinterpret_cast<const __m128i*>(from));"},
{"lineNum":"  770","line":"  return vec4i_swizzle1(tmp, 0, 0, 1, 1);"},
{"lineNum":"  771","line":"}"},
{"lineNum":"  772","line":""},
{"lineNum":"  773","line":"// Loads 8 bools from memory and returns the packet"},
{"lineNum":"  774","line":"// {b0, b0, b1, b1, b2, b2, b3, b3, b4, b4, b5, b5, b6, b6, b7, b7}"},
{"lineNum":"  775","line":"template<> EIGEN_STRONG_INLINE Packet16b ploaddup<Packet16b>(const bool*     from)"},
{"lineNum":"  776","line":"{"},
{"lineNum":"  777","line":"  __m128i tmp = _mm_castpd_si128(pload1<Packet2d>(reinterpret_cast<const double*>(from)));"},
{"lineNum":"  778","line":"  return  _mm_unpacklo_epi8(tmp, tmp);"},
{"lineNum":"  779","line":"}"},
{"lineNum":"  780","line":""},
{"lineNum":"  781","line":"// Loads 4 bools from memory and returns the packet"},
{"lineNum":"  782","line":"// {b0, b0  b0, b0, b1, b1, b1, b1, b2, b2, b2, b2, b3, b3, b3, b3}"},
{"lineNum":"  783","line":"template<> EIGEN_STRONG_INLINE Packet16b"},
{"lineNum":"  784","line":"ploadquad<Packet16b>(const bool* from) {"},
{"lineNum":"  785","line":"  __m128i tmp = _mm_castps_si128(pload1<Packet4f>(reinterpret_cast<const float*>(from)));"},
{"lineNum":"  786","line":"  tmp = _mm_unpacklo_epi8(tmp, tmp);"},
{"lineNum":"  787","line":"  return  _mm_unpacklo_epi16(tmp, tmp);"},
{"lineNum":"  788","line":"}"},
{"lineNum":"  789","line":""},
{"lineNum":"  790","line":"template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }"},
{"lineNum":"  791","line":"template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }","class":"lineNoCov","hits":"0","possible_hits":"316",},
{"lineNum":"  792","line":"template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<__m128i*>(to), from); }"},
{"lineNum":"  793","line":"template<> EIGEN_STRONG_INLINE void pstore<bool>(bool*     to, const Packet16b& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<__m128i*>(to), from); }"},
{"lineNum":"  794","line":""},
{"lineNum":"  795","line":"template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_pd(to, from); }","class":"lineNoCov","hits":"0","possible_hits":"88",},
{"lineNum":"  796","line":"template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_ps(to, from); }"},
{"lineNum":"  797","line":"template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE _mm_storeu_si128(reinterpret_cast<__m128i*>(to), from); }"},
{"lineNum":"  798","line":"template<> EIGEN_STRONG_INLINE void pstoreu<bool>(bool*     to, const Packet16b& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_storeu_si128(reinterpret_cast<__m128i*>(to), from); }"},
{"lineNum":"  799","line":""},
{"lineNum":"  800","line":"template<> EIGEN_DEVICE_FUNC inline Packet4f pgather<float, Packet4f>(const float* from, Index stride)"},
{"lineNum":"  801","line":"{"},
{"lineNum":"  802","line":" return _mm_set_ps(from[3*stride], from[2*stride], from[1*stride], from[0*stride]);"},
{"lineNum":"  803","line":"}"},
{"lineNum":"  804","line":"template<> EIGEN_DEVICE_FUNC inline Packet2d pgather<double, Packet2d>(const double* from, Index stride)"},
{"lineNum":"  805","line":"{"},
{"lineNum":"  806","line":" return _mm_set_pd(from[1*stride], from[0*stride]);"},
{"lineNum":"  807","line":"}"},
{"lineNum":"  808","line":"template<> EIGEN_DEVICE_FUNC inline Packet4i pgather<int, Packet4i>(const int* from, Index stride)"},
{"lineNum":"  809","line":"{"},
{"lineNum":"  810","line":" return _mm_set_epi32(from[3*stride], from[2*stride], from[1*stride], from[0*stride]);"},
{"lineNum":"  811","line":"}"},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"template<> EIGEN_DEVICE_FUNC inline Packet16b pgather<bool, Packet16b>(const bool* from, Index stride)"},
{"lineNum":"  814","line":"{"},
{"lineNum":"  815","line":"  return _mm_set_epi8(from[15*stride], from[14*stride], from[13*stride], from[12*stride],"},
{"lineNum":"  816","line":"                      from[11*stride], from[10*stride], from[9*stride], from[8*stride],"},
{"lineNum":"  817","line":"                      from[7*stride], from[6*stride], from[5*stride], from[4*stride],"},
{"lineNum":"  818","line":"                      from[3*stride], from[2*stride], from[1*stride], from[0*stride]);"},
{"lineNum":"  819","line":"}"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"template<> EIGEN_DEVICE_FUNC inline void pscatter<float, Packet4f>(float* to, const Packet4f& from, Index stride)"},
{"lineNum":"  822","line":"{"},
{"lineNum":"  823","line":"  to[stride*0] = _mm_cvtss_f32(from);"},
{"lineNum":"  824","line":"  to[stride*1] = _mm_cvtss_f32(_mm_shuffle_ps(from, from, 1));"},
{"lineNum":"  825","line":"  to[stride*2] = _mm_cvtss_f32(_mm_shuffle_ps(from, from, 2));"},
{"lineNum":"  826","line":"  to[stride*3] = _mm_cvtss_f32(_mm_shuffle_ps(from, from, 3));"},
{"lineNum":"  827","line":"}"},
{"lineNum":"  828","line":"template<> EIGEN_DEVICE_FUNC inline void pscatter<double, Packet2d>(double* to, const Packet2d& from, Index stride)"},
{"lineNum":"  829","line":"{"},
{"lineNum":"  830","line":"  to[stride*0] = _mm_cvtsd_f64(from);"},
{"lineNum":"  831","line":"  to[stride*1] = _mm_cvtsd_f64(_mm_shuffle_pd(from, from, 1));"},
{"lineNum":"  832","line":"}"},
{"lineNum":"  833","line":"template<> EIGEN_DEVICE_FUNC inline void pscatter<int, Packet4i>(int* to, const Packet4i& from, Index stride)"},
{"lineNum":"  834","line":"{"},
{"lineNum":"  835","line":"  to[stride*0] = _mm_cvtsi128_si32(from);"},
{"lineNum":"  836","line":"  to[stride*1] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 1));"},
{"lineNum":"  837","line":"  to[stride*2] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 2));"},
{"lineNum":"  838","line":"  to[stride*3] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 3));"},
{"lineNum":"  839","line":"}"},
{"lineNum":"  840","line":"template<> EIGEN_DEVICE_FUNC inline void pscatter<bool, Packet16b>(bool* to, const Packet16b& from, Index stride)"},
{"lineNum":"  841","line":"{"},
{"lineNum":"  842","line":"  to[4*stride*0] = _mm_cvtsi128_si32(from);"},
{"lineNum":"  843","line":"  to[4*stride*1] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 1));"},
{"lineNum":"  844","line":"  to[4*stride*2] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 2));"},
{"lineNum":"  845","line":"  to[4*stride*3] = _mm_cvtsi128_si32(_mm_shuffle_epi32(from, 3));"},
{"lineNum":"  846","line":"}"},
{"lineNum":"  847","line":""},
{"lineNum":"  848","line":""},
{"lineNum":"  849","line":"// some compilers might be tempted to perform multiple moves instead of using a vector path."},
{"lineNum":"  850","line":"template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)"},
{"lineNum":"  851","line":"{"},
{"lineNum":"  852","line":"  Packet4f pa = _mm_set_ss(a);"},
{"lineNum":"  853","line":"  pstore(to, Packet4f(vec4f_swizzle1(pa,0,0,0,0)));"},
{"lineNum":"  854","line":"}"},
{"lineNum":"  855","line":"// some compilers might be tempted to perform multiple moves instead of using a vector path."},
{"lineNum":"  856","line":"template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)"},
{"lineNum":"  857","line":"{"},
{"lineNum":"  858","line":"  Packet2d pa = _mm_set_sd(a);"},
{"lineNum":"  859","line":"  pstore(to, Packet2d(vec2d_swizzle1(pa,0,0)));"},
{"lineNum":"  860","line":"}"},
{"lineNum":"  861","line":""},
{"lineNum":"  862","line":"#if EIGEN_COMP_PGI && EIGEN_COMP_PGI < 1900"},
{"lineNum":"  863","line":"typedef const void * SsePrefetchPtrType;"},
{"lineNum":"  864","line":"#else"},
{"lineNum":"  865","line":"typedef const char * SsePrefetchPtrType;"},
{"lineNum":"  866","line":"#endif"},
{"lineNum":"  867","line":""},
{"lineNum":"  868","line":"#ifndef EIGEN_VECTORIZE_AVX"},
{"lineNum":"  869","line":"template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }"},
{"lineNum":"  870","line":"template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }","class":"lineNoCov","hits":"0","possible_hits":"26",},
{"lineNum":"  871","line":"template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((SsePrefetchPtrType)(addr), _MM_HINT_T0); }"},
{"lineNum":"  872","line":"#endif"},
{"lineNum":"  873","line":""},
{"lineNum":"  874","line":"#if EIGEN_COMP_MSVC_STRICT && EIGEN_OS_WIN64"},
{"lineNum":"  875","line":"// The temporary variable fixes an internal compilation error in vs <= 2008 and a wrong-result bug in vs 2010"},
{"lineNum":"  876","line":"// Direct of the struct members fixed bug #62."},
{"lineNum":"  877","line":"template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }"},
{"lineNum":"  878","line":"template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }"},
{"lineNum":"  879","line":"template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }"},
{"lineNum":"  880","line":"#elif EIGEN_COMP_MSVC_STRICT"},
{"lineNum":"  881","line":"// The temporary variable fixes an internal compilation error in vs <= 2008 and a wrong-result bug in vs 2010"},
{"lineNum":"  882","line":"template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }"},
{"lineNum":"  883","line":"template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }"},
{"lineNum":"  884","line":"template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }"},
{"lineNum":"  885","line":"#else"},
{"lineNum":"  886","line":"template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }"},
{"lineNum":"  887","line":"template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }"},
{"lineNum":"  888","line":"template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }"},
{"lineNum":"  889","line":"#endif"},
{"lineNum":"  890","line":"template<> EIGEN_STRONG_INLINE bool   pfirst<Packet16b>(const Packet16b& a) { int x = _mm_cvtsi128_si32(a); return static_cast<bool>(x & 1); }"},
{"lineNum":"  891","line":""},
{"lineNum":"  892","line":"template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) { return _mm_shuffle_ps(a,a,0x1B); }"},
{"lineNum":"  893","line":"template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a) { return _mm_shuffle_pd(a,a,0x1); }"},
{"lineNum":"  894","line":"template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) { return _mm_shuffle_epi32(a,0x1B); }"},
{"lineNum":"  895","line":"template<> EIGEN_STRONG_INLINE Packet16b preverse(const Packet16b& a) {"},
{"lineNum":"  896","line":"#ifdef EIGEN_VECTORIZE_SSSE3"},
{"lineNum":"  897","line":"  __m128i mask = _mm_set_epi8(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);"},
{"lineNum":"  898","line":"  return _mm_shuffle_epi8(a, mask);"},
{"lineNum":"  899","line":"#else"},
{"lineNum":"  900","line":"  Packet16b tmp = _mm_shuffle_epi32(a, _MM_SHUFFLE(0, 1, 2, 3));"},
{"lineNum":"  901","line":"  tmp = _mm_shufflehi_epi16(_mm_shufflelo_epi16(tmp, _MM_SHUFFLE(2, 3, 0, 1)), _MM_SHUFFLE(2, 3, 0, 1));"},
{"lineNum":"  902","line":"  return _mm_or_si128(_mm_slli_epi16(tmp, 8), _mm_srli_epi16(tmp, 8));"},
{"lineNum":"  903","line":"#endif"},
{"lineNum":"  904","line":"}"},
{"lineNum":"  905","line":""},
{"lineNum":"  906","line":"template<> EIGEN_STRONG_INLINE Packet4f pfrexp<Packet4f>(const Packet4f& a, Packet4f& exponent) {"},
{"lineNum":"  907","line":"  return pfrexp_generic(a,exponent);"},
{"lineNum":"  908","line":"}"},
{"lineNum":"  909","line":""},
{"lineNum":"  910","line":"// Extract exponent without existence of Packet2l."},
{"lineNum":"  911","line":"template<>"},
{"lineNum":"  912","line":"EIGEN_STRONG_INLINE"},
{"lineNum":"  913","line":"Packet2d pfrexp_generic_get_biased_exponent(const Packet2d& a) {"},
{"lineNum":"  914","line":"  const Packet2d cst_exp_mask  = pset1frombits<Packet2d>(static_cast<uint64_t>(0x7ff0000000000000ull));"},
{"lineNum":"  915","line":"  __m128i a_expo = _mm_srli_epi64(_mm_castpd_si128(pand(a, cst_exp_mask)), 52);"},
{"lineNum":"  916","line":"  return _mm_cvtepi32_pd(vec4i_swizzle1(a_expo, 0, 2, 1, 3));"},
{"lineNum":"  917","line":"}"},
{"lineNum":"  918","line":""},
{"lineNum":"  919","line":"template<> EIGEN_STRONG_INLINE Packet2d pfrexp<Packet2d>(const Packet2d& a, Packet2d& exponent) {"},
{"lineNum":"  920","line":"  return pfrexp_generic(a, exponent);"},
{"lineNum":"  921","line":"}"},
{"lineNum":"  922","line":""},
{"lineNum":"  923","line":"template<> EIGEN_STRONG_INLINE Packet4f pldexp<Packet4f>(const Packet4f& a, const Packet4f& exponent) {"},
{"lineNum":"  924","line":"  return pldexp_generic(a,exponent);"},
{"lineNum":"  925","line":"}"},
{"lineNum":"  926","line":""},
{"lineNum":"  927","line":"// We specialize pldexp here, since the generic implementation uses Packet2l, which is not well"},
{"lineNum":"  928","line":"// supported by SSE, and has more range than is needed for exponents."},
{"lineNum":"  929","line":"template<> EIGEN_STRONG_INLINE Packet2d pldexp<Packet2d>(const Packet2d& a, const Packet2d& exponent) {"},
{"lineNum":"  930","line":"  // Clamp exponent to [-2099, 2099]"},
{"lineNum":"  931","line":"  const Packet2d max_exponent = pset1<Packet2d>(2099.0);"},
{"lineNum":"  932","line":"  const Packet2d e = pmin(pmax(exponent, pnegate(max_exponent)), max_exponent);"},
{"lineNum":"  933","line":""},
{"lineNum":"  934","line":"  // Convert e to integer and swizzle to low-order bits."},
{"lineNum":"  935","line":"  const Packet4i ei = vec4i_swizzle1(_mm_cvtpd_epi32(e), 0, 3, 1, 3);"},
{"lineNum":"  936","line":""},
{"lineNum":"  937","line":"  // Split 2^e into four factors and multiply:"},
{"lineNum":"  938","line":"  const Packet4i bias = _mm_set_epi32(0, 1023, 0, 1023);"},
{"lineNum":"  939","line":"  Packet4i b = parithmetic_shift_right<2>(ei);  // floor(e/4)"},
{"lineNum":"  940","line":"  Packet2d c = _mm_castsi128_pd(_mm_slli_epi64(padd(b, bias), 52));  // 2^b"},
{"lineNum":"  941","line":"  Packet2d out = pmul(pmul(pmul(a, c), c), c); // a * 2^(3b)"},
{"lineNum":"  942","line":"  b = psub(psub(psub(ei, b), b), b);  // e - 3b"},
{"lineNum":"  943","line":"  c = _mm_castsi128_pd(_mm_slli_epi64(padd(b, bias), 52));  // 2^(e - 3b)"},
{"lineNum":"  944","line":"  out = pmul(out, c);  // a * 2^e"},
{"lineNum":"  945","line":"  return out;"},
{"lineNum":"  946","line":"}"},
{"lineNum":"  947","line":""},
{"lineNum":"  948","line":"// with AVX, the default implementations based on pload1 are faster"},
{"lineNum":"  949","line":"#ifndef __AVX__"},
{"lineNum":"  950","line":"template<> EIGEN_STRONG_INLINE void"},
{"lineNum":"  951","line":"pbroadcast4<Packet4f>(const float *a,"},
{"lineNum":"  952","line":"                      Packet4f& a0, Packet4f& a1, Packet4f& a2, Packet4f& a3)"},
{"lineNum":"  953","line":"{"},
{"lineNum":"  954","line":"  a3 = pload<Packet4f>(a);"},
{"lineNum":"  955","line":"  a0 = vec4f_swizzle1(a3, 0,0,0,0);"},
{"lineNum":"  956","line":"  a1 = vec4f_swizzle1(a3, 1,1,1,1);"},
{"lineNum":"  957","line":"  a2 = vec4f_swizzle1(a3, 2,2,2,2);"},
{"lineNum":"  958","line":"  a3 = vec4f_swizzle1(a3, 3,3,3,3);"},
{"lineNum":"  959","line":"}"},
{"lineNum":"  960","line":"template<> EIGEN_STRONG_INLINE void"},
{"lineNum":"  961","line":"pbroadcast4<Packet2d>(const double *a,"},
{"lineNum":"  962","line":"                      Packet2d& a0, Packet2d& a1, Packet2d& a2, Packet2d& a3)"},
{"lineNum":"  963","line":"{"},
{"lineNum":"  964","line":"#ifdef EIGEN_VECTORIZE_SSE3"},
{"lineNum":"  965","line":"  a0 = _mm_loaddup_pd(a+0);"},
{"lineNum":"  966","line":"  a1 = _mm_loaddup_pd(a+1);"},
{"lineNum":"  967","line":"  a2 = _mm_loaddup_pd(a+2);"},
{"lineNum":"  968","line":"  a3 = _mm_loaddup_pd(a+3);"},
{"lineNum":"  969","line":"#else"},
{"lineNum":"  970","line":"  a1 = pload<Packet2d>(a);"},
{"lineNum":"  971","line":"  a0 = vec2d_swizzle1(a1, 0,0);"},
{"lineNum":"  972","line":"  a1 = vec2d_swizzle1(a1, 1,1);"},
{"lineNum":"  973","line":"  a3 = pload<Packet2d>(a+2);"},
{"lineNum":"  974","line":"  a2 = vec2d_swizzle1(a3, 0,0);"},
{"lineNum":"  975","line":"  a3 = vec2d_swizzle1(a3, 1,1);"},
{"lineNum":"  976","line":"#endif"},
{"lineNum":"  977","line":"}"},
{"lineNum":"  978","line":"#endif"},
{"lineNum":"  979","line":""},
{"lineNum":"  980","line":"EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)"},
{"lineNum":"  981","line":"{"},
{"lineNum":"  982","line":"  vecs[1] = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(vecs[0]), 0x55));"},
{"lineNum":"  983","line":"  vecs[2] = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(vecs[0]), 0xAA));"},
{"lineNum":"  984","line":"  vecs[3] = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(vecs[0]), 0xFF));"},
{"lineNum":"  985","line":"  vecs[0] = _mm_castsi128_ps(_mm_shuffle_epi32(_mm_castps_si128(vecs[0]), 0x00));"},
{"lineNum":"  986","line":"}"},
{"lineNum":"  987","line":""},
{"lineNum":"  988","line":"template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)"},
{"lineNum":"  989","line":"{"},
{"lineNum":"  990","line":"  // Disable SSE3 _mm_hadd_pd that is extremely slow on all existing Intel\'s architectures"},
{"lineNum":"  991","line":"  // (from Nehalem to Haswell)"},
{"lineNum":"  992","line":"// #ifdef EIGEN_VECTORIZE_SSE3"},
{"lineNum":"  993","line":"//   Packet4f tmp = _mm_add_ps(a, vec4f_swizzle1(a,2,3,2,3));"},
{"lineNum":"  994","line":"//   return pfirst<Packet4f>(_mm_hadd_ps(tmp, tmp));"},
{"lineNum":"  995","line":"// #else"},
{"lineNum":"  996","line":"  Packet4f tmp = _mm_add_ps(a, _mm_movehl_ps(a,a));"},
{"lineNum":"  997","line":"  return pfirst<Packet4f>(_mm_add_ss(tmp, _mm_shuffle_ps(tmp,tmp, 1)));"},
{"lineNum":"  998","line":"// #endif"},
{"lineNum":"  999","line":"}"},
{"lineNum":" 1000","line":""},
{"lineNum":" 1001","line":"template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)"},
{"lineNum":" 1002","line":"{"},
{"lineNum":" 1003","line":"  // Disable SSE3 _mm_hadd_pd that is extremely slow on all existing Intel\'s architectures"},
{"lineNum":" 1004","line":"  // (from Nehalem to Haswell)"},
{"lineNum":" 1005","line":"// #ifdef EIGEN_VECTORIZE_SSE3"},
{"lineNum":" 1006","line":"//   return pfirst<Packet2d>(_mm_hadd_pd(a, a));"},
{"lineNum":" 1007","line":"// #else"},
{"lineNum":" 1008","line":"  return pfirst<Packet2d>(_mm_add_sd(a, _mm_unpackhi_pd(a,a)));","class":"lineNoCov","hits":"0","possible_hits":"40",},
{"lineNum":" 1009","line":"// #endif"},
{"lineNum":" 1010","line":"}"},
{"lineNum":" 1011","line":""},
{"lineNum":" 1012","line":"#ifdef EIGEN_VECTORIZE_SSSE3"},
{"lineNum":" 1013","line":"template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)"},
{"lineNum":" 1014","line":"{"},
{"lineNum":" 1015","line":"  Packet4i tmp0 = _mm_hadd_epi32(a,a);"},
{"lineNum":" 1016","line":"  return pfirst<Packet4i>(_mm_hadd_epi32(tmp0,tmp0));"},
{"lineNum":" 1017","line":"}"},
{"lineNum":" 1018","line":""},
{"lineNum":" 1019","line":"#else"},
{"lineNum":" 1020","line":"template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)"},
{"lineNum":" 1021","line":"{"},
{"lineNum":" 1022","line":"  Packet4i tmp = _mm_add_epi32(a, _mm_unpackhi_epi64(a,a));"},
{"lineNum":" 1023","line":"  return pfirst(tmp) + pfirst<Packet4i>(_mm_shuffle_epi32(tmp, 1));"},
{"lineNum":" 1024","line":"}"},
{"lineNum":" 1025","line":"#endif"},
{"lineNum":" 1026","line":""},
{"lineNum":" 1027","line":"template<> EIGEN_STRONG_INLINE bool predux<Packet16b>(const Packet16b& a) {"},
{"lineNum":" 1028","line":"  Packet4i tmp = _mm_or_si128(a, _mm_unpackhi_epi64(a,a));"},
{"lineNum":" 1029","line":"  return (pfirst(tmp) != 0) || (pfirst<Packet4i>(_mm_shuffle_epi32(tmp, 1)) != 0);"},
{"lineNum":" 1030","line":"}"},
{"lineNum":" 1031","line":""},
{"lineNum":" 1032","line":"// Other reduction functions:"},
{"lineNum":" 1033","line":""},
{"lineNum":" 1034","line":""},
{"lineNum":" 1035","line":"// mul"},
{"lineNum":" 1036","line":"template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)"},
{"lineNum":" 1037","line":"{"},
{"lineNum":" 1038","line":"  Packet4f tmp = _mm_mul_ps(a, _mm_movehl_ps(a,a));"},
{"lineNum":" 1039","line":"  return pfirst<Packet4f>(_mm_mul_ss(tmp, _mm_shuffle_ps(tmp,tmp, 1)));"},
{"lineNum":" 1040","line":"}"},
{"lineNum":" 1041","line":"template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)"},
{"lineNum":" 1042","line":"{"},
{"lineNum":" 1043","line":"  return pfirst<Packet2d>(_mm_mul_sd(a, _mm_unpackhi_pd(a,a)));"},
{"lineNum":" 1044","line":"}"},
{"lineNum":" 1045","line":"template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)"},
{"lineNum":" 1046","line":"{"},
{"lineNum":" 1047","line":"  // after some experiments, it is seems this is the fastest way to implement it"},
{"lineNum":" 1048","line":"  // for GCC (eg., reusing pmul is very slow !)"},
{"lineNum":" 1049","line":"  // TODO try to call _mm_mul_epu32 directly"},
{"lineNum":" 1050","line":"  EIGEN_ALIGN16 int aux[4];"},
{"lineNum":" 1051","line":"  pstore(aux, a);"},
{"lineNum":" 1052","line":"  return  (aux[0] * aux[1]) * (aux[2] * aux[3]);"},
{"lineNum":" 1053","line":"}"},
{"lineNum":" 1054","line":""},
{"lineNum":" 1055","line":"template<> EIGEN_STRONG_INLINE bool predux_mul<Packet16b>(const Packet16b& a) {"},
{"lineNum":" 1056","line":"  Packet4i tmp = _mm_and_si128(a, _mm_unpackhi_epi64(a,a));"},
{"lineNum":" 1057","line":"  return ((pfirst<Packet4i>(tmp) == 0x01010101) &&"},
{"lineNum":" 1058","line":"          (pfirst<Packet4i>(_mm_shuffle_epi32(tmp, 1)) == 0x01010101));"},
{"lineNum":" 1059","line":"}"},
{"lineNum":" 1060","line":""},
{"lineNum":" 1061","line":"// min"},
{"lineNum":" 1062","line":"template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)"},
{"lineNum":" 1063","line":"{"},
{"lineNum":" 1064","line":"  Packet4f tmp = _mm_min_ps(a, _mm_movehl_ps(a,a));"},
{"lineNum":" 1065","line":"  return pfirst<Packet4f>(_mm_min_ss(tmp, _mm_shuffle_ps(tmp,tmp, 1)));"},
{"lineNum":" 1066","line":"}"},
{"lineNum":" 1067","line":"template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)"},
{"lineNum":" 1068","line":"{"},
{"lineNum":" 1069","line":"  return pfirst<Packet2d>(_mm_min_sd(a, _mm_unpackhi_pd(a,a)));"},
{"lineNum":" 1070","line":"}"},
{"lineNum":" 1071","line":"template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)"},
{"lineNum":" 1072","line":"{"},
{"lineNum":" 1073","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":" 1074","line":"  Packet4i tmp = _mm_min_epi32(a, _mm_shuffle_epi32(a, _MM_SHUFFLE(0,0,3,2)));"},
{"lineNum":" 1075","line":"  return pfirst<Packet4i>(_mm_min_epi32(tmp,_mm_shuffle_epi32(tmp, 1)));"},
{"lineNum":" 1076","line":"#else"},
{"lineNum":" 1077","line":"  // after some experiments, it is seems this is the fastest way to implement it"},
{"lineNum":" 1078","line":"  // for GCC (eg., it does not like using std::min after the pstore !!)"},
{"lineNum":" 1079","line":"  EIGEN_ALIGN16 int aux[4];"},
{"lineNum":" 1080","line":"  pstore(aux, a);"},
{"lineNum":" 1081","line":"  int aux0 = aux[0]<aux[1] ? aux[0] : aux[1];"},
{"lineNum":" 1082","line":"  int aux2 = aux[2]<aux[3] ? aux[2] : aux[3];"},
{"lineNum":" 1083","line":"  return aux0<aux2 ? aux0 : aux2;"},
{"lineNum":" 1084","line":"#endif // EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":" 1085","line":"}"},
{"lineNum":" 1086","line":""},
{"lineNum":" 1087","line":"// max"},
{"lineNum":" 1088","line":"template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)"},
{"lineNum":" 1089","line":"{"},
{"lineNum":" 1090","line":"  Packet4f tmp = _mm_max_ps(a, _mm_movehl_ps(a,a));"},
{"lineNum":" 1091","line":"  return pfirst<Packet4f>(_mm_max_ss(tmp, _mm_shuffle_ps(tmp,tmp, 1)));"},
{"lineNum":" 1092","line":"}"},
{"lineNum":" 1093","line":"template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)"},
{"lineNum":" 1094","line":"{"},
{"lineNum":" 1095","line":"  return pfirst<Packet2d>(_mm_max_sd(a, _mm_unpackhi_pd(a,a)));"},
{"lineNum":" 1096","line":"}"},
{"lineNum":" 1097","line":"template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)"},
{"lineNum":" 1098","line":"{"},
{"lineNum":" 1099","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":" 1100","line":"  Packet4i tmp = _mm_max_epi32(a, _mm_shuffle_epi32(a, _MM_SHUFFLE(0,0,3,2)));"},
{"lineNum":" 1101","line":"  return pfirst<Packet4i>(_mm_max_epi32(tmp,_mm_shuffle_epi32(tmp, 1)));"},
{"lineNum":" 1102","line":"#else"},
{"lineNum":" 1103","line":"  // after some experiments, it is seems this is the fastest way to implement it"},
{"lineNum":" 1104","line":"  // for GCC (eg., it does not like using std::min after the pstore !!)"},
{"lineNum":" 1105","line":"  EIGEN_ALIGN16 int aux[4];"},
{"lineNum":" 1106","line":"  pstore(aux, a);"},
{"lineNum":" 1107","line":"  int aux0 = aux[0]>aux[1] ? aux[0] : aux[1];"},
{"lineNum":" 1108","line":"  int aux2 = aux[2]>aux[3] ? aux[2] : aux[3];"},
{"lineNum":" 1109","line":"  return aux0>aux2 ? aux0 : aux2;"},
{"lineNum":" 1110","line":"#endif // EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":" 1111","line":"}"},
{"lineNum":" 1112","line":""},
{"lineNum":" 1113","line":"// not needed yet"},
{"lineNum":" 1114","line":"// template<> EIGEN_STRONG_INLINE bool predux_all(const Packet4f& x)"},
{"lineNum":" 1115","line":"// {"},
{"lineNum":" 1116","line":"//   return _mm_movemask_ps(x) == 0xF;"},
{"lineNum":" 1117","line":"// }"},
{"lineNum":" 1118","line":""},
{"lineNum":" 1119","line":"template<> EIGEN_STRONG_INLINE bool predux_any(const Packet4f& x)"},
{"lineNum":" 1120","line":"{"},
{"lineNum":" 1121","line":"  return _mm_movemask_ps(x) != 0x0;"},
{"lineNum":" 1122","line":"}"},
{"lineNum":" 1123","line":""},
{"lineNum":" 1124","line":"EIGEN_DEVICE_FUNC inline void"},
{"lineNum":" 1125","line":"ptranspose(PacketBlock<Packet4f,4>& kernel) {"},
{"lineNum":" 1126","line":"  _MM_TRANSPOSE4_PS(kernel.packet[0], kernel.packet[1], kernel.packet[2], kernel.packet[3]);"},
{"lineNum":" 1127","line":"}"},
{"lineNum":" 1128","line":""},
{"lineNum":" 1129","line":"EIGEN_DEVICE_FUNC inline void"},
{"lineNum":" 1130","line":"ptranspose(PacketBlock<Packet2d,2>& kernel) {"},
{"lineNum":" 1131","line":"  __m128d tmp = _mm_unpackhi_pd(kernel.packet[0], kernel.packet[1]);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1132","line":"  kernel.packet[0] = _mm_unpacklo_pd(kernel.packet[0], kernel.packet[1]);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 1133","line":"  kernel.packet[1] = tmp;"},
{"lineNum":" 1134","line":"}"},
{"lineNum":" 1135","line":""},
{"lineNum":" 1136","line":"EIGEN_DEVICE_FUNC inline void"},
{"lineNum":" 1137","line":"ptranspose(PacketBlock<Packet4i,4>& kernel) {"},
{"lineNum":" 1138","line":"  __m128i T0 = _mm_unpacklo_epi32(kernel.packet[0], kernel.packet[1]);"},
{"lineNum":" 1139","line":"  __m128i T1 = _mm_unpacklo_epi32(kernel.packet[2], kernel.packet[3]);"},
{"lineNum":" 1140","line":"  __m128i T2 = _mm_unpackhi_epi32(kernel.packet[0], kernel.packet[1]);"},
{"lineNum":" 1141","line":"  __m128i T3 = _mm_unpackhi_epi32(kernel.packet[2], kernel.packet[3]);"},
{"lineNum":" 1142","line":""},
{"lineNum":" 1143","line":"  kernel.packet[0] = _mm_unpacklo_epi64(T0, T1);"},
{"lineNum":" 1144","line":"  kernel.packet[1] = _mm_unpackhi_epi64(T0, T1);"},
{"lineNum":" 1145","line":"  kernel.packet[2] = _mm_unpacklo_epi64(T2, T3);"},
{"lineNum":" 1146","line":"  kernel.packet[3] = _mm_unpackhi_epi64(T2, T3);"},
{"lineNum":" 1147","line":"}"},
{"lineNum":" 1148","line":""},
{"lineNum":" 1149","line":"EIGEN_DEVICE_FUNC inline void"},
{"lineNum":" 1150","line":"ptranspose(PacketBlock<Packet16b,4>& kernel) {"},
{"lineNum":" 1151","line":"  __m128i T0 =  _mm_unpacklo_epi8(kernel.packet[0], kernel.packet[1]);"},
{"lineNum":" 1152","line":"  __m128i T1 =  _mm_unpackhi_epi8(kernel.packet[0], kernel.packet[1]);"},
{"lineNum":" 1153","line":"  __m128i T2 =  _mm_unpacklo_epi8(kernel.packet[2], kernel.packet[3]);"},
{"lineNum":" 1154","line":"  __m128i T3 =  _mm_unpackhi_epi8(kernel.packet[2], kernel.packet[3]);"},
{"lineNum":" 1155","line":"  kernel.packet[0] = _mm_unpacklo_epi16(T0, T2);"},
{"lineNum":" 1156","line":"  kernel.packet[1] = _mm_unpackhi_epi16(T0, T2);"},
{"lineNum":" 1157","line":"  kernel.packet[2] = _mm_unpacklo_epi16(T1, T3);"},
{"lineNum":" 1158","line":"  kernel.packet[3] = _mm_unpackhi_epi16(T1, T3);"},
{"lineNum":" 1159","line":"}"},
{"lineNum":" 1160","line":""},
{"lineNum":" 1161","line":"EIGEN_DEVICE_FUNC inline void"},
{"lineNum":" 1162","line":"ptranspose(PacketBlock<Packet16b,16>& kernel) {"},
{"lineNum":" 1163","line":"  // If we number the elements in the input thus:"},
{"lineNum":" 1164","line":"  // kernel.packet[ 0] = {00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 0a, 0b, 0c, 0d, 0e, 0f}"},
{"lineNum":" 1165","line":"  // kernel.packet[ 1] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1a, 1b, 1c, 1d, 1e, 1f}"},
{"lineNum":" 1166","line":"  // ..."},
{"lineNum":" 1167","line":"  // kernel.packet[15] = {f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, fa, fb, fc, fd, fe, ff},"},
{"lineNum":" 1168","line":"  //"},
{"lineNum":" 1169","line":"  // the desired output is:"},
{"lineNum":" 1170","line":"  // kernel.packet[ 0] = {00, 10, 20, 30, 40, 50, 60, 70, 80, 90, a0, b0, c0, d0, e0, f0}"},
{"lineNum":" 1171","line":"  // kernel.packet[ 1] = {01, 11, 21, 31, 41, 51, 61, 71, 81, 91, a1, b1, c1, d1, e1, f1}"},
{"lineNum":" 1172","line":"  // ..."},
{"lineNum":" 1173","line":"  // kernel.packet[15] = {0f, 1f, 2f, 3f, 4f, 5f, 6f, 7f, 8f, 9f, af, bf, cf, df, ef, ff},"},
{"lineNum":" 1174","line":"  __m128i t0 =  _mm_unpacklo_epi8(kernel.packet[0], kernel.packet[1]); // 00 10 01 11 02 12 03 13 04 14 05 15 06 16 07 17"},
{"lineNum":" 1175","line":"  __m128i t1 =  _mm_unpackhi_epi8(kernel.packet[0], kernel.packet[1]); // 08 18 09 19 0a 1a 0b 1b 0c 1c 0d 1d 0e 1e 0f 1f"},
{"lineNum":" 1176","line":"  __m128i t2 =  _mm_unpacklo_epi8(kernel.packet[2], kernel.packet[3]); // 20 30 21 31 22 32 ...                     27 37"},
{"lineNum":" 1177","line":"  __m128i t3 =  _mm_unpackhi_epi8(kernel.packet[2], kernel.packet[3]); // 28 38 29 39 2a 3a ...                     2f 3f"},
{"lineNum":" 1178","line":"  __m128i t4 =  _mm_unpacklo_epi8(kernel.packet[4], kernel.packet[5]); // 40 50 41 51 42 52                         47 57"},
{"lineNum":" 1179","line":"  __m128i t5 =  _mm_unpackhi_epi8(kernel.packet[4], kernel.packet[5]); // 48 58 49 59 4a 5a"},
{"lineNum":" 1180","line":"  __m128i t6 =  _mm_unpacklo_epi8(kernel.packet[6], kernel.packet[7]);"},
{"lineNum":" 1181","line":"  __m128i t7 =  _mm_unpackhi_epi8(kernel.packet[6], kernel.packet[7]);"},
{"lineNum":" 1182","line":"  __m128i t8 =  _mm_unpacklo_epi8(kernel.packet[8], kernel.packet[9]);"},
{"lineNum":" 1183","line":"  __m128i t9 =  _mm_unpackhi_epi8(kernel.packet[8], kernel.packet[9]);"},
{"lineNum":" 1184","line":"  __m128i ta =  _mm_unpacklo_epi8(kernel.packet[10], kernel.packet[11]);"},
{"lineNum":" 1185","line":"  __m128i tb =  _mm_unpackhi_epi8(kernel.packet[10], kernel.packet[11]);"},
{"lineNum":" 1186","line":"  __m128i tc =  _mm_unpacklo_epi8(kernel.packet[12], kernel.packet[13]);"},
{"lineNum":" 1187","line":"  __m128i td =  _mm_unpackhi_epi8(kernel.packet[12], kernel.packet[13]);"},
{"lineNum":" 1188","line":"  __m128i te =  _mm_unpacklo_epi8(kernel.packet[14], kernel.packet[15]);"},
{"lineNum":" 1189","line":"  __m128i tf =  _mm_unpackhi_epi8(kernel.packet[14], kernel.packet[15]);"},
{"lineNum":" 1190","line":""},
{"lineNum":" 1191","line":"  __m128i s0 =  _mm_unpacklo_epi16(t0, t2); // 00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33"},
{"lineNum":" 1192","line":"  __m128i s1 =  _mm_unpackhi_epi16(t0, t2); // 04 14 24 34"},
{"lineNum":" 1193","line":"  __m128i s2 =  _mm_unpacklo_epi16(t1, t3); // 08 18 28 38 ..."},
{"lineNum":" 1194","line":"  __m128i s3 =  _mm_unpackhi_epi16(t1, t3); // 0c 1c 2c 3c ..."},
{"lineNum":" 1195","line":"  __m128i s4 =  _mm_unpacklo_epi16(t4, t6); // 40 50 60 70 41 51 61 71 42 52 62 72 43 53 63 73"},
{"lineNum":" 1196","line":"  __m128i s5 =  _mm_unpackhi_epi16(t4, t6); // 44 54 64 74 ..."},
{"lineNum":" 1197","line":"  __m128i s6 =  _mm_unpacklo_epi16(t5, t7);"},
{"lineNum":" 1198","line":"  __m128i s7 =  _mm_unpackhi_epi16(t5, t7);"},
{"lineNum":" 1199","line":"  __m128i s8 =  _mm_unpacklo_epi16(t8, ta);"},
{"lineNum":" 1200","line":"  __m128i s9 =  _mm_unpackhi_epi16(t8, ta);"},
{"lineNum":" 1201","line":"  __m128i sa =  _mm_unpacklo_epi16(t9, tb);"},
{"lineNum":" 1202","line":"  __m128i sb =  _mm_unpackhi_epi16(t9, tb);"},
{"lineNum":" 1203","line":"  __m128i sc =  _mm_unpacklo_epi16(tc, te);"},
{"lineNum":" 1204","line":"  __m128i sd =  _mm_unpackhi_epi16(tc, te);"},
{"lineNum":" 1205","line":"  __m128i se =  _mm_unpacklo_epi16(td, tf);"},
{"lineNum":" 1206","line":"  __m128i sf =  _mm_unpackhi_epi16(td, tf);"},
{"lineNum":" 1207","line":""},
{"lineNum":" 1208","line":"  __m128i u0 =  _mm_unpacklo_epi32(s0, s4); // 00 10 20 30 40 50 60 70 01 11 21 31 41 51 61 71"},
{"lineNum":" 1209","line":"  __m128i u1 =  _mm_unpackhi_epi32(s0, s4); // 02 12 22 32 42 52 62 72 03 13 23 33 43 53 63 73"},
{"lineNum":" 1210","line":"  __m128i u2 =  _mm_unpacklo_epi32(s1, s5);"},
{"lineNum":" 1211","line":"  __m128i u3 =  _mm_unpackhi_epi32(s1, s5);"},
{"lineNum":" 1212","line":"  __m128i u4 =  _mm_unpacklo_epi32(s2, s6);"},
{"lineNum":" 1213","line":"  __m128i u5 =  _mm_unpackhi_epi32(s2, s6);"},
{"lineNum":" 1214","line":"  __m128i u6 =  _mm_unpacklo_epi32(s3, s7);"},
{"lineNum":" 1215","line":"  __m128i u7 =  _mm_unpackhi_epi32(s3, s7);"},
{"lineNum":" 1216","line":"  __m128i u8 =  _mm_unpacklo_epi32(s8, sc);"},
{"lineNum":" 1217","line":"  __m128i u9 =  _mm_unpackhi_epi32(s8, sc);"},
{"lineNum":" 1218","line":"  __m128i ua =  _mm_unpacklo_epi32(s9, sd);"},
{"lineNum":" 1219","line":"  __m128i ub =  _mm_unpackhi_epi32(s9, sd);"},
{"lineNum":" 1220","line":"  __m128i uc =  _mm_unpacklo_epi32(sa, se);"},
{"lineNum":" 1221","line":"  __m128i ud =  _mm_unpackhi_epi32(sa, se);"},
{"lineNum":" 1222","line":"  __m128i ue =  _mm_unpacklo_epi32(sb, sf);"},
{"lineNum":" 1223","line":"  __m128i uf =  _mm_unpackhi_epi32(sb, sf);"},
{"lineNum":" 1224","line":""},
{"lineNum":" 1225","line":"  kernel.packet[0]  = _mm_unpacklo_epi64(u0, u8);"},
{"lineNum":" 1226","line":"  kernel.packet[1]  = _mm_unpackhi_epi64(u0, u8);"},
{"lineNum":" 1227","line":"  kernel.packet[2]  = _mm_unpacklo_epi64(u1, u9);"},
{"lineNum":" 1228","line":"  kernel.packet[3]  = _mm_unpackhi_epi64(u1, u9);"},
{"lineNum":" 1229","line":"  kernel.packet[4]  = _mm_unpacklo_epi64(u2, ua);"},
{"lineNum":" 1230","line":"  kernel.packet[5]  = _mm_unpackhi_epi64(u2, ua);"},
{"lineNum":" 1231","line":"  kernel.packet[6]  = _mm_unpacklo_epi64(u3, ub);"},
{"lineNum":" 1232","line":"  kernel.packet[7]  = _mm_unpackhi_epi64(u3, ub);"},
{"lineNum":" 1233","line":"  kernel.packet[8]  = _mm_unpacklo_epi64(u4, uc);"},
{"lineNum":" 1234","line":"  kernel.packet[9]  = _mm_unpackhi_epi64(u4, uc);"},
{"lineNum":" 1235","line":"  kernel.packet[10] = _mm_unpacklo_epi64(u5, ud);"},
{"lineNum":" 1236","line":"  kernel.packet[11] = _mm_unpackhi_epi64(u5, ud);"},
{"lineNum":" 1237","line":"  kernel.packet[12] = _mm_unpacklo_epi64(u6, ue);"},
{"lineNum":" 1238","line":"  kernel.packet[13] = _mm_unpackhi_epi64(u6, ue);"},
{"lineNum":" 1239","line":"  kernel.packet[14] = _mm_unpacklo_epi64(u7, uf);"},
{"lineNum":" 1240","line":"  kernel.packet[15] = _mm_unpackhi_epi64(u7, uf);"},
{"lineNum":" 1241","line":"}"},
{"lineNum":" 1242","line":""},
{"lineNum":" 1243","line":"template<> EIGEN_STRONG_INLINE Packet4i pblend(const Selector<4>& ifPacket, const Packet4i& thenPacket, const Packet4i& elsePacket) {"},
{"lineNum":" 1244","line":"  const __m128i zero = _mm_setzero_si128();"},
{"lineNum":" 1245","line":"  const __m128i select = _mm_set_epi32(ifPacket.select[3], ifPacket.select[2], ifPacket.select[1], ifPacket.select[0]);"},
{"lineNum":" 1246","line":"  __m128i false_mask = _mm_cmpeq_epi32(select, zero);"},
{"lineNum":" 1247","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":" 1248","line":"  return _mm_blendv_epi8(thenPacket, elsePacket, false_mask);"},
{"lineNum":" 1249","line":"#else"},
{"lineNum":" 1250","line":"  return _mm_or_si128(_mm_andnot_si128(false_mask, thenPacket), _mm_and_si128(false_mask, elsePacket));"},
{"lineNum":" 1251","line":"#endif"},
{"lineNum":" 1252","line":"}"},
{"lineNum":" 1253","line":"template<> EIGEN_STRONG_INLINE Packet4f pblend(const Selector<4>& ifPacket, const Packet4f& thenPacket, const Packet4f& elsePacket) {"},
{"lineNum":" 1254","line":"  const __m128 zero = _mm_setzero_ps();"},
{"lineNum":" 1255","line":"  const __m128 select = _mm_set_ps(ifPacket.select[3], ifPacket.select[2], ifPacket.select[1], ifPacket.select[0]);"},
{"lineNum":" 1256","line":"  __m128 false_mask = _mm_cmpeq_ps(select, zero);"},
{"lineNum":" 1257","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":" 1258","line":"  return _mm_blendv_ps(thenPacket, elsePacket, false_mask);"},
{"lineNum":" 1259","line":"#else"},
{"lineNum":" 1260","line":"  return _mm_or_ps(_mm_andnot_ps(false_mask, thenPacket), _mm_and_ps(false_mask, elsePacket));"},
{"lineNum":" 1261","line":"#endif"},
{"lineNum":" 1262","line":"}"},
{"lineNum":" 1263","line":"template<> EIGEN_STRONG_INLINE Packet2d pblend(const Selector<2>& ifPacket, const Packet2d& thenPacket, const Packet2d& elsePacket) {"},
{"lineNum":" 1264","line":"  const __m128d zero = _mm_setzero_pd();"},
{"lineNum":" 1265","line":"  const __m128d select = _mm_set_pd(ifPacket.select[1], ifPacket.select[0]);"},
{"lineNum":" 1266","line":"  __m128d false_mask = _mm_cmpeq_pd(select, zero);"},
{"lineNum":" 1267","line":"#ifdef EIGEN_VECTORIZE_SSE4_1"},
{"lineNum":" 1268","line":"  return _mm_blendv_pd(thenPacket, elsePacket, false_mask);"},
{"lineNum":" 1269","line":"#else"},
{"lineNum":" 1270","line":"  return _mm_or_pd(_mm_andnot_pd(false_mask, thenPacket), _mm_and_pd(false_mask, elsePacket));"},
{"lineNum":" 1271","line":"#endif"},
{"lineNum":" 1272","line":"}"},
{"lineNum":" 1273","line":""},
{"lineNum":" 1274","line":"// Scalar path for pmadd with FMA to ensure consistency with vectorized path."},
{"lineNum":" 1275","line":"#ifdef EIGEN_VECTORIZE_FMA"},
{"lineNum":" 1276","line":"template<> EIGEN_STRONG_INLINE float pmadd(const float& a, const float& b, const float& c) {"},
{"lineNum":" 1277","line":"  return ::fmaf(a,b,c);"},
{"lineNum":" 1278","line":"}"},
{"lineNum":" 1279","line":"template<> EIGEN_STRONG_INLINE double pmadd(const double& a, const double& b, const double& c) {"},
{"lineNum":" 1280","line":"  return ::fma(a,b,c);"},
{"lineNum":" 1281","line":"}"},
{"lineNum":" 1282","line":"#endif"},
{"lineNum":" 1283","line":""},
{"lineNum":" 1284","line":""},
{"lineNum":" 1285","line":"// Packet math for Eigen::half"},
{"lineNum":" 1286","line":"// Disable the following code since it\'s broken on too many platforms / compilers."},
{"lineNum":" 1287","line":"//#elif defined(EIGEN_VECTORIZE_SSE) && (!EIGEN_ARCH_x86_64) && (!EIGEN_COMP_MSVC)"},
{"lineNum":" 1288","line":"#if 0"},
{"lineNum":" 1289","line":""},
{"lineNum":" 1290","line":"typedef struct {"},
{"lineNum":" 1291","line":"  __m64 x;"},
{"lineNum":" 1292","line":"} Packet4h;"},
{"lineNum":" 1293","line":""},
{"lineNum":" 1294","line":""},
{"lineNum":" 1295","line":"template<> struct is_arithmetic<Packet4h> { enum { value = true }; };"},
{"lineNum":" 1296","line":""},
{"lineNum":" 1297","line":"template <>"},
{"lineNum":" 1298","line":"struct packet_traits<Eigen::half> : default_packet_traits {"},
{"lineNum":" 1299","line":"  typedef Packet4h type;"},
{"lineNum":" 1300","line":"  // There is no half-size packet for Packet4h."},
{"lineNum":" 1301","line":"  typedef Packet4h half;"},
{"lineNum":" 1302","line":"  enum {"},
{"lineNum":" 1303","line":"    Vectorizable = 1,"},
{"lineNum":" 1304","line":"    AlignedOnScalar = 1,"},
{"lineNum":" 1305","line":"    size = 4,"},
{"lineNum":" 1306","line":"    HasHalfPacket = 0,"},
{"lineNum":" 1307","line":"    HasAdd    = 1,"},
{"lineNum":" 1308","line":"    HasSub    = 1,"},
{"lineNum":" 1309","line":"    HasMul    = 1,"},
{"lineNum":" 1310","line":"    HasDiv    = 1,"},
{"lineNum":" 1311","line":"    HasNegate = 0,"},
{"lineNum":" 1312","line":"    HasAbs    = 0,"},
{"lineNum":" 1313","line":"    HasAbs2   = 0,"},
{"lineNum":" 1314","line":"    HasMin    = 0,"},
{"lineNum":" 1315","line":"    HasMax    = 0,"},
{"lineNum":" 1316","line":"    HasConj   = 0,"},
{"lineNum":" 1317","line":"    HasSetLinear = 0,"},
{"lineNum":" 1318","line":"    HasSqrt = 0,"},
{"lineNum":" 1319","line":"    HasRsqrt = 0,"},
{"lineNum":" 1320","line":"    HasExp = 0,"},
{"lineNum":" 1321","line":"    HasLog = 0,"},
{"lineNum":" 1322","line":"    HasBlend = 0"},
{"lineNum":" 1323","line":"  };"},
{"lineNum":" 1324","line":"};"},
{"lineNum":" 1325","line":""},
{"lineNum":" 1326","line":""},
{"lineNum":" 1327","line":"template<> struct unpacket_traits<Packet4h> { typedef Eigen::half type; enum {size=4, alignment=Aligned16, vectorizable=true, masked_load_available=false, masked_store_available=false}; typedef Packet4h half; };"},
{"lineNum":" 1328","line":""},
{"lineNum":" 1329","line":"template<> EIGEN_STRONG_INLINE Packet4h pset1<Packet4h>(const Eigen::half& from) {"},
{"lineNum":" 1330","line":"  Packet4h result;"},
{"lineNum":" 1331","line":"  result.x = _mm_set1_pi16(from.x);"},
{"lineNum":" 1332","line":"  return result;"},
{"lineNum":" 1333","line":"}"},
{"lineNum":" 1334","line":""},
{"lineNum":" 1335","line":"template<> EIGEN_STRONG_INLINE Eigen::half pfirst<Packet4h>(const Packet4h& from) {"},
{"lineNum":" 1336","line":"  return half_impl::raw_uint16_to_half(static_cast<unsigned short>(_mm_cvtsi64_si32(from.x)));"},
{"lineNum":" 1337","line":"}"},
{"lineNum":" 1338","line":""},
{"lineNum":" 1339","line":"template<> EIGEN_STRONG_INLINE Packet4h pconj(const Packet4h& a) { return a; }"},
{"lineNum":" 1340","line":""},
{"lineNum":" 1341","line":"template<> EIGEN_STRONG_INLINE Packet4h padd<Packet4h>(const Packet4h& a, const Packet4h& b) {"},
{"lineNum":" 1342","line":"  __int64_t a64 = _mm_cvtm64_si64(a.x);"},
{"lineNum":" 1343","line":"  __int64_t b64 = _mm_cvtm64_si64(b.x);"},
{"lineNum":" 1344","line":""},
{"lineNum":" 1345","line":"  Eigen::half h[4];"},
{"lineNum":" 1346","line":""},
{"lineNum":" 1347","line":"  Eigen::half ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64));"},
{"lineNum":" 1348","line":"  Eigen::half hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64));"},
{"lineNum":" 1349","line":"  h[0] = ha + hb;"},
{"lineNum":" 1350","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 16));"},
{"lineNum":" 1351","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 16));"},
{"lineNum":" 1352","line":"  h[1] = ha + hb;"},
{"lineNum":" 1353","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 32));"},
{"lineNum":" 1354","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 32));"},
{"lineNum":" 1355","line":"  h[2] = ha + hb;"},
{"lineNum":" 1356","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 48));"},
{"lineNum":" 1357","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 48));"},
{"lineNum":" 1358","line":"  h[3] = ha + hb;"},
{"lineNum":" 1359","line":"  Packet4h result;"},
{"lineNum":" 1360","line":"  result.x = _mm_set_pi16(h[3].x, h[2].x, h[1].x, h[0].x);"},
{"lineNum":" 1361","line":"  return result;"},
{"lineNum":" 1362","line":"}"},
{"lineNum":" 1363","line":""},
{"lineNum":" 1364","line":"template<> EIGEN_STRONG_INLINE Packet4h psub<Packet4h>(const Packet4h& a, const Packet4h& b) {"},
{"lineNum":" 1365","line":"  __int64_t a64 = _mm_cvtm64_si64(a.x);"},
{"lineNum":" 1366","line":"  __int64_t b64 = _mm_cvtm64_si64(b.x);"},
{"lineNum":" 1367","line":""},
{"lineNum":" 1368","line":"  Eigen::half h[4];"},
{"lineNum":" 1369","line":""},
{"lineNum":" 1370","line":"  Eigen::half ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64));"},
{"lineNum":" 1371","line":"  Eigen::half hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64));"},
{"lineNum":" 1372","line":"  h[0] = ha - hb;"},
{"lineNum":" 1373","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 16));"},
{"lineNum":" 1374","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 16));"},
{"lineNum":" 1375","line":"  h[1] = ha - hb;"},
{"lineNum":" 1376","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 32));"},
{"lineNum":" 1377","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 32));"},
{"lineNum":" 1378","line":"  h[2] = ha - hb;"},
{"lineNum":" 1379","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 48));"},
{"lineNum":" 1380","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 48));"},
{"lineNum":" 1381","line":"  h[3] = ha - hb;"},
{"lineNum":" 1382","line":"  Packet4h result;"},
{"lineNum":" 1383","line":"  result.x = _mm_set_pi16(h[3].x, h[2].x, h[1].x, h[0].x);"},
{"lineNum":" 1384","line":"  return result;"},
{"lineNum":" 1385","line":"}"},
{"lineNum":" 1386","line":""},
{"lineNum":" 1387","line":"template<> EIGEN_STRONG_INLINE Packet4h pmul<Packet4h>(const Packet4h& a, const Packet4h& b) {"},
{"lineNum":" 1388","line":"  __int64_t a64 = _mm_cvtm64_si64(a.x);"},
{"lineNum":" 1389","line":"  __int64_t b64 = _mm_cvtm64_si64(b.x);"},
{"lineNum":" 1390","line":""},
{"lineNum":" 1391","line":"  Eigen::half h[4];"},
{"lineNum":" 1392","line":""},
{"lineNum":" 1393","line":"  Eigen::half ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64));"},
{"lineNum":" 1394","line":"  Eigen::half hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64));"},
{"lineNum":" 1395","line":"  h[0] = ha * hb;"},
{"lineNum":" 1396","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 16));"},
{"lineNum":" 1397","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 16));"},
{"lineNum":" 1398","line":"  h[1] = ha * hb;"},
{"lineNum":" 1399","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 32));"},
{"lineNum":" 1400","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 32));"},
{"lineNum":" 1401","line":"  h[2] = ha * hb;"},
{"lineNum":" 1402","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 48));"},
{"lineNum":" 1403","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 48));"},
{"lineNum":" 1404","line":"  h[3] = ha * hb;"},
{"lineNum":" 1405","line":"  Packet4h result;"},
{"lineNum":" 1406","line":"  result.x = _mm_set_pi16(h[3].x, h[2].x, h[1].x, h[0].x);"},
{"lineNum":" 1407","line":"  return result;"},
{"lineNum":" 1408","line":"}"},
{"lineNum":" 1409","line":""},
{"lineNum":" 1410","line":"template<> EIGEN_STRONG_INLINE Packet4h pdiv<Packet4h>(const Packet4h& a, const Packet4h& b) {"},
{"lineNum":" 1411","line":"  __int64_t a64 = _mm_cvtm64_si64(a.x);"},
{"lineNum":" 1412","line":"  __int64_t b64 = _mm_cvtm64_si64(b.x);"},
{"lineNum":" 1413","line":""},
{"lineNum":" 1414","line":"  Eigen::half h[4];"},
{"lineNum":" 1415","line":""},
{"lineNum":" 1416","line":"  Eigen::half ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64));"},
{"lineNum":" 1417","line":"  Eigen::half hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64));"},
{"lineNum":" 1418","line":"  h[0] = ha / hb;"},
{"lineNum":" 1419","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 16));"},
{"lineNum":" 1420","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 16));"},
{"lineNum":" 1421","line":"  h[1] = ha / hb;"},
{"lineNum":" 1422","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 32));"},
{"lineNum":" 1423","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 32));"},
{"lineNum":" 1424","line":"  h[2] = ha / hb;"},
{"lineNum":" 1425","line":"  ha = half_impl::raw_uint16_to_half(static_cast<unsigned short>(a64 >> 48));"},
{"lineNum":" 1426","line":"  hb = half_impl::raw_uint16_to_half(static_cast<unsigned short>(b64 >> 48));"},
{"lineNum":" 1427","line":"  h[3] = ha / hb;"},
{"lineNum":" 1428","line":"  Packet4h result;"},
{"lineNum":" 1429","line":"  result.x = _mm_set_pi16(h[3].x, h[2].x, h[1].x, h[0].x);"},
{"lineNum":" 1430","line":"  return result;"},
{"lineNum":" 1431","line":"}"},
{"lineNum":" 1432","line":""},
{"lineNum":" 1433","line":"template<> EIGEN_STRONG_INLINE Packet4h pload<Packet4h>(const Eigen::half* from) {"},
{"lineNum":" 1434","line":"  Packet4h result;"},
{"lineNum":" 1435","line":"  result.x = _mm_cvtsi64_m64(*reinterpret_cast<const __int64_t*>(from));"},
{"lineNum":" 1436","line":"  return result;"},
{"lineNum":" 1437","line":"}"},
{"lineNum":" 1438","line":""},
{"lineNum":" 1439","line":"template<> EIGEN_STRONG_INLINE Packet4h ploadu<Packet4h>(const Eigen::half* from) {"},
{"lineNum":" 1440","line":"  Packet4h result;"},
{"lineNum":" 1441","line":"  result.x = _mm_cvtsi64_m64(*reinterpret_cast<const __int64_t*>(from));"},
{"lineNum":" 1442","line":"  return result;"},
{"lineNum":" 1443","line":"}"},
{"lineNum":" 1444","line":""},
{"lineNum":" 1445","line":"template<> EIGEN_STRONG_INLINE void pstore<Eigen::half>(Eigen::half* to, const Packet4h& from) {"},
{"lineNum":" 1446","line":"  __int64_t r = _mm_cvtm64_si64(from.x);"},
{"lineNum":" 1447","line":"  *(reinterpret_cast<__int64_t*>(to)) = r;"},
{"lineNum":" 1448","line":"}"},
{"lineNum":" 1449","line":""},
{"lineNum":" 1450","line":"template<> EIGEN_STRONG_INLINE void pstoreu<Eigen::half>(Eigen::half* to, const Packet4h& from) {"},
{"lineNum":" 1451","line":"  __int64_t r = _mm_cvtm64_si64(from.x);"},
{"lineNum":" 1452","line":"  *(reinterpret_cast<__int64_t*>(to)) = r;"},
{"lineNum":" 1453","line":"}"},
{"lineNum":" 1454","line":""},
{"lineNum":" 1455","line":"template<> EIGEN_STRONG_INLINE Packet4h"},
{"lineNum":" 1456","line":"ploadquad<Packet4h>(const Eigen::half* from) {"},
{"lineNum":" 1457","line":"  return pset1<Packet4h>(*from);"},
{"lineNum":" 1458","line":"}"},
{"lineNum":" 1459","line":""},
{"lineNum":" 1460","line":"template<> EIGEN_STRONG_INLINE Packet4h pgather<Eigen::half, Packet4h>(const Eigen::half* from, Index stride)"},
{"lineNum":" 1461","line":"{"},
{"lineNum":" 1462","line":"  Packet4h result;"},
{"lineNum":" 1463","line":"  result.x = _mm_set_pi16(from[3*stride].x, from[2*stride].x, from[1*stride].x, from[0*stride].x);"},
{"lineNum":" 1464","line":"  return result;"},
{"lineNum":" 1465","line":"}"},
{"lineNum":" 1466","line":""},
{"lineNum":" 1467","line":"template<> EIGEN_STRONG_INLINE void pscatter<Eigen::half, Packet4h>(Eigen::half* to, const Packet4h& from, Index stride)"},
{"lineNum":" 1468","line":"{"},
{"lineNum":" 1469","line":"  __int64_t a = _mm_cvtm64_si64(from.x);"},
{"lineNum":" 1470","line":"  to[stride*0].x = static_cast<unsigned short>(a);"},
{"lineNum":" 1471","line":"  to[stride*1].x = static_cast<unsigned short>(a >> 16);"},
{"lineNum":" 1472","line":"  to[stride*2].x = static_cast<unsigned short>(a >> 32);"},
{"lineNum":" 1473","line":"  to[stride*3].x = static_cast<unsigned short>(a >> 48);"},
{"lineNum":" 1474","line":"}"},
{"lineNum":" 1475","line":""},
{"lineNum":" 1476","line":"EIGEN_STRONG_INLINE void"},
{"lineNum":" 1477","line":"ptranspose(PacketBlock<Packet4h,4>& kernel) {"},
{"lineNum":" 1478","line":"  __m64 T0 = _mm_unpacklo_pi16(kernel.packet[0].x, kernel.packet[1].x);"},
{"lineNum":" 1479","line":"  __m64 T1 = _mm_unpacklo_pi16(kernel.packet[2].x, kernel.packet[3].x);"},
{"lineNum":" 1480","line":"  __m64 T2 = _mm_unpackhi_pi16(kernel.packet[0].x, kernel.packet[1].x);"},
{"lineNum":" 1481","line":"  __m64 T3 = _mm_unpackhi_pi16(kernel.packet[2].x, kernel.packet[3].x);"},
{"lineNum":" 1482","line":""},
{"lineNum":" 1483","line":"  kernel.packet[0].x = _mm_unpacklo_pi32(T0, T1);"},
{"lineNum":" 1484","line":"  kernel.packet[1].x = _mm_unpackhi_pi32(T0, T1);"},
{"lineNum":" 1485","line":"  kernel.packet[2].x = _mm_unpacklo_pi32(T2, T3);"},
{"lineNum":" 1486","line":"  kernel.packet[3].x = _mm_unpackhi_pi32(T2, T3);"},
{"lineNum":" 1487","line":"}"},
{"lineNum":" 1488","line":""},
{"lineNum":" 1489","line":"#endif"},
{"lineNum":" 1490","line":""},
{"lineNum":" 1491","line":""},
{"lineNum":" 1492","line":"} // end namespace internal"},
{"lineNum":" 1493","line":""},
{"lineNum":" 1494","line":"} // end namespace Eigen"},
{"lineNum":" 1495","line":""},
{"lineNum":" 1496","line":"#if EIGEN_COMP_PGI && EIGEN_COMP_PGI < 1900"},
{"lineNum":" 1497","line":"// PGI++ does not define the following intrinsics in C++ mode."},
{"lineNum":" 1498","line":"static inline __m128  _mm_castpd_ps   (__m128d x) { return reinterpret_cast<__m128&>(x);  }"},
{"lineNum":" 1499","line":"static inline __m128i _mm_castpd_si128(__m128d x) { return reinterpret_cast<__m128i&>(x); }"},
{"lineNum":" 1500","line":"static inline __m128d _mm_castps_pd   (__m128  x) { return reinterpret_cast<__m128d&>(x); }"},
{"lineNum":" 1501","line":"static inline __m128i _mm_castps_si128(__m128  x) { return reinterpret_cast<__m128i&>(x); }"},
{"lineNum":" 1502","line":"static inline __m128  _mm_castsi128_ps(__m128i x) { return reinterpret_cast<__m128&>(x);  }"},
{"lineNum":" 1503","line":"static inline __m128d _mm_castsi128_pd(__m128i x) { return reinterpret_cast<__m128d&>(x); }"},
{"lineNum":" 1504","line":"#endif"},
{"lineNum":" 1505","line":""},
{"lineNum":" 1506","line":"#endif // EIGEN_PACKET_MATH_SSE_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 16, "covered" : 0,};
var merged_data = [];
