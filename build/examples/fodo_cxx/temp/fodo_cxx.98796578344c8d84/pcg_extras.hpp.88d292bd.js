var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":" * PCG Random Number Generation for C++"},
{"lineNum":"    3","line":" *"},
{"lineNum":"    4","line":" * Copyright 2014 Melissa O\'Neill <oneill@pcg-random.org>"},
{"lineNum":"    5","line":" *"},
{"lineNum":"    6","line":" * Licensed under the Apache License, Version 2.0 (the \"License\");"},
{"lineNum":"    7","line":" * you may not use this file except in compliance with the License."},
{"lineNum":"    8","line":" * You may obtain a copy of the License at"},
{"lineNum":"    9","line":" *"},
{"lineNum":"   10","line":" *     http://www.apache.org/licenses/LICENSE-2.0"},
{"lineNum":"   11","line":" *"},
{"lineNum":"   12","line":" * Unless required by applicable law or agreed to in writing, software"},
{"lineNum":"   13","line":" * distributed under the License is distributed on an \"AS IS\" BASIS,"},
{"lineNum":"   14","line":" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."},
{"lineNum":"   15","line":" * See the License for the specific language governing permissions and"},
{"lineNum":"   16","line":" * limitations under the License."},
{"lineNum":"   17","line":" *"},
{"lineNum":"   18","line":" * For additional information about the PCG random number generation scheme,"},
{"lineNum":"   19","line":" * including its license and other licensing options, visit"},
{"lineNum":"   20","line":" *"},
{"lineNum":"   21","line":" *     http://www.pcg-random.org"},
{"lineNum":"   22","line":" */"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"/*"},
{"lineNum":"   25","line":" * This file provides support code that is useful for random-number generation"},
{"lineNum":"   26","line":" * but not specific to the PCG generation scheme, including:"},
{"lineNum":"   27","line":" *      - 128-bit int support for platforms where it isn\'t available natively"},
{"lineNum":"   28","line":" *      - bit twiddling operations"},
{"lineNum":"   29","line":" *      - I/O of 128-bit and 8-bit integers"},
{"lineNum":"   30","line":" *      - Handling the evilness of SeedSeq"},
{"lineNum":"   31","line":" *      - Support for efficiently producing random numbers less than a given"},
{"lineNum":"   32","line":" *        bound"},
{"lineNum":"   33","line":" */"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"#ifndef PCG_EXTRAS_HPP_INCLUDED"},
{"lineNum":"   36","line":"#define PCG_EXTRAS_HPP_INCLUDED 1"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"#include <cinttypes>"},
{"lineNum":"   39","line":"#include <cstddef>"},
{"lineNum":"   40","line":"#include <cstdlib>"},
{"lineNum":"   41","line":"#include <cstring>"},
{"lineNum":"   42","line":"#include <cassert>"},
{"lineNum":"   43","line":"#include <limits>"},
{"lineNum":"   44","line":"#include <iostream>"},
{"lineNum":"   45","line":"#include <type_traits>"},
{"lineNum":"   46","line":"#include <utility>"},
{"lineNum":"   47","line":"#include <locale>"},
{"lineNum":"   48","line":"#include <iterator>"},
{"lineNum":"   49","line":"#include <utility>"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"#ifdef __GNUC__"},
{"lineNum":"   52","line":"    #include <cxxabi.h>"},
{"lineNum":"   53","line":"#endif"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"/*"},
{"lineNum":"   56","line":" * Abstractions for compiler-specific directives"},
{"lineNum":"   57","line":" */"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"#ifdef __GNUC__"},
{"lineNum":"   60","line":"    #define PCG_NOINLINE __attribute__((noinline))"},
{"lineNum":"   61","line":"#else"},
{"lineNum":"   62","line":"    #define PCG_NOINLINE"},
{"lineNum":"   63","line":"#endif"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"/*"},
{"lineNum":"   66","line":" * Some members of the PCG library use 128-bit math.  When compiling on 64-bit"},
{"lineNum":"   67","line":" * platforms, both GCC and Clang provide 128-bit integer types that are ideal"},
{"lineNum":"   68","line":" * for the job."},
{"lineNum":"   69","line":" *"},
{"lineNum":"   70","line":" * On 32-bit platforms (or with other compilers), we fall back to a C++"},
{"lineNum":"   71","line":" * class that provides 128-bit unsigned integers instead.  It may seem"},
{"lineNum":"   72","line":" * like we\'re reinventing the wheel here, because libraries already exist"},
{"lineNum":"   73","line":" * that support large integers, but most existing libraries provide a very"},
{"lineNum":"   74","line":" * generic multiprecision code, but here we\'re operating at a fixed size."},
{"lineNum":"   75","line":" * Also, most other libraries are fairly heavyweight.  So we use a direct"},
{"lineNum":"   76","line":" * implementation.  Sadly, it\'s much slower than hand-coded assembly or"},
{"lineNum":"   77","line":" * direct CPU support."},
{"lineNum":"   78","line":" *"},
{"lineNum":"   79","line":" */"},
{"lineNum":"   80","line":"#if __SIZEOF_INT128__"},
{"lineNum":"   81","line":"    namespace pcg_extras {"},
{"lineNum":"   82","line":"        typedef __uint128_t pcg128_t;"},
{"lineNum":"   83","line":"    }"},
{"lineNum":"   84","line":"    #define PCG_128BIT_CONSTANT(high,low) \\"},
{"lineNum":"   85","line":"            ((pcg128_t(high) << 64) + low)"},
{"lineNum":"   86","line":"#else"},
{"lineNum":"   87","line":"    #include \"pcg_uint128.hpp\""},
{"lineNum":"   88","line":"    namespace pcg_extras {"},
{"lineNum":"   89","line":"        typedef pcg_extras::uint_x4<uint32_t,uint64_t> pcg128_t;"},
{"lineNum":"   90","line":"    }"},
{"lineNum":"   91","line":"    #define PCG_128BIT_CONSTANT(high,low) \\"},
{"lineNum":"   92","line":"            pcg128_t(high,low)"},
{"lineNum":"   93","line":"    #define PCG_EMULATED_128BIT_MATH 1"},
{"lineNum":"   94","line":"#endif"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"namespace pcg_extras {"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"/*"},
{"lineNum":"  100","line":" * We often need to represent a \"number of bits\".  When used normally, these"},
{"lineNum":"  101","line":" * numbers are never greater than 128, so an unsigned char is plenty."},
{"lineNum":"  102","line":" * If you\'re using a nonstandard generator of a larger size, you can set"},
{"lineNum":"  103","line":" * PCG_BITCOUNT_T to have it define it as a larger size.  (Some compilers"},
{"lineNum":"  104","line":" * might produce faster code if you set it to an unsigned int.)"},
{"lineNum":"  105","line":" */"},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"#ifndef PCG_BITCOUNT_T"},
{"lineNum":"  108","line":"    typedef uint8_t bitcount_t;"},
{"lineNum":"  109","line":"#else"},
{"lineNum":"  110","line":"    typedef PCG_BITCOUNT_T bitcount_t;"},
{"lineNum":"  111","line":"#endif"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"/*"},
{"lineNum":"  114","line":" * C++ requires us to be able to serialize RNG state by printing or reading"},
{"lineNum":"  115","line":" * it from a stream.  Because we use 128-bit ints, we also need to be able"},
{"lineNum":"  116","line":" * ot print them, so here is code to do so."},
{"lineNum":"  117","line":" *"},
{"lineNum":"  118","line":" * This code provides enough functionality to print 128-bit ints in decimal"},
{"lineNum":"  119","line":" * and zero-padded in hex.  It\'s not a full-featured implementation."},
{"lineNum":"  120","line":" */"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"template <typename CharT, typename Traits>"},
{"lineNum":"  123","line":"std::basic_ostream<CharT,Traits>&"},
{"lineNum":"  124","line":"operator<<(std::basic_ostream<CharT,Traits>& out, pcg128_t value)"},
{"lineNum":"  125","line":"{"},
{"lineNum":"  126","line":"    auto desired_base = out.flags() & out.basefield;"},
{"lineNum":"  127","line":"    bool want_hex = desired_base == out.hex;"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    if (want_hex) {"},
{"lineNum":"  130","line":"        uint64_t highpart = uint64_t(value >> 64);"},
{"lineNum":"  131","line":"        uint64_t lowpart  = uint64_t(value);"},
{"lineNum":"  132","line":"        auto desired_width = out.width();"},
{"lineNum":"  133","line":"        if (desired_width > 16) {"},
{"lineNum":"  134","line":"            out.width(desired_width - 16);"},
{"lineNum":"  135","line":"        }"},
{"lineNum":"  136","line":"        if (highpart != 0 || desired_width > 16)"},
{"lineNum":"  137","line":"            out << highpart;"},
{"lineNum":"  138","line":"        CharT oldfill;"},
{"lineNum":"  139","line":"        if (highpart != 0) {"},
{"lineNum":"  140","line":"            out.width(16);"},
{"lineNum":"  141","line":"            oldfill = out.fill(\'0\');"},
{"lineNum":"  142","line":"        }"},
{"lineNum":"  143","line":"        auto oldflags = out.setf(decltype(desired_base){}, out.showbase);"},
{"lineNum":"  144","line":"        out << lowpart;"},
{"lineNum":"  145","line":"        out.setf(oldflags);"},
{"lineNum":"  146","line":"        if (highpart != 0) {"},
{"lineNum":"  147","line":"            out.fill(oldfill);"},
{"lineNum":"  148","line":"        }"},
{"lineNum":"  149","line":"        return out;"},
{"lineNum":"  150","line":"    }"},
{"lineNum":"  151","line":"    constexpr size_t MAX_CHARS_128BIT = 40;"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"    char buffer[MAX_CHARS_128BIT];"},
{"lineNum":"  154","line":"    char* pos = buffer+sizeof(buffer);"},
{"lineNum":"  155","line":"    *(--pos) = \'\\0\';"},
{"lineNum":"  156","line":"    constexpr auto BASE = pcg128_t(10ULL);"},
{"lineNum":"  157","line":"    do {"},
{"lineNum":"  158","line":"        auto div = value / BASE;"},
{"lineNum":"  159","line":"        auto mod = uint32_t(value - (div * BASE));"},
{"lineNum":"  160","line":"        *(--pos) = \'0\' + mod;"},
{"lineNum":"  161","line":"        value = div;"},
{"lineNum":"  162","line":"    } while(value != pcg128_t(0ULL));"},
{"lineNum":"  163","line":"    return out << pos;"},
{"lineNum":"  164","line":"}"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"template <typename CharT, typename Traits>"},
{"lineNum":"  167","line":"std::basic_istream<CharT,Traits>&"},
{"lineNum":"  168","line":"operator>>(std::basic_istream<CharT,Traits>& in, pcg128_t& value)"},
{"lineNum":"  169","line":"{"},
{"lineNum":"  170","line":"    typename std::basic_istream<CharT,Traits>::sentry s(in);"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"    if (!s)"},
{"lineNum":"  173","line":"         return in;"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"    constexpr auto BASE = pcg128_t(10ULL);"},
{"lineNum":"  176","line":"    pcg128_t current(0ULL);"},
{"lineNum":"  177","line":"    bool did_nothing = true;"},
{"lineNum":"  178","line":"    bool overflow = false;"},
{"lineNum":"  179","line":"    for(;;) {"},
{"lineNum":"  180","line":"        CharT wide_ch = in.get();"},
{"lineNum":"  181","line":"        if (!in.good())"},
{"lineNum":"  182","line":"            break;"},
{"lineNum":"  183","line":"        auto ch = in.narrow(wide_ch, \'\\0\');"},
{"lineNum":"  184","line":"        if (ch < \'0\' || ch > \'9\') {"},
{"lineNum":"  185","line":"            in.unget();"},
{"lineNum":"  186","line":"            break;"},
{"lineNum":"  187","line":"        }"},
{"lineNum":"  188","line":"        did_nothing = false;"},
{"lineNum":"  189","line":"        pcg128_t digit(uint32_t(ch - \'0\'));"},
{"lineNum":"  190","line":"        pcg128_t timesbase = current*BASE;"},
{"lineNum":"  191","line":"        overflow = overflow || timesbase < current;"},
{"lineNum":"  192","line":"        current = timesbase + digit;"},
{"lineNum":"  193","line":"        overflow = overflow || current < digit;"},
{"lineNum":"  194","line":"    }"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"    if (did_nothing || overflow) {"},
{"lineNum":"  197","line":"        in.setstate(std::ios::failbit);"},
{"lineNum":"  198","line":"        if (overflow)"},
{"lineNum":"  199","line":"            current = ~pcg128_t(0ULL);"},
{"lineNum":"  200","line":"    }"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"    value = current;"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    return in;"},
{"lineNum":"  205","line":"}"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"/*"},
{"lineNum":"  208","line":" * Likewise, if people use tiny rngs, we\'ll be serializing uint8_t."},
{"lineNum":"  209","line":" * If we just used the provided IO operators, they\'d read/write chars,"},
{"lineNum":"  210","line":" * not ints, so we need to define our own.  We *can* redefine this operator"},
{"lineNum":"  211","line":" * here because we\'re in our own namespace."},
{"lineNum":"  212","line":" */"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"template <typename CharT, typename Traits>"},
{"lineNum":"  215","line":"std::basic_ostream<CharT,Traits>&"},
{"lineNum":"  216","line":"operator<<(std::basic_ostream<CharT,Traits>&out, uint8_t value)"},
{"lineNum":"  217","line":"{"},
{"lineNum":"  218","line":"    return out << uint32_t(value);"},
{"lineNum":"  219","line":"}"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"template <typename CharT, typename Traits>"},
{"lineNum":"  222","line":"std::basic_istream<CharT,Traits>&"},
{"lineNum":"  223","line":"operator>>(std::basic_istream<CharT,Traits>& in, uint8_t target)"},
{"lineNum":"  224","line":"{"},
{"lineNum":"  225","line":"    uint32_t value = 0xdecea5edU;"},
{"lineNum":"  226","line":"    in >> value;"},
{"lineNum":"  227","line":"    if (!in && value == 0xdecea5edU)"},
{"lineNum":"  228","line":"        return in;"},
{"lineNum":"  229","line":"    if (value > uint8_t(~0)) {"},
{"lineNum":"  230","line":"        in.setstate(std::ios::failbit);"},
{"lineNum":"  231","line":"        value = ~0U;"},
{"lineNum":"  232","line":"    }"},
{"lineNum":"  233","line":"    target = uint8_t(value);"},
{"lineNum":"  234","line":"    return in;"},
{"lineNum":"  235","line":"}"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"/* Unfortunately, the above functions don\'t get found in preference to the"},
{"lineNum":"  238","line":" * built in ones, so we create some more specific overloads that will."},
{"lineNum":"  239","line":" * Ugh."},
{"lineNum":"  240","line":" */"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"inline std::ostream& operator<<(std::ostream& out, uint8_t value)"},
{"lineNum":"  243","line":"{"},
{"lineNum":"  244","line":"    return pcg_extras::operator<< <char>(out, value);"},
{"lineNum":"  245","line":"}"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"inline std::istream& operator>>(std::istream& in, uint8_t& value)"},
{"lineNum":"  248","line":"{"},
{"lineNum":"  249","line":"    return pcg_extras::operator>> <char>(in, value);"},
{"lineNum":"  250","line":"}"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"/*"},
{"lineNum":"  255","line":" * Useful bitwise operations."},
{"lineNum":"  256","line":" */"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"/*"},
{"lineNum":"  259","line":" * XorShifts are invertable, but they are someting of a pain to invert."},
{"lineNum":"  260","line":" * This function backs them out.  It\'s used by the whacky \"inside out\""},
{"lineNum":"  261","line":" * generator defined later."},
{"lineNum":"  262","line":" */"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"template <typename itype>"},
{"lineNum":"  265","line":"inline itype unxorshift(itype x, bitcount_t bits, bitcount_t shift)"},
{"lineNum":"  266","line":"{"},
{"lineNum":"  267","line":"    if (2*shift >= bits) {"},
{"lineNum":"  268","line":"        return x ^ (x >> shift);"},
{"lineNum":"  269","line":"    }"},
{"lineNum":"  270","line":"    itype lowmask1 = (itype(1U) << (bits - shift*2)) - 1;"},
{"lineNum":"  271","line":"    itype highmask1 = ~lowmask1;"},
{"lineNum":"  272","line":"    itype top1 = x;"},
{"lineNum":"  273","line":"    itype bottom1 = x & lowmask1;"},
{"lineNum":"  274","line":"    top1 ^= top1 >> shift;"},
{"lineNum":"  275","line":"    top1 &= highmask1;"},
{"lineNum":"  276","line":"    x = top1 | bottom1;"},
{"lineNum":"  277","line":"    itype lowmask2 = (itype(1U) << (bits - shift)) - 1;"},
{"lineNum":"  278","line":"    itype bottom2 = x & lowmask2;"},
{"lineNum":"  279","line":"    bottom2 = unxorshift(bottom2, bits - shift, shift);"},
{"lineNum":"  280","line":"    bottom2 &= lowmask1;"},
{"lineNum":"  281","line":"    return top1 | bottom2;"},
{"lineNum":"  282","line":"}"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"/*"},
{"lineNum":"  285","line":" * Rotate left and right."},
{"lineNum":"  286","line":" *"},
{"lineNum":"  287","line":" * In ideal world, compilers would spot idiomatic rotate code and convert it"},
{"lineNum":"  288","line":" * to a rotate instruction.  Of course, opinions vary on what the correct"},
{"lineNum":"  289","line":" * idiom is and how to spot it.  For clang, sometimes it generates better"},
{"lineNum":"  290","line":" * (but still crappy) code if you define PCG_USE_ZEROCHECK_ROTATE_IDIOM."},
{"lineNum":"  291","line":" */"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"template <typename itype>"},
{"lineNum":"  294","line":"inline itype rotl(itype value, bitcount_t rot)"},
{"lineNum":"  295","line":"{"},
{"lineNum":"  296","line":"    constexpr bitcount_t bits = sizeof(itype) * 8;"},
{"lineNum":"  297","line":"    constexpr bitcount_t mask = bits - 1;"},
{"lineNum":"  298","line":"#if PCG_USE_ZEROCHECK_ROTATE_IDIOM"},
{"lineNum":"  299","line":"    return rot ? (value << rot) | (value >> (bits - rot)) : value;"},
{"lineNum":"  300","line":"#else"},
{"lineNum":"  301","line":"    return (value << rot) | (value >> ((- rot) & mask));"},
{"lineNum":"  302","line":"#endif"},
{"lineNum":"  303","line":"}"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"template <typename itype>"},
{"lineNum":"  306","line":"inline itype rotr(itype value, bitcount_t rot)"},
{"lineNum":"  307","line":"{"},
{"lineNum":"  308","line":"    constexpr bitcount_t bits = sizeof(itype) * 8;"},
{"lineNum":"  309","line":"    constexpr bitcount_t mask = bits - 1;"},
{"lineNum":"  310","line":"#if PCG_USE_ZEROCHECK_ROTATE_IDIOM"},
{"lineNum":"  311","line":"    return rot ? (value >> rot) | (value << (bits - rot)) : value;"},
{"lineNum":"  312","line":"#else"},
{"lineNum":"  313","line":"    return (value >> rot) | (value << ((- rot) & mask));","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  314","line":"#endif"},
{"lineNum":"  315","line":"}"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"/* Unfortunately, both Clang and GCC sometimes perform poorly when it comes"},
{"lineNum":"  318","line":" * to properly recognizing idiomatic rotate code, so for we also provide"},
{"lineNum":"  319","line":" * assembler directives (enabled with PCG_USE_INLINE_ASM).  Boo, hiss."},
{"lineNum":"  320","line":" * (I hope that these compilers get better so that this code can die.)"},
{"lineNum":"  321","line":" *"},
{"lineNum":"  322","line":" * These overloads will be preferred over the general template code above."},
{"lineNum":"  323","line":" */"},
{"lineNum":"  324","line":"#if PCG_USE_INLINE_ASM && __GNUC__ && (__x86_64__  || __i386__)"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"inline uint8_t rotr(uint8_t value, bitcount_t rot)"},
{"lineNum":"  327","line":"{"},
{"lineNum":"  328","line":"    asm (\"rorb   %%cl, %0\" : \"=r\" (value) : \"0\" (value), \"c\" (rot));"},
{"lineNum":"  329","line":"    return value;"},
{"lineNum":"  330","line":"}"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"inline uint16_t rotr(uint16_t value, bitcount_t rot)"},
{"lineNum":"  333","line":"{"},
{"lineNum":"  334","line":"    asm (\"rorw   %%cl, %0\" : \"=r\" (value) : \"0\" (value), \"c\" (rot));"},
{"lineNum":"  335","line":"    return value;"},
{"lineNum":"  336","line":"}"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"inline uint32_t rotr(uint32_t value, bitcount_t rot)"},
{"lineNum":"  339","line":"{"},
{"lineNum":"  340","line":"    asm (\"rorl   %%cl, %0\" : \"=r\" (value) : \"0\" (value), \"c\" (rot));"},
{"lineNum":"  341","line":"    return value;"},
{"lineNum":"  342","line":"}"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"#if __x86_64__"},
{"lineNum":"  345","line":"inline uint64_t rotr(uint64_t value, bitcount_t rot)"},
{"lineNum":"  346","line":"{"},
{"lineNum":"  347","line":"    asm (\"rorq   %%cl, %0\" : \"=r\" (value) : \"0\" (value), \"c\" (rot));"},
{"lineNum":"  348","line":"    return value;"},
{"lineNum":"  349","line":"}"},
{"lineNum":"  350","line":"#endif // __x86_64__"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"#endif // PCG_USE_INLINE_ASM"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"/*"},
{"lineNum":"  356","line":" * The C++ SeedSeq concept (modelled by seed_seq) can fill an array of"},
{"lineNum":"  357","line":" * 32-bit integers with seed data, but sometimes we want to produce"},
{"lineNum":"  358","line":" * larger or smaller integers."},
{"lineNum":"  359","line":" *"},
{"lineNum":"  360","line":" * The following code handles this annoyance."},
{"lineNum":"  361","line":" *"},
{"lineNum":"  362","line":" * uneven_copy will copy an array of 32-bit ints to an array of larger or"},
{"lineNum":"  363","line":" * smaller ints (actually, the code is general it only needing forward"},
{"lineNum":"  364","line":" * iterators).  The copy is identical to the one that would be performed if"},
{"lineNum":"  365","line":" * we just did memcpy on a standard little-endian machine, but works"},
{"lineNum":"  366","line":" * regardless of the endian of the machine (or the weirdness of the ints"},
{"lineNum":"  367","line":" * involved)."},
{"lineNum":"  368","line":" *"},
{"lineNum":"  369","line":" * generate_to initializes an array of integers using a SeedSeq"},
{"lineNum":"  370","line":" * object.  It is given the size as a static constant at compile time and"},
{"lineNum":"  371","line":" * tries to avoid memory allocation.  If we\'re filling in 32-bit constants"},
{"lineNum":"  372","line":" * we just do it directly.  If we need a separate buffer and it\'s small,"},
{"lineNum":"  373","line":" * we allocate it on the stack.  Otherwise, we fall back to heap allocation."},
{"lineNum":"  374","line":" * Ugh."},
{"lineNum":"  375","line":" *"},
{"lineNum":"  376","line":" * generate_one produces a single value of some integral type using a"},
{"lineNum":"  377","line":" * SeedSeq object."},
{"lineNum":"  378","line":" */"},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":" /* uneven_copy helper, case where destination ints are less than 32 bit. */"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"template<class SrcIter, class DestIter>"},
{"lineNum":"  383","line":"SrcIter uneven_copy_impl("},
{"lineNum":"  384","line":"    SrcIter src_first, DestIter dest_first, DestIter dest_last,"},
{"lineNum":"  385","line":"    std::true_type)"},
{"lineNum":"  386","line":"{"},
{"lineNum":"  387","line":"    typedef typename std::iterator_traits<SrcIter>::value_type  src_t;"},
{"lineNum":"  388","line":"    typedef typename std::iterator_traits<DestIter>::value_type dest_t;"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"    constexpr bitcount_t SRC_SIZE  = sizeof(src_t);"},
{"lineNum":"  391","line":"    constexpr bitcount_t DEST_SIZE = sizeof(dest_t);"},
{"lineNum":"  392","line":"    constexpr bitcount_t DEST_BITS = DEST_SIZE * 8;"},
{"lineNum":"  393","line":"    constexpr bitcount_t SCALE     = SRC_SIZE / DEST_SIZE;"},
{"lineNum":"  394","line":""},
{"lineNum":"  395","line":"    size_t count = 0;"},
{"lineNum":"  396","line":"    src_t value;"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"    while (dest_first != dest_last) {"},
{"lineNum":"  399","line":"        if ((count++ % SCALE) == 0)"},
{"lineNum":"  400","line":"            value = *src_first++;       // Get more bits"},
{"lineNum":"  401","line":"        else"},
{"lineNum":"  402","line":"            value >>= DEST_BITS;        // Move down bits"},
{"lineNum":"  403","line":""},
{"lineNum":"  404","line":"        *dest_first++ = dest_t(value);  // Truncates, ignores high bits."},
{"lineNum":"  405","line":"    }"},
{"lineNum":"  406","line":"    return src_first;"},
{"lineNum":"  407","line":"}"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":" /* uneven_copy helper, case where destination ints are more than 32 bit. */"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"template<class SrcIter, class DestIter>"},
{"lineNum":"  412","line":"SrcIter uneven_copy_impl("},
{"lineNum":"  413","line":"    SrcIter src_first, DestIter dest_first, DestIter dest_last,"},
{"lineNum":"  414","line":"    std::false_type)"},
{"lineNum":"  415","line":"{"},
{"lineNum":"  416","line":"    typedef typename std::iterator_traits<SrcIter>::value_type  src_t;"},
{"lineNum":"  417","line":"    typedef typename std::iterator_traits<DestIter>::value_type dest_t;"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"    constexpr auto SRC_SIZE  = sizeof(src_t);"},
{"lineNum":"  420","line":"    constexpr auto SRC_BITS  = SRC_SIZE * 8;"},
{"lineNum":"  421","line":"    constexpr auto DEST_SIZE = sizeof(dest_t);"},
{"lineNum":"  422","line":"    constexpr auto SCALE     = (DEST_SIZE+SRC_SIZE-1) / SRC_SIZE;"},
{"lineNum":"  423","line":""},
{"lineNum":"  424","line":"    while (dest_first != dest_last) {"},
{"lineNum":"  425","line":"        dest_t value(0UL);"},
{"lineNum":"  426","line":"        unsigned int shift = 0;"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"        for (size_t i = 0; i < SCALE; ++i) {"},
{"lineNum":"  429","line":"            value |= dest_t(*src_first++) << shift;"},
{"lineNum":"  430","line":"            shift += SRC_BITS;"},
{"lineNum":"  431","line":"        }"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"        *dest_first++ = value;"},
{"lineNum":"  434","line":"    }"},
{"lineNum":"  435","line":"    return src_first;"},
{"lineNum":"  436","line":"}"},
{"lineNum":"  437","line":""},
{"lineNum":"  438","line":"/* uneven_copy, call the right code for larger vs. smaller */"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"template<class SrcIter, class DestIter>"},
{"lineNum":"  441","line":"inline SrcIter uneven_copy(SrcIter src_first,"},
{"lineNum":"  442","line":"                           DestIter dest_first, DestIter dest_last)"},
{"lineNum":"  443","line":"{"},
{"lineNum":"  444","line":"    typedef typename std::iterator_traits<SrcIter>::value_type  src_t;"},
{"lineNum":"  445","line":"    typedef typename std::iterator_traits<DestIter>::value_type dest_t;"},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"    constexpr bool DEST_IS_SMALLER = sizeof(dest_t) < sizeof(src_t);"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"    return uneven_copy_impl(src_first, dest_first, dest_last,"},
{"lineNum":"  450","line":"                            std::integral_constant<bool, DEST_IS_SMALLER>{});"},
{"lineNum":"  451","line":"}"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"/* generate_to, fill in a fixed-size array of integral type using a SeedSeq"},
{"lineNum":"  454","line":" * (actually works for any random-access iterator)"},
{"lineNum":"  455","line":" */"},
{"lineNum":"  456","line":""},
{"lineNum":"  457","line":"template <size_t size, typename SeedSeq, typename DestIter>"},
{"lineNum":"  458","line":"inline void generate_to_impl(SeedSeq&& generator, DestIter dest,"},
{"lineNum":"  459","line":"                             std::true_type)"},
{"lineNum":"  460","line":"{"},
{"lineNum":"  461","line":"    generator.generate(dest, dest+size);"},
{"lineNum":"  462","line":"}"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"template <size_t size, typename SeedSeq, typename DestIter>"},
{"lineNum":"  465","line":"void generate_to_impl(SeedSeq&& generator, DestIter dest,"},
{"lineNum":"  466","line":"                      std::false_type)"},
{"lineNum":"  467","line":"{"},
{"lineNum":"  468","line":"    typedef typename std::iterator_traits<DestIter>::value_type dest_t;"},
{"lineNum":"  469","line":"    constexpr auto DEST_SIZE = sizeof(dest_t);"},
{"lineNum":"  470","line":"    constexpr auto GEN_SIZE  = sizeof(uint32_t);"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"    constexpr bool GEN_IS_SMALLER = GEN_SIZE < DEST_SIZE;"},
{"lineNum":"  473","line":"    constexpr size_t FROM_ELEMS ="},
{"lineNum":"  474","line":"        GEN_IS_SMALLER"},
{"lineNum":"  475","line":"            ? size * ((DEST_SIZE+GEN_SIZE-1) / GEN_SIZE)"},
{"lineNum":"  476","line":"            : (size + (GEN_SIZE / DEST_SIZE) - 1)"},
{"lineNum":"  477","line":"                / ((GEN_SIZE / DEST_SIZE) + GEN_IS_SMALLER);"},
{"lineNum":"  478","line":"                        //  this odd code ^^^^^^^^^^^^^^^^^ is work-around for"},
{"lineNum":"  479","line":"                        //  a bug: http://llvm.org/bugs/show_bug.cgi?id=21287"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"    if (FROM_ELEMS <= 1024) {"},
{"lineNum":"  482","line":"        uint32_t buffer[FROM_ELEMS];"},
{"lineNum":"  483","line":"        generator.generate(buffer, buffer+FROM_ELEMS);"},
{"lineNum":"  484","line":"        uneven_copy(buffer, dest, dest+size);"},
{"lineNum":"  485","line":"    } else {"},
{"lineNum":"  486","line":"        uint32_t* buffer = (uint32_t*) malloc(GEN_SIZE * FROM_ELEMS);"},
{"lineNum":"  487","line":"        generator.generate(buffer, buffer+FROM_ELEMS);"},
{"lineNum":"  488","line":"        uneven_copy(buffer, dest, dest+size);"},
{"lineNum":"  489","line":"        free(buffer);"},
{"lineNum":"  490","line":"    }"},
{"lineNum":"  491","line":"}"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"template <size_t size, typename SeedSeq, typename DestIter>"},
{"lineNum":"  494","line":"inline void generate_to(SeedSeq&& generator, DestIter dest)"},
{"lineNum":"  495","line":"{"},
{"lineNum":"  496","line":"    typedef typename std::iterator_traits<DestIter>::value_type dest_t;"},
{"lineNum":"  497","line":"    constexpr bool IS_32BIT = sizeof(dest_t) == sizeof(uint32_t);"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"    generate_to_impl<size>(std::forward<SeedSeq>(generator), dest,"},
{"lineNum":"  500","line":"                           std::integral_constant<bool, IS_32BIT>{});"},
{"lineNum":"  501","line":"}"},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"/* generate_one, produce a value of integral type using a SeedSeq"},
{"lineNum":"  504","line":" * (optionally, we can have it produce more than one and pick which one"},
{"lineNum":"  505","line":" * we want)"},
{"lineNum":"  506","line":" */"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"template <typename UInt, size_t i = 0UL, size_t N = i+1UL, typename SeedSeq>"},
{"lineNum":"  509","line":"inline UInt generate_one(SeedSeq&& generator)"},
{"lineNum":"  510","line":"{"},
{"lineNum":"  511","line":"    UInt result[N];"},
{"lineNum":"  512","line":"    generate_to<N>(std::forward<SeedSeq>(generator), result);"},
{"lineNum":"  513","line":"    return result[i];"},
{"lineNum":"  514","line":"}"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"template <typename RngType>"},
{"lineNum":"  517","line":"auto bounded_rand(RngType& rng, typename RngType::result_type upper_bound)"},
{"lineNum":"  518","line":"        -> typename RngType::result_type"},
{"lineNum":"  519","line":"{"},
{"lineNum":"  520","line":"    typedef typename RngType::result_type rtype;"},
{"lineNum":"  521","line":"    rtype threshold = (RngType::max() - RngType::min() + rtype(1) - upper_bound)"},
{"lineNum":"  522","line":"                    % upper_bound;"},
{"lineNum":"  523","line":"    for (;;) {"},
{"lineNum":"  524","line":"        rtype r = rng() - RngType::min();"},
{"lineNum":"  525","line":"        if (r >= threshold)"},
{"lineNum":"  526","line":"            return r % upper_bound;"},
{"lineNum":"  527","line":"    }"},
{"lineNum":"  528","line":"}"},
{"lineNum":"  529","line":""},
{"lineNum":"  530","line":"template <typename Iter, typename RandType>"},
{"lineNum":"  531","line":"void shuffle(Iter from, Iter to, RandType&& rng)"},
{"lineNum":"  532","line":"{"},
{"lineNum":"  533","line":"    typedef typename std::iterator_traits<Iter>::difference_type delta_t;"},
{"lineNum":"  534","line":"    auto count = to - from;"},
{"lineNum":"  535","line":"    while (count > 1) {"},
{"lineNum":"  536","line":"        delta_t chosen(bounded_rand(rng, count));"},
{"lineNum":"  537","line":"        --count;"},
{"lineNum":"  538","line":"        --to;"},
{"lineNum":"  539","line":"        using std::swap;"},
{"lineNum":"  540","line":"        swap(*(from+chosen), *to);"},
{"lineNum":"  541","line":"    }"},
{"lineNum":"  542","line":"}"},
{"lineNum":"  543","line":""},
{"lineNum":"  544","line":"/*"},
{"lineNum":"  545","line":" * Although std::seed_seq is useful, it isn\'t everything.  Often we want to"},
{"lineNum":"  546","line":" * initialize a random-number generator some other way, such as from a random"},
{"lineNum":"  547","line":" * device."},
{"lineNum":"  548","line":" *"},
{"lineNum":"  549","line":" * Technically, it does not meet the requirements of a SeedSequence because"},
{"lineNum":"  550","line":" * it lacks some of the rarely-used member functions (some of which would"},
{"lineNum":"  551","line":" * be impossible to provide).  However the C++ standard is quite specific"},
{"lineNum":"  552","line":" * that actual engines only called the generate method, so it ought not to be"},
{"lineNum":"  553","line":" * a problem in practice."},
{"lineNum":"  554","line":" */"},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"template <typename RngType>"},
{"lineNum":"  557","line":"class seed_seq_from {"},
{"lineNum":"  558","line":"private:"},
{"lineNum":"  559","line":"    RngType rng_;"},
{"lineNum":"  560","line":""},
{"lineNum":"  561","line":"    typedef uint_least32_t result_type;"},
{"lineNum":"  562","line":""},
{"lineNum":"  563","line":"public:"},
{"lineNum":"  564","line":"    template<typename... Args>"},
{"lineNum":"  565","line":"    seed_seq_from(Args&&... args) :"},
{"lineNum":"  566","line":"        rng_(std::forward<Args>(args)...)"},
{"lineNum":"  567","line":"    {"},
{"lineNum":"  568","line":"        // Nothing (else) to do..."},
{"lineNum":"  569","line":"    }"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"    template<typename Iter>"},
{"lineNum":"  572","line":"    void generate(Iter start, Iter finish)"},
{"lineNum":"  573","line":"    {"},
{"lineNum":"  574","line":"        for (auto i = start; i != finish; ++i)"},
{"lineNum":"  575","line":"            *i = result_type(rng_());"},
{"lineNum":"  576","line":"    }"},
{"lineNum":"  577","line":""},
{"lineNum":"  578","line":"    constexpr size_t size() const"},
{"lineNum":"  579","line":"    {"},
{"lineNum":"  580","line":"        return (sizeof(typename RngType::result_type) > sizeof(result_type)"},
{"lineNum":"  581","line":"                && RngType::max() > ~size_t(0UL))"},
{"lineNum":"  582","line":"             ? ~size_t(0UL)"},
{"lineNum":"  583","line":"             : size_t(RngType::max());"},
{"lineNum":"  584","line":"    }"},
{"lineNum":"  585","line":"};"},
{"lineNum":"  586","line":""},
{"lineNum":"  587","line":"/*"},
{"lineNum":"  588","line":" * Sometimes you might want a distinct seed based on when the program"},
{"lineNum":"  589","line":" * was compiled.  That way, a particular instance of the program will"},
{"lineNum":"  590","line":" * behave the same way, but when recompiled it\'ll produce a different"},
{"lineNum":"  591","line":" * value."},
{"lineNum":"  592","line":" */"},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"template <typename IntType>"},
{"lineNum":"  595","line":"struct static_arbitrary_seed {"},
{"lineNum":"  596","line":"private:"},
{"lineNum":"  597","line":"    static constexpr IntType fnv(IntType hash, const char* pos) {"},
{"lineNum":"  598","line":"        return *pos == \'\\0\'"},
{"lineNum":"  599","line":"             ? hash"},
{"lineNum":"  600","line":"             : fnv((hash * IntType(16777619U)) ^ *pos, (pos+1));"},
{"lineNum":"  601","line":"    }"},
{"lineNum":"  602","line":""},
{"lineNum":"  603","line":"public:"},
{"lineNum":"  604","line":"    static constexpr IntType value = fnv(IntType(2166136261U ^ sizeof(IntType)),"},
{"lineNum":"  605","line":"                        __DATE__ __TIME__ __FILE__);"},
{"lineNum":"  606","line":"};"},
{"lineNum":"  607","line":""},
{"lineNum":"  608","line":"// Sometimes, when debugging or testing, it\'s handy to be able print the name"},
{"lineNum":"  609","line":"// of a (in human-readable form).  This code allows the idiom:"},
{"lineNum":"  610","line":"//"},
{"lineNum":"  611","line":"//      cout << printable_typename<my_foo_type_t>()"},
{"lineNum":"  612","line":"//"},
{"lineNum":"  613","line":"// to print out my_foo_type_t (or its concrete type if it is a synonym)"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"template <typename T>"},
{"lineNum":"  616","line":"struct printable_typename {};"},
{"lineNum":"  617","line":""},
{"lineNum":"  618","line":"template <typename T>"},
{"lineNum":"  619","line":"std::ostream& operator<<(std::ostream& out, printable_typename<T>) {"},
{"lineNum":"  620","line":"    const char *implementation_typename = typeid(T).name();"},
{"lineNum":"  621","line":"#ifdef __GNUC__"},
{"lineNum":"  622","line":"    int status;"},
{"lineNum":"  623","line":"    const char* pretty_name ="},
{"lineNum":"  624","line":"        abi::__cxa_demangle(implementation_typename, NULL, NULL, &status);"},
{"lineNum":"  625","line":"    if (status == 0)"},
{"lineNum":"  626","line":"        out << pretty_name;"},
{"lineNum":"  627","line":"    free((void*) pretty_name);"},
{"lineNum":"  628","line":"    if (status == 0)"},
{"lineNum":"  629","line":"        return out;"},
{"lineNum":"  630","line":"#endif"},
{"lineNum":"  631","line":"    out << implementation_typename;"},
{"lineNum":"  632","line":"    return out;"},
{"lineNum":"  633","line":"}"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"} // namespace pcg_extras"},
{"lineNum":"  636","line":""},
{"lineNum":"  637","line":"#endif // PCG_EXTRAS_HPP_INCLUDED"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
