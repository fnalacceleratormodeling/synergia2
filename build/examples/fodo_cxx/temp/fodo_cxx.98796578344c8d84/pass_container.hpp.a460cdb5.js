var data = {lines:[
{"lineNum":"    1","line":"/*============================================================================="},
{"lineNum":"    2","line":"    Copyright (c) 2001-2011 Joel de Guzman"},
{"lineNum":"    3","line":"    Copyright (c) 2001-2011 Hartmut Kaiser"},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"    Distributed under the Boost Software License, Version 1.0. (See accompanying"},
{"lineNum":"    6","line":"    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    7","line":"=============================================================================*/"},
{"lineNum":"    8","line":"#if !defined(SPIRIT_PASS_CONTAINER_JANUARY_06_2009_0802PM)"},
{"lineNum":"    9","line":"#define SPIRIT_PASS_CONTAINER_JANUARY_06_2009_0802PM"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#if defined(_MSC_VER)"},
{"lineNum":"   12","line":"#pragma once"},
{"lineNum":"   13","line":"#endif"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"#include <boost/spirit/home/qi/detail/attributes.hpp>"},
{"lineNum":"   16","line":"#include <boost/spirit/home/support/container.hpp>"},
{"lineNum":"   17","line":"#include <boost/spirit/home/support/handles_container.hpp>"},
{"lineNum":"   18","line":"#include <boost/type_traits/is_base_of.hpp>"},
{"lineNum":"   19","line":"#include <boost/type_traits/is_convertible.hpp>"},
{"lineNum":"   20","line":"#include <boost/mpl/bool.hpp>"},
{"lineNum":"   21","line":"#include <boost/mpl/and.hpp>"},
{"lineNum":"   22","line":"#include <boost/mpl/or.hpp>"},
{"lineNum":"   23","line":"#include <boost/preprocessor/cat.hpp>"},
{"lineNum":"   24","line":"#include <boost/preprocessor/repetition/repeat.hpp>"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"namespace boost { namespace spirit { namespace qi { namespace detail"},
{"lineNum":"   27","line":"{"},
{"lineNum":"   28","line":"    // Helper meta-function allowing to evaluate weak substitutability and"},
{"lineNum":"   29","line":"    // negate the result if the predicate (Sequence) is not true"},
{"lineNum":"   30","line":"    template <typename Sequence, typename Attribute, typename ValueType>"},
{"lineNum":"   31","line":"    struct negate_weak_substitute_if_not"},
{"lineNum":"   32","line":"      : mpl::if_<"},
{"lineNum":"   33","line":"            Sequence"},
{"lineNum":"   34","line":"          , typename traits::is_weak_substitute<Attribute, ValueType>::type"},
{"lineNum":"   35","line":"          , typename mpl::not_<"},
{"lineNum":"   36","line":"                traits::is_weak_substitute<Attribute, ValueType>"},
{"lineNum":"   37","line":"            >::type>"},
{"lineNum":"   38","line":"    {};"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"    // pass_through_container: utility to check decide whether a provided"},
{"lineNum":"   41","line":"    // container attribute needs to be passed through to the current component"},
{"lineNum":"   42","line":"    // or of we need to split the container by passing along instances of its"},
{"lineNum":"   43","line":"    // value type"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"    // if the expected attribute of the current component is neither a Fusion"},
{"lineNum":"   46","line":"    // sequence nor a container, we will pass through the provided container"},
{"lineNum":"   47","line":"    // only if its value type is not compatible with the component"},
{"lineNum":"   48","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"   49","line":"      , typename Sequence, typename Enable = void>"},
{"lineNum":"   50","line":"    struct pass_through_container_base"},
{"lineNum":"   51","line":"      : negate_weak_substitute_if_not<Sequence, Attribute, ValueType>"},
{"lineNum":"   52","line":"    {};"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"    // Specialization for fusion sequences, in this case we check whether all"},
{"lineNum":"   55","line":"    // the types in the sequence are convertible to the lhs attribute."},
{"lineNum":"   56","line":"    //"},
{"lineNum":"   57","line":"    // We return false if the rhs attribute itself is a fusion sequence, which"},
{"lineNum":"   58","line":"    // is compatible with the LHS sequence (we want to pass through this"},
{"lineNum":"   59","line":"    // attribute without it being split apart)."},
{"lineNum":"   60","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"   61","line":"      , typename Sequence = mpl::true_>"},
{"lineNum":"   62","line":"    struct not_compatible_element"},
{"lineNum":"   63","line":"      : mpl::and_<"},
{"lineNum":"   64","line":"            negate_weak_substitute_if_not<Sequence, Attribute, Container>"},
{"lineNum":"   65","line":"          , negate_weak_substitute_if_not<Sequence, Attribute, ValueType> >"},
{"lineNum":"   66","line":"    {};"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"    // If the value type of the container is not a Fusion sequence, we pass"},
{"lineNum":"   69","line":"    // through the container if each of the elements of the Attribute"},
{"lineNum":"   70","line":"    // sequence is compatible with either the container or its value type."},
{"lineNum":"   71","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"   72","line":"      , typename Sequence"},
{"lineNum":"   73","line":"      , bool IsSequence = fusion::traits::is_sequence<ValueType>::value>"},
{"lineNum":"   74","line":"    struct pass_through_container_fusion_sequence"},
{"lineNum":"   75","line":"    {"},
{"lineNum":"   76","line":"        typedef typename mpl::find_if<"},
{"lineNum":"   77","line":"            Attribute, not_compatible_element<Container, ValueType, mpl::_1>"},
{"lineNum":"   78","line":"        >::type iter;"},
{"lineNum":"   79","line":"        typedef typename mpl::end<Attribute>::type end;"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"        typedef typename is_same<iter, end>::type type;"},
{"lineNum":"   82","line":"    };"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"    // If both, the Attribute and the value type of the provided container"},
{"lineNum":"   85","line":"    // are Fusion sequences, we pass the container only if the two"},
{"lineNum":"   86","line":"    // sequences are not compatible."},
{"lineNum":"   87","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"   88","line":"      , typename Sequence>"},
{"lineNum":"   89","line":"    struct pass_through_container_fusion_sequence<"},
{"lineNum":"   90","line":"            Container, ValueType, Attribute, Sequence, true>"},
{"lineNum":"   91","line":"    {"},
{"lineNum":"   92","line":"        typedef typename mpl::find_if<"},
{"lineNum":"   93","line":"            Attribute"},
{"lineNum":"   94","line":"          , not_compatible_element<Container, ValueType, mpl::_1, Sequence>"},
{"lineNum":"   95","line":"        >::type iter;"},
{"lineNum":"   96","line":"        typedef typename mpl::end<Attribute>::type end;"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"        typedef typename is_same<iter, end>::type type;"},
{"lineNum":"   99","line":"    };"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  102","line":"      , typename Sequence>"},
{"lineNum":"  103","line":"    struct pass_through_container_base<Container, ValueType, Attribute"},
{"lineNum":"  104","line":"          , Sequence"},
{"lineNum":"  105","line":"          , typename enable_if<fusion::traits::is_sequence<Attribute> >::type>"},
{"lineNum":"  106","line":"      : pass_through_container_fusion_sequence<"},
{"lineNum":"  107","line":"            Container, ValueType, Attribute, Sequence>"},
{"lineNum":"  108","line":"    {};"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"    // Specialization for containers"},
{"lineNum":"  111","line":"    //"},
{"lineNum":"  112","line":"    // If the value type of the attribute of the current component is not"},
{"lineNum":"  113","line":"    // a Fusion sequence, we have to pass through the provided container if"},
{"lineNum":"  114","line":"    // both are compatible."},
{"lineNum":"  115","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  116","line":"      , typename Sequence, typename AttributeValueType"},
{"lineNum":"  117","line":"      , bool IsSequence = fusion::traits::is_sequence<AttributeValueType>::value>"},
{"lineNum":"  118","line":"    struct pass_through_container_container"},
{"lineNum":"  119","line":"      : mpl::or_<"},
{"lineNum":"  120","line":"            traits::is_weak_substitute<Attribute, Container>"},
{"lineNum":"  121","line":"          , traits::is_weak_substitute<AttributeValueType, Container> >"},
{"lineNum":"  122","line":"    {};"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"    // If the value type of the exposed container attribute is a Fusion"},
{"lineNum":"  125","line":"    // sequence, we use the already existing logic for those."},
{"lineNum":"  126","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  127","line":"      , typename Sequence, typename AttributeValueType>"},
{"lineNum":"  128","line":"    struct pass_through_container_container<"},
{"lineNum":"  129","line":"            Container, ValueType, Attribute, Sequence, AttributeValueType, true>"},
{"lineNum":"  130","line":"      : pass_through_container_fusion_sequence<"},
{"lineNum":"  131","line":"            Container, ValueType, AttributeValueType, Sequence>"},
{"lineNum":"  132","line":"    {};"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  135","line":"      , typename Sequence>"},
{"lineNum":"  136","line":"    struct pass_through_container_base<"},
{"lineNum":"  137","line":"            Container, ValueType, Attribute, Sequence"},
{"lineNum":"  138","line":"          , typename enable_if<traits::is_container<Attribute> >::type>"},
{"lineNum":"  139","line":"      : detail::pass_through_container_container<"},
{"lineNum":"  140","line":"            Container, ValueType, Attribute, Sequence"},
{"lineNum":"  141","line":"          , typename traits::container_value<Attribute>::type>"},
{"lineNum":"  142","line":"    {};"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"    // Specialization for exposed optional attributes"},
{"lineNum":"  145","line":"    //"},
{"lineNum":"  146","line":"    // If the type embedded in the exposed optional is not a Fusion"},
{"lineNum":"  147","line":"    // sequence we pass through the container attribute if it is compatible"},
{"lineNum":"  148","line":"    // either to the optionals embedded type or to the containers value"},
{"lineNum":"  149","line":"    // type."},
{"lineNum":"  150","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  151","line":"      , typename Sequence"},
{"lineNum":"  152","line":"      , bool IsSequence = fusion::traits::is_sequence<Attribute>::value>"},
{"lineNum":"  153","line":"    struct pass_through_container_optional"},
{"lineNum":"  154","line":"      : mpl::or_<"},
{"lineNum":"  155","line":"            traits::is_weak_substitute<Attribute, Container>"},
{"lineNum":"  156","line":"          , traits::is_weak_substitute<Attribute, ValueType> >"},
{"lineNum":"  157","line":"    {};"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    // If the embedded type of the exposed optional attribute is a Fusion"},
{"lineNum":"  160","line":"    // sequence, we use the already existing logic for those."},
{"lineNum":"  161","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  162","line":"      , typename Sequence>"},
{"lineNum":"  163","line":"    struct pass_through_container_optional<"},
{"lineNum":"  164","line":"                Container, ValueType, Attribute, Sequence, true>"},
{"lineNum":"  165","line":"      : pass_through_container_fusion_sequence<"},
{"lineNum":"  166","line":"            Container, ValueType, Attribute, Sequence>"},
{"lineNum":"  167","line":"    {};"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  170","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  171","line":"      , typename Sequence>"},
{"lineNum":"  172","line":"    struct pass_through_container"},
{"lineNum":"  173","line":"      : pass_through_container_base<Container, ValueType, Attribute, Sequence>"},
{"lineNum":"  174","line":"    {};"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    // Handle optional attributes"},
{"lineNum":"  177","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  178","line":"      , typename Sequence>"},
{"lineNum":"  179","line":"    struct pass_through_container<"},
{"lineNum":"  180","line":"                Container, ValueType, boost::optional<Attribute>, Sequence>"},
{"lineNum":"  181","line":"      : pass_through_container_optional<"},
{"lineNum":"  182","line":"            Container, ValueType, Attribute, Sequence>"},
{"lineNum":"  183","line":"    {};"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"    // If both, the containers value type and the exposed attribute type are"},
{"lineNum":"  186","line":"    // optionals we are allowed to pass through the container only if the"},
{"lineNum":"  187","line":"    // embedded types of those optionals are not compatible."},
{"lineNum":"  188","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  189","line":"      , typename Sequence>"},
{"lineNum":"  190","line":"    struct pass_through_container<"},
{"lineNum":"  191","line":"            Container, boost::optional<ValueType>, boost::optional<Attribute>"},
{"lineNum":"  192","line":"          , Sequence>"},
{"lineNum":"  193","line":"      : mpl::not_<traits::is_weak_substitute<Attribute, ValueType> >"},
{"lineNum":"  194","line":"    {};"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"    // Specialization for exposed variant attributes"},
{"lineNum":"  197","line":"    //"},
{"lineNum":"  198","line":"    // We pass through the container attribute if at least one of the embedded"},
{"lineNum":"  199","line":"    // types in the variant requires to pass through the attribute"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"#if !defined(BOOST_VARIANT_DO_NOT_USE_VARIADIC_TEMPLATES)"},
{"lineNum":"  202","line":"    template <typename Container, typename ValueType, typename Sequence"},
{"lineNum":"  203","line":"      , typename T>"},
{"lineNum":"  204","line":"    struct pass_through_container<Container, ValueType, boost::variant<T>"},
{"lineNum":"  205","line":"          , Sequence>"},
{"lineNum":"  206","line":"      : pass_through_container<Container, ValueType, T, Sequence>"},
{"lineNum":"  207","line":"    {};"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"    template <typename Container, typename ValueType, typename Sequence"},
{"lineNum":"  210","line":"      , typename T0, typename ...TN>"},
{"lineNum":"  211","line":"    struct pass_through_container<Container, ValueType"},
{"lineNum":"  212","line":"          , boost::variant<T0, TN...>, Sequence>"},
{"lineNum":"  213","line":"      : mpl::bool_<pass_through_container<"},
{"lineNum":"  214","line":"            Container, ValueType, T0, Sequence"},
{"lineNum":"  215","line":"            >::type::value || pass_through_container<"},
{"lineNum":"  216","line":"                Container, ValueType, boost::variant<TN...>, Sequence"},
{"lineNum":"  217","line":"            >::type::value>"},
{"lineNum":"  218","line":"    {};"},
{"lineNum":"  219","line":"#else"},
{"lineNum":"  220","line":"#define BOOST_SPIRIT_PASS_THROUGH_CONTAINER(z, N, _)                          \\"},
{"lineNum":"  221","line":"    pass_through_container<Container, ValueType,                              \\"},
{"lineNum":"  222","line":"        BOOST_PP_CAT(T, N), Sequence>::type::value ||                         \\"},
{"lineNum":"  223","line":"    /***/"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"    // make sure unused variant parameters do not affect the outcome"},
{"lineNum":"  226","line":"    template <typename Container, typename ValueType, typename Sequence>"},
{"lineNum":"  227","line":"    struct pass_through_container<Container, ValueType"},
{"lineNum":"  228","line":"          , boost::detail::variant::void_, Sequence>"},
{"lineNum":"  229","line":"      : mpl::false_"},
{"lineNum":"  230","line":"    {};"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"    template <typename Container, typename ValueType, typename Sequence"},
{"lineNum":"  233","line":"      , BOOST_VARIANT_ENUM_PARAMS(typename T)>"},
{"lineNum":"  234","line":"    struct pass_through_container<Container, ValueType"},
{"lineNum":"  235","line":"          , boost::variant<BOOST_VARIANT_ENUM_PARAMS(T)>, Sequence>"},
{"lineNum":"  236","line":"      : mpl::bool_<BOOST_PP_REPEAT(BOOST_VARIANT_LIMIT_TYPES"},
{"lineNum":"  237","line":"          , BOOST_SPIRIT_PASS_THROUGH_CONTAINER, _) false>"},
{"lineNum":"  238","line":"    {};"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"#undef BOOST_SPIRIT_PASS_THROUGH_CONTAINER"},
{"lineNum":"  241","line":"#endif"},
{"lineNum":"  242","line":"}}}}"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  245","line":"namespace boost { namespace spirit { namespace traits"},
{"lineNum":"  246","line":"{"},
{"lineNum":"  247","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  248","line":"    // forwarding customization point for domain qi::domain"},
{"lineNum":"  249","line":"    template <typename Container, typename ValueType, typename Attribute"},
{"lineNum":"  250","line":"      , typename Sequence>"},
{"lineNum":"  251","line":"    struct pass_through_container<"},
{"lineNum":"  252","line":"            Container, ValueType, Attribute, Sequence, qi::domain>"},
{"lineNum":"  253","line":"      : qi::detail::pass_through_container<"},
{"lineNum":"  254","line":"            Container, ValueType, Attribute, Sequence>"},
{"lineNum":"  255","line":"    {};"},
{"lineNum":"  256","line":"}}}"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"namespace boost { namespace spirit { namespace qi { namespace detail"},
{"lineNum":"  259","line":"{"},
{"lineNum":"  260","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  261","line":"    // This function handles the case where the attribute (Attr) given"},
{"lineNum":"  262","line":"    // the sequence is an STL container. This is a wrapper around F."},
{"lineNum":"  263","line":"    // The function F does the actual parsing."},
{"lineNum":"  264","line":"    template <typename F, typename Attr, typename Sequence>"},
{"lineNum":"  265","line":"    struct pass_container"},
{"lineNum":"  266","line":"    {"},
{"lineNum":"  267","line":"        typedef typename F::context_type context_type;"},
{"lineNum":"  268","line":"        typedef typename F::iterator_type iterator_type;"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"        pass_container(F const& f_, Attr& attr_)"},
{"lineNum":"  271","line":"          : f(f_), attr(attr_) {}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"        // this is for the case when the current element exposes an attribute"},
{"lineNum":"  274","line":"        // which is pushed back onto the container"},
{"lineNum":"  275","line":"        template <typename Component>"},
{"lineNum":"  276","line":"        bool dispatch_container(Component const& component, mpl::false_) const"},
{"lineNum":"  277","line":"        {"},
{"lineNum":"  278","line":"            // synthesized attribute needs to be default constructed"},
{"lineNum":"  279","line":"            typename traits::container_value<Attr>::type val ="},
{"lineNum":"  280","line":"                typename traits::container_value<Attr>::type();"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"            iterator_type save = f.first;"},
{"lineNum":"  283","line":"            bool r = f(component, val);"},
{"lineNum":"  284","line":"            if (!r)"},
{"lineNum":"  285","line":"            {"},
{"lineNum":"  286","line":"                // push the parsed value into our attribute"},
{"lineNum":"  287","line":"                r = !traits::push_back(attr, val);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  288","line":"                if (r)"},
{"lineNum":"  289","line":"                    f.first = save;"},
{"lineNum":"  290","line":"            }"},
{"lineNum":"  291","line":"            return r;"},
{"lineNum":"  292","line":"        }"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"        // this is for the case when the current element is able to handle an"},
{"lineNum":"  295","line":"        // attribute which is a container itself, this element will push its"},
{"lineNum":"  296","line":"        // data directly into the attribute container"},
{"lineNum":"  297","line":"        template <typename Component>"},
{"lineNum":"  298","line":"        bool dispatch_container(Component const& component, mpl::true_) const"},
{"lineNum":"  299","line":"        {"},
{"lineNum":"  300","line":"            return f(component, attr);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  301","line":"        }"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"        ///////////////////////////////////////////////////////////////////////"},
{"lineNum":"  304","line":"        // this is for the case when the current element doesn\'t expect an"},
{"lineNum":"  305","line":"        // attribute"},
{"lineNum":"  306","line":"        template <typename Component>"},
{"lineNum":"  307","line":"        bool dispatch_attribute(Component const& component, mpl::false_) const"},
{"lineNum":"  308","line":"        {"},
{"lineNum":"  309","line":"            return f(component, unused);","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  310","line":"        }"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"        // the current element expects an attribute"},
{"lineNum":"  313","line":"        template <typename Component>"},
{"lineNum":"  314","line":"        bool dispatch_attribute(Component const& component, mpl::true_) const"},
{"lineNum":"  315","line":"        {"},
{"lineNum":"  316","line":"            typedef typename traits::container_value<Attr>::type value_type;"},
{"lineNum":"  317","line":"            typedef typename traits::attribute_of<"},
{"lineNum":"  318","line":"                Component, context_type, iterator_type>::type"},
{"lineNum":"  319","line":"            rhs_attribute;"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"            // this predicate detects, whether the attribute of the current"},
{"lineNum":"  322","line":"            // element is a substitute for the value type of the container"},
{"lineNum":"  323","line":"            // attribute"},
{"lineNum":"  324","line":"            typedef mpl::and_<"},
{"lineNum":"  325","line":"                traits::handles_container<"},
{"lineNum":"  326","line":"                    Component, Attr, context_type, iterator_type>"},
{"lineNum":"  327","line":"              , traits::pass_through_container<"},
{"lineNum":"  328","line":"                    Attr, value_type, rhs_attribute, Sequence, qi::domain>"},
{"lineNum":"  329","line":"            > predicate;"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"            return dispatch_container(component, predicate());"},
{"lineNum":"  332","line":"        }"},
{"lineNum":"  333","line":""},
{"lineNum":"  334","line":"        // Dispatches to dispatch_main depending on the attribute type"},
{"lineNum":"  335","line":"        // of the Component"},
{"lineNum":"  336","line":"        template <typename Component>"},
{"lineNum":"  337","line":"        bool operator()(Component const& component) const"},
{"lineNum":"  338","line":"        {"},
{"lineNum":"  339","line":"            // we need to dispatch depending on the type of the attribute"},
{"lineNum":"  340","line":"            // of the current element (component). If this is has no attribute"},
{"lineNum":"  341","line":"            // we shouldn\'t pass an attribute at all."},
{"lineNum":"  342","line":"            typedef typename traits::not_is_unused<"},
{"lineNum":"  343","line":"                typename traits::attribute_of<"},
{"lineNum":"  344","line":"                    Component, context_type, iterator_type"},
{"lineNum":"  345","line":"                >::type"},
{"lineNum":"  346","line":"            >::type predicate;"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"            // ensure the attribute is actually a container type"},
{"lineNum":"  349","line":"            traits::make_container(attr);"},
{"lineNum":"  350","line":""},
{"lineNum":"  351","line":"            return dispatch_attribute(component, predicate());"},
{"lineNum":"  352","line":"        }"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"        F f;"},
{"lineNum":"  355","line":"        Attr& attr;"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"    private:"},
{"lineNum":"  358","line":"        // silence MSVC warning C4512: assignment operator could not be generated"},
{"lineNum":"  359","line":"        pass_container& operator= (pass_container const&);"},
{"lineNum":"  360","line":"    };"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  363","line":"    // Utility function to make a pass_container for container components"},
{"lineNum":"  364","line":"    // (kleene, list, plus, repeat)"},
{"lineNum":"  365","line":"    template <typename F, typename Attr>"},
{"lineNum":"  366","line":"    inline pass_container<F, Attr, mpl::false_>"},
{"lineNum":"  367","line":"    make_pass_container(F const& f, Attr& attr)"},
{"lineNum":"  368","line":"    {"},
{"lineNum":"  369","line":"        return pass_container<F, Attr, mpl::false_>(f, attr);"},
{"lineNum":"  370","line":"    }"},
{"lineNum":"  371","line":""},
{"lineNum":"  372","line":"    // Utility function to make a pass_container for sequences"},
{"lineNum":"  373","line":"    template <typename F, typename Attr>"},
{"lineNum":"  374","line":"    inline pass_container<F, Attr, mpl::true_>"},
{"lineNum":"  375","line":"    make_sequence_pass_container(F const& f, Attr& attr)"},
{"lineNum":"  376","line":"    {"},
{"lineNum":"  377","line":"        return pass_container<F, Attr, mpl::true_>(f, attr);"},
{"lineNum":"  378","line":"    }"},
{"lineNum":"  379","line":"}}}}"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"#endif"},
{"lineNum":"  382","line":""},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
