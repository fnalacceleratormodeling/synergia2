var data = {lines:[
{"lineNum":"    1","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"    2","line":"/// \\file matches.hpp"},
{"lineNum":"    3","line":"/// Contains definition of matches\\<\\> metafunction for determining if"},
{"lineNum":"    4","line":"/// a given expression matches a given pattern."},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"//  Copyright 2008 Eric Niebler. Distributed under the Boost"},
{"lineNum":"    7","line":"//  Software License, Version 1.0. (See accompanying file"},
{"lineNum":"    8","line":"//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef BOOST_PROTO_MATCHES_HPP_EAN_11_03_2006"},
{"lineNum":"   11","line":"#define BOOST_PROTO_MATCHES_HPP_EAN_11_03_2006"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include <boost/config.hpp>"},
{"lineNum":"   14","line":"#include <boost/detail/workaround.hpp>"},
{"lineNum":"   15","line":"#include <boost/preprocessor/cat.hpp>"},
{"lineNum":"   16","line":"#include <boost/preprocessor/arithmetic/dec.hpp>"},
{"lineNum":"   17","line":"#include <boost/preprocessor/arithmetic/sub.hpp>"},
{"lineNum":"   18","line":"#include <boost/preprocessor/iteration/iterate.hpp>"},
{"lineNum":"   19","line":"#include <boost/preprocessor/facilities/intercept.hpp>"},
{"lineNum":"   20","line":"#include <boost/preprocessor/punctuation/comma_if.hpp>"},
{"lineNum":"   21","line":"#include <boost/preprocessor/repetition/enum.hpp>"},
{"lineNum":"   22","line":"#include <boost/preprocessor/repetition/enum_params.hpp>"},
{"lineNum":"   23","line":"#include <boost/preprocessor/repetition/enum_shifted.hpp>"},
{"lineNum":"   24","line":"#include <boost/preprocessor/repetition/enum_binary_params.hpp>"},
{"lineNum":"   25","line":"#include <boost/preprocessor/repetition/enum_shifted_params.hpp>"},
{"lineNum":"   26","line":"#include <boost/preprocessor/repetition/enum_trailing_params.hpp>"},
{"lineNum":"   27","line":"#include <boost/preprocessor/repetition/enum_params_with_a_default.hpp>"},
{"lineNum":"   28","line":"#include <boost/preprocessor/repetition/repeat.hpp>"},
{"lineNum":"   29","line":"#include <boost/config.hpp>"},
{"lineNum":"   30","line":"#include <boost/mpl/logical.hpp>"},
{"lineNum":"   31","line":"#include <boost/mpl/eval_if.hpp>"},
{"lineNum":"   32","line":"#include <boost/proto/detail/template_arity.hpp>"},
{"lineNum":"   33","line":"#include <boost/utility/enable_if.hpp>"},
{"lineNum":"   34","line":"#if BOOST_WORKAROUND(BOOST_MSVC, == 1310)"},
{"lineNum":"   35","line":"#include <boost/type_traits/is_array.hpp>"},
{"lineNum":"   36","line":"#endif"},
{"lineNum":"   37","line":"#include <boost/type_traits/is_const.hpp>"},
{"lineNum":"   38","line":"#include <boost/type_traits/is_convertible.hpp>"},
{"lineNum":"   39","line":"#include <boost/type_traits/is_reference.hpp>"},
{"lineNum":"   40","line":"#include <boost/type_traits/is_pointer.hpp>"},
{"lineNum":"   41","line":"#include <boost/proto/proto_fwd.hpp>"},
{"lineNum":"   42","line":"#include <boost/proto/traits.hpp>"},
{"lineNum":"   43","line":"#include <boost/proto/transform/when.hpp>"},
{"lineNum":"   44","line":"#include <boost/proto/transform/impl.hpp>"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"#if defined(_MSC_VER)"},
{"lineNum":"   47","line":"# pragma warning(push)"},
{"lineNum":"   48","line":"# pragma warning(disable:4305) // \'specialization\' : truncation from \'const int\' to \'bool\'"},
{"lineNum":"   49","line":"#endif"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"#define BOOST_PROTO_LOGICAL_typename_G  BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, typename G)"},
{"lineNum":"   52","line":"#define BOOST_PROTO_LOGICAL_G           BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"namespace boost { namespace proto"},
{"lineNum":"   55","line":"{"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    namespace detail"},
{"lineNum":"   58","line":"    {"},
{"lineNum":"   59","line":"        template<typename Expr, typename BasicExpr, typename Grammar>"},
{"lineNum":"   60","line":"        struct matches_;"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"        template<bool B, typename Pred>"},
{"lineNum":"   63","line":"        struct and_2;"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"        template<typename And, typename Expr, typename State, typename Data>"},
{"lineNum":"   66","line":"        struct _and_impl;"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"        template<typename T, typename U>"},
{"lineNum":"   69","line":"        struct array_matches"},
{"lineNum":"   70","line":"          : mpl::false_"},
{"lineNum":"   71","line":"        {};"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"        template<typename T, std::size_t M>"},
{"lineNum":"   74","line":"        struct array_matches<T[M], T *>"},
{"lineNum":"   75","line":"          : mpl::true_"},
{"lineNum":"   76","line":"        {};"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"        template<typename T, std::size_t M>"},
{"lineNum":"   79","line":"        struct array_matches<T[M], T const *>"},
{"lineNum":"   80","line":"          : mpl::true_"},
{"lineNum":"   81","line":"        {};"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"        template<typename T, std::size_t M>"},
{"lineNum":"   84","line":"        struct array_matches<T[M], T[proto::N]>"},
{"lineNum":"   85","line":"          : mpl::true_"},
{"lineNum":"   86","line":"        {};"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"        template<typename T, typename U"},
{"lineNum":"   89","line":"            BOOST_PROTO_TEMPLATE_ARITY_PARAM(long Arity = detail::template_arity<U>::value)"},
{"lineNum":"   90","line":"        >"},
{"lineNum":"   91","line":"        struct lambda_matches"},
{"lineNum":"   92","line":"          : mpl::false_"},
{"lineNum":"   93","line":"        {};"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"        template<typename T>"},
{"lineNum":"   96","line":"        struct lambda_matches<T, proto::_ BOOST_PROTO_TEMPLATE_ARITY_PARAM(-1)>"},
{"lineNum":"   97","line":"          : mpl::true_"},
{"lineNum":"   98","line":"        {};"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"        template<typename T>"},
{"lineNum":"  101","line":"        struct lambda_matches<T, T BOOST_PROTO_TEMPLATE_ARITY_PARAM(-1)>"},
{"lineNum":"  102","line":"          : mpl::true_"},
{"lineNum":"  103","line":"        {};"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"        template<typename T, std::size_t M, typename U>"},
{"lineNum":"  106","line":"        struct lambda_matches<T[M], U BOOST_PROTO_TEMPLATE_ARITY_PARAM(-1)>"},
{"lineNum":"  107","line":"          : array_matches<T[M], U>"},
{"lineNum":"  108","line":"        {};"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"        template<typename T, std::size_t M>"},
{"lineNum":"  111","line":"        struct lambda_matches<T[M], _ BOOST_PROTO_TEMPLATE_ARITY_PARAM(-1)>"},
{"lineNum":"  112","line":"          : mpl::true_"},
{"lineNum":"  113","line":"        {};"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"        template<typename T, std::size_t M>"},
{"lineNum":"  116","line":"        struct lambda_matches<T[M], T[M] BOOST_PROTO_TEMPLATE_ARITY_PARAM(-1)>"},
{"lineNum":"  117","line":"          : mpl::true_"},
{"lineNum":"  118","line":"        {};"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"        template<template<typename> class T, typename Expr0, typename Grammar0>"},
{"lineNum":"  121","line":"        struct lambda_matches<T<Expr0>, T<Grammar0> BOOST_PROTO_TEMPLATE_ARITY_PARAM(1) >"},
{"lineNum":"  122","line":"          : lambda_matches<Expr0, Grammar0>"},
{"lineNum":"  123","line":"        {};"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"        // vararg_matches_impl"},
{"lineNum":"  126","line":"        template<typename Args1, typename Back, long From, long To>"},
{"lineNum":"  127","line":"        struct vararg_matches_impl;"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"        // vararg_matches"},
{"lineNum":"  130","line":"        template<typename Expr, typename Args1, typename Args2, typename Back, bool Can, bool Zero, typename Void = void>"},
{"lineNum":"  131","line":"        struct vararg_matches"},
{"lineNum":"  132","line":"          : mpl::false_"},
{"lineNum":"  133","line":"        {};"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"        template<typename Expr, typename Args1, typename Args2, typename Back>"},
{"lineNum":"  136","line":"        struct vararg_matches<Expr, Args1, Args2, Back, true, true, typename Back::proto_is_vararg_>"},
{"lineNum":"  137","line":"          : matches_<"},
{"lineNum":"  138","line":"                Expr"},
{"lineNum":"  139","line":"              , proto::basic_expr<ignore, Args1, Args1::arity>"},
{"lineNum":"  140","line":"              , proto::basic_expr<ignore, Args2, Args1::arity>"},
{"lineNum":"  141","line":"            >"},
{"lineNum":"  142","line":"        {};"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"        template<typename Expr, typename Args1, typename Args2, typename Back>"},
{"lineNum":"  145","line":"        struct vararg_matches<Expr, Args1, Args2, Back, true, false, typename Back::proto_is_vararg_>"},
{"lineNum":"  146","line":"          : and_2<"},
{"lineNum":"  147","line":"                matches_<"},
{"lineNum":"  148","line":"                    Expr"},
{"lineNum":"  149","line":"                  , proto::basic_expr<ignore, Args1, Args2::arity>"},
{"lineNum":"  150","line":"                  , proto::basic_expr<ignore, Args2, Args2::arity>"},
{"lineNum":"  151","line":"                >::value"},
{"lineNum":"  152","line":"              , vararg_matches_impl<Args1, typename Back::proto_grammar, Args2::arity + 1, Args1::arity>"},
{"lineNum":"  153","line":"            >"},
{"lineNum":"  154","line":"        {};"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"        // How terminal_matches<> handles references and cv-qualifiers."},
{"lineNum":"  157","line":"        // The cv and ref matter *only* if the grammar has a top-level ref."},
{"lineNum":"  158","line":"        //"},
{"lineNum":"  159","line":"        // Expr       |   Grammar    |  Matches?"},
{"lineNum":"  160","line":"        // -------------------------------------"},
{"lineNum":"  161","line":"        // T              T             yes"},
{"lineNum":"  162","line":"        // T &            T             yes"},
{"lineNum":"  163","line":"        // T const &      T             yes"},
{"lineNum":"  164","line":"        // T              T &           no"},
{"lineNum":"  165","line":"        // T &            T &           yes"},
{"lineNum":"  166","line":"        // T const &      T &           no"},
{"lineNum":"  167","line":"        // T              T const &     no"},
{"lineNum":"  168","line":"        // T &            T const &     no"},
{"lineNum":"  169","line":"        // T const &      T const &     yes"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"        template<typename T, typename U>"},
{"lineNum":"  172","line":"        struct is_cv_ref_compatible"},
{"lineNum":"  173","line":"          : mpl::true_"},
{"lineNum":"  174","line":"        {};"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"        template<typename T, typename U>"},
{"lineNum":"  177","line":"        struct is_cv_ref_compatible<T, U &>"},
{"lineNum":"  178","line":"          : mpl::false_"},
{"lineNum":"  179","line":"        {};"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"        template<typename T, typename U>"},
{"lineNum":"  182","line":"        struct is_cv_ref_compatible<T &, U &>"},
{"lineNum":"  183","line":"          : mpl::bool_<is_const<T>::value == is_const<U>::value>"},
{"lineNum":"  184","line":"        {};"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"    #if BOOST_WORKAROUND(BOOST_MSVC, == 1310)"},
{"lineNum":"  187","line":"        // MSVC-7.1 has lots of problems with array types that have been"},
{"lineNum":"  188","line":"        // deduced. Partially specializing terminal_matches<> on array types"},
{"lineNum":"  189","line":"        // doesn\'t seem to work."},
{"lineNum":"  190","line":"        template<"},
{"lineNum":"  191","line":"            typename T"},
{"lineNum":"  192","line":"          , typename U"},
{"lineNum":"  193","line":"          , bool B = is_array<BOOST_PROTO_UNCVREF(T)>::value"},
{"lineNum":"  194","line":"        >"},
{"lineNum":"  195","line":"        struct terminal_array_matches"},
{"lineNum":"  196","line":"          : mpl::false_"},
{"lineNum":"  197","line":"        {};"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"        template<typename T, typename U, std::size_t M>"},
{"lineNum":"  200","line":"        struct terminal_array_matches<T, U(&)[M], true>"},
{"lineNum":"  201","line":"          : is_convertible<T, U(&)[M]>"},
{"lineNum":"  202","line":"        {};"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"        template<typename T, typename U>"},
{"lineNum":"  205","line":"        struct terminal_array_matches<T, U(&)[proto::N], true>"},
{"lineNum":"  206","line":"          : is_convertible<T, U *>"},
{"lineNum":"  207","line":"        {};"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"        template<typename T, typename U>"},
{"lineNum":"  210","line":"        struct terminal_array_matches<T, U *, true>"},
{"lineNum":"  211","line":"          : is_convertible<T, U *>"},
{"lineNum":"  212","line":"        {};"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"        // terminal_matches"},
{"lineNum":"  215","line":"        template<typename T, typename U>"},
{"lineNum":"  216","line":"        struct terminal_matches"},
{"lineNum":"  217","line":"          : mpl::or_<"},
{"lineNum":"  218","line":"                mpl::and_<"},
{"lineNum":"  219","line":"                    is_cv_ref_compatible<T, U>"},
{"lineNum":"  220","line":"                  , lambda_matches<"},
{"lineNum":"  221","line":"                        BOOST_PROTO_UNCVREF(T)"},
{"lineNum":"  222","line":"                      , BOOST_PROTO_UNCVREF(U)"},
{"lineNum":"  223","line":"                    >"},
{"lineNum":"  224","line":"                >"},
{"lineNum":"  225","line":"              , terminal_array_matches<T, U>"},
{"lineNum":"  226","line":"            >"},
{"lineNum":"  227","line":"        {};"},
{"lineNum":"  228","line":"    #else"},
{"lineNum":"  229","line":"        // terminal_matches"},
{"lineNum":"  230","line":"        template<typename T, typename U>"},
{"lineNum":"  231","line":"        struct terminal_matches"},
{"lineNum":"  232","line":"          : mpl::and_<"},
{"lineNum":"  233","line":"                is_cv_ref_compatible<T, U>"},
{"lineNum":"  234","line":"              , lambda_matches<"},
{"lineNum":"  235","line":"                    BOOST_PROTO_UNCVREF(T)"},
{"lineNum":"  236","line":"                  , BOOST_PROTO_UNCVREF(U)"},
{"lineNum":"  237","line":"                >"},
{"lineNum":"  238","line":"            >"},
{"lineNum":"  239","line":"        {};"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"        template<typename T, std::size_t M>"},
{"lineNum":"  242","line":"        struct terminal_matches<T(&)[M], T(&)[proto::N]>"},
{"lineNum":"  243","line":"          : mpl::true_"},
{"lineNum":"  244","line":"        {};"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"        template<typename T, std::size_t M>"},
{"lineNum":"  247","line":"        struct terminal_matches<T(&)[M], T *>"},
{"lineNum":"  248","line":"          : mpl::true_"},
{"lineNum":"  249","line":"        {};"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"        // Avoid ambiguity errors on MSVC"},
{"lineNum":"  252","line":"        #if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1500))"},
{"lineNum":"  253","line":"        template<typename T, std::size_t M>"},
{"lineNum":"  254","line":"        struct terminal_matches<T const (&)[M], T const[M]>"},
{"lineNum":"  255","line":"          : mpl::true_"},
{"lineNum":"  256","line":"        {};"},
{"lineNum":"  257","line":"        #endif"},
{"lineNum":"  258","line":"    #endif"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"        template<typename T>"},
{"lineNum":"  261","line":"        struct terminal_matches<T, T>"},
{"lineNum":"  262","line":"          : mpl::true_"},
{"lineNum":"  263","line":"        {};"},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"        template<typename T>"},
{"lineNum":"  266","line":"        struct terminal_matches<T &, T>"},
{"lineNum":"  267","line":"          : mpl::true_"},
{"lineNum":"  268","line":"        {};"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"        template<typename T>"},
{"lineNum":"  271","line":"        struct terminal_matches<T const &, T>"},
{"lineNum":"  272","line":"          : mpl::true_"},
{"lineNum":"  273","line":"        {};"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"        template<typename T>"},
{"lineNum":"  276","line":"        struct terminal_matches<T, proto::_>"},
{"lineNum":"  277","line":"          : mpl::true_"},
{"lineNum":"  278","line":"        {};"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"        template<typename T>"},
{"lineNum":"  281","line":"        struct terminal_matches<T, exact<T> >"},
{"lineNum":"  282","line":"          : mpl::true_"},
{"lineNum":"  283","line":"        {};"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"        template<typename T, typename U>"},
{"lineNum":"  286","line":"        struct terminal_matches<T, proto::convertible_to<U> >"},
{"lineNum":"  287","line":"          : is_convertible<T, U>"},
{"lineNum":"  288","line":"        {};"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"        // matches_"},
{"lineNum":"  291","line":"        template<typename Expr, typename BasicExpr, typename Grammar>"},
{"lineNum":"  292","line":"        struct matches_"},
{"lineNum":"  293","line":"          : mpl::false_"},
{"lineNum":"  294","line":"        {};"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"        template<typename Expr, typename BasicExpr>"},
{"lineNum":"  297","line":"        struct matches_< Expr, BasicExpr, proto::_ >"},
{"lineNum":"  298","line":"          : mpl::true_"},
{"lineNum":"  299","line":"        {};"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"        template<typename Expr, typename Tag, typename Args1, long N1, typename Args2, long N2>"},
{"lineNum":"  302","line":"        struct matches_< Expr, proto::basic_expr<Tag, Args1, N1>, proto::basic_expr<Tag, Args2, N2> >"},
{"lineNum":"  303","line":"          : vararg_matches< Expr, Args1, Args2, typename Args2::back_, (N1+2 > N2), (N2 > N1) >"},
{"lineNum":"  304","line":"        {};"},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"        template<typename Expr, typename Tag, typename Args1, long N1, typename Args2, long N2>"},
{"lineNum":"  307","line":"        struct matches_< Expr, proto::basic_expr<Tag, Args1, N1>, proto::basic_expr<proto::_, Args2, N2> >"},
{"lineNum":"  308","line":"          : vararg_matches< Expr, Args1, Args2, typename Args2::back_, (N1+2 > N2), (N2 > N1) >"},
{"lineNum":"  309","line":"        {};"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"        template<typename Expr, typename Tag, typename Args1, typename Args2>"},
{"lineNum":"  312","line":"        struct matches_< Expr, proto::basic_expr<Tag, Args1, 0>, proto::basic_expr<Tag, Args2, 0> >"},
{"lineNum":"  313","line":"          : terminal_matches<typename Args1::child0, typename Args2::child0>"},
{"lineNum":"  314","line":"        {};"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"        template<typename Expr, typename Tag, typename Args1, typename Args2, long N2>"},
{"lineNum":"  317","line":"        struct matches_< Expr, proto::basic_expr<Tag, Args1, 0>, proto::basic_expr<proto::_, Args2, N2> >"},
{"lineNum":"  318","line":"          : mpl::false_"},
{"lineNum":"  319","line":"        {};"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"        template<typename Expr, typename Tag, typename Args1, typename Args2>"},
{"lineNum":"  322","line":"        struct matches_< Expr, proto::basic_expr<Tag, Args1, 0>, proto::basic_expr<proto::_, Args2, 0> >"},
{"lineNum":"  323","line":"          : terminal_matches<typename Args1::child0, typename Args2::child0>"},
{"lineNum":"  324","line":"        {};"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"        template<typename Expr, typename Tag, typename Args1, typename Args2>"},
{"lineNum":"  327","line":"        struct matches_< Expr, proto::basic_expr<Tag, Args1, 1>, proto::basic_expr<Tag, Args2, 1> >"},
{"lineNum":"  328","line":"          : matches_<"},
{"lineNum":"  329","line":"                typename detail::expr_traits<typename Args1::child0>::value_type::proto_derived_expr"},
{"lineNum":"  330","line":"              , typename detail::expr_traits<typename Args1::child0>::value_type::proto_grammar"},
{"lineNum":"  331","line":"              , typename Args2::child0::proto_grammar"},
{"lineNum":"  332","line":"            >"},
{"lineNum":"  333","line":"        {};"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"        template<typename Expr, typename Tag, typename Args1, typename Args2>"},
{"lineNum":"  336","line":"        struct matches_< Expr, proto::basic_expr<Tag, Args1, 1>, proto::basic_expr<proto::_, Args2, 1> >"},
{"lineNum":"  337","line":"          : matches_<"},
{"lineNum":"  338","line":"                typename detail::expr_traits<typename Args1::child0>::value_type::proto_derived_expr"},
{"lineNum":"  339","line":"              , typename detail::expr_traits<typename Args1::child0>::value_type::proto_grammar"},
{"lineNum":"  340","line":"              , typename Args2::child0::proto_grammar"},
{"lineNum":"  341","line":"            >"},
{"lineNum":"  342","line":"        {};"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"        #include <boost/proto/detail/and_n.hpp>"},
{"lineNum":"  345","line":"        #include <boost/proto/detail/or_n.hpp>"},
{"lineNum":"  346","line":"        #include <boost/proto/detail/matches_.hpp>"},
{"lineNum":"  347","line":"        #include <boost/proto/detail/vararg_matches_impl.hpp>"},
{"lineNum":"  348","line":"        #include <boost/proto/detail/lambda_matches.hpp>"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"        // handle proto::if_"},
{"lineNum":"  351","line":"        template<typename Expr, typename Tag, typename Args, long Arity, typename If, typename Then, typename Else>"},
{"lineNum":"  352","line":"        struct matches_<Expr, proto::basic_expr<Tag, Args, Arity>, proto::if_<If, Then, Else> >"},
{"lineNum":"  353","line":"          : mpl::eval_if_c<"},
{"lineNum":"  354","line":"                static_cast<bool>("},
{"lineNum":"  355","line":"                    remove_reference<"},
{"lineNum":"  356","line":"                        typename when<_, If>::template impl<Expr, int, int>::result_type"},
{"lineNum":"  357","line":"                    >::type::value"},
{"lineNum":"  358","line":"                )"},
{"lineNum":"  359","line":"              , matches_<Expr, proto::basic_expr<Tag, Args, Arity>, typename Then::proto_grammar>"},
{"lineNum":"  360","line":"              , matches_<Expr, proto::basic_expr<Tag, Args, Arity>, typename Else::proto_grammar>"},
{"lineNum":"  361","line":"            >::type"},
{"lineNum":"  362","line":"        {"},
{"lineNum":"  363","line":"            typedef"},
{"lineNum":"  364","line":"                typename mpl::if_c<"},
{"lineNum":"  365","line":"                    static_cast<bool>("},
{"lineNum":"  366","line":"                        remove_reference<"},
{"lineNum":"  367","line":"                            typename when<_, If>::template impl<Expr, int, int>::result_type"},
{"lineNum":"  368","line":"                        >::type::value"},
{"lineNum":"  369","line":"                    )"},
{"lineNum":"  370","line":"                  , Then"},
{"lineNum":"  371","line":"                  , Else"},
{"lineNum":"  372","line":"                >::type"},
{"lineNum":"  373","line":"            which;"},
{"lineNum":"  374","line":"        };"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"        // handle degenerate cases of proto::or_"},
{"lineNum":"  377","line":"        template<typename Expr, typename BasicExpr>"},
{"lineNum":"  378","line":"        struct matches_<Expr, BasicExpr, or_<> >"},
{"lineNum":"  379","line":"          : mpl::false_"},
{"lineNum":"  380","line":"        {"},
{"lineNum":"  381","line":"            typedef not_<_> which;"},
{"lineNum":"  382","line":"        };"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"        template<typename Expr, typename BasicExpr, typename G0>"},
{"lineNum":"  385","line":"        struct matches_<Expr, BasicExpr, or_<G0> >"},
{"lineNum":"  386","line":"          : matches_<Expr, BasicExpr, typename G0::proto_grammar>"},
{"lineNum":"  387","line":"        {"},
{"lineNum":"  388","line":"            typedef G0 which;"},
{"lineNum":"  389","line":"        };"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"        // handle degenerate cases of proto::and_"},
{"lineNum":"  392","line":"        template<typename Expr, typename BasicExpr>"},
{"lineNum":"  393","line":"        struct matches_<Expr, BasicExpr, and_<> >"},
{"lineNum":"  394","line":"          : mpl::true_"},
{"lineNum":"  395","line":"        {};"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"        template<typename Expr, typename BasicExpr, typename G0>"},
{"lineNum":"  398","line":"        struct matches_<Expr, BasicExpr, and_<G0> >"},
{"lineNum":"  399","line":"          : matches_<Expr, BasicExpr, typename G0::proto_grammar>"},
{"lineNum":"  400","line":"        {};"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"        // handle proto::not_"},
{"lineNum":"  403","line":"        template<typename Expr, typename BasicExpr, typename Grammar>"},
{"lineNum":"  404","line":"        struct matches_<Expr, BasicExpr, not_<Grammar> >"},
{"lineNum":"  405","line":"          : mpl::not_<matches_<Expr, BasicExpr, typename Grammar::proto_grammar> >"},
{"lineNum":"  406","line":"        {};"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"        // handle proto::switch_"},
{"lineNum":"  409","line":"        template<typename Expr, typename Tag, typename Args, long Arity, typename Cases, typename Transform>"},
{"lineNum":"  410","line":"        struct matches_<Expr, proto::basic_expr<Tag, Args, Arity>, switch_<Cases, Transform> >"},
{"lineNum":"  411","line":"          : matches_<"},
{"lineNum":"  412","line":"                Expr"},
{"lineNum":"  413","line":"              , proto::basic_expr<Tag, Args, Arity>"},
{"lineNum":"  414","line":"              , typename Cases::template case_<"},
{"lineNum":"  415","line":"                    typename when<_,Transform>::template impl<Expr,int,int>::result_type"},
{"lineNum":"  416","line":"                >::proto_grammar"},
{"lineNum":"  417","line":"            >"},
{"lineNum":"  418","line":"        {"},
{"lineNum":"  419","line":"            typedef"},
{"lineNum":"  420","line":"                typename Cases::template case_<"},
{"lineNum":"  421","line":"                    typename when<_, Transform>::template impl<Expr, int, int>::result_type"},
{"lineNum":"  422","line":"                >"},
{"lineNum":"  423","line":"            which;"},
{"lineNum":"  424","line":"        };"},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"        // handle proto::switch_ with the default Transform for specially for better compile times"},
{"lineNum":"  427","line":"        template<typename Expr, typename Tag, typename Args, long Arity, typename Cases>"},
{"lineNum":"  428","line":"        struct matches_<Expr, proto::basic_expr<Tag, Args, Arity>, switch_<Cases> >"},
{"lineNum":"  429","line":"          : matches_<"},
{"lineNum":"  430","line":"                Expr"},
{"lineNum":"  431","line":"              , proto::basic_expr<Tag, Args, Arity>"},
{"lineNum":"  432","line":"              , typename Cases::template case_<Tag>::proto_grammar"},
{"lineNum":"  433","line":"            >"},
{"lineNum":"  434","line":"        {"},
{"lineNum":"  435","line":"            typedef typename Cases::template case_<Tag> which;"},
{"lineNum":"  436","line":"        };"},
{"lineNum":"  437","line":"    }"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"    /// \\brief A Boolean metafunction that evaluates whether a given"},
{"lineNum":"  440","line":"    /// expression type matches a grammar."},
{"lineNum":"  441","line":"    ///"},
{"lineNum":"  442","line":"    /// <tt>matches\\<Expr,Grammar\\></tt> inherits (indirectly) from"},
{"lineNum":"  443","line":"    /// \\c mpl::true_ if <tt>Expr::proto_grammar</tt> matches"},
{"lineNum":"  444","line":"    /// <tt>Grammar::proto_grammar</tt>, and from \\c mpl::false_"},
{"lineNum":"  445","line":"    /// otherwise."},
{"lineNum":"  446","line":"    ///"},
{"lineNum":"  447","line":"    /// Non-terminal expressions are matched against a grammar"},
{"lineNum":"  448","line":"    /// according to the following rules:"},
{"lineNum":"  449","line":"    ///"},
{"lineNum":"  450","line":"    /// \\li The wildcard pattern, \\c _, matches any expression."},
{"lineNum":"  451","line":"    /// \\li An expression <tt>expr\\<AT, listN\\<A0,A1,...An\\> \\></tt>"},
{"lineNum":"  452","line":"    ///     matches a grammar <tt>expr\\<BT, listN\\<B0,B1,...Bn\\> \\></tt>"},
{"lineNum":"  453","line":"    ///     if \\c BT is \\c _ or \\c AT, and if \\c Ax matches \\c Bx for"},
{"lineNum":"  454","line":"    ///     each \\c x in <tt>[0,n)</tt>."},
{"lineNum":"  455","line":"    /// \\li An expression <tt>expr\\<AT, listN\\<A0,...An,U0,...Um\\> \\></tt>"},
{"lineNum":"  456","line":"    ///     matches a grammar <tt>expr\\<BT, listM\\<B0,...Bn,vararg\\<V\\> \\> \\></tt>"},
{"lineNum":"  457","line":"    ///     if \\c BT is \\c _ or \\c AT, and if \\c Ax matches \\c Bx"},
{"lineNum":"  458","line":"    ///     for each \\c x in <tt>[0,n)</tt> and if \\c Ux matches \\c V"},
{"lineNum":"  459","line":"    ///     for each \\c x in <tt>[0,m)</tt>."},
{"lineNum":"  460","line":"    /// \\li An expression \\c E matches <tt>or_\\<B0,B1,...Bn\\></tt> if \\c E"},
{"lineNum":"  461","line":"    ///     matches some \\c Bx for \\c x in <tt>[0,n)</tt>."},
{"lineNum":"  462","line":"    /// \\li An expression \\c E matches <tt>and_\\<B0,B1,...Bn\\></tt> if \\c E"},
{"lineNum":"  463","line":"    ///     matches all \\c Bx for \\c x in <tt>[0,n)</tt>."},
{"lineNum":"  464","line":"    /// \\li An expression \\c E matches <tt>if_\\<T,U,V\\></tt> if"},
{"lineNum":"  465","line":"    ///     <tt>boost::result_of\\<when\\<_,T\\>(E,int,int)\\>::type::value</tt>"},
{"lineNum":"  466","line":"    ///     is \\c true and \\c E matches \\c U; or, if"},
{"lineNum":"  467","line":"    ///     <tt>boost::result_of\\<when\\<_,T\\>(E,int,int)\\>::type::value</tt>"},
{"lineNum":"  468","line":"    ///     is \\c false and \\c E matches \\c V. (Note: \\c U defaults to \\c _"},
{"lineNum":"  469","line":"    ///     and \\c V defaults to \\c not_\\<_\\>.)"},
{"lineNum":"  470","line":"    /// \\li An expression \\c E matches <tt>not_\\<T\\></tt> if \\c E does"},
{"lineNum":"  471","line":"    ///     not match \\c T."},
{"lineNum":"  472","line":"    /// \\li An expression \\c E matches <tt>switch_\\<C,T\\></tt> if"},
{"lineNum":"  473","line":"    ///     \\c E matches <tt>C::case_\\<boost::result_of\\<T(E)\\>::type\\></tt>."},
{"lineNum":"  474","line":"    ///     (Note: T defaults to <tt>tag_of\\<_\\>()</tt>.)"},
{"lineNum":"  475","line":"    ///"},
{"lineNum":"  476","line":"    /// A terminal expression <tt>expr\\<AT,term\\<A\\> \\></tt> matches"},
{"lineNum":"  477","line":"    /// a grammar <tt>expr\\<BT,term\\<B\\> \\></tt> if \\c BT is \\c AT or"},
{"lineNum":"  478","line":"    /// \\c proto::_ and if one of the following is true:"},
{"lineNum":"  479","line":"    ///"},
{"lineNum":"  480","line":"    /// \\li \\c B is the wildcard pattern, \\c _"},
{"lineNum":"  481","line":"    /// \\li \\c A is \\c B"},
{"lineNum":"  482","line":"    /// \\li \\c A is <tt>B &</tt>"},
{"lineNum":"  483","line":"    /// \\li \\c A is <tt>B const &</tt>"},
{"lineNum":"  484","line":"    /// \\li \\c B is <tt>exact\\<A\\></tt>"},
{"lineNum":"  485","line":"    /// \\li \\c B is <tt>convertible_to\\<X\\></tt> and"},
{"lineNum":"  486","line":"    ///     <tt>is_convertible\\<A,X\\>::value</tt> is \\c true."},
{"lineNum":"  487","line":"    /// \\li \\c A is <tt>X[M]</tt> or <tt>X(&)[M]</tt> and"},
{"lineNum":"  488","line":"    ///     \\c B is <tt>X[proto::N]</tt>."},
{"lineNum":"  489","line":"    /// \\li \\c A is <tt>X(&)[M]</tt> and \\c B is <tt>X(&)[proto::N]</tt>."},
{"lineNum":"  490","line":"    /// \\li \\c A is <tt>X[M]</tt> or <tt>X(&)[M]</tt> and"},
{"lineNum":"  491","line":"    ///     \\c B is <tt>X*</tt>."},
{"lineNum":"  492","line":"    /// \\li \\c B lambda-matches \\c A (see below)."},
{"lineNum":"  493","line":"    ///"},
{"lineNum":"  494","line":"    /// A type \\c B lambda-matches \\c A if one of the following is true:"},
{"lineNum":"  495","line":"    ///"},
{"lineNum":"  496","line":"    /// \\li \\c B is \\c A"},
{"lineNum":"  497","line":"    /// \\li \\c B is the wildcard pattern, \\c _"},
{"lineNum":"  498","line":"    /// \\li \\c B is <tt>T\\<B0,B1,...Bn\\></tt> and \\c A is"},
{"lineNum":"  499","line":"    ///     <tt>T\\<A0,A1,...An\\></tt> and for each \\c x in"},
{"lineNum":"  500","line":"    ///     <tt>[0,n)</tt>, \\c Ax and \\c Bx are types"},
{"lineNum":"  501","line":"    ///     such that \\c Ax lambda-matches \\c Bx"},
{"lineNum":"  502","line":"    template<typename Expr, typename Grammar>"},
{"lineNum":"  503","line":"    struct matches"},
{"lineNum":"  504","line":"      : detail::matches_<"},
{"lineNum":"  505","line":"            typename Expr::proto_derived_expr"},
{"lineNum":"  506","line":"          , typename Expr::proto_grammar"},
{"lineNum":"  507","line":"          , typename Grammar::proto_grammar"},
{"lineNum":"  508","line":"        >"},
{"lineNum":"  509","line":"    {};"},
{"lineNum":"  510","line":""},
{"lineNum":"  511","line":"    /// INTERNAL ONLY"},
{"lineNum":"  512","line":"    ///"},
{"lineNum":"  513","line":"    template<typename Expr, typename Grammar>"},
{"lineNum":"  514","line":"    struct matches<Expr &, Grammar>"},
{"lineNum":"  515","line":"      : detail::matches_<"},
{"lineNum":"  516","line":"            typename Expr::proto_derived_expr"},
{"lineNum":"  517","line":"          , typename Expr::proto_grammar"},
{"lineNum":"  518","line":"          , typename Grammar::proto_grammar"},
{"lineNum":"  519","line":"        >"},
{"lineNum":"  520","line":"    {};"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"    /// \\brief A wildcard grammar element that matches any expression,"},
{"lineNum":"  523","line":"    /// and a transform that returns the current expression unchanged."},
{"lineNum":"  524","line":"    ///"},
{"lineNum":"  525","line":"    /// The wildcard type, \\c _, is a grammar element such that"},
{"lineNum":"  526","line":"    /// <tt>matches\\<E,_\\>::value</tt> is \\c true for any expression"},
{"lineNum":"  527","line":"    /// type \\c E."},
{"lineNum":"  528","line":"    ///"},
{"lineNum":"  529","line":"    /// The wildcard can also be used as a stand-in for a template"},
{"lineNum":"  530","line":"    /// argument when matching terminals. For instance, the following"},
{"lineNum":"  531","line":"    /// is a grammar that will match any <tt>std::complex\\<\\></tt>"},
{"lineNum":"  532","line":"    /// terminal:"},
{"lineNum":"  533","line":"    ///"},
{"lineNum":"  534","line":"    /// \\code"},
{"lineNum":"  535","line":"    /// BOOST_MPL_ASSERT(("},
{"lineNum":"  536","line":"    ///     matches<"},
{"lineNum":"  537","line":"    ///         terminal<std::complex<double> >::type"},
{"lineNum":"  538","line":"    ///       , terminal<std::complex< _ > >"},
{"lineNum":"  539","line":"    ///     >"},
{"lineNum":"  540","line":"    /// ));"},
{"lineNum":"  541","line":"    /// \\endcode"},
{"lineNum":"  542","line":"    ///"},
{"lineNum":"  543","line":"    /// When used as a transform, \\c _ returns the current expression"},
{"lineNum":"  544","line":"    /// unchanged. For instance, in the following, \\c _ is used with"},
{"lineNum":"  545","line":"    /// the \\c fold\\<\\> transform to fold the children of a node:"},
{"lineNum":"  546","line":"    ///"},
{"lineNum":"  547","line":"    /// \\code"},
{"lineNum":"  548","line":"    /// struct CountChildren"},
{"lineNum":"  549","line":"    ///   : or_<"},
{"lineNum":"  550","line":"    ///         // Terminals have no children"},
{"lineNum":"  551","line":"    ///         when<terminal<_>, mpl::int_<0>()>"},
{"lineNum":"  552","line":"    ///         // Use fold<> to count the children of non-terminals"},
{"lineNum":"  553","line":"    ///       , otherwise<"},
{"lineNum":"  554","line":"    ///             fold<"},
{"lineNum":"  555","line":"    ///                 _ // <-- fold the current expression"},
{"lineNum":"  556","line":"    ///               , mpl::int_<0>()"},
{"lineNum":"  557","line":"    ///               , mpl::plus<_state, mpl::int_<1> >()"},
{"lineNum":"  558","line":"    ///             >"},
{"lineNum":"  559","line":"    ///         >"},
{"lineNum":"  560","line":"    ///     >"},
{"lineNum":"  561","line":"    /// {};"},
{"lineNum":"  562","line":"    /// \\endcode"},
{"lineNum":"  563","line":"    struct _ : transform<_>"},
{"lineNum":"  564","line":"    {"},
{"lineNum":"  565","line":"        typedef _ proto_grammar;"},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  568","line":"        struct impl : transform_impl<Expr, State, Data>"},
{"lineNum":"  569","line":"        {"},
{"lineNum":"  570","line":"            typedef Expr result_type;"},
{"lineNum":"  571","line":""},
{"lineNum":"  572","line":"            /// \\param expr An expression"},
{"lineNum":"  573","line":"            /// \\return \\c e"},
{"lineNum":"  574","line":"            BOOST_PROTO_RETURN_TYPE_STRICT_LOOSE(result_type, typename impl::expr_param)"},
{"lineNum":"  575","line":"            operator()("},
{"lineNum":"  576","line":"                typename impl::expr_param e"},
{"lineNum":"  577","line":"              , typename impl::state_param"},
{"lineNum":"  578","line":"              , typename impl::data_param"},
{"lineNum":"  579","line":"            ) const"},
{"lineNum":"  580","line":"            {"},
{"lineNum":"  581","line":"                return e;"},
{"lineNum":"  582","line":"            }"},
{"lineNum":"  583","line":"        };"},
{"lineNum":"  584","line":"    };"},
{"lineNum":"  585","line":""},
{"lineNum":"  586","line":"    namespace detail"},
{"lineNum":"  587","line":"    {"},
{"lineNum":"  588","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  589","line":"        struct _and_impl<proto::and_<>, Expr, State, Data>"},
{"lineNum":"  590","line":"          : proto::_::impl<Expr, State, Data>"},
{"lineNum":"  591","line":"        {};"},
{"lineNum":"  592","line":""},
{"lineNum":"  593","line":"        template<typename G0, typename Expr, typename State, typename Data>"},
{"lineNum":"  594","line":"        struct _and_impl<proto::and_<G0>, Expr, State, Data>"},
{"lineNum":"  595","line":"          : proto::when<proto::_, G0>::template impl<Expr, State, Data>"},
{"lineNum":"  596","line":"        {};"},
{"lineNum":"  597","line":"    }"},
{"lineNum":"  598","line":""},
{"lineNum":"  599","line":"    /// \\brief Inverts the set of expressions matched by a grammar. When"},
{"lineNum":"  600","line":"    /// used as a transform, \\c not_\\<\\> returns the current expression"},
{"lineNum":"  601","line":"    /// unchanged."},
{"lineNum":"  602","line":"    ///"},
{"lineNum":"  603","line":"    /// If an expression type \\c E does not match a grammar \\c G, then"},
{"lineNum":"  604","line":"    /// \\c E \\e does match <tt>not_\\<G\\></tt>. For example,"},
{"lineNum":"  605","line":"    /// <tt>not_\\<terminal\\<_\\> \\></tt> will match any non-terminal."},
{"lineNum":"  606","line":"    template<typename Grammar>"},
{"lineNum":"  607","line":"    struct not_ : transform<not_<Grammar> >"},
{"lineNum":"  608","line":"    {"},
{"lineNum":"  609","line":"        typedef not_ proto_grammar;"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  612","line":"        struct impl : transform_impl<Expr, State, Data>"},
{"lineNum":"  613","line":"        {"},
{"lineNum":"  614","line":"            typedef Expr result_type;"},
{"lineNum":"  615","line":""},
{"lineNum":"  616","line":"            /// \\param e An expression"},
{"lineNum":"  617","line":"            /// \\pre <tt>matches\\<Expr,not_\\>::value</tt> is \\c true."},
{"lineNum":"  618","line":"            /// \\return \\c e"},
{"lineNum":"  619","line":"            BOOST_PROTO_RETURN_TYPE_STRICT_LOOSE(result_type, typename impl::expr_param)"},
{"lineNum":"  620","line":"            operator()("},
{"lineNum":"  621","line":"                typename impl::expr_param e"},
{"lineNum":"  622","line":"              , typename impl::state_param"},
{"lineNum":"  623","line":"              , typename impl::data_param"},
{"lineNum":"  624","line":"            ) const"},
{"lineNum":"  625","line":"            {"},
{"lineNum":"  626","line":"                return e;"},
{"lineNum":"  627","line":"            }"},
{"lineNum":"  628","line":"        };"},
{"lineNum":"  629","line":"    };"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"    /// \\brief Used to select one grammar or another based on the result"},
{"lineNum":"  632","line":"    /// of a compile-time Boolean. When used as a transform, \\c if_\\<\\>"},
{"lineNum":"  633","line":"    /// selects between two transforms based on a compile-time Boolean."},
{"lineNum":"  634","line":"    ///"},
{"lineNum":"  635","line":"    /// When <tt>if_\\<If,Then,Else\\></tt> is used as a grammar, \\c If"},
{"lineNum":"  636","line":"    /// must be a Proto transform and \\c Then and \\c Else must be grammars."},
{"lineNum":"  637","line":"    /// An expression type \\c E matches <tt>if_\\<If,Then,Else\\></tt> if"},
{"lineNum":"  638","line":"    /// <tt>boost::result_of\\<when\\<_,If\\>(E,int,int)\\>::type::value</tt>"},
{"lineNum":"  639","line":"    /// is \\c true and \\c E matches \\c U; or, if"},
{"lineNum":"  640","line":"    /// <tt>boost::result_of\\<when\\<_,If\\>(E,int,int)\\>::type::value</tt>"},
{"lineNum":"  641","line":"    /// is \\c false and \\c E matches \\c V."},
{"lineNum":"  642","line":"    ///"},
{"lineNum":"  643","line":"    /// The template parameter \\c Then defaults to \\c _"},
{"lineNum":"  644","line":"    /// and \\c Else defaults to \\c not\\<_\\>, so an expression type \\c E"},
{"lineNum":"  645","line":"    /// will match <tt>if_\\<If\\></tt> if and only if"},
{"lineNum":"  646","line":"    /// <tt>boost::result_of\\<when\\<_,If\\>(E,int,int)\\>::type::value</tt>"},
{"lineNum":"  647","line":"    /// is \\c true."},
{"lineNum":"  648","line":"    ///"},
{"lineNum":"  649","line":"    /// \\code"},
{"lineNum":"  650","line":"    /// // A grammar that only matches integral terminals,"},
{"lineNum":"  651","line":"    /// // using is_integral<> from Boost.Type_traits."},
{"lineNum":"  652","line":"    /// struct IsIntegral"},
{"lineNum":"  653","line":"    ///   : and_<"},
{"lineNum":"  654","line":"    ///         terminal<_>"},
{"lineNum":"  655","line":"    ///       , if_< is_integral<_value>() >"},
{"lineNum":"  656","line":"    ///     >"},
{"lineNum":"  657","line":"    /// {};"},
{"lineNum":"  658","line":"    /// \\endcode"},
{"lineNum":"  659","line":"    ///"},
{"lineNum":"  660","line":"    /// When <tt>if_\\<If,Then,Else\\></tt> is used as a transform, \\c If,"},
{"lineNum":"  661","line":"    /// \\c Then and \\c Else must be Proto transforms. When applying"},
{"lineNum":"  662","line":"    /// the transform to an expression \\c E, state \\c S and data \\c V,"},
{"lineNum":"  663","line":"    /// if <tt>boost::result_of\\<when\\<_,If\\>(E,S,V)\\>::type::value</tt>"},
{"lineNum":"  664","line":"    /// is \\c true then the \\c Then transform is applied; otherwise"},
{"lineNum":"  665","line":"    /// the \\c Else transform is applied."},
{"lineNum":"  666","line":"    ///"},
{"lineNum":"  667","line":"    /// \\code"},
{"lineNum":"  668","line":"    /// // Match a terminal. If the terminal is integral, return"},
{"lineNum":"  669","line":"    /// // mpl::true_; otherwise, return mpl::false_."},
{"lineNum":"  670","line":"    /// struct IsIntegral2"},
{"lineNum":"  671","line":"    ///   : when<"},
{"lineNum":"  672","line":"    ///         terminal<_>"},
{"lineNum":"  673","line":"    ///       , if_<"},
{"lineNum":"  674","line":"    ///             is_integral<_value>()"},
{"lineNum":"  675","line":"    ///           , mpl::true_()"},
{"lineNum":"  676","line":"    ///           , mpl::false_()"},
{"lineNum":"  677","line":"    ///         >"},
{"lineNum":"  678","line":"    ///     >"},
{"lineNum":"  679","line":"    /// {};"},
{"lineNum":"  680","line":"    /// \\endcode"},
{"lineNum":"  681","line":"    template<"},
{"lineNum":"  682","line":"        typename If"},
{"lineNum":"  683","line":"      , typename Then   // = _"},
{"lineNum":"  684","line":"      , typename Else   // = not_<_>"},
{"lineNum":"  685","line":"    >"},
{"lineNum":"  686","line":"    struct if_ : transform<if_<If, Then, Else> >"},
{"lineNum":"  687","line":"    {"},
{"lineNum":"  688","line":"        typedef if_ proto_grammar;"},
{"lineNum":"  689","line":""},
{"lineNum":"  690","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  691","line":"        struct impl : transform_impl<Expr, State, Data>"},
{"lineNum":"  692","line":"        {"},
{"lineNum":"  693","line":"            typedef"},
{"lineNum":"  694","line":"                typename when<_, If>::template impl<Expr, State, Data>::result_type"},
{"lineNum":"  695","line":"            condition;"},
{"lineNum":"  696","line":""},
{"lineNum":"  697","line":"            typedef"},
{"lineNum":"  698","line":"                typename mpl::if_c<"},
{"lineNum":"  699","line":"                    static_cast<bool>(remove_reference<condition>::type::value)"},
{"lineNum":"  700","line":"                  , when<_, Then>"},
{"lineNum":"  701","line":"                  , when<_, Else>"},
{"lineNum":"  702","line":"                >::type"},
{"lineNum":"  703","line":"            which;"},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"            typedef typename which::template impl<Expr, State, Data>::result_type result_type;"},
{"lineNum":"  706","line":""},
{"lineNum":"  707","line":"            /// \\param e An expression"},
{"lineNum":"  708","line":"            /// \\param s The current state"},
{"lineNum":"  709","line":"            /// \\param d A data of arbitrary type"},
{"lineNum":"  710","line":"            /// \\return <tt>which::impl<Expr, State, Data>()(e, s, d)</tt>"},
{"lineNum":"  711","line":"            result_type operator ()("},
{"lineNum":"  712","line":"                typename impl::expr_param e"},
{"lineNum":"  713","line":"              , typename impl::state_param s"},
{"lineNum":"  714","line":"              , typename impl::data_param d"},
{"lineNum":"  715","line":"            ) const"},
{"lineNum":"  716","line":"            {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  717","line":"                return typename which::template impl<Expr, State, Data>()(e, s, d);","class":"lineNoCov","hits":"0","possible_hits":"38",},
{"lineNum":"  718","line":"            }"},
{"lineNum":"  719","line":"        };"},
{"lineNum":"  720","line":"    };"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"    /// \\brief For matching one of a set of alternate grammars. Alternates"},
{"lineNum":"  723","line":"    /// tried in order to avoid ambiguity. When used as a transform, \\c or_\\<\\>"},
{"lineNum":"  724","line":"    /// applies the transform associated with the first grammar that matches"},
{"lineNum":"  725","line":"    /// the expression."},
{"lineNum":"  726","line":"    ///"},
{"lineNum":"  727","line":"    /// An expression type \\c E matches <tt>or_\\<B0,B1,...Bn\\></tt> if \\c E"},
{"lineNum":"  728","line":"    /// matches any \\c Bx for \\c x in <tt>[0,n)</tt>."},
{"lineNum":"  729","line":"    ///"},
{"lineNum":"  730","line":"    /// When applying <tt>or_\\<B0,B1,...Bn\\></tt> as a transform with an"},
{"lineNum":"  731","line":"    /// expression \\c e of type \\c E, state \\c s and data \\c d, it is"},
{"lineNum":"  732","line":"    /// equivalent to <tt>Bx()(e, s, d)</tt>, where \\c x is the lowest"},
{"lineNum":"  733","line":"    /// number such that <tt>matches\\<E,Bx\\>::value</tt> is \\c true."},
{"lineNum":"  734","line":"    template<BOOST_PROTO_LOGICAL_typename_G>"},
{"lineNum":"  735","line":"    struct or_ : transform<or_<BOOST_PROTO_LOGICAL_G> >"},
{"lineNum":"  736","line":"    {"},
{"lineNum":"  737","line":"        typedef or_ proto_grammar;"},
{"lineNum":"  738","line":""},
{"lineNum":"  739","line":"        /// \\param e An expression"},
{"lineNum":"  740","line":"        /// \\param s The current state"},
{"lineNum":"  741","line":"        /// \\param d A data of arbitrary type"},
{"lineNum":"  742","line":"        /// \\pre <tt>matches\\<Expr,or_\\>::value</tt> is \\c true."},
{"lineNum":"  743","line":"        /// \\return <tt>which()(e, s, d)</tt>, where <tt>which</tt> is the"},
{"lineNum":"  744","line":"        /// sub-grammar that matched <tt>Expr</tt>."},
{"lineNum":"  745","line":""},
{"lineNum":"  746","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  747","line":"        struct impl"},
{"lineNum":"  748","line":"          : detail::matches_<"},
{"lineNum":"  749","line":"                typename Expr::proto_derived_expr"},
{"lineNum":"  750","line":"              , typename Expr::proto_grammar"},
{"lineNum":"  751","line":"              , or_"},
{"lineNum":"  752","line":"            >::which::template impl<Expr, State, Data>"},
{"lineNum":"  753","line":"        {};"},
{"lineNum":"  754","line":""},
{"lineNum":"  755","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  756","line":"        struct impl<Expr &, State, Data>"},
{"lineNum":"  757","line":"          : detail::matches_<"},
{"lineNum":"  758","line":"                typename Expr::proto_derived_expr"},
{"lineNum":"  759","line":"              , typename Expr::proto_grammar"},
{"lineNum":"  760","line":"              , or_"},
{"lineNum":"  761","line":"            >::which::template impl<Expr &, State, Data>"},
{"lineNum":"  762","line":"        {};"},
{"lineNum":"  763","line":"    };"},
{"lineNum":"  764","line":""},
{"lineNum":"  765","line":"    /// \\brief For matching all of a set of grammars. When used as a"},
{"lineNum":"  766","line":"    /// transform, \\c and_\\<\\> applies the transforms associated with"},
{"lineNum":"  767","line":"    /// the each grammar in the set, and returns the result of the last."},
{"lineNum":"  768","line":"    ///"},
{"lineNum":"  769","line":"    /// An expression type \\c E matches <tt>and_\\<B0,B1,...Bn\\></tt> if \\c E"},
{"lineNum":"  770","line":"    /// matches all \\c Bx for \\c x in <tt>[0,n)</tt>."},
{"lineNum":"  771","line":"    ///"},
{"lineNum":"  772","line":"    /// When applying <tt>and_\\<B0,B1,...Bn\\></tt> as a transform with an"},
{"lineNum":"  773","line":"    /// expression \\c e, state \\c s and data \\c d, it is"},
{"lineNum":"  774","line":"    /// equivalent to <tt>(B0()(e, s, d),B1()(e, s, d),...Bn()(e, s, d))</tt>."},
{"lineNum":"  775","line":"    template<BOOST_PROTO_LOGICAL_typename_G>"},
{"lineNum":"  776","line":"    struct and_ : transform<and_<BOOST_PROTO_LOGICAL_G> >"},
{"lineNum":"  777","line":"    {"},
{"lineNum":"  778","line":"        typedef and_ proto_grammar;"},
{"lineNum":"  779","line":""},
{"lineNum":"  780","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  781","line":"        struct impl"},
{"lineNum":"  782","line":"          : detail::_and_impl<and_, Expr, State, Data>"},
{"lineNum":"  783","line":"        {};"},
{"lineNum":"  784","line":"    };"},
{"lineNum":"  785","line":""},
{"lineNum":"  786","line":"    /// \\brief For matching one of a set of alternate grammars, which"},
{"lineNum":"  787","line":"    /// are looked up based on some property of an expression. The"},
{"lineNum":"  788","line":"    /// property on which to dispatch is specified by the \\c Transform"},
{"lineNum":"  789","line":"    /// template parameter, which defaults to <tt>tag_of\\<_\\>()</tt>."},
{"lineNum":"  790","line":"    /// That is, when the \\c Trannsform is not specified, the alternate"},
{"lineNum":"  791","line":"    /// grammar is looked up using the tag type of the current expression."},
{"lineNum":"  792","line":"    ///"},
{"lineNum":"  793","line":"    /// When used as a transform, \\c switch_\\<\\> applies the transform"},
{"lineNum":"  794","line":"    /// associated with the grammar that matches the expression."},
{"lineNum":"  795","line":"    ///"},
{"lineNum":"  796","line":"    /// \\note \\c switch_\\<\\> is functionally identical to \\c or_\\<\\> but"},
{"lineNum":"  797","line":"    /// is often more efficient. It does a fast, O(1) lookup using the"},
{"lineNum":"  798","line":"    /// result of the specified transform to find a sub-grammar that may"},
{"lineNum":"  799","line":"    /// potentially match the expression."},
{"lineNum":"  800","line":"    ///"},
{"lineNum":"  801","line":"    /// An expression type \\c E matches <tt>switch_\\<C,T\\></tt> if \\c E"},
{"lineNum":"  802","line":"    /// matches <tt>C::case_\\<boost::result_of\\<T(E)\\>::type\\></tt>."},
{"lineNum":"  803","line":"    ///"},
{"lineNum":"  804","line":"    /// When applying <tt>switch_\\<C,T\\></tt> as a transform with an"},
{"lineNum":"  805","line":"    /// expression \\c e of type \\c E, state \\c s of type \\S and data"},
{"lineNum":"  806","line":"    /// \\c d of type \\c D, it is equivalent to"},
{"lineNum":"  807","line":"    /// <tt>C::case_\\<boost::result_of\\<T(E,S,D)\\>::type\\>()(e, s, d)</tt>."},
{"lineNum":"  808","line":"    template<typename Cases, typename Transform>"},
{"lineNum":"  809","line":"    struct switch_ : transform<switch_<Cases, Transform> >"},
{"lineNum":"  810","line":"    {"},
{"lineNum":"  811","line":"        typedef switch_ proto_grammar;"},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  814","line":"        struct impl"},
{"lineNum":"  815","line":"          : Cases::template case_<"},
{"lineNum":"  816","line":"                typename when<_, Transform>::template impl<Expr, State, Data>::result_type"},
{"lineNum":"  817","line":"            >::template impl<Expr, State, Data>"},
{"lineNum":"  818","line":"        {};"},
{"lineNum":"  819","line":"    };"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"    /// INTERNAL ONLY (This is merely a compile-time optimization for the common case)"},
{"lineNum":"  822","line":"    ///"},
{"lineNum":"  823","line":"    template<typename Cases>"},
{"lineNum":"  824","line":"    struct switch_<Cases> : transform<switch_<Cases> >"},
{"lineNum":"  825","line":"    {"},
{"lineNum":"  826","line":"        typedef switch_ proto_grammar;"},
{"lineNum":"  827","line":""},
{"lineNum":"  828","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  829","line":"        struct impl"},
{"lineNum":"  830","line":"          : Cases::template case_<typename Expr::proto_tag>::template impl<Expr, State, Data>"},
{"lineNum":"  831","line":"        {};"},
{"lineNum":"  832","line":""},
{"lineNum":"  833","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  834","line":"        struct impl<Expr &, State, Data>"},
{"lineNum":"  835","line":"          : Cases::template case_<typename Expr::proto_tag>::template impl<Expr &, State, Data>"},
{"lineNum":"  836","line":"        {};"},
{"lineNum":"  837","line":"    };"},
{"lineNum":"  838","line":""},
{"lineNum":"  839","line":"    /// \\brief For forcing exact matches of terminal types."},
{"lineNum":"  840","line":"    ///"},
{"lineNum":"  841","line":"    /// By default, matching terminals ignores references and"},
{"lineNum":"  842","line":"    /// cv-qualifiers. For instance, a terminal expression of"},
{"lineNum":"  843","line":"    /// type <tt>terminal\\<int const &\\>::type</tt> will match"},
{"lineNum":"  844","line":"    /// the grammar <tt>terminal\\<int\\></tt>. If that is not"},
{"lineNum":"  845","line":"    /// desired, you can force an exact match with"},
{"lineNum":"  846","line":"    /// <tt>terminal\\<exact\\<int\\> \\></tt>. This will only"},
{"lineNum":"  847","line":"    /// match integer terminals where the terminal is held by"},
{"lineNum":"  848","line":"    /// value."},
{"lineNum":"  849","line":"    template<typename T>"},
{"lineNum":"  850","line":"    struct exact"},
{"lineNum":"  851","line":"    {};"},
{"lineNum":"  852","line":""},
{"lineNum":"  853","line":"    /// \\brief For matching terminals that are convertible to"},
{"lineNum":"  854","line":"    /// a type."},
{"lineNum":"  855","line":"    ///"},
{"lineNum":"  856","line":"    /// Use \\c convertible_to\\<\\> to match a terminal that is"},
{"lineNum":"  857","line":"    /// convertible to some type. For example, the grammar"},
{"lineNum":"  858","line":"    /// <tt>terminal\\<convertible_to\\<int\\> \\></tt> will match"},
{"lineNum":"  859","line":"    /// any terminal whose argument is convertible to an integer."},
{"lineNum":"  860","line":"    ///"},
{"lineNum":"  861","line":"    /// \\note The trait \\c is_convertible\\<\\> from Boost.Type_traits"},
{"lineNum":"  862","line":"    /// is used to determinal convertibility."},
{"lineNum":"  863","line":"    template<typename T>"},
{"lineNum":"  864","line":"    struct convertible_to"},
{"lineNum":"  865","line":"    {};"},
{"lineNum":"  866","line":""},
{"lineNum":"  867","line":"    /// \\brief For matching a Grammar to a variable number of"},
{"lineNum":"  868","line":"    /// sub-expressions."},
{"lineNum":"  869","line":"    ///"},
{"lineNum":"  870","line":"    /// An expression type <tt>expr\\<AT, listN\\<A0,...An,U0,...Um\\> \\></tt>"},
{"lineNum":"  871","line":"    /// matches a grammar <tt>expr\\<BT, listM\\<B0,...Bn,vararg\\<V\\> \\> \\></tt>"},
{"lineNum":"  872","line":"    /// if \\c BT is \\c _ or \\c AT, and if \\c Ax matches \\c Bx"},
{"lineNum":"  873","line":"    /// for each \\c x in <tt>[0,n)</tt> and if \\c Ux matches \\c V"},
{"lineNum":"  874","line":"    /// for each \\c x in <tt>[0,m)</tt>."},
{"lineNum":"  875","line":"    ///"},
{"lineNum":"  876","line":"    /// For example:"},
{"lineNum":"  877","line":"    ///"},
{"lineNum":"  878","line":"    /// \\code"},
{"lineNum":"  879","line":"    /// // Match any function call expression, irregardless"},
{"lineNum":"  880","line":"    /// // of the number of function arguments:"},
{"lineNum":"  881","line":"    /// struct Function"},
{"lineNum":"  882","line":"    ///   : function< vararg<_> >"},
{"lineNum":"  883","line":"    /// {};"},
{"lineNum":"  884","line":"    /// \\endcode"},
{"lineNum":"  885","line":"    ///"},
{"lineNum":"  886","line":"    /// When used as a transform, <tt>vararg\\<G\\></tt> applies"},
{"lineNum":"  887","line":"    /// <tt>G</tt>\'s transform."},
{"lineNum":"  888","line":"    template<typename Grammar>"},
{"lineNum":"  889","line":"    struct vararg"},
{"lineNum":"  890","line":"      : Grammar"},
{"lineNum":"  891","line":"    {"},
{"lineNum":"  892","line":"        /// INTERNAL ONLY"},
{"lineNum":"  893","line":"        typedef void proto_is_vararg_;"},
{"lineNum":"  894","line":"    };"},
{"lineNum":"  895","line":""},
{"lineNum":"  896","line":"    /// INTERNAL ONLY"},
{"lineNum":"  897","line":"    ///"},
{"lineNum":"  898","line":"    template<BOOST_PROTO_LOGICAL_typename_G>"},
{"lineNum":"  899","line":"    struct is_callable<or_<BOOST_PROTO_LOGICAL_G> >"},
{"lineNum":"  900","line":"      : mpl::true_"},
{"lineNum":"  901","line":"    {};"},
{"lineNum":"  902","line":""},
{"lineNum":"  903","line":"    /// INTERNAL ONLY"},
{"lineNum":"  904","line":"    ///"},
{"lineNum":"  905","line":"    template<BOOST_PROTO_LOGICAL_typename_G>"},
{"lineNum":"  906","line":"    struct is_callable<and_<BOOST_PROTO_LOGICAL_G> >"},
{"lineNum":"  907","line":"      : mpl::true_"},
{"lineNum":"  908","line":"    {};"},
{"lineNum":"  909","line":""},
{"lineNum":"  910","line":"    /// INTERNAL ONLY"},
{"lineNum":"  911","line":"    ///"},
{"lineNum":"  912","line":"    template<typename Grammar>"},
{"lineNum":"  913","line":"    struct is_callable<not_<Grammar> >"},
{"lineNum":"  914","line":"      : mpl::true_"},
{"lineNum":"  915","line":"    {};"},
{"lineNum":"  916","line":""},
{"lineNum":"  917","line":"    /// INTERNAL ONLY"},
{"lineNum":"  918","line":"    ///"},
{"lineNum":"  919","line":"    template<typename If, typename Then, typename Else>"},
{"lineNum":"  920","line":"    struct is_callable<if_<If, Then, Else> >"},
{"lineNum":"  921","line":"      : mpl::true_"},
{"lineNum":"  922","line":"    {};"},
{"lineNum":"  923","line":""},
{"lineNum":"  924","line":"    /// INTERNAL ONLY"},
{"lineNum":"  925","line":"    ///"},
{"lineNum":"  926","line":"    template<typename Grammar>"},
{"lineNum":"  927","line":"    struct is_callable<vararg<Grammar> >"},
{"lineNum":"  928","line":"      : mpl::true_"},
{"lineNum":"  929","line":"    {};"},
{"lineNum":"  930","line":""},
{"lineNum":"  931","line":"    /// INTERNAL ONLY"},
{"lineNum":"  932","line":"    ///"},
{"lineNum":"  933","line":"    template<typename Cases, typename Transform>"},
{"lineNum":"  934","line":"    struct is_callable<switch_<Cases, Transform> >"},
{"lineNum":"  935","line":"      : mpl::true_"},
{"lineNum":"  936","line":"    {};"},
{"lineNum":"  937","line":""},
{"lineNum":"  938","line":"}}"},
{"lineNum":"  939","line":""},
{"lineNum":"  940","line":"#undef BOOST_PROTO_LOGICAL_typename_G"},
{"lineNum":"  941","line":"#undef BOOST_PROTO_LOGICAL_G"},
{"lineNum":"  942","line":""},
{"lineNum":"  943","line":"#if defined(_MSC_VER)"},
{"lineNum":"  944","line":"# pragma warning(pop)"},
{"lineNum":"  945","line":"#endif"},
{"lineNum":"  946","line":""},
{"lineNum":"  947","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
