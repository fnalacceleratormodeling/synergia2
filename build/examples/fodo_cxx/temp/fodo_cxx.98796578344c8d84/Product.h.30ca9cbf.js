var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2011 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_PRODUCT_H"},
{"lineNum":"   11","line":"#define EIGEN_PRODUCT_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"template<typename Lhs, typename Rhs, int Option, typename StorageKind> class ProductImpl;"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"namespace internal {"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"template<typename Lhs, typename Rhs, int Option>"},
{"lineNum":"   22","line":"struct traits<Product<Lhs, Rhs, Option> >"},
{"lineNum":"   23","line":"{"},
{"lineNum":"   24","line":"  typedef typename remove_all<Lhs>::type LhsCleaned;"},
{"lineNum":"   25","line":"  typedef typename remove_all<Rhs>::type RhsCleaned;"},
{"lineNum":"   26","line":"  typedef traits<LhsCleaned> LhsTraits;"},
{"lineNum":"   27","line":"  typedef traits<RhsCleaned> RhsTraits;"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"  typedef MatrixXpr XprKind;"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"  typedef typename ScalarBinaryOpTraits<typename traits<LhsCleaned>::Scalar, typename traits<RhsCleaned>::Scalar>::ReturnType Scalar;"},
{"lineNum":"   32","line":"  typedef typename product_promote_storage_type<typename LhsTraits::StorageKind,"},
{"lineNum":"   33","line":"                                                typename RhsTraits::StorageKind,"},
{"lineNum":"   34","line":"                                                internal::product_type<Lhs,Rhs>::ret>::ret StorageKind;"},
{"lineNum":"   35","line":"  typedef typename promote_index_type<typename LhsTraits::StorageIndex,"},
{"lineNum":"   36","line":"                                      typename RhsTraits::StorageIndex>::type StorageIndex;"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"  enum {"},
{"lineNum":"   39","line":"    RowsAtCompileTime    = LhsTraits::RowsAtCompileTime,"},
{"lineNum":"   40","line":"    ColsAtCompileTime    = RhsTraits::ColsAtCompileTime,"},
{"lineNum":"   41","line":"    MaxRowsAtCompileTime = LhsTraits::MaxRowsAtCompileTime,"},
{"lineNum":"   42","line":"    MaxColsAtCompileTime = RhsTraits::MaxColsAtCompileTime,"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"    // FIXME: only needed by GeneralMatrixMatrixTriangular"},
{"lineNum":"   45","line":"    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(LhsTraits::ColsAtCompileTime, RhsTraits::RowsAtCompileTime),"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"    // The storage order is somewhat arbitrary here. The correct one will be determined through the evaluator."},
{"lineNum":"   48","line":"    Flags = (MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1) ? RowMajorBit"},
{"lineNum":"   49","line":"          : (MaxColsAtCompileTime==1 && MaxRowsAtCompileTime!=1) ? 0"},
{"lineNum":"   50","line":"          : (   ((LhsTraits::Flags&NoPreferredStorageOrderBit) && (RhsTraits::Flags&RowMajorBit))"},
{"lineNum":"   51","line":"             || ((RhsTraits::Flags&NoPreferredStorageOrderBit) && (LhsTraits::Flags&RowMajorBit)) ) ? RowMajorBit"},
{"lineNum":"   52","line":"          : NoPreferredStorageOrderBit"},
{"lineNum":"   53","line":"  };"},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"} // end namespace internal"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"/** \\class Product"},
{"lineNum":"   59","line":"  * \\ingroup Core_Module"},
{"lineNum":"   60","line":"  *"},
{"lineNum":"   61","line":"  * \\brief Expression of the product of two arbitrary matrices or vectors"},
{"lineNum":"   62","line":"  *"},
{"lineNum":"   63","line":"  * \\tparam Lhs_ the type of the left-hand side expression"},
{"lineNum":"   64","line":"  * \\tparam Rhs_ the type of the right-hand side expression"},
{"lineNum":"   65","line":"  *"},
{"lineNum":"   66","line":"  * This class represents an expression of the product of two arbitrary matrices."},
{"lineNum":"   67","line":"  *"},
{"lineNum":"   68","line":"  * The other template parameters are:"},
{"lineNum":"   69","line":"  * \\tparam Option     can be DefaultProduct, AliasFreeProduct, or LazyProduct"},
{"lineNum":"   70","line":"  *"},
{"lineNum":"   71","line":"  */"},
{"lineNum":"   72","line":"template<typename Lhs_, typename Rhs_, int Option>"},
{"lineNum":"   73","line":"class Product : public ProductImpl<Lhs_,Rhs_,Option,"},
{"lineNum":"   74","line":"                                   typename internal::product_promote_storage_type<typename internal::traits<Lhs_>::StorageKind,"},
{"lineNum":"   75","line":"                                                                                   typename internal::traits<Rhs_>::StorageKind,"},
{"lineNum":"   76","line":"                                                                                   internal::product_type<Lhs_,Rhs_>::ret>::ret>"},
{"lineNum":"   77","line":"{"},
{"lineNum":"   78","line":"  public:"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"    typedef Lhs_ Lhs;"},
{"lineNum":"   81","line":"    typedef Rhs_ Rhs;"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"    typedef typename ProductImpl<"},
{"lineNum":"   84","line":"        Lhs, Rhs, Option,"},
{"lineNum":"   85","line":"        typename internal::product_promote_storage_type<typename internal::traits<Lhs>::StorageKind,"},
{"lineNum":"   86","line":"                                                        typename internal::traits<Rhs>::StorageKind,"},
{"lineNum":"   87","line":"                                                        internal::product_type<Lhs,Rhs>::ret>::ret>::Base Base;"},
{"lineNum":"   88","line":"    EIGEN_GENERIC_PUBLIC_INTERFACE(Product)"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"    typedef typename internal::ref_selector<Lhs>::type LhsNested;"},
{"lineNum":"   91","line":"    typedef typename internal::ref_selector<Rhs>::type RhsNested;"},
{"lineNum":"   92","line":"    typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;"},
{"lineNum":"   93","line":"    typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"   96","line":"    Product(const Lhs& lhs, const Rhs& rhs) : m_lhs(lhs), m_rhs(rhs)","class":"lineNoCov","hits":"0","possible_hits":"32",},
{"lineNum":"   97","line":"    {"},
{"lineNum":"   98","line":"      eigen_assert(lhs.cols() == rhs.rows()"},
{"lineNum":"   99","line":"        && \"invalid matrix product\""},
{"lineNum":"  100","line":"        && \"if you wanted a coeff-wise or a dot product use the respective explicit functions\");"},
{"lineNum":"  101","line":"    }"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  104","line":"    Index rows() const EIGEN_NOEXCEPT { return m_lhs.rows(); }","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  105","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"  106","line":"    Index cols() const EIGEN_NOEXCEPT { return m_rhs.cols(); }","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  109","line":"    const LhsNestedCleaned& lhs() const { return m_lhs; }","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  110","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  111","line":"    const RhsNestedCleaned& rhs() const { return m_rhs; }","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"  protected:"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    LhsNested m_lhs;"},
{"lineNum":"  116","line":"    RhsNested m_rhs;"},
{"lineNum":"  117","line":"};"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"namespace internal {"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"template<typename Lhs, typename Rhs, int Option, int ProductTag = internal::product_type<Lhs,Rhs>::ret>"},
{"lineNum":"  122","line":"class dense_product_base"},
{"lineNum":"  123","line":" : public internal::dense_xpr_base<Product<Lhs,Rhs,Option> >::type"},
{"lineNum":"  124","line":"{};"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"/** Conversion to scalar for inner-products */"},
{"lineNum":"  127","line":"template<typename Lhs, typename Rhs, int Option>"},
{"lineNum":"  128","line":"class dense_product_base<Lhs, Rhs, Option, InnerProduct>"},
{"lineNum":"  129","line":" : public internal::dense_xpr_base<Product<Lhs,Rhs,Option> >::type"},
{"lineNum":"  130","line":"{"},
{"lineNum":"  131","line":"  typedef Product<Lhs,Rhs,Option> ProductXpr;"},
{"lineNum":"  132","line":"  typedef typename internal::dense_xpr_base<ProductXpr>::type Base;"},
{"lineNum":"  133","line":"public:"},
{"lineNum":"  134","line":"  using Base::derived;"},
{"lineNum":"  135","line":"  typedef typename Base::Scalar Scalar;"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE operator const Scalar() const"},
{"lineNum":"  138","line":"  {"},
{"lineNum":"  139","line":"    return internal::evaluator<ProductXpr>(derived()).coeff(0,0);"},
{"lineNum":"  140","line":"  }"},
{"lineNum":"  141","line":"};"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"} // namespace internal"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"// Generic API dispatcher"},
{"lineNum":"  146","line":"template<typename Lhs, typename Rhs, int Option, typename StorageKind>"},
{"lineNum":"  147","line":"class ProductImpl : public internal::generic_xpr_base<Product<Lhs,Rhs,Option>, MatrixXpr, StorageKind>::type"},
{"lineNum":"  148","line":"{"},
{"lineNum":"  149","line":"  public:"},
{"lineNum":"  150","line":"    typedef typename internal::generic_xpr_base<Product<Lhs,Rhs,Option>, MatrixXpr, StorageKind>::type Base;"},
{"lineNum":"  151","line":"};"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"template<typename Lhs, typename Rhs, int Option>"},
{"lineNum":"  154","line":"class ProductImpl<Lhs,Rhs,Option,Dense>"},
{"lineNum":"  155","line":"  : public internal::dense_product_base<Lhs,Rhs,Option>"},
{"lineNum":"  156","line":"{"},
{"lineNum":"  157","line":"    typedef Product<Lhs, Rhs, Option> Derived;"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"  public:"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"    typedef typename internal::dense_product_base<Lhs, Rhs, Option> Base;"},
{"lineNum":"  162","line":"    EIGEN_DENSE_PUBLIC_INTERFACE(Derived)"},
{"lineNum":"  163","line":"  protected:"},
{"lineNum":"  164","line":"    enum {"},
{"lineNum":"  165","line":"      IsOneByOne = (RowsAtCompileTime == 1 || RowsAtCompileTime == Dynamic) &&"},
{"lineNum":"  166","line":"                   (ColsAtCompileTime == 1 || ColsAtCompileTime == Dynamic),"},
{"lineNum":"  167","line":"      EnableCoeff = IsOneByOne || Option==LazyProduct"},
{"lineNum":"  168","line":"    };"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"  public:"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar coeff(Index row, Index col) const"},
{"lineNum":"  173","line":"    {"},
{"lineNum":"  174","line":"      EIGEN_STATIC_ASSERT(EnableCoeff, THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS);"},
{"lineNum":"  175","line":"      eigen_assert( (Option==LazyProduct) || (this->rows() == 1 && this->cols() == 1) );"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"      return internal::evaluator<Derived>(derived()).coeff(row,col);"},
{"lineNum":"  178","line":"    }"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE Scalar coeff(Index i) const"},
{"lineNum":"  181","line":"    {"},
{"lineNum":"  182","line":"      EIGEN_STATIC_ASSERT(EnableCoeff, THIS_METHOD_IS_ONLY_FOR_INNER_OR_LAZY_PRODUCTS);"},
{"lineNum":"  183","line":"      eigen_assert( (Option==LazyProduct) || (this->rows() == 1 && this->cols() == 1) );"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"      return internal::evaluator<Derived>(derived()).coeff(i);"},
{"lineNum":"  186","line":"    }"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"};"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"} // end namespace Eigen"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"#endif // EIGEN_PRODUCT_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 5, "covered" : 0,};
var merged_data = [];
