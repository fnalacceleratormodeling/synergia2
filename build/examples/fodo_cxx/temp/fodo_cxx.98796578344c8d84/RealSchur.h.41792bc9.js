var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2010,2012 Jitse Niesen <jitse@maths.leeds.ac.uk>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_REAL_SCHUR_H"},
{"lineNum":"   12","line":"#define EIGEN_REAL_SCHUR_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./HessenbergDecomposition.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace Eigen {"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"/** \\eigenvalues_module \\ingroup Eigenvalues_Module"},
{"lineNum":"   21","line":"  *"},
{"lineNum":"   22","line":"  *"},
{"lineNum":"   23","line":"  * \\class RealSchur"},
{"lineNum":"   24","line":"  *"},
{"lineNum":"   25","line":"  * \\brief Performs a real Schur decomposition of a square matrix"},
{"lineNum":"   26","line":"  *"},
{"lineNum":"   27","line":"  * \\tparam MatrixType_ the type of the matrix of which we are computing the"},
{"lineNum":"   28","line":"  * real Schur decomposition; this is expected to be an instantiation of the"},
{"lineNum":"   29","line":"  * Matrix class template."},
{"lineNum":"   30","line":"  *"},
{"lineNum":"   31","line":"  * Given a real square matrix A, this class computes the real Schur"},
{"lineNum":"   32","line":"  * decomposition: \\f$ A = U T U^T \\f$ where U is a real orthogonal matrix and"},
{"lineNum":"   33","line":"  * T is a real quasi-triangular matrix. An orthogonal matrix is a matrix whose"},
{"lineNum":"   34","line":"  * inverse is equal to its transpose, \\f$ U^{-1} = U^T \\f$. A quasi-triangular"},
{"lineNum":"   35","line":"  * matrix is a block-triangular matrix whose diagonal consists of 1-by-1"},
{"lineNum":"   36","line":"  * blocks and 2-by-2 blocks with complex eigenvalues. The eigenvalues of the"},
{"lineNum":"   37","line":"  * blocks on the diagonal of T are the same as the eigenvalues of the matrix"},
{"lineNum":"   38","line":"  * A, and thus the real Schur decomposition is used in EigenSolver to compute"},
{"lineNum":"   39","line":"  * the eigendecomposition of a matrix."},
{"lineNum":"   40","line":"  *"},
{"lineNum":"   41","line":"  * Call the function compute() to compute the real Schur decomposition of a"},
{"lineNum":"   42","line":"  * given matrix. Alternatively, you can use the RealSchur(const MatrixType&, bool)"},
{"lineNum":"   43","line":"  * constructor which computes the real Schur decomposition at construction"},
{"lineNum":"   44","line":"  * time. Once the decomposition is computed, you can use the matrixU() and"},
{"lineNum":"   45","line":"  * matrixT() functions to retrieve the matrices U and T in the decomposition."},
{"lineNum":"   46","line":"  *"},
{"lineNum":"   47","line":"  * The documentation of RealSchur(const MatrixType&, bool) contains an example"},
{"lineNum":"   48","line":"  * of the typical use of this class."},
{"lineNum":"   49","line":"  *"},
{"lineNum":"   50","line":"  * \\note The implementation is adapted from"},
{"lineNum":"   51","line":"  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> (public domain)."},
{"lineNum":"   52","line":"  * Their code is based on EISPACK."},
{"lineNum":"   53","line":"  *"},
{"lineNum":"   54","line":"  * \\sa class ComplexSchur, class EigenSolver, class ComplexEigenSolver"},
{"lineNum":"   55","line":"  */"},
{"lineNum":"   56","line":"template<typename MatrixType_> class RealSchur","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   57","line":"{"},
{"lineNum":"   58","line":"  public:"},
{"lineNum":"   59","line":"    typedef MatrixType_ MatrixType;"},
{"lineNum":"   60","line":"    enum {"},
{"lineNum":"   61","line":"      RowsAtCompileTime = MatrixType::RowsAtCompileTime,"},
{"lineNum":"   62","line":"      ColsAtCompileTime = MatrixType::ColsAtCompileTime,"},
{"lineNum":"   63","line":"      Options = MatrixType::Options,"},
{"lineNum":"   64","line":"      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,"},
{"lineNum":"   65","line":"      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime"},
{"lineNum":"   66","line":"    };"},
{"lineNum":"   67","line":"    typedef typename MatrixType::Scalar Scalar;"},
{"lineNum":"   68","line":"    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;"},
{"lineNum":"   69","line":"    typedef Eigen::Index Index; ///< \\deprecated since Eigen 3.3"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;"},
{"lineNum":"   72","line":"    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"    /** \\brief Default constructor."},
{"lineNum":"   75","line":"      *"},
{"lineNum":"   76","line":"      * \\param [in] size  Positive integer, size of the matrix whose Schur decomposition will be computed."},
{"lineNum":"   77","line":"      *"},
{"lineNum":"   78","line":"      * The default constructor is useful in cases in which the user intends to"},
{"lineNum":"   79","line":"      * perform decompositions via compute().  The \\p size parameter is only"},
{"lineNum":"   80","line":"      * used as a hint. It is not an error to give a wrong \\p size, but it may"},
{"lineNum":"   81","line":"      * impair performance."},
{"lineNum":"   82","line":"      *"},
{"lineNum":"   83","line":"      * \\sa compute() for an example."},
{"lineNum":"   84","line":"      */"},
{"lineNum":"   85","line":"    explicit RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)"},
{"lineNum":"   86","line":"            : m_matT(size, size),"},
{"lineNum":"   87","line":"              m_matU(size, size),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   88","line":"              m_workspaceVector(size),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   89","line":"              m_hess(size),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   90","line":"              m_isInitialized(false),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   91","line":"              m_matUisUptodate(false),"},
{"lineNum":"   92","line":"              m_maxIters(-1)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   93","line":"    { }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"    /** \\brief Constructor; computes real Schur decomposition of given matrix."},
{"lineNum":"   96","line":"      *"},
{"lineNum":"   97","line":"      * \\param[in]  matrix    Square matrix whose Schur decomposition is to be computed."},
{"lineNum":"   98","line":"      * \\param[in]  computeU  If true, both T and U are computed; if false, only T is computed."},
{"lineNum":"   99","line":"      *"},
{"lineNum":"  100","line":"      * This constructor calls compute() to compute the Schur decomposition."},
{"lineNum":"  101","line":"      *"},
{"lineNum":"  102","line":"      * Example: \\include RealSchur_RealSchur_MatrixType.cpp"},
{"lineNum":"  103","line":"      * Output: \\verbinclude RealSchur_RealSchur_MatrixType.out"},
{"lineNum":"  104","line":"      */"},
{"lineNum":"  105","line":"    template<typename InputType>"},
{"lineNum":"  106","line":"    explicit RealSchur(const EigenBase<InputType>& matrix, bool computeU = true)"},
{"lineNum":"  107","line":"            : m_matT(matrix.rows(),matrix.cols()),"},
{"lineNum":"  108","line":"              m_matU(matrix.rows(),matrix.cols()),"},
{"lineNum":"  109","line":"              m_workspaceVector(matrix.rows()),"},
{"lineNum":"  110","line":"              m_hess(matrix.rows()),"},
{"lineNum":"  111","line":"              m_isInitialized(false),"},
{"lineNum":"  112","line":"              m_matUisUptodate(false),"},
{"lineNum":"  113","line":"              m_maxIters(-1)"},
{"lineNum":"  114","line":"    {"},
{"lineNum":"  115","line":"      compute(matrix.derived(), computeU);"},
{"lineNum":"  116","line":"    }"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"    /** \\brief Returns the orthogonal matrix in the Schur decomposition."},
{"lineNum":"  119","line":"      *"},
{"lineNum":"  120","line":"      * \\returns A const reference to the matrix U."},
{"lineNum":"  121","line":"      *"},
{"lineNum":"  122","line":"      * \\pre Either the constructor RealSchur(const MatrixType&, bool) or the"},
{"lineNum":"  123","line":"      * member function compute(const MatrixType&, bool) has been called before"},
{"lineNum":"  124","line":"      * to compute the Schur decomposition of a matrix, and \\p computeU was set"},
{"lineNum":"  125","line":"      * to true (the default value)."},
{"lineNum":"  126","line":"      *"},
{"lineNum":"  127","line":"      * \\sa RealSchur(const MatrixType&, bool) for an example"},
{"lineNum":"  128","line":"      */"},
{"lineNum":"  129","line":"    const MatrixType& matrixU() const"},
{"lineNum":"  130","line":"    {"},
{"lineNum":"  131","line":"      eigen_assert(m_isInitialized && \"RealSchur is not initialized.\");"},
{"lineNum":"  132","line":"      eigen_assert(m_matUisUptodate && \"The matrix U has not been computed during the RealSchur decomposition.\");"},
{"lineNum":"  133","line":"      return m_matU;"},
{"lineNum":"  134","line":"    }"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"    /** \\brief Returns the quasi-triangular matrix in the Schur decomposition."},
{"lineNum":"  137","line":"      *"},
{"lineNum":"  138","line":"      * \\returns A const reference to the matrix T."},
{"lineNum":"  139","line":"      *"},
{"lineNum":"  140","line":"      * \\pre Either the constructor RealSchur(const MatrixType&, bool) or the"},
{"lineNum":"  141","line":"      * member function compute(const MatrixType&, bool) has been called before"},
{"lineNum":"  142","line":"      * to compute the Schur decomposition of a matrix."},
{"lineNum":"  143","line":"      *"},
{"lineNum":"  144","line":"      * \\sa RealSchur(const MatrixType&, bool) for an example"},
{"lineNum":"  145","line":"      */"},
{"lineNum":"  146","line":"    const MatrixType& matrixT() const"},
{"lineNum":"  147","line":"    {"},
{"lineNum":"  148","line":"      eigen_assert(m_isInitialized && \"RealSchur is not initialized.\");"},
{"lineNum":"  149","line":"      return m_matT;"},
{"lineNum":"  150","line":"    }"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"    /** \\brief Computes Schur decomposition of given matrix."},
{"lineNum":"  153","line":"      *"},
{"lineNum":"  154","line":"      * \\param[in]  matrix    Square matrix whose Schur decomposition is to be computed."},
{"lineNum":"  155","line":"      * \\param[in]  computeU  If true, both T and U are computed; if false, only T is computed."},
{"lineNum":"  156","line":"      * \\returns    Reference to \\c *this"},
{"lineNum":"  157","line":"      *"},
{"lineNum":"  158","line":"      * The Schur decomposition is computed by first reducing the matrix to"},
{"lineNum":"  159","line":"      * Hessenberg form using the class HessenbergDecomposition. The Hessenberg"},
{"lineNum":"  160","line":"      * matrix is then reduced to triangular form by performing Francis QR"},
{"lineNum":"  161","line":"      * iterations with implicit double shift. The cost of computing the Schur"},
{"lineNum":"  162","line":"      * decomposition depends on the number of iterations; as a rough guide, it"},
{"lineNum":"  163","line":"      * may be taken to be \\f$25n^3\\f$ flops if \\a computeU is true and"},
{"lineNum":"  164","line":"      * \\f$10n^3\\f$ flops if \\a computeU is false."},
{"lineNum":"  165","line":"      *"},
{"lineNum":"  166","line":"      * Example: \\include RealSchur_compute.cpp"},
{"lineNum":"  167","line":"      * Output: \\verbinclude RealSchur_compute.out"},
{"lineNum":"  168","line":"      *"},
{"lineNum":"  169","line":"      * \\sa compute(const MatrixType&, bool, Index)"},
{"lineNum":"  170","line":"      */"},
{"lineNum":"  171","line":"    template<typename InputType>"},
{"lineNum":"  172","line":"    RealSchur& compute(const EigenBase<InputType>& matrix, bool computeU = true);"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"    /** \\brief Computes Schur decomposition of a Hessenberg matrix H = Z T Z^T"},
{"lineNum":"  175","line":"     *  \\param[in] matrixH Matrix in Hessenberg form H"},
{"lineNum":"  176","line":"     *  \\param[in] matrixQ orthogonal matrix Q that transform a matrix A to H : A = Q H Q^T"},
{"lineNum":"  177","line":"     *  \\param computeU Computes the matriX U of the Schur vectors"},
{"lineNum":"  178","line":"     * \\return Reference to \\c *this"},
{"lineNum":"  179","line":"     *"},
{"lineNum":"  180","line":"     *  This routine assumes that the matrix is already reduced in Hessenberg form matrixH"},
{"lineNum":"  181","line":"     *  using either the class HessenbergDecomposition or another mean."},
{"lineNum":"  182","line":"     *  It computes the upper quasi-triangular matrix T of the Schur decomposition of H"},
{"lineNum":"  183","line":"     *  When computeU is true, this routine computes the matrix U such that"},
{"lineNum":"  184","line":"     *  A = U T U^T =  (QZ) T (QZ)^T = Q H Q^T where A is the initial matrix"},
{"lineNum":"  185","line":"     *"},
{"lineNum":"  186","line":"     * NOTE Q is referenced if computeU is true; so, if the initial orthogonal matrix"},
{"lineNum":"  187","line":"     * is not available, the user should give an identity matrix (Q.setIdentity())"},
{"lineNum":"  188","line":"     *"},
{"lineNum":"  189","line":"     * \\sa compute(const MatrixType&, bool)"},
{"lineNum":"  190","line":"     */"},
{"lineNum":"  191","line":"    template<typename HessMatrixType, typename OrthMatrixType>"},
{"lineNum":"  192","line":"    RealSchur& computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU);"},
{"lineNum":"  193","line":"    /** \\brief Reports whether previous computation was successful."},
{"lineNum":"  194","line":"      *"},
{"lineNum":"  195","line":"      * \\returns \\c Success if computation was successful, \\c NoConvergence otherwise."},
{"lineNum":"  196","line":"      */"},
{"lineNum":"  197","line":"    ComputationInfo info() const"},
{"lineNum":"  198","line":"    {"},
{"lineNum":"  199","line":"      eigen_assert(m_isInitialized && \"RealSchur is not initialized.\");"},
{"lineNum":"  200","line":"      return m_info;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  201","line":"    }"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"    /** \\brief Sets the maximum number of iterations allowed."},
{"lineNum":"  204","line":"      *"},
{"lineNum":"  205","line":"      * If not specified by the user, the maximum number of iterations is m_maxIterationsPerRow times the size"},
{"lineNum":"  206","line":"      * of the matrix."},
{"lineNum":"  207","line":"      */"},
{"lineNum":"  208","line":"    RealSchur& setMaxIterations(Index maxIters)"},
{"lineNum":"  209","line":"    {"},
{"lineNum":"  210","line":"      m_maxIters = maxIters;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  211","line":"      return *this;"},
{"lineNum":"  212","line":"    }"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"    /** \\brief Returns the maximum number of iterations. */"},
{"lineNum":"  215","line":"    Index getMaxIterations()"},
{"lineNum":"  216","line":"    {"},
{"lineNum":"  217","line":"      return m_maxIters;"},
{"lineNum":"  218","line":"    }"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    /** \\brief Maximum number of iterations per row."},
{"lineNum":"  221","line":"      *"},
{"lineNum":"  222","line":"      * If not otherwise specified, the maximum number of iterations is this number times the size of the"},
{"lineNum":"  223","line":"      * matrix. It is currently set to 40."},
{"lineNum":"  224","line":"      */"},
{"lineNum":"  225","line":"    static const int m_maxIterationsPerRow = 40;"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"  private:"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"    MatrixType m_matT;"},
{"lineNum":"  230","line":"    MatrixType m_matU;"},
{"lineNum":"  231","line":"    ColumnVectorType m_workspaceVector;"},
{"lineNum":"  232","line":"    HessenbergDecomposition<MatrixType> m_hess;"},
{"lineNum":"  233","line":"    ComputationInfo m_info;"},
{"lineNum":"  234","line":"    bool m_isInitialized;"},
{"lineNum":"  235","line":"    bool m_matUisUptodate;"},
{"lineNum":"  236","line":"    Index m_maxIters;"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"    typedef Matrix<Scalar,3,1> Vector3s;"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"    Scalar computeNormOfT();"},
{"lineNum":"  241","line":"    Index findSmallSubdiagEntry(Index iu, const Scalar& considerAsZero);"},
{"lineNum":"  242","line":"    void splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift);"},
{"lineNum":"  243","line":"    void computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo);"},
{"lineNum":"  244","line":"    void initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector);"},
{"lineNum":"  245","line":"    void performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace);"},
{"lineNum":"  246","line":"};"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"template<typename MatrixType>"},
{"lineNum":"  250","line":"template<typename InputType>"},
{"lineNum":"  251","line":"RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const EigenBase<InputType>& matrix, bool computeU)"},
{"lineNum":"  252","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  253","line":"  const Scalar considerAsZero = (std::numeric_limits<Scalar>::min)();"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"  eigen_assert(matrix.cols() == matrix.rows());"},
{"lineNum":"  256","line":"  Index maxIters = m_maxIters;"},
{"lineNum":"  257","line":"  if (maxIters == -1)"},
{"lineNum":"  258","line":"    maxIters = m_maxIterationsPerRow * matrix.rows();"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"  Scalar scale = matrix.derived().cwiseAbs().maxCoeff();"},
{"lineNum":"  261","line":"  if(scale<considerAsZero)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  262","line":"  {"},
{"lineNum":"  263","line":"    m_matT.setZero(matrix.rows(),matrix.cols());"},
{"lineNum":"  264","line":"    if(computeU)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  265","line":"      m_matU.setIdentity(matrix.rows(),matrix.cols());"},
{"lineNum":"  266","line":"    m_info = Success;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  267","line":"    m_isInitialized = true;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  268","line":"    m_matUisUptodate = computeU;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  269","line":"    return *this;"},
{"lineNum":"  270","line":"  }"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"  // Step 1. Reduce to Hessenberg form"},
{"lineNum":"  273","line":"  m_hess.compute(matrix.derived()/scale);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"  // Step 2. Reduce to real Schur form"},
{"lineNum":"  276","line":"  // Note: we copy m_hess.matrixQ() into m_matU here and not in computeFromHessenberg"},
{"lineNum":"  277","line":"  //       to be able to pass our working-space buffer for the Householder to Dense evaluation."},
{"lineNum":"  278","line":"  m_workspaceVector.resize(matrix.cols());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  279","line":"  if(computeU)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  280","line":"    m_hess.matrixQ().evalTo(m_matU, m_workspaceVector);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  281","line":"  computeFromHessenberg(m_hess.matrixH(), m_matU, computeU);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"  m_matT *= scale;"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"  return *this;"},
{"lineNum":"  286","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  287","line":"template<typename MatrixType>"},
{"lineNum":"  288","line":"template<typename HessMatrixType, typename OrthMatrixType>"},
{"lineNum":"  289","line":"RealSchur<MatrixType>& RealSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU)"},
{"lineNum":"  290","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  291","line":"  using std::abs;"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"  m_matT = matrixH;"},
{"lineNum":"  294","line":"  m_workspaceVector.resize(m_matT.cols());","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  295","line":"  if(computeU && !internal::is_same_dense(m_matU,matrixQ))","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  296","line":"    m_matU = matrixQ;"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"  Index maxIters = m_maxIters;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  299","line":"  if (maxIters == -1)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  300","line":"    maxIters = m_maxIterationsPerRow * matrixH.rows();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  301","line":"  Scalar* workspace = &m_workspaceVector.coeffRef(0);"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"  // The matrix m_matT is divided in three parts."},
{"lineNum":"  304","line":"  // Rows 0,...,il-1 are decoupled from the rest because m_matT(il,il-1) is zero."},
{"lineNum":"  305","line":"  // Rows il,...,iu is the part we are working on (the active window)."},
{"lineNum":"  306","line":"  // Rows iu+1,...,end are already brought in triangular form."},
{"lineNum":"  307","line":"  Index iu = m_matT.cols() - 1;"},
{"lineNum":"  308","line":"  Index iter = 0;      // iteration count for current eigenvalue"},
{"lineNum":"  309","line":"  Index totalIter = 0; // iteration count for whole matrix"},
{"lineNum":"  310","line":"  Scalar exshift(0);   // sum of exceptional shifts","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  311","line":"  Scalar norm = computeNormOfT();"},
{"lineNum":"  312","line":"  // sub-diagonal entries smaller than considerAsZero will be treated as zero."},
{"lineNum":"  313","line":"  // We use eps^2 to enable more precision in small eigenvalues."},
{"lineNum":"  314","line":"  Scalar considerAsZero = numext::maxi<Scalar>( norm * numext::abs2(NumTraits<Scalar>::epsilon()),"},
{"lineNum":"  315","line":"                                                (std::numeric_limits<Scalar>::min)() );"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"  if(norm!=Scalar(0))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  318","line":"  {"},
{"lineNum":"  319","line":"    while (iu >= 0)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  320","line":"    {"},
{"lineNum":"  321","line":"      Index il = findSmallSubdiagEntry(iu,considerAsZero);"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"      // Check for convergence"},
{"lineNum":"  324","line":"      if (il == iu) // One root found","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  325","line":"      {"},
{"lineNum":"  326","line":"        m_matT.coeffRef(iu,iu) = m_matT.coeff(iu,iu) + exshift;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  327","line":"        if (iu > 0)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  328","line":"          m_matT.coeffRef(iu, iu-1) = Scalar(0);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  329","line":"        iu--;"},
{"lineNum":"  330","line":"        iter = 0;"},
{"lineNum":"  331","line":"      }"},
{"lineNum":"  332","line":"      else if (il == iu-1) // Two roots found","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  333","line":"      {"},
{"lineNum":"  334","line":"        splitOffTwoRows(iu, computeU, exshift);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  335","line":"        iu -= 2;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  336","line":"        iter = 0;"},
{"lineNum":"  337","line":"      }"},
{"lineNum":"  338","line":"      else // No convergence yet"},
{"lineNum":"  339","line":"      {"},
{"lineNum":"  340","line":"        // The firstHouseholderVector vector has to be initialized to something to get rid of a silly GCC warning (-O1 -Wall -DNDEBUG )"},
{"lineNum":"  341","line":"        Vector3s firstHouseholderVector = Vector3s::Zero(), shiftInfo;"},
{"lineNum":"  342","line":"        computeShift(iu, iter, exshift, shiftInfo);"},
{"lineNum":"  343","line":"        iter = iter + 1;"},
{"lineNum":"  344","line":"        totalIter = totalIter + 1;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  345","line":"        if (totalIter > maxIters) break;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  346","line":"        Index im;"},
{"lineNum":"  347","line":"        initFrancisQRStep(il, iu, shiftInfo, im, firstHouseholderVector);"},
{"lineNum":"  348","line":"        performFrancisQRStep(il, im, iu, computeU, firstHouseholderVector, workspace);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  349","line":"      }"},
{"lineNum":"  350","line":"    }"},
{"lineNum":"  351","line":"  }"},
{"lineNum":"  352","line":"  if(totalIter <= maxIters)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  353","line":"    m_info = Success;"},
{"lineNum":"  354","line":"  else"},
{"lineNum":"  355","line":"    m_info = NoConvergence;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"  m_isInitialized = true;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  358","line":"  m_matUisUptodate = computeU;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  359","line":"  return *this;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  360","line":"}"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"/** \\internal Computes and returns vector L1 norm of T */"},
{"lineNum":"  363","line":"template<typename MatrixType>"},
{"lineNum":"  364","line":"inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()"},
{"lineNum":"  365","line":"{"},
{"lineNum":"  366","line":"  const Index size = m_matT.cols();"},
{"lineNum":"  367","line":"  // FIXME to be efficient the following would requires a triangular reduxion code"},
{"lineNum":"  368","line":"  // Scalar norm = m_matT.upper().cwiseAbs().sum()"},
{"lineNum":"  369","line":"  //               + m_matT.bottomLeftCorner(size-1,size-1).diagonal().cwiseAbs().sum();"},
{"lineNum":"  370","line":"  Scalar norm(0);"},
{"lineNum":"  371","line":"  for (Index j = 0; j < size; ++j)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  372","line":"    norm += m_matT.col(j).segment(0, (std::min)(size,j+2)).cwiseAbs().sum();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  373","line":"  return norm;"},
{"lineNum":"  374","line":"}"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"/** \\internal Look for single small sub-diagonal element and returns its index */"},
{"lineNum":"  377","line":"template<typename MatrixType>"},
{"lineNum":"  378","line":"inline Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu, const Scalar& considerAsZero)"},
{"lineNum":"  379","line":"{"},
{"lineNum":"  380","line":"  using std::abs;"},
{"lineNum":"  381","line":"  Index res = iu;"},
{"lineNum":"  382","line":"  while (res > 0)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  383","line":"  {"},
{"lineNum":"  384","line":"    Scalar s = abs(m_matT.coeff(res-1,res-1)) + abs(m_matT.coeff(res,res));","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"    s = numext::maxi<Scalar>(s * NumTraits<Scalar>::epsilon(), considerAsZero);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"    if (abs(m_matT.coeff(res,res-1)) <= s)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  389","line":"      break;"},
{"lineNum":"  390","line":"    res--;"},
{"lineNum":"  391","line":"  }"},
{"lineNum":"  392","line":"  return res;"},
{"lineNum":"  393","line":"}"},
{"lineNum":"  394","line":""},
{"lineNum":"  395","line":"/** \\internal Update T given that rows iu-1 and iu decouple from the rest. */"},
{"lineNum":"  396","line":"template<typename MatrixType>"},
{"lineNum":"  397","line":"inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift)"},
{"lineNum":"  398","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  399","line":"  using std::sqrt;"},
{"lineNum":"  400","line":"  using std::abs;"},
{"lineNum":"  401","line":"  const Index size = m_matT.cols();"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"  // The eigenvalues of the 2x2 matrix [a b; c d] are"},
{"lineNum":"  404","line":"  // trace +/- sqrt(discr/4) where discr = tr^2 - 4*det, tr = a + d, det = ad - bc"},
{"lineNum":"  405","line":"  Scalar p = Scalar(0.5) * (m_matT.coeff(iu-1,iu-1) - m_matT.coeff(iu,iu));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  406","line":"  Scalar q = p * p + m_matT.coeff(iu,iu-1) * m_matT.coeff(iu-1,iu);   // q = tr^2 / 4 - det = discr/4","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  407","line":"  m_matT.coeffRef(iu,iu) += exshift;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  408","line":"  m_matT.coeffRef(iu-1,iu-1) += exshift;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  409","line":""},
{"lineNum":"  410","line":"  if (q >= Scalar(0)) // Two real eigenvalues","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  411","line":"  {"},
{"lineNum":"  412","line":"    Scalar z = sqrt(abs(q));"},
{"lineNum":"  413","line":"    JacobiRotation<Scalar> rot;"},
{"lineNum":"  414","line":"    if (p >= Scalar(0))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  415","line":"      rot.makeGivens(p + z, m_matT.coeff(iu, iu-1));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  416","line":"    else"},
{"lineNum":"  417","line":"      rot.makeGivens(p - z, m_matT.coeff(iu, iu-1));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"    m_matT.rightCols(size-iu+1).applyOnTheLeft(iu-1, iu, rot.adjoint());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  420","line":"    m_matT.topRows(iu+1).applyOnTheRight(iu-1, iu, rot);"},
{"lineNum":"  421","line":"    m_matT.coeffRef(iu, iu-1) = Scalar(0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  422","line":"    if (computeU)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  423","line":"      m_matU.applyOnTheRight(iu-1, iu, rot);"},
{"lineNum":"  424","line":"  }"},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"  if (iu > 1)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  427","line":"    m_matT.coeffRef(iu-1, iu-2) = Scalar(0);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  428","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"/** \\internal Form shift in shiftInfo, and update exshift if an exceptional shift is performed. */"},
{"lineNum":"  431","line":"template<typename MatrixType>"},
{"lineNum":"  432","line":"inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)"},
{"lineNum":"  433","line":"{"},
{"lineNum":"  434","line":"  using std::sqrt;"},
{"lineNum":"  435","line":"  using std::abs;"},
{"lineNum":"  436","line":"  shiftInfo.coeffRef(0) = m_matT.coeff(iu,iu);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  437","line":"  shiftInfo.coeffRef(1) = m_matT.coeff(iu-1,iu-1);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  438","line":"  shiftInfo.coeffRef(2) = m_matT.coeff(iu,iu-1) * m_matT.coeff(iu-1,iu);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"  // Wilkinson\'s original ad hoc shift"},
{"lineNum":"  441","line":"  if (iter == 10)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  442","line":"  {"},
{"lineNum":"  443","line":"    exshift += shiftInfo.coeff(0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  444","line":"    for (Index i = 0; i <= iu; ++i)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  445","line":"      m_matT.coeffRef(i,i) -= shiftInfo.coeff(0);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  446","line":"    Scalar s = abs(m_matT.coeff(iu,iu-1)) + abs(m_matT.coeff(iu-1,iu-2));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  447","line":"    shiftInfo.coeffRef(0) = Scalar(0.75) * s;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  448","line":"    shiftInfo.coeffRef(1) = Scalar(0.75) * s;"},
{"lineNum":"  449","line":"    shiftInfo.coeffRef(2) = Scalar(-0.4375) * s * s;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  450","line":"  }"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"  // MATLAB\'s new ad hoc shift"},
{"lineNum":"  453","line":"  if (iter == 30)"},
{"lineNum":"  454","line":"  {"},
{"lineNum":"  455","line":"    Scalar s = (shiftInfo.coeff(1) - shiftInfo.coeff(0)) / Scalar(2.0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  456","line":"    s = s * s + shiftInfo.coeff(2);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  457","line":"    if (s > Scalar(0))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  458","line":"    {"},
{"lineNum":"  459","line":"      s = sqrt(s);"},
{"lineNum":"  460","line":"      if (shiftInfo.coeff(1) < shiftInfo.coeff(0))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  461","line":"        s = -s;"},
{"lineNum":"  462","line":"      s = s + (shiftInfo.coeff(1) - shiftInfo.coeff(0)) / Scalar(2.0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  463","line":"      s = shiftInfo.coeff(0) - shiftInfo.coeff(2) / s;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  464","line":"      exshift += s;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  465","line":"      for (Index i = 0; i <= iu; ++i)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  466","line":"        m_matT.coeffRef(i,i) -= s;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  467","line":"      shiftInfo.setConstant(Scalar(0.964));"},
{"lineNum":"  468","line":"    }"},
{"lineNum":"  469","line":"  }"},
{"lineNum":"  470","line":"}"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"/** \\internal Compute index im at which Francis QR step starts and the first Householder vector. */"},
{"lineNum":"  473","line":"template<typename MatrixType>"},
{"lineNum":"  474","line":"inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)"},
{"lineNum":"  475","line":"{"},
{"lineNum":"  476","line":"  using std::abs;"},
{"lineNum":"  477","line":"  Vector3s& v = firstHouseholderVector; // alias to save typing"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"  for (im = iu-2; im >= il; --im)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  480","line":"  {"},
{"lineNum":"  481","line":"    const Scalar Tmm = m_matT.coeff(im,im);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  482","line":"    const Scalar r = shiftInfo.coeff(0) - Tmm;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  483","line":"    const Scalar s = shiftInfo.coeff(1) - Tmm;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  484","line":"    v.coeffRef(0) = (r * s - shiftInfo.coeff(2)) / m_matT.coeff(im+1,im) + m_matT.coeff(im,im+1);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  485","line":"    v.coeffRef(1) = m_matT.coeff(im+1,im+1) - Tmm - r - s;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  486","line":"    v.coeffRef(2) = m_matT.coeff(im+2,im+1);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  487","line":"    if (im == il) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  488","line":"      break;"},
{"lineNum":"  489","line":"    }"},
{"lineNum":"  490","line":"    const Scalar lhs = m_matT.coeff(im,im-1) * (abs(v.coeff(1)) + abs(v.coeff(2)));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  491","line":"    const Scalar rhs = v.coeff(0) * (abs(m_matT.coeff(im-1,im-1)) + abs(Tmm) + abs(m_matT.coeff(im+1,im+1)));","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  492","line":"    if (abs(lhs) < NumTraits<Scalar>::epsilon() * rhs)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  493","line":"      break;"},
{"lineNum":"  494","line":"  }"},
{"lineNum":"  495","line":"}"},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"/** \\internal Perform a Francis QR step involving rows il:iu and columns im:iu. */"},
{"lineNum":"  498","line":"template<typename MatrixType>"},
{"lineNum":"  499","line":"inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)"},
{"lineNum":"  500","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  501","line":"  eigen_assert(im >= il);"},
{"lineNum":"  502","line":"  eigen_assert(im <= iu-2);"},
{"lineNum":"  503","line":""},
{"lineNum":"  504","line":"  const Index size = m_matT.cols();"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"  for (Index k = im; k <= iu-2; ++k)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  507","line":"  {"},
{"lineNum":"  508","line":"    bool firstIteration = (k == im);","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  509","line":""},
{"lineNum":"  510","line":"    Vector3s v;"},
{"lineNum":"  511","line":"    if (firstIteration)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  512","line":"      v = firstHouseholderVector;"},
{"lineNum":"  513","line":"    else"},
{"lineNum":"  514","line":"      v = m_matT.template block<3,1>(k,k-1);"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"    Scalar tau, beta;"},
{"lineNum":"  517","line":"    Matrix<Scalar, 2, 1> ess;"},
{"lineNum":"  518","line":"    v.makeHouseholder(ess, tau, beta);"},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"    if (beta != Scalar(0)) // if v is not zero","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  521","line":"    {"},
{"lineNum":"  522","line":"      if (firstIteration && k > il)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  523","line":"        m_matT.coeffRef(k,k-1) = -m_matT.coeff(k,k-1);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  524","line":"      else if (!firstIteration)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  525","line":"        m_matT.coeffRef(k,k-1) = beta;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"      // These Householder transformations form the O(n^3) part of the algorithm"},
{"lineNum":"  528","line":"      m_matT.block(k, k, 3, size-k).applyHouseholderOnTheLeft(ess, tau, workspace);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  529","line":"      m_matT.block(0, k, (std::min)(iu,k+3) + 1, 3).applyHouseholderOnTheRight(ess, tau, workspace);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  530","line":"      if (computeU)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  531","line":"        m_matU.block(0, k, size, 3).applyHouseholderOnTheRight(ess, tau, workspace);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  532","line":"    }"},
{"lineNum":"  533","line":"  }"},
{"lineNum":"  534","line":""},
{"lineNum":"  535","line":"  Matrix<Scalar, 2, 1> v = m_matT.template block<2,1>(iu-1, iu-2);"},
{"lineNum":"  536","line":"  Scalar tau, beta;"},
{"lineNum":"  537","line":"  Matrix<Scalar, 1, 1> ess;"},
{"lineNum":"  538","line":"  v.makeHouseholder(ess, tau, beta);"},
{"lineNum":"  539","line":""},
{"lineNum":"  540","line":"  if (beta != Scalar(0)) // if v is not zero","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  541","line":"  {"},
{"lineNum":"  542","line":"    m_matT.coeffRef(iu-1, iu-2) = beta;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  543","line":"    m_matT.block(iu-1, iu-1, 2, size-iu+1).applyHouseholderOnTheLeft(ess, tau, workspace);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  544","line":"    m_matT.block(0, iu-1, iu+1, 2).applyHouseholderOnTheRight(ess, tau, workspace);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  545","line":"    if (computeU)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  546","line":"      m_matU.block(0, iu-1, size, 2).applyHouseholderOnTheRight(ess, tau, workspace);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  547","line":"  }"},
{"lineNum":"  548","line":""},
{"lineNum":"  549","line":"  // clean up pollution due to round-off errors"},
{"lineNum":"  550","line":"  for (Index i = im+2; i <= iu; ++i)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  551","line":"  {"},
{"lineNum":"  552","line":"    m_matT.coeffRef(i,i-2) = Scalar(0);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  553","line":"    if (i > im+2)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  554","line":"      m_matT.coeffRef(i,i-3) = Scalar(0);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  555","line":"  }"},
{"lineNum":"  556","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  557","line":""},
{"lineNum":"  558","line":"} // end namespace Eigen"},
{"lineNum":"  559","line":""},
{"lineNum":"  560","line":"#endif // EIGEN_REAL_SCHUR_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 120, "covered" : 0,};
var merged_data = [];
