var data = {lines:[
{"lineNum":"    1","line":"/****************************  vectori128.h   *******************************"},
{"lineNum":"    2","line":"* Author:        Agner Fog"},
{"lineNum":"    3","line":"* Date created:  2012-05-30"},
{"lineNum":"    4","line":"* Last modified: 2019-08-01"},
{"lineNum":"    5","line":"* Version:       1.40.00"},
{"lineNum":"    6","line":"* Project:       vector class library"},
{"lineNum":"    7","line":"* Description:"},
{"lineNum":"    8","line":"* Header file defining 128-bit integer vector classes"},
{"lineNum":"    9","line":"*"},
{"lineNum":"   10","line":"* Instructions: see vcl_manual.pdf"},
{"lineNum":"   11","line":"*"},
{"lineNum":"   12","line":"* The following vector classes are defined here:"},
{"lineNum":"   13","line":"* Vec128b   Vector of 128  1-bit unsigned  integers or Booleans"},
{"lineNum":"   14","line":"* Vec16c    Vector of  16  8-bit signed    integers"},
{"lineNum":"   15","line":"* Vec16uc   Vector of  16  8-bit unsigned  integers"},
{"lineNum":"   16","line":"* Vec16cb   Vector of  16  Booleans for use with Vec16c and Vec16uc"},
{"lineNum":"   17","line":"* Vec8s     Vector of   8  16-bit signed   integers"},
{"lineNum":"   18","line":"* Vec8us    Vector of   8  16-bit unsigned integers"},
{"lineNum":"   19","line":"* Vec8sb    Vector of   8  Booleans for use with Vec8s and Vec8us"},
{"lineNum":"   20","line":"* Vec4i     Vector of   4  32-bit signed   integers"},
{"lineNum":"   21","line":"* Vec4ui    Vector of   4  32-bit unsigned integers"},
{"lineNum":"   22","line":"* Vec4ib    Vector of   4  Booleans for use with Vec4i and Vec4ui"},
{"lineNum":"   23","line":"* Vec2q     Vector of   2  64-bit signed   integers"},
{"lineNum":"   24","line":"* Vec2uq    Vector of   2  64-bit unsigned integers"},
{"lineNum":"   25","line":"* Vec2qb    Vector of   2  Booleans for use with Vec2q and Vec2uq"},
{"lineNum":"   26","line":"*"},
{"lineNum":"   27","line":"* Each vector object is represented internally in the CPU as a 128-bit register."},
{"lineNum":"   28","line":"* This header file defines operators and functions for these vectors."},
{"lineNum":"   29","line":"*"},
{"lineNum":"   30","line":"* (c) Copyright 2012-2019 Agner Fog."},
{"lineNum":"   31","line":"* Apache License version 2.0 or later."},
{"lineNum":"   32","line":"*****************************************************************************/"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"#ifndef VECTORCLASS_H"},
{"lineNum":"   35","line":"#include \"vectorclass.h\""},
{"lineNum":"   36","line":"#endif"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"#if VECTORCLASS_H > 19999"},
{"lineNum":"   39","line":"#error Incompatible versions of vector class library mixed"},
{"lineNum":"   40","line":"#endif"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"#ifndef VECTORI128_H"},
{"lineNum":"   43","line":"#define VECTORI128_H"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"#ifdef VCL_NAMESPACE         // optional namespace"},
{"lineNum":"   47","line":"namespace VCL_NAMESPACE {"},
{"lineNum":"   48","line":"#endif"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"/*****************************************************************************"},
{"lineNum":"   51","line":"*"},
{"lineNum":"   52","line":"*          Vector of 128 1-bit unsigned integers or Booleans"},
{"lineNum":"   53","line":"*"},
{"lineNum":"   54","line":"*****************************************************************************/"},
{"lineNum":"   55","line":"class Vec128b {"},
{"lineNum":"   56","line":"protected:"},
{"lineNum":"   57","line":"    __m128i xmm; // Integer vector"},
{"lineNum":"   58","line":"public:"},
{"lineNum":"   59","line":"    // Default constructor:"},
{"lineNum":"   60","line":"    Vec128b() {"},
{"lineNum":"   61","line":"    }"},
{"lineNum":"   62","line":"    // Constructor to broadcast the same value into all elements"},
{"lineNum":"   63","line":"    // Removed because of undesired implicit conversions"},
{"lineNum":"   64","line":"    // Vec128b(int i) {xmm = _mm_set1_epi32(-(i & 1));}"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":"   67","line":"    Vec128b(__m128i const & x) {"},
{"lineNum":"   68","line":"        xmm = x;"},
{"lineNum":"   69","line":"    }"},
{"lineNum":"   70","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":"   71","line":"    Vec128b & operator = (__m128i const & x) {"},
{"lineNum":"   72","line":"        xmm = x;"},
{"lineNum":"   73","line":"        return *this;"},
{"lineNum":"   74","line":"    }"},
{"lineNum":"   75","line":"    // Type cast operator to convert to __m128i used in intrinsics"},
{"lineNum":"   76","line":"    operator __m128i() const {"},
{"lineNum":"   77","line":"        return xmm;"},
{"lineNum":"   78","line":"    }"},
{"lineNum":"   79","line":"    // Member function to load from array (unaligned)"},
{"lineNum":"   80","line":"    Vec128b & load(void const * p) {"},
{"lineNum":"   81","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":"   82","line":"        return *this;"},
{"lineNum":"   83","line":"    }"},
{"lineNum":"   84","line":"    // Member function to load from array, aligned by 16"},
{"lineNum":"   85","line":"    // \"load_a\" is faster than \"load\" on older Intel processors (Pentium 4, Pentium M, Core 1,"},
{"lineNum":"   86","line":"    // Merom, Wolfdale, and Atom), but not on other processors from Intel, AMD or VIA."},
{"lineNum":"   87","line":"    // You may use load_a instead of load if you are certain that p points to an address"},
{"lineNum":"   88","line":"    // divisible by 16."},
{"lineNum":"   89","line":"    void load_a(void const * p) {"},
{"lineNum":"   90","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":"   91","line":"    }"},
{"lineNum":"   92","line":"    // Member function to store into array (unaligned)"},
{"lineNum":"   93","line":"    void store(void * p) const {"},
{"lineNum":"   94","line":"        _mm_storeu_si128((__m128i*)p, xmm);"},
{"lineNum":"   95","line":"    }"},
{"lineNum":"   96","line":"    // Member function to store into array, aligned by 16"},
{"lineNum":"   97","line":"    // \"store_a\" is faster than \"store\" on older Intel processors (Pentium 4, Pentium M, Core 1,"},
{"lineNum":"   98","line":"    // Merom, Wolfdale, and Atom), but not on other processors from Intel, AMD or VIA."},
{"lineNum":"   99","line":"    // You may use store_a instead of store if you are certain that p points to an address"},
{"lineNum":"  100","line":"    // divisible by 16."},
{"lineNum":"  101","line":"    void store_a(void * p) const {"},
{"lineNum":"  102","line":"        _mm_store_si128((__m128i*)p, xmm);"},
{"lineNum":"  103","line":"    }"},
{"lineNum":"  104","line":"    // Member function to change a single bit"},
{"lineNum":"  105","line":"    // DEPRECATED"},
{"lineNum":"  106","line":"    Vec128b const & set_bit(int index, int value) {"},
{"lineNum":"  107","line":"        static const union {"},
{"lineNum":"  108","line":"            uint64_t i[4];"},
{"lineNum":"  109","line":"            __m128i  x[2];"},
{"lineNum":"  110","line":"        } u = {{1,0,0,1}};                 // 2 vectors with bit 0 and 64 set, respectively"},
{"lineNum":"  111","line":"        uint32_t w = ((uint32_t)index >> 6u) & 1;     // qword index"},
{"lineNum":"  112","line":"        int bi = index & 0x3F;             // bit index within qword w"},
{"lineNum":"  113","line":"        __m128i mask = u.x[w];"},
{"lineNum":"  114","line":"        mask = _mm_sll_epi64(mask,_mm_cvtsi32_si128(bi)); // mask with bit number b set"},
{"lineNum":"  115","line":"        if (value & 1) {"},
{"lineNum":"  116","line":"            xmm = _mm_or_si128(mask,xmm);"},
{"lineNum":"  117","line":"        }"},
{"lineNum":"  118","line":"        else {"},
{"lineNum":"  119","line":"            xmm = _mm_andnot_si128(mask,xmm);"},
{"lineNum":"  120","line":"        }"},
{"lineNum":"  121","line":"        return *this;"},
{"lineNum":"  122","line":"    }"},
{"lineNum":"  123","line":"    // Member function to get a single bit"},
{"lineNum":"  124","line":"    // DEPRECATED"},
{"lineNum":"  125","line":"    int get_bit(int index) const {"},
{"lineNum":"  126","line":"        union {"},
{"lineNum":"  127","line":"            __m128i x;"},
{"lineNum":"  128","line":"            uint8_t i[16];"},
{"lineNum":"  129","line":"        } u;"},
{"lineNum":"  130","line":"        u.x = xmm;"},
{"lineNum":"  131","line":"        int32_t w = (index >> 3) & 0xF;       // byte index"},
{"lineNum":"  132","line":"        int32_t bi = index & 7;               // bit index within byte w"},
{"lineNum":"  133","line":"        return (u.i[w] >> bi) & 1;"},
{"lineNum":"  134","line":"    }"},
{"lineNum":"  135","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":"  136","line":"    // DEPRECATED"},
{"lineNum":"  137","line":"    bool operator [] (int index) const {"},
{"lineNum":"  138","line":"        return get_bit(index) != 0;"},
{"lineNum":"  139","line":"    }"},
{"lineNum":"  140","line":"    static int size() {"},
{"lineNum":"  141","line":"        return 128;"},
{"lineNum":"  142","line":"    }"},
{"lineNum":"  143","line":"    static int elementtype() {"},
{"lineNum":"  144","line":"        return 1;"},
{"lineNum":"  145","line":"    }"},
{"lineNum":"  146","line":"};"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"// Define operators for this class"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"// vector operator & : bitwise and"},
{"lineNum":"  152","line":"static inline Vec128b operator & (Vec128b const & a, Vec128b const & b) {"},
{"lineNum":"  153","line":"    return _mm_and_si128(a, b);","class":"lineNoCov","hits":"0","possible_hits":"20",},
{"lineNum":"  154","line":"}"},
{"lineNum":"  155","line":"static inline Vec128b operator && (Vec128b const & a, Vec128b const & b) {"},
{"lineNum":"  156","line":"    return a & b;"},
{"lineNum":"  157","line":"}"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"// vector operator | : bitwise or"},
{"lineNum":"  160","line":"static inline Vec128b operator | (Vec128b const & a, Vec128b const & b) {"},
{"lineNum":"  161","line":"    return _mm_or_si128(a, b);","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  162","line":"}"},
{"lineNum":"  163","line":"static inline Vec128b operator || (Vec128b const & a, Vec128b const & b) {"},
{"lineNum":"  164","line":"    return a | b;"},
{"lineNum":"  165","line":"}"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"// vector operator ^ : bitwise xor"},
{"lineNum":"  168","line":"static inline Vec128b operator ^ (Vec128b const & a, Vec128b const & b) {"},
{"lineNum":"  169","line":"    return _mm_xor_si128(a, b);","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  170","line":"}"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"// vector operator ~ : bitwise not"},
{"lineNum":"  173","line":"static inline Vec128b operator ~ (Vec128b const & a) {"},
{"lineNum":"  174","line":"    return _mm_xor_si128(a, _mm_set1_epi32(-1));"},
{"lineNum":"  175","line":"}"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"// vector operator &= : bitwise and"},
{"lineNum":"  178","line":"static inline Vec128b & operator &= (Vec128b & a, Vec128b const & b) {"},
{"lineNum":"  179","line":"    a = a & b;"},
{"lineNum":"  180","line":"    return a;"},
{"lineNum":"  181","line":"}"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"// vector operator |= : bitwise or"},
{"lineNum":"  184","line":"static inline Vec128b & operator |= (Vec128b & a, Vec128b const & b) {"},
{"lineNum":"  185","line":"    a = a | b;"},
{"lineNum":"  186","line":"    return a;"},
{"lineNum":"  187","line":"}"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"// vector operator ^= : bitwise xor"},
{"lineNum":"  190","line":"static inline Vec128b & operator ^= (Vec128b & a, Vec128b const & b) {"},
{"lineNum":"  191","line":"    a = a ^ b;"},
{"lineNum":"  192","line":"    return a;"},
{"lineNum":"  193","line":"}"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"// Define functions for this class"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"// function andnot: a & ~ b"},
{"lineNum":"  198","line":"static inline Vec128b andnot (Vec128b const & a, Vec128b const & b) {"},
{"lineNum":"  199","line":"    return _mm_andnot_si128(b, a);"},
{"lineNum":"  200","line":"}"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"/*****************************************************************************"},
{"lineNum":"  204","line":"*"},
{"lineNum":"  205","line":"*          Generate compile-time constant vector"},
{"lineNum":"  206","line":"*"},
{"lineNum":"  207","line":"*****************************************************************************/"},
{"lineNum":"  208","line":"// Generate a constant vector of 4 integers stored in memory."},
{"lineNum":"  209","line":"// Can be converted to any integer vector type"},
{"lineNum":"  210","line":"template <int32_t i0, int32_t i1, int32_t i2, int32_t i3>"},
{"lineNum":"  211","line":"static inline __m128i constant4i() {"},
{"lineNum":"  212","line":"    static const union {"},
{"lineNum":"  213","line":"        int     i[4];"},
{"lineNum":"  214","line":"        __m128i xmm;"},
{"lineNum":"  215","line":"    } u = {{i0,i1,i2,i3}};"},
{"lineNum":"  216","line":"    return u.xmm;"},
{"lineNum":"  217","line":"}"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"template <uint32_t i0, uint32_t i1, uint32_t i2, uint32_t i3>"},
{"lineNum":"  220","line":"static inline __m128i constant4ui() {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  221","line":"    return constant4i<int32_t(i0), int32_t(i1), int32_t(i2), int32_t(i3)>();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  222","line":"}"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"/*****************************************************************************"},
{"lineNum":"  225","line":"*"},
{"lineNum":"  226","line":"*          selectb function"},
{"lineNum":"  227","line":"*"},
{"lineNum":"  228","line":"*****************************************************************************/"},
{"lineNum":"  229","line":"// Select between two sources, byte by byte. Used in various functions and operators"},
{"lineNum":"  230","line":"// Corresponds to this pseudocode:"},
{"lineNum":"  231","line":"// for (int i = 0; i < 16; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":"  232","line":"// Each byte in s must be either 0 (false) or 0xFF (true). No other values are allowed."},
{"lineNum":"  233","line":"// The implementation depends on the instruction set:"},
{"lineNum":"  234","line":"// If SSE4.1 is supported then only bit 7 in each byte of s is checked,"},
{"lineNum":"  235","line":"// otherwise all bits in s are used."},
{"lineNum":"  236","line":"static inline __m128i selectb (__m128i const & s, __m128i const & a, __m128i const & b) {"},
{"lineNum":"  237","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":"  238","line":"    return _mm_blendv_epi8 (b, a, s);"},
{"lineNum":"  239","line":"#else"},
{"lineNum":"  240","line":"    return _mm_or_si128(","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  241","line":"        _mm_and_si128(s,a),"},
{"lineNum":"  242","line":"        _mm_andnot_si128(s,b));"},
{"lineNum":"  243","line":"#endif"},
{"lineNum":"  244","line":"}"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"/*****************************************************************************"},
{"lineNum":"  249","line":"*"},
{"lineNum":"  250","line":"*          Horizontal Boolean functions"},
{"lineNum":"  251","line":"*"},
{"lineNum":"  252","line":"*****************************************************************************/"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"// horizontal_and. Returns true if all bits are 1"},
{"lineNum":"  255","line":"static inline bool horizontal_and (Vec128b const & a) {"},
{"lineNum":"  256","line":"#if INSTRSET >= 5   // SSE4.1 supported. Use PTEST"},
{"lineNum":"  257","line":"    return _mm_testc_si128(a,_mm_set1_epi32(-1)) != 0;"},
{"lineNum":"  258","line":"#else"},
{"lineNum":"  259","line":"    __m128i t1 = _mm_unpackhi_epi64(a,a);                  // get 64 bits down"},
{"lineNum":"  260","line":"    __m128i t2 = _mm_and_si128(a,t1);                      // and 64 bits"},
{"lineNum":"  261","line":"#ifdef __x86_64__"},
{"lineNum":"  262","line":"    int64_t t5 = _mm_cvtsi128_si64(t2);                    // transfer 64 bits to integer"},
{"lineNum":"  263","line":"    return  t5 == int64_t(-1);"},
{"lineNum":"  264","line":"#else"},
{"lineNum":"  265","line":"    __m128i t3 = _mm_srli_epi64(t2,32);                    // get 32 bits down"},
{"lineNum":"  266","line":"    __m128i t4 = _mm_and_si128(t2,t3);                     // and 32 bits"},
{"lineNum":"  267","line":"    int     t5 = _mm_cvtsi128_si32(t4);                    // transfer 32 bits to integer"},
{"lineNum":"  268","line":"    return  t5 == -1;"},
{"lineNum":"  269","line":"#endif  // __x86_64__"},
{"lineNum":"  270","line":"#endif  // INSTRSET"},
{"lineNum":"  271","line":"}"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"// horizontal_or. Returns true if at least one bit is 1"},
{"lineNum":"  274","line":"static inline bool horizontal_or (Vec128b const & a) {"},
{"lineNum":"  275","line":"#if INSTRSET >= 5   // SSE4.1 supported. Use PTEST"},
{"lineNum":"  276","line":"    return ! _mm_testz_si128(a,a);"},
{"lineNum":"  277","line":"#else"},
{"lineNum":"  278","line":"    __m128i t1 = _mm_unpackhi_epi64(a,a);                  // get 64 bits down"},
{"lineNum":"  279","line":"    __m128i t2 = _mm_or_si128(a,t1);                       // and 64 bits"},
{"lineNum":"  280","line":"#ifdef __x86_64__"},
{"lineNum":"  281","line":"    int64_t t5 = _mm_cvtsi128_si64(t2);                    // transfer 64 bits to integer"},
{"lineNum":"  282","line":"    return  t5 != int64_t(0);"},
{"lineNum":"  283","line":"#else"},
{"lineNum":"  284","line":"    __m128i t3 = _mm_srli_epi64(t2,32);                    // get 32 bits down"},
{"lineNum":"  285","line":"    __m128i t4 = _mm_or_si128(t2,t3);                      // and 32 bits"},
{"lineNum":"  286","line":"    int     t5 = _mm_cvtsi128_si32(t4);                    // transfer to integer"},
{"lineNum":"  287","line":"    return  t5 != 0;"},
{"lineNum":"  288","line":"#endif  // __x86_64__"},
{"lineNum":"  289","line":"#endif  // INSTRSET"},
{"lineNum":"  290","line":"}"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"/*****************************************************************************"},
{"lineNum":"  295","line":"*"},
{"lineNum":"  296","line":"*          Vector of 16 8-bit signed integers"},
{"lineNum":"  297","line":"*"},
{"lineNum":"  298","line":"*****************************************************************************/"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"class Vec16c : public Vec128b {"},
{"lineNum":"  301","line":"public:"},
{"lineNum":"  302","line":"    // Default constructor:"},
{"lineNum":"  303","line":"    Vec16c() {"},
{"lineNum":"  304","line":"    }"},
{"lineNum":"  305","line":"    // Constructor to broadcast the same value into all elements:"},
{"lineNum":"  306","line":"    Vec16c(int i) {"},
{"lineNum":"  307","line":"        xmm = _mm_set1_epi8((char)i);"},
{"lineNum":"  308","line":"    }"},
{"lineNum":"  309","line":"    // Constructor to build from all elements:"},
{"lineNum":"  310","line":"    Vec16c(int8_t i0, int8_t i1, int8_t i2, int8_t i3, int8_t i4, int8_t i5, int8_t i6, int8_t i7,"},
{"lineNum":"  311","line":"        int8_t i8, int8_t i9, int8_t i10, int8_t i11, int8_t i12, int8_t i13, int8_t i14, int8_t i15) {"},
{"lineNum":"  312","line":"        xmm = _mm_setr_epi8(i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15);"},
{"lineNum":"  313","line":"    }"},
{"lineNum":"  314","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":"  315","line":"    Vec16c(__m128i const & x) {"},
{"lineNum":"  316","line":"        xmm = x;"},
{"lineNum":"  317","line":"    }"},
{"lineNum":"  318","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":"  319","line":"    Vec16c & operator = (__m128i const & x) {"},
{"lineNum":"  320","line":"        xmm = x;"},
{"lineNum":"  321","line":"        return *this;"},
{"lineNum":"  322","line":"    }"},
{"lineNum":"  323","line":"    // Type cast operator to convert to __m128i used in intrinsics"},
{"lineNum":"  324","line":"    operator __m128i() const {"},
{"lineNum":"  325","line":"        return xmm;"},
{"lineNum":"  326","line":"    }"},
{"lineNum":"  327","line":"    // Member function to load from array (unaligned)"},
{"lineNum":"  328","line":"    Vec16c & load(void const * p) {"},
{"lineNum":"  329","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":"  330","line":"        return *this;"},
{"lineNum":"  331","line":"    }"},
{"lineNum":"  332","line":"    // Member function to load from array (aligned)"},
{"lineNum":"  333","line":"    Vec16c & load_a(void const * p) {"},
{"lineNum":"  334","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":"  335","line":"        return *this;"},
{"lineNum":"  336","line":"    }"},
{"lineNum":"  337","line":"    // Partial load. Load n elements and set the rest to 0"},
{"lineNum":"  338","line":"    Vec16c & load_partial(int n, void const * p) {"},
{"lineNum":"  339","line":"#if INSTRSET >= 10  // AVX512VL + AVX512BW"},
{"lineNum":"  340","line":"        xmm = _mm_maskz_loadu_epi8(__mmask16((1u << n) - 1), p);"},
{"lineNum":"  341","line":"#else"},
{"lineNum":"  342","line":"        if      (n >= 16) load(p);"},
{"lineNum":"  343","line":"        else if (n <= 0)  *this = 0;"},
{"lineNum":"  344","line":"        else if (((int)(intptr_t)p & 0xFFF) < 0xFF0) {"},
{"lineNum":"  345","line":"            // p is at least 16 bytes from a page boundary. OK to read 16 bytes"},
{"lineNum":"  346","line":"            load(p);"},
{"lineNum":"  347","line":"        }"},
{"lineNum":"  348","line":"        else {"},
{"lineNum":"  349","line":"            // worst case. read 1 byte at a time and suffer store forwarding penalty"},
{"lineNum":"  350","line":"            char x[16];"},
{"lineNum":"  351","line":"            for (int i = 0; i < n; i++) x[i] = ((char const *)p)[i];"},
{"lineNum":"  352","line":"            load(x);"},
{"lineNum":"  353","line":"        }"},
{"lineNum":"  354","line":"        cutoff(n);"},
{"lineNum":"  355","line":"#endif"},
{"lineNum":"  356","line":"        return *this;"},
{"lineNum":"  357","line":"    }"},
{"lineNum":"  358","line":"    // Partial store. Store n elements"},
{"lineNum":"  359","line":"    void store_partial(int n, void * p) const {"},
{"lineNum":"  360","line":"#if INSTRSET >= 10  // AVX512VL + AVX512BW"},
{"lineNum":"  361","line":"        _mm_mask_storeu_epi8(p, __mmask16((1u << n) - 1), xmm);"},
{"lineNum":"  362","line":"#else"},
{"lineNum":"  363","line":"        if (n >= 16) {"},
{"lineNum":"  364","line":"            store(p);"},
{"lineNum":"  365","line":"            return;"},
{"lineNum":"  366","line":"        }"},
{"lineNum":"  367","line":"        if (n <= 0) return;"},
{"lineNum":"  368","line":"        // we are not using _mm_maskmoveu_si128 because it is too slow on many processors"},
{"lineNum":"  369","line":"        union {"},
{"lineNum":"  370","line":"            int8_t  c[16];"},
{"lineNum":"  371","line":"            int16_t s[8];"},
{"lineNum":"  372","line":"            int32_t i[4];"},
{"lineNum":"  373","line":"            int64_t q[2];"},
{"lineNum":"  374","line":"        } u;"},
{"lineNum":"  375","line":"        store(u.c);"},
{"lineNum":"  376","line":"        int j = 0;"},
{"lineNum":"  377","line":"        if (n & 8) {"},
{"lineNum":"  378","line":"            *(int64_t*)p = u.q[0];"},
{"lineNum":"  379","line":"            j += 8;"},
{"lineNum":"  380","line":"        }"},
{"lineNum":"  381","line":"        if (n & 4) {"},
{"lineNum":"  382","line":"            ((int32_t*)p)[j/4] = u.i[j/4];"},
{"lineNum":"  383","line":"            j += 4;"},
{"lineNum":"  384","line":"        }"},
{"lineNum":"  385","line":"        if (n & 2) {"},
{"lineNum":"  386","line":"            ((int16_t*)p)[j/2] = u.s[j/2];"},
{"lineNum":"  387","line":"            j += 2;"},
{"lineNum":"  388","line":"        }"},
{"lineNum":"  389","line":"        if (n & 1) {"},
{"lineNum":"  390","line":"            ((int8_t*)p)[j]    = u.c[j];"},
{"lineNum":"  391","line":"        }"},
{"lineNum":"  392","line":"#endif"},
{"lineNum":"  393","line":"    }"},
{"lineNum":"  394","line":"    // cut off vector to n elements. The last 16-n elements are set to zero"},
{"lineNum":"  395","line":"    Vec16c & cutoff(int n) {"},
{"lineNum":"  396","line":"#if INSTRSET >= 10"},
{"lineNum":"  397","line":"        xmm = _mm_maskz_mov_epi8(__mmask16((1u << n) - 1), xmm);"},
{"lineNum":"  398","line":"#else"},
{"lineNum":"  399","line":"        if (uint32_t(n) >= 16) return *this;"},
{"lineNum":"  400","line":"        static const char mask[32] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,"},
{"lineNum":"  401","line":"            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};"},
{"lineNum":"  402","line":"        *this &= Vec16c().load(mask+16-n);"},
{"lineNum":"  403","line":"#endif"},
{"lineNum":"  404","line":"        return *this;"},
{"lineNum":"  405","line":"    }"},
{"lineNum":"  406","line":"    // Member function to change a single element in vector"},
{"lineNum":"  407","line":"    Vec16c const & insert(int index, int8_t value) {"},
{"lineNum":"  408","line":"#if INSTRSET >= 10"},
{"lineNum":"  409","line":"        xmm = _mm_mask_set1_epi8(xmm, __mmask16(1u << index), value);"},
{"lineNum":"  410","line":"#else"},
{"lineNum":"  411","line":"        static const int8_t maskl[32] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"},
{"lineNum":"  412","line":"            -1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};"},
{"lineNum":"  413","line":"        __m128i broad = _mm_set1_epi8(value);  // broadcast value into all elements"},
{"lineNum":"  414","line":"        __m128i mask  = _mm_loadu_si128((__m128i const*)(maskl+16-(index & 0x0F))); // mask with FF at index position"},
{"lineNum":"  415","line":"        xmm = selectb(mask,broad,xmm);"},
{"lineNum":"  416","line":"#endif"},
{"lineNum":"  417","line":"        return *this;"},
{"lineNum":"  418","line":"    }"},
{"lineNum":"  419","line":"    /* Note: The extract(), insert(), size(), [], etc. all use int index for consistency."},
{"lineNum":"  420","line":"    An unsigned type for index might cause problems in case of underflow, for example:"},
{"lineNum":"  421","line":"    for (i = 0; i < a.size() - 4; i++) a[i] = ..."},
{"lineNum":"  422","line":"    This would go nuts if a.size() is 2."},
{"lineNum":"  423","line":"    */"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"    // Member function extract a single element from vector"},
{"lineNum":"  426","line":"    int8_t extract(int index) const {"},
{"lineNum":"  427","line":"#if INSTRSET >= 10 && defined (__AVX512VBMI2__)"},
{"lineNum":"  428","line":"        __m128i x = _mm_maskz_compress_epi8 (__mmask16(1u << index), xmm);"},
{"lineNum":"  429","line":"        return (int8_t)_mm_cvtsi128_si32(x);"},
{"lineNum":"  430","line":"#else"},
{"lineNum":"  431","line":"        int8_t x[16];"},
{"lineNum":"  432","line":"        store(x);"},
{"lineNum":"  433","line":"        return x[index & 0x0F];"},
{"lineNum":"  434","line":"#endif"},
{"lineNum":"  435","line":"    }"},
{"lineNum":"  436","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":"  437","line":"    // Operator [] can only read an element, not write."},
{"lineNum":"  438","line":"    int8_t operator [] (int index) const {"},
{"lineNum":"  439","line":"        return extract(index);"},
{"lineNum":"  440","line":"    }"},
{"lineNum":"  441","line":"    static int size() {"},
{"lineNum":"  442","line":"        return 16;"},
{"lineNum":"  443","line":"    }"},
{"lineNum":"  444","line":"    static int elementtype() {"},
{"lineNum":"  445","line":"        return 4;"},
{"lineNum":"  446","line":"    }"},
{"lineNum":"  447","line":"};"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"/*****************************************************************************"},
{"lineNum":"  450","line":"*"},
{"lineNum":"  451","line":"*          Vec16cb: Vector of 16 Booleans for use with Vec16c and Vec16uc"},
{"lineNum":"  452","line":"*"},
{"lineNum":"  453","line":"*****************************************************************************/"},
{"lineNum":"  454","line":""},
{"lineNum":"  455","line":"class Vec16cb : public Vec16c {"},
{"lineNum":"  456","line":"public:"},
{"lineNum":"  457","line":"    // Default constructor"},
{"lineNum":"  458","line":"    Vec16cb() {}"},
{"lineNum":"  459","line":"    // Constructor to build from all elements:"},
{"lineNum":"  460","line":"    Vec16cb(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7,"},
{"lineNum":"  461","line":"        bool x8, bool x9, bool x10, bool x11, bool x12, bool x13, bool x14, bool x15) {"},
{"lineNum":"  462","line":"        xmm = Vec16c(-int8_t(x0), -int8_t(x1), -int8_t(x2), -int8_t(x3), -int8_t(x4), -int8_t(x5), -int8_t(x6), -int8_t(x7),"},
{"lineNum":"  463","line":"            -int8_t(x8), -int8_t(x9), -int8_t(x10), -int8_t(x11), -int8_t(x12), -int8_t(x13), -int8_t(x14), -int8_t(x15));"},
{"lineNum":"  464","line":"    }"},
{"lineNum":"  465","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":"  466","line":"    Vec16cb(__m128i const & x) {"},
{"lineNum":"  467","line":"        xmm = x;"},
{"lineNum":"  468","line":"    }"},
{"lineNum":"  469","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":"  470","line":"    Vec16cb & operator = (__m128i const & x) {"},
{"lineNum":"  471","line":"        xmm = x;"},
{"lineNum":"  472","line":"        return *this;"},
{"lineNum":"  473","line":"    }"},
{"lineNum":"  474","line":"    // Constructor to broadcast scalar value:"},
{"lineNum":"  475","line":"    Vec16cb(bool b) : Vec16c(-int8_t(b)) {"},
{"lineNum":"  476","line":"    }"},
{"lineNum":"  477","line":"    // Assignment operator to broadcast scalar value:"},
{"lineNum":"  478","line":"    Vec16cb & operator = (bool b) {"},
{"lineNum":"  479","line":"        *this = Vec16cb(b);"},
{"lineNum":"  480","line":"        return *this;"},
{"lineNum":"  481","line":"    }"},
{"lineNum":"  482","line":"    // Member function to change a single element in vector"},
{"lineNum":"  483","line":"    Vec16cb & insert (int index, bool a) {"},
{"lineNum":"  484","line":"        Vec16c::insert(index, -(int)a);"},
{"lineNum":"  485","line":"        return *this;"},
{"lineNum":"  486","line":"    }"},
{"lineNum":"  487","line":"    // Member function to change a bitfield to a boolean vector"},
{"lineNum":"  488","line":"    Vec16cb & load_bits(uint16_t a) {"},
{"lineNum":"  489","line":"        uint16_t an = uint16_t(~a);      // invert because we have no compare-not-equal"},
{"lineNum":"  490","line":"#if  INSTRSET >= 4  // SSSE3 (PSHUFB available only under SSSE3)"},
{"lineNum":"  491","line":"        __m128i a1 = _mm_cvtsi32_si128(an);  // load into xmm register"},
{"lineNum":"  492","line":"        __m128i dist = constant4ui<0,0,0x01010101,0x01010101>();"},
{"lineNum":"  493","line":"        __m128i a2 = _mm_shuffle_epi8(a1, dist);  // one byte of a in each element"},
{"lineNum":"  494","line":"        __m128i mask = constant4ui<0x08040201,0x80402010,0x08040201,0x80402010>();"},
{"lineNum":"  495","line":"        __m128i a3 = _mm_and_si128(a2, mask); // isolate one bit in each byte"},
{"lineNum":"  496","line":"#else"},
{"lineNum":"  497","line":"        __m128i b1 = _mm_set1_epi8((int8_t)an);  // broadcast low byte"},
{"lineNum":"  498","line":"        __m128i b2 = _mm_set1_epi8((int8_t)(an >> 8));  // broadcast high byte"},
{"lineNum":"  499","line":"        __m128i m1 = constant4ui<0x08040201,0x80402010,0,0>();"},
{"lineNum":"  500","line":"        __m128i m2 = constant4ui<0,0,0x08040201,0x80402010>();"},
{"lineNum":"  501","line":"        __m128i c1 = _mm_and_si128(b1, m1); // isolate one bit in each byte of lower half"},
{"lineNum":"  502","line":"        __m128i c2 = _mm_and_si128(b2, m2); // isolate one bit in each byte of upper half"},
{"lineNum":"  503","line":"        __m128i a3 = _mm_or_si128(c1, c2);"},
{"lineNum":"  504","line":"#endif"},
{"lineNum":"  505","line":"        xmm = _mm_cmpeq_epi8(a3, _mm_setzero_si128());  // compare with 0"},
{"lineNum":"  506","line":"        return *this;"},
{"lineNum":"  507","line":"    }"},
{"lineNum":"  508","line":"    // Member function extract a single element from vector"},
{"lineNum":"  509","line":"    bool extract(int index) const {"},
{"lineNum":"  510","line":"        return Vec16c::extract(index) != 0;"},
{"lineNum":"  511","line":"    }"},
{"lineNum":"  512","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":"  513","line":"    // Operator [] can only read an element, not write."},
{"lineNum":"  514","line":"    bool operator [] (int index) const {"},
{"lineNum":"  515","line":"        return extract(index);"},
{"lineNum":"  516","line":"    }"},
{"lineNum":"  517","line":"    static int elementtype() {"},
{"lineNum":"  518","line":"        return 3;"},
{"lineNum":"  519","line":"    }"},
{"lineNum":"  520","line":"private: // Prevent constructing from int, etc."},
{"lineNum":"  521","line":"    Vec16cb(int b);"},
{"lineNum":"  522","line":"    Vec16cb & operator = (int x);"},
{"lineNum":"  523","line":"};"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":""},
{"lineNum":"  526","line":"/*****************************************************************************"},
{"lineNum":"  527","line":"*"},
{"lineNum":"  528","line":"*          Define operators for Vec16cb"},
{"lineNum":"  529","line":"*"},
{"lineNum":"  530","line":"*****************************************************************************/"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"// vector operator & : bitwise and"},
{"lineNum":"  533","line":"static inline Vec16cb operator & (Vec16cb const & a, Vec16cb const & b) {"},
{"lineNum":"  534","line":"    return Vec16cb(Vec128b(a) & Vec128b(b));"},
{"lineNum":"  535","line":"}"},
{"lineNum":"  536","line":"static inline Vec16cb operator && (Vec16cb const & a, Vec16cb const & b) {"},
{"lineNum":"  537","line":"    return a & b;"},
{"lineNum":"  538","line":"}"},
{"lineNum":"  539","line":"// vector operator &= : bitwise and"},
{"lineNum":"  540","line":"static inline Vec16cb & operator &= (Vec16cb & a, Vec16cb const & b) {"},
{"lineNum":"  541","line":"    a = a & b;"},
{"lineNum":"  542","line":"    return a;"},
{"lineNum":"  543","line":"}"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"// vector operator | : bitwise or"},
{"lineNum":"  546","line":"static inline Vec16cb operator | (Vec16cb const & a, Vec16cb const & b) {"},
{"lineNum":"  547","line":"    return Vec16cb(Vec128b(a) | Vec128b(b));"},
{"lineNum":"  548","line":"}"},
{"lineNum":"  549","line":"static inline Vec16cb operator || (Vec16cb const & a, Vec16cb const & b) {"},
{"lineNum":"  550","line":"    return a | b;"},
{"lineNum":"  551","line":"}"},
{"lineNum":"  552","line":"// vector operator |= : bitwise or"},
{"lineNum":"  553","line":"static inline Vec16cb & operator |= (Vec16cb & a, Vec16cb const & b) {"},
{"lineNum":"  554","line":"    a = a | b;"},
{"lineNum":"  555","line":"    return a;"},
{"lineNum":"  556","line":"}"},
{"lineNum":"  557","line":""},
{"lineNum":"  558","line":"// vector operator ^ : bitwise xor"},
{"lineNum":"  559","line":"static inline Vec16cb operator ^ (Vec16cb const & a, Vec16cb const & b) {"},
{"lineNum":"  560","line":"    return Vec16cb(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":"  561","line":"}"},
{"lineNum":"  562","line":""},
{"lineNum":"  563","line":"// vector operator ^= : bitwise xor"},
{"lineNum":"  564","line":"static inline Vec16cb & operator ^= (Vec16cb & a, Vec16cb const & b) {"},
{"lineNum":"  565","line":"    a = a ^ b;"},
{"lineNum":"  566","line":"    return a;"},
{"lineNum":"  567","line":"}"},
{"lineNum":"  568","line":""},
{"lineNum":"  569","line":"// vector operator == : xnor"},
{"lineNum":"  570","line":"static inline Vec16cb operator == (Vec16cb const & a, Vec16cb const & b) {"},
{"lineNum":"  571","line":"    return Vec16cb(a ^ (~b));"},
{"lineNum":"  572","line":"}"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"// vector operator != : xor"},
{"lineNum":"  575","line":"static inline Vec16cb operator != (Vec16cb const & a, Vec16cb const & b) {"},
{"lineNum":"  576","line":"    return Vec16cb(a ^ b);"},
{"lineNum":"  577","line":"}"},
{"lineNum":"  578","line":""},
{"lineNum":"  579","line":"// vector operator ~ : bitwise not"},
{"lineNum":"  580","line":"static inline Vec16cb operator ~ (Vec16cb const & a) {"},
{"lineNum":"  581","line":"    return Vec16cb( ~ Vec128b(a));"},
{"lineNum":"  582","line":"}"},
{"lineNum":"  583","line":""},
{"lineNum":"  584","line":"// vector operator ! : element not"},
{"lineNum":"  585","line":"static inline Vec16cb operator ! (Vec16cb const & a) {"},
{"lineNum":"  586","line":"    return ~ a;"},
{"lineNum":"  587","line":"}"},
{"lineNum":"  588","line":""},
{"lineNum":"  589","line":"// vector function andnot"},
{"lineNum":"  590","line":"static inline Vec16cb andnot (Vec16cb const & a, Vec16cb const & b) {"},
{"lineNum":"  591","line":"    return Vec16cb(andnot(Vec128b(a), Vec128b(b)));"},
{"lineNum":"  592","line":"}"},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"// Horizontal Boolean functions for Vec16cb"},
{"lineNum":"  595","line":""},
{"lineNum":"  596","line":"// horizontal_and. Returns true if all elements are true"},
{"lineNum":"  597","line":"static inline bool horizontal_and(Vec16cb const & a) {"},
{"lineNum":"  598","line":"    return _mm_movemask_epi8(a) == 0xFFFF;"},
{"lineNum":"  599","line":"}"},
{"lineNum":"  600","line":""},
{"lineNum":"  601","line":"// horizontal_or. Returns true if at least one element is true"},
{"lineNum":"  602","line":"static inline bool horizontal_or(Vec16cb const & a) {"},
{"lineNum":"  603","line":"#if INSTRSET >= 5   // SSE4.1 supported. Use PTEST"},
{"lineNum":"  604","line":"    return !_mm_testz_si128(a, a);"},
{"lineNum":"  605","line":"#else"},
{"lineNum":"  606","line":"    return _mm_movemask_epi8(a) != 0;"},
{"lineNum":"  607","line":"#endif"},
{"lineNum":"  608","line":"}"},
{"lineNum":"  609","line":""},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"/*****************************************************************************"},
{"lineNum":"  612","line":"*"},
{"lineNum":"  613","line":"*          Define operators for Vec16c"},
{"lineNum":"  614","line":"*"},
{"lineNum":"  615","line":"*****************************************************************************/"},
{"lineNum":"  616","line":""},
{"lineNum":"  617","line":"// vector operator + : add element by element"},
{"lineNum":"  618","line":"static inline Vec16c operator + (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  619","line":"    return _mm_add_epi8(a, b);"},
{"lineNum":"  620","line":"}"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"// vector operator += : add"},
{"lineNum":"  623","line":"static inline Vec16c & operator += (Vec16c & a, Vec16c const & b) {"},
{"lineNum":"  624","line":"    a = a + b;"},
{"lineNum":"  625","line":"    return a;"},
{"lineNum":"  626","line":"}"},
{"lineNum":"  627","line":""},
{"lineNum":"  628","line":"// postfix operator ++"},
{"lineNum":"  629","line":"static inline Vec16c operator ++ (Vec16c & a, int) {"},
{"lineNum":"  630","line":"    Vec16c a0 = a;"},
{"lineNum":"  631","line":"    a = a + 1;"},
{"lineNum":"  632","line":"    return a0;"},
{"lineNum":"  633","line":"}"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"// prefix operator ++"},
{"lineNum":"  636","line":"static inline Vec16c & operator ++ (Vec16c & a) {"},
{"lineNum":"  637","line":"    a = a + 1;"},
{"lineNum":"  638","line":"    return a;"},
{"lineNum":"  639","line":"}"},
{"lineNum":"  640","line":""},
{"lineNum":"  641","line":"// vector operator - : subtract element by element"},
{"lineNum":"  642","line":"static inline Vec16c operator - (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  643","line":"    return _mm_sub_epi8(a, b);"},
{"lineNum":"  644","line":"}"},
{"lineNum":"  645","line":""},
{"lineNum":"  646","line":"// vector operator - : unary minus"},
{"lineNum":"  647","line":"static inline Vec16c operator - (Vec16c const & a) {"},
{"lineNum":"  648","line":"    return _mm_sub_epi8(_mm_setzero_si128(), a);"},
{"lineNum":"  649","line":"}"},
{"lineNum":"  650","line":""},
{"lineNum":"  651","line":"// vector operator -= : add"},
{"lineNum":"  652","line":"static inline Vec16c & operator -= (Vec16c & a, Vec16c const & b) {"},
{"lineNum":"  653","line":"    a = a - b;"},
{"lineNum":"  654","line":"    return a;"},
{"lineNum":"  655","line":"}"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"// postfix operator --"},
{"lineNum":"  658","line":"static inline Vec16c operator -- (Vec16c & a, int) {"},
{"lineNum":"  659","line":"    Vec16c a0 = a;"},
{"lineNum":"  660","line":"    a = a - 1;"},
{"lineNum":"  661","line":"    return a0;"},
{"lineNum":"  662","line":"}"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"// prefix operator --"},
{"lineNum":"  665","line":"static inline Vec16c & operator -- (Vec16c & a) {"},
{"lineNum":"  666","line":"    a = a - 1;"},
{"lineNum":"  667","line":"    return a;"},
{"lineNum":"  668","line":"}"},
{"lineNum":"  669","line":""},
{"lineNum":"  670","line":"// vector operator * : multiply element by element"},
{"lineNum":"  671","line":"static inline Vec16c operator * (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  672","line":"    // There is no 8-bit multiply in SSE2. Split into two 16-bit multiplies"},
{"lineNum":"  673","line":"    __m128i aodd    = _mm_srli_epi16(a,8);                 // odd numbered elements of a"},
{"lineNum":"  674","line":"    __m128i bodd    = _mm_srli_epi16(b,8);                 // odd numbered elements of b"},
{"lineNum":"  675","line":"    __m128i muleven = _mm_mullo_epi16(a,b);                // product of even numbered elements"},
{"lineNum":"  676","line":"    __m128i mulodd  = _mm_mullo_epi16(aodd,bodd);          // product of odd  numbered elements"},
{"lineNum":"  677","line":"            mulodd  = _mm_slli_epi16(mulodd,8);            // put odd numbered elements back in place"},
{"lineNum":"  678","line":"#if INSTRSET >= 10   // AVX512VL + AVX512BW"},
{"lineNum":"  679","line":"    return _mm_mask_mov_epi8(mulodd, 0x5555, muleven);"},
{"lineNum":"  680","line":"#else"},
{"lineNum":"  681","line":"    __m128i mask    = _mm_set1_epi32(0x00FF00FF);          // mask for even positions"},
{"lineNum":"  682","line":"    return selectb(mask,muleven,mulodd);                   // interleave even and odd"},
{"lineNum":"  683","line":"#endif"},
{"lineNum":"  684","line":"}"},
{"lineNum":"  685","line":""},
{"lineNum":"  686","line":"// vector operator *= : multiply"},
{"lineNum":"  687","line":"static inline Vec16c & operator *= (Vec16c & a, Vec16c const & b) {"},
{"lineNum":"  688","line":"    a = a * b;"},
{"lineNum":"  689","line":"    return a;"},
{"lineNum":"  690","line":"}"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"// vector operator << : shift left all elements"},
{"lineNum":"  693","line":"static inline Vec16c operator << (Vec16c const & a, int b) {"},
{"lineNum":"  694","line":"    uint32_t mask = (uint32_t)0xFF >> (uint32_t)b;         // mask to remove bits that are shifted out"},
{"lineNum":"  695","line":"    __m128i am    = _mm_and_si128(a,_mm_set1_epi8((char)mask));  // remove bits that will overflow"},
{"lineNum":"  696","line":"    __m128i res   = _mm_sll_epi16(am,_mm_cvtsi32_si128(b));// 16-bit shifts"},
{"lineNum":"  697","line":"    return res;"},
{"lineNum":"  698","line":"}"},
{"lineNum":"  699","line":""},
{"lineNum":"  700","line":"// vector operator <<= : shift left"},
{"lineNum":"  701","line":"static inline Vec16c & operator <<= (Vec16c & a, int b) {"},
{"lineNum":"  702","line":"    a = a << b;"},
{"lineNum":"  703","line":"    return a;"},
{"lineNum":"  704","line":"}"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":"// vector operator >> : shift right arithmetic all elements"},
{"lineNum":"  707","line":"static inline Vec16c operator >> (Vec16c const & a, int b) {"},
{"lineNum":"  708","line":"    __m128i aeven = _mm_slli_epi16(a,8);                   // even numbered elements of a. get sign bit in position"},
{"lineNum":"  709","line":"            aeven = _mm_sra_epi16(aeven,_mm_cvtsi32_si128(b+8)); // shift arithmetic, back to position"},
{"lineNum":"  710","line":"    __m128i aodd  = _mm_sra_epi16(a,_mm_cvtsi32_si128(b)); // shift odd numbered elements arithmetic"},
{"lineNum":"  711","line":"#if INSTRSET >= 10   // AVX512VL + AVX512BW"},
{"lineNum":"  712","line":"    return _mm_mask_mov_epi8(aodd, 0x5555, aeven);"},
{"lineNum":"  713","line":"#else"},
{"lineNum":"  714","line":"    __m128i mask    = _mm_set1_epi32(0x00FF00FF);          // mask for even positions"},
{"lineNum":"  715","line":"    __m128i res     = selectb(mask,aeven,aodd);            // interleave even and odd"},
{"lineNum":"  716","line":"    return res;"},
{"lineNum":"  717","line":"#endif"},
{"lineNum":"  718","line":"}"},
{"lineNum":"  719","line":""},
{"lineNum":"  720","line":"// vector operator >>= : shift right arithmetic"},
{"lineNum":"  721","line":"static inline Vec16c & operator >>= (Vec16c & a, int b) {"},
{"lineNum":"  722","line":"    a = a >> b;"},
{"lineNum":"  723","line":"    return a;"},
{"lineNum":"  724","line":"}"},
{"lineNum":"  725","line":""},
{"lineNum":"  726","line":"// vector operator == : returns true for elements for which a == b"},
{"lineNum":"  727","line":"static inline Vec16cb operator == (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  728","line":"    return _mm_cmpeq_epi8(a,b);"},
{"lineNum":"  729","line":"}"},
{"lineNum":"  730","line":""},
{"lineNum":"  731","line":"// vector operator != : returns true for elements for which a != b"},
{"lineNum":"  732","line":"static inline Vec16cb operator != (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  733","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":"  734","line":"    return (Vec16cb)_mm_comneq_epi8(a,b);"},
{"lineNum":"  735","line":"#else  // SSE2 instruction set"},
{"lineNum":"  736","line":"    return Vec16cb(Vec16c(~(a == b)));"},
{"lineNum":"  737","line":"#endif"},
{"lineNum":"  738","line":"}"},
{"lineNum":"  739","line":""},
{"lineNum":"  740","line":"// vector operator > : returns true for elements for which a > b (signed)"},
{"lineNum":"  741","line":"static inline Vec16cb operator > (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  742","line":"    return _mm_cmpgt_epi8(a,b);"},
{"lineNum":"  743","line":"}"},
{"lineNum":"  744","line":""},
{"lineNum":"  745","line":"// vector operator < : returns true for elements for which a < b (signed)"},
{"lineNum":"  746","line":"static inline Vec16cb operator < (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  747","line":"    return b > a;"},
{"lineNum":"  748","line":"}"},
{"lineNum":"  749","line":""},
{"lineNum":"  750","line":"// vector operator >= : returns true for elements for which a >= b (signed)"},
{"lineNum":"  751","line":"static inline Vec16cb operator >= (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  752","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":"  753","line":"    return (Vec16cb)_mm_comge_epi8(a,b);"},
{"lineNum":"  754","line":"#else  // SSE2 instruction set"},
{"lineNum":"  755","line":"    return Vec16cb(Vec16c(~(b > a)));"},
{"lineNum":"  756","line":"#endif"},
{"lineNum":"  757","line":"}"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":"// vector operator <= : returns true for elements for which a <= b (signed)"},
{"lineNum":"  760","line":"static inline Vec16cb operator <= (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  761","line":"    return b >= a;"},
{"lineNum":"  762","line":"}"},
{"lineNum":"  763","line":""},
{"lineNum":"  764","line":"// vector operator & : bitwise and"},
{"lineNum":"  765","line":"static inline Vec16c operator & (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  766","line":"    return Vec16c(Vec128b(a) & Vec128b(b));"},
{"lineNum":"  767","line":"}"},
{"lineNum":"  768","line":"static inline Vec16c operator && (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  769","line":"    return a & b;"},
{"lineNum":"  770","line":"}"},
{"lineNum":"  771","line":"// vector operator &= : bitwise and"},
{"lineNum":"  772","line":"static inline Vec16c & operator &= (Vec16c & a, Vec16c const & b) {"},
{"lineNum":"  773","line":"    a = a & b;"},
{"lineNum":"  774","line":"    return a;"},
{"lineNum":"  775","line":"}"},
{"lineNum":"  776","line":""},
{"lineNum":"  777","line":"// vector operator | : bitwise or"},
{"lineNum":"  778","line":"static inline Vec16c operator | (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  779","line":"    return Vec16c(Vec128b(a) | Vec128b(b));"},
{"lineNum":"  780","line":"}"},
{"lineNum":"  781","line":"static inline Vec16c operator || (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  782","line":"    return a | b;"},
{"lineNum":"  783","line":"}"},
{"lineNum":"  784","line":"// vector operator |= : bitwise or"},
{"lineNum":"  785","line":"static inline Vec16c & operator |= (Vec16c & a, Vec16c const & b) {"},
{"lineNum":"  786","line":"    a = a | b;"},
{"lineNum":"  787","line":"    return a;"},
{"lineNum":"  788","line":"}"},
{"lineNum":"  789","line":""},
{"lineNum":"  790","line":"// vector operator ^ : bitwise xor"},
{"lineNum":"  791","line":"static inline Vec16c operator ^ (Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  792","line":"    return Vec16c(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":"  793","line":"}"},
{"lineNum":"  794","line":"// vector operator ^= : bitwise xor"},
{"lineNum":"  795","line":"static inline Vec16c & operator ^= (Vec16c & a, Vec16c const & b) {"},
{"lineNum":"  796","line":"    a = a ^ b;"},
{"lineNum":"  797","line":"    return a;"},
{"lineNum":"  798","line":"}"},
{"lineNum":"  799","line":""},
{"lineNum":"  800","line":"// vector operator ~ : bitwise not"},
{"lineNum":"  801","line":"static inline Vec16c operator ~ (Vec16c const & a) {"},
{"lineNum":"  802","line":"    return Vec16c( ~ Vec128b(a));"},
{"lineNum":"  803","line":"}"},
{"lineNum":"  804","line":""},
{"lineNum":"  805","line":"// vector operator ! : logical not, returns true for elements == 0"},
{"lineNum":"  806","line":"static inline Vec16cb operator ! (Vec16c const & a) {"},
{"lineNum":"  807","line":"    return _mm_cmpeq_epi8(a,_mm_setzero_si128());"},
{"lineNum":"  808","line":"}"},
{"lineNum":"  809","line":""},
{"lineNum":"  810","line":"// Functions for this class"},
{"lineNum":"  811","line":""},
{"lineNum":"  812","line":"// Select between two operands. Corresponds to this pseudocode:"},
{"lineNum":"  813","line":"// for (int i = 0; i < 16; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":"  814","line":"// Each byte in s must be either 0 (false) or -1 (true). No other values are allowed."},
{"lineNum":"  815","line":"static inline Vec16c select (Vec16cb const & s, Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  816","line":"    return selectb(s,a,b);"},
{"lineNum":"  817","line":"}"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]"},
{"lineNum":"  820","line":"static inline Vec16c if_add (Vec16cb const & f, Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  821","line":"    return a + (Vec16c(f) & b);"},
{"lineNum":"  822","line":"}"},
{"lineNum":"  823","line":""},
{"lineNum":"  824","line":"// Conditional sub: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]"},
{"lineNum":"  825","line":"static inline Vec16c if_sub (Vec16cb const & f, Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  826","line":"    return a - (Vec16c(f) & b);"},
{"lineNum":"  827","line":"}"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"// Conditional mul: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]"},
{"lineNum":"  830","line":"static inline Vec16c if_mul (Vec16cb const & f, Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  831","line":"    return select(f, a*b, a);"},
{"lineNum":"  832","line":"}"},
{"lineNum":"  833","line":""},
{"lineNum":"  834","line":"// Horizontal add: Calculates the sum of all vector elements."},
{"lineNum":"  835","line":"// Overflow will wrap around"},
{"lineNum":"  836","line":"static inline int32_t horizontal_add (Vec16c const & a) {"},
{"lineNum":"  837","line":"    __m128i sum1 = _mm_sad_epu8(a,_mm_setzero_si128());"},
{"lineNum":"  838","line":"    __m128i sum2 = _mm_unpackhi_epi64(sum1,sum1);"},
{"lineNum":"  839","line":"    __m128i sum3 = _mm_add_epi16(sum1,sum2);"},
{"lineNum":"  840","line":"    int8_t  sum4 = (int8_t)_mm_cvtsi128_si32(sum3);        // truncate to 8 bits"},
{"lineNum":"  841","line":"    return  sum4;                                          // sign extend to 32 bits"},
{"lineNum":"  842","line":"}"},
{"lineNum":"  843","line":""},
{"lineNum":"  844","line":"// Horizontal add extended: Calculates the sum of all vector elements."},
{"lineNum":"  845","line":"// Each element is sign-extended before addition to avoid overflow"},
{"lineNum":"  846","line":"static inline int32_t horizontal_add_x (Vec16c const & a) {"},
{"lineNum":"  847","line":"#ifdef __XOP__       // AMD XOP instruction set"},
{"lineNum":"  848","line":"    __m128i sum1  = _mm_haddq_epi8(a);"},
{"lineNum":"  849","line":"    __m128i sum2  = _mm_shuffle_epi32(sum1,0x0E);          // high element"},
{"lineNum":"  850","line":"    __m128i sum3  = _mm_add_epi32(sum1,sum2);              // sum"},
{"lineNum":"  851","line":"    return          _mm_cvtsi128_si32(sum3);"},
{"lineNum":"  852","line":"#else"},
{"lineNum":"  853","line":"    __m128i aeven = _mm_slli_epi16(a,8);                   // even numbered elements of a. get sign bit in position"},
{"lineNum":"  854","line":"            aeven = _mm_srai_epi16(aeven,8);               // sign extend even numbered elements"},
{"lineNum":"  855","line":"    __m128i aodd  = _mm_srai_epi16(a,8);                   // sign extend odd  numbered elements"},
{"lineNum":"  856","line":"    __m128i sum1  = _mm_add_epi16(aeven,aodd);             // add even and odd elements"},
{"lineNum":"  857","line":"    // The hadd instruction is inefficient, and may be split into two instructions for faster decoding"},
{"lineNum":"  858","line":"#if INSTRSET >= 4 && false // SSSE3"},
{"lineNum":"  859","line":"    __m128i sum2  = _mm_hadd_epi16(sum1,sum1);"},
{"lineNum":"  860","line":"    __m128i sum3  = _mm_hadd_epi16(sum2,sum2);"},
{"lineNum":"  861","line":"    __m128i sum4  = _mm_hadd_epi16(sum3,sum3);"},
{"lineNum":"  862","line":"#else"},
{"lineNum":"  863","line":"    __m128i sum2  = _mm_add_epi16(sum1,_mm_unpackhi_epi64(sum1,sum1));"},
{"lineNum":"  864","line":"    __m128i sum3  = _mm_add_epi16(sum2,_mm_shuffle_epi32(sum2,1));"},
{"lineNum":"  865","line":"    __m128i sum4  = _mm_add_epi16(sum3,_mm_shufflelo_epi16(sum3,1));"},
{"lineNum":"  866","line":"#endif"},
{"lineNum":"  867","line":"    int16_t sum5  = (int16_t)_mm_cvtsi128_si32(sum4);      // 16 bit sum"},
{"lineNum":"  868","line":"    return  sum5;                                          // sign extend to 32 bits"},
{"lineNum":"  869","line":"#endif"},
{"lineNum":"  870","line":"}"},
{"lineNum":"  871","line":""},
{"lineNum":"  872","line":""},
{"lineNum":"  873","line":"// function add_saturated: add element by element, signed with saturation"},
{"lineNum":"  874","line":"static inline Vec16c add_saturated(Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  875","line":"    return _mm_adds_epi8(a, b);"},
{"lineNum":"  876","line":"}"},
{"lineNum":"  877","line":""},
{"lineNum":"  878","line":"// function sub_saturated: subtract element by element, signed with saturation"},
{"lineNum":"  879","line":"static inline Vec16c sub_saturated(Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  880","line":"    return _mm_subs_epi8(a, b);"},
{"lineNum":"  881","line":"}"},
{"lineNum":"  882","line":""},
{"lineNum":"  883","line":"// function max: a > b ? a : b"},
{"lineNum":"  884","line":"static inline Vec16c max(Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  885","line":"#if INSTRSET >= 5   // SSE4.1"},
{"lineNum":"  886","line":"    return _mm_max_epi8(a,b);"},
{"lineNum":"  887","line":"#else  // SSE2"},
{"lineNum":"  888","line":"    __m128i signbit = _mm_set1_epi32(0x80808080);"},
{"lineNum":"  889","line":"    __m128i a1      = _mm_xor_si128(a,signbit);            // add 0x80"},
{"lineNum":"  890","line":"    __m128i b1      = _mm_xor_si128(b,signbit);            // add 0x80"},
{"lineNum":"  891","line":"    __m128i m1      = _mm_max_epu8(a1,b1);                 // unsigned max"},
{"lineNum":"  892","line":"    return  _mm_xor_si128(m1,signbit);                     // sub 0x80"},
{"lineNum":"  893","line":"#endif"},
{"lineNum":"  894","line":"}"},
{"lineNum":"  895","line":""},
{"lineNum":"  896","line":"// function min: a < b ? a : b"},
{"lineNum":"  897","line":"static inline Vec16c min(Vec16c const & a, Vec16c const & b) {"},
{"lineNum":"  898","line":"#if INSTRSET >= 5   // SSE4.1"},
{"lineNum":"  899","line":"    return _mm_min_epi8(a,b);"},
{"lineNum":"  900","line":"#else  // SSE2"},
{"lineNum":"  901","line":"    __m128i signbit = _mm_set1_epi32(0x80808080);"},
{"lineNum":"  902","line":"    __m128i a1      = _mm_xor_si128(a,signbit);            // add 0x80"},
{"lineNum":"  903","line":"    __m128i b1      = _mm_xor_si128(b,signbit);            // add 0x80"},
{"lineNum":"  904","line":"    __m128i m1      = _mm_min_epu8(a1,b1);                 // unsigned min"},
{"lineNum":"  905","line":"    return  _mm_xor_si128(m1,signbit);                     // sub 0x80"},
{"lineNum":"  906","line":"#endif"},
{"lineNum":"  907","line":"}"},
{"lineNum":"  908","line":""},
{"lineNum":"  909","line":"// function abs: a >= 0 ? a : -a"},
{"lineNum":"  910","line":"static inline Vec16c abs(Vec16c const & a) {"},
{"lineNum":"  911","line":"#if INSTRSET >= 4     // SSSE3 supported"},
{"lineNum":"  912","line":"    return _mm_abs_epi8(a);"},
{"lineNum":"  913","line":"#else                 // SSE2"},
{"lineNum":"  914","line":"    __m128i nega = _mm_sub_epi8(_mm_setzero_si128(), a);"},
{"lineNum":"  915","line":"    return _mm_min_epu8(a, nega);   // unsigned min (the negative value is bigger when compared as unsigned)"},
{"lineNum":"  916","line":"#endif"},
{"lineNum":"  917","line":"}"},
{"lineNum":"  918","line":""},
{"lineNum":"  919","line":"// function abs_saturated: same as abs, saturate if overflow"},
{"lineNum":"  920","line":"static inline Vec16c abs_saturated(Vec16c const & a) {"},
{"lineNum":"  921","line":"    __m128i absa   = abs(a);                               // abs(a)"},
{"lineNum":"  922","line":"    __m128i overfl = _mm_cmpgt_epi8(_mm_setzero_si128(),absa);// 0 > a"},
{"lineNum":"  923","line":"    return           _mm_add_epi8(absa,overfl);            // subtract 1 if 0x80"},
{"lineNum":"  924","line":"}"},
{"lineNum":"  925","line":""},
{"lineNum":"  926","line":"// function rotate_left: rotate each element left by b bits"},
{"lineNum":"  927","line":"// Use negative count to rotate right"},
{"lineNum":"  928","line":"static inline Vec16c rotate_left(Vec16c const & a, int b) {"},
{"lineNum":"  929","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":"  930","line":"    return (Vec16c)_mm_rot_epi8(a,_mm_set1_epi8(b));"},
{"lineNum":"  931","line":"#else  // SSE2 instruction set"},
{"lineNum":"  932","line":"    uint8_t mask = 0xFFu << b;                     // mask off overflow bits"},
{"lineNum":"  933","line":"    __m128i m     = _mm_set1_epi8(mask);"},
{"lineNum":"  934","line":"    __m128i bb    = _mm_cvtsi32_si128(b & 7);      // b modulo 8"},
{"lineNum":"  935","line":"    __m128i mbb   = _mm_cvtsi32_si128((- b) & 7);  // 8-b modulo 8"},
{"lineNum":"  936","line":"    __m128i left  = _mm_sll_epi16(a, bb);          // a << b"},
{"lineNum":"  937","line":"    __m128i right = _mm_srl_epi16(a, mbb);         // a >> 8-b"},
{"lineNum":"  938","line":"    left  = _mm_and_si128(m, left);                // mask off overflow bits"},
{"lineNum":"  939","line":"    right = _mm_andnot_si128(m, right);"},
{"lineNum":"  940","line":"    return  _mm_or_si128(left, right);             // combine left and right shifted bits"},
{"lineNum":"  941","line":"#endif"},
{"lineNum":"  942","line":"}"},
{"lineNum":"  943","line":""},
{"lineNum":"  944","line":""},
{"lineNum":"  945","line":"/*****************************************************************************"},
{"lineNum":"  946","line":"*"},
{"lineNum":"  947","line":"*          Vector of 16 8-bit unsigned integers"},
{"lineNum":"  948","line":"*"},
{"lineNum":"  949","line":"*****************************************************************************/"},
{"lineNum":"  950","line":""},
{"lineNum":"  951","line":"class Vec16uc : public Vec16c {"},
{"lineNum":"  952","line":"public:"},
{"lineNum":"  953","line":"    // Default constructor:"},
{"lineNum":"  954","line":"    Vec16uc() {"},
{"lineNum":"  955","line":"    }"},
{"lineNum":"  956","line":"    // Constructor to broadcast the same value into all elements:"},
{"lineNum":"  957","line":"    Vec16uc(uint32_t i) {"},
{"lineNum":"  958","line":"        xmm = _mm_set1_epi8((char)i);"},
{"lineNum":"  959","line":"    }"},
{"lineNum":"  960","line":"    // Constructor to build from all elements:"},
{"lineNum":"  961","line":"    Vec16uc(uint8_t i0, uint8_t i1, uint8_t i2, uint8_t i3, uint8_t i4, uint8_t i5, uint8_t i6, uint8_t i7,"},
{"lineNum":"  962","line":"        uint8_t i8, uint8_t i9, uint8_t i10, uint8_t i11, uint8_t i12, uint8_t i13, uint8_t i14, uint8_t i15) {"},
{"lineNum":"  963","line":"        xmm = _mm_setr_epi8((int8_t)i0, (int8_t)i1, (int8_t)i2, (int8_t)i3, (int8_t)i4, (int8_t)i5, (int8_t)i6,"},
{"lineNum":"  964","line":"            (int8_t)i7, (int8_t)i8, (int8_t)i9, (int8_t)i10, (int8_t)i11, (int8_t)i12, (int8_t)i13, (int8_t)i14, (int8_t)i15);"},
{"lineNum":"  965","line":"    }"},
{"lineNum":"  966","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":"  967","line":"    Vec16uc(__m128i const & x) {"},
{"lineNum":"  968","line":"        xmm = x;"},
{"lineNum":"  969","line":"    }"},
{"lineNum":"  970","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":"  971","line":"    Vec16uc & operator = (__m128i const & x) {"},
{"lineNum":"  972","line":"        xmm = x;"},
{"lineNum":"  973","line":"        return *this;"},
{"lineNum":"  974","line":"    }"},
{"lineNum":"  975","line":"    // Member function to load from array (unaligned)"},
{"lineNum":"  976","line":"    Vec16uc & load(void const * p) {"},
{"lineNum":"  977","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":"  978","line":"        return *this;"},
{"lineNum":"  979","line":"    }"},
{"lineNum":"  980","line":"    // Member function to load from array (aligned)"},
{"lineNum":"  981","line":"    Vec16uc & load_a(void const * p) {"},
{"lineNum":"  982","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":"  983","line":"        return *this;"},
{"lineNum":"  984","line":"    }"},
{"lineNum":"  985","line":"    // Member function to change a single element in vector"},
{"lineNum":"  986","line":"    // Note: This function is inefficient. Use load function if changing more than one element"},
{"lineNum":"  987","line":"    Vec16uc const & insert(int index, uint8_t value) {"},
{"lineNum":"  988","line":"        Vec16c::insert(index, (int8_t)value);"},
{"lineNum":"  989","line":"        return *this;"},
{"lineNum":"  990","line":"    }"},
{"lineNum":"  991","line":"    // Member function extract a single element from vector"},
{"lineNum":"  992","line":"    uint8_t extract(int index) const {"},
{"lineNum":"  993","line":"        return uint8_t(Vec16c::extract(index));"},
{"lineNum":"  994","line":"    }"},
{"lineNum":"  995","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":"  996","line":"    // Operator [] can only read an element, not write."},
{"lineNum":"  997","line":"    uint8_t operator [] (int index) const {"},
{"lineNum":"  998","line":"        return extract(index);"},
{"lineNum":"  999","line":"    }"},
{"lineNum":" 1000","line":"    static int elementtype() {"},
{"lineNum":" 1001","line":"        return 5;"},
{"lineNum":" 1002","line":"    }"},
{"lineNum":" 1003","line":"};"},
{"lineNum":" 1004","line":""},
{"lineNum":" 1005","line":"// Define operators for this class"},
{"lineNum":" 1006","line":""},
{"lineNum":" 1007","line":"// vector operator << : shift left all elements"},
{"lineNum":" 1008","line":"static inline Vec16uc operator << (Vec16uc const & a, uint32_t b) {"},
{"lineNum":" 1009","line":"    uint32_t mask = (uint32_t)0xFF >> (uint32_t)b;               // mask to remove bits that are shifted out"},
{"lineNum":" 1010","line":"    __m128i am    = _mm_and_si128(a,_mm_set1_epi8((char)mask));  // remove bits that will overflow"},
{"lineNum":" 1011","line":"    __m128i res   = _mm_sll_epi16(am,_mm_cvtsi32_si128((int)b)); // 16-bit shifts"},
{"lineNum":" 1012","line":"    return res;"},
{"lineNum":" 1013","line":"}"},
{"lineNum":" 1014","line":""},
{"lineNum":" 1015","line":"// vector operator << : shift left all elements"},
{"lineNum":" 1016","line":"static inline Vec16uc operator << (Vec16uc const & a, int32_t b) {"},
{"lineNum":" 1017","line":"    return a << (uint32_t)b;"},
{"lineNum":" 1018","line":"}"},
{"lineNum":" 1019","line":""},
{"lineNum":" 1020","line":"// vector operator >> : shift right logical all elements"},
{"lineNum":" 1021","line":"static inline Vec16uc operator >> (Vec16uc const & a, uint32_t b) {"},
{"lineNum":" 1022","line":"    uint32_t mask = (uint32_t)0xFF << (uint32_t)b;               // mask to remove bits that are shifted out"},
{"lineNum":" 1023","line":"    __m128i am    = _mm_and_si128(a,_mm_set1_epi8((char)mask));  // remove bits that will overflow"},
{"lineNum":" 1024","line":"    __m128i res   = _mm_srl_epi16(am,_mm_cvtsi32_si128((int)b)); // 16-bit shifts"},
{"lineNum":" 1025","line":"    return res;"},
{"lineNum":" 1026","line":"}"},
{"lineNum":" 1027","line":""},
{"lineNum":" 1028","line":"// vector operator >> : shift right logical all elements"},
{"lineNum":" 1029","line":"static inline Vec16uc operator >> (Vec16uc const & a, int32_t b) {"},
{"lineNum":" 1030","line":"    return a >> (uint32_t)b;"},
{"lineNum":" 1031","line":"}"},
{"lineNum":" 1032","line":""},
{"lineNum":" 1033","line":"// vector operator >>= : shift right logical"},
{"lineNum":" 1034","line":"static inline Vec16uc & operator >>= (Vec16uc & a, int b) {"},
{"lineNum":" 1035","line":"    a = a >> b;"},
{"lineNum":" 1036","line":"    return a;"},
{"lineNum":" 1037","line":"}"},
{"lineNum":" 1038","line":""},
{"lineNum":" 1039","line":"// vector operator >= : returns true for elements for which a >= b (unsigned)"},
{"lineNum":" 1040","line":"static inline Vec16cb operator >= (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1041","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 1042","line":"    return (Vec16cb)_mm_comge_epu8(a,b);"},
{"lineNum":" 1043","line":"#else  // SSE2 instruction set"},
{"lineNum":" 1044","line":"    return (Vec16cb)_mm_cmpeq_epi8(_mm_max_epu8(a,b),a); // a == max(a,b)"},
{"lineNum":" 1045","line":"#endif"},
{"lineNum":" 1046","line":"}"},
{"lineNum":" 1047","line":""},
{"lineNum":" 1048","line":"// vector operator <= : returns true for elements for which a <= b (unsigned)"},
{"lineNum":" 1049","line":"static inline Vec16cb operator <= (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1050","line":"    return b >= a;"},
{"lineNum":" 1051","line":"}"},
{"lineNum":" 1052","line":""},
{"lineNum":" 1053","line":"// vector operator > : returns true for elements for which a > b (unsigned)"},
{"lineNum":" 1054","line":"static inline Vec16cb operator > (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1055","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 1056","line":"    return (Vec16cb)_mm_comgt_epu8(a,b);"},
{"lineNum":" 1057","line":"#else  // SSE2 instruction set"},
{"lineNum":" 1058","line":"    return Vec16cb(Vec16c(~(b >= a)));"},
{"lineNum":" 1059","line":"#endif"},
{"lineNum":" 1060","line":"}"},
{"lineNum":" 1061","line":""},
{"lineNum":" 1062","line":"// vector operator < : returns true for elements for which a < b (unsigned)"},
{"lineNum":" 1063","line":"static inline Vec16cb operator < (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1064","line":"    return b > a;"},
{"lineNum":" 1065","line":"}"},
{"lineNum":" 1066","line":""},
{"lineNum":" 1067","line":"// vector operator + : add"},
{"lineNum":" 1068","line":"static inline Vec16uc operator + (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1069","line":"    return Vec16uc (Vec16c(a) + Vec16c(b));"},
{"lineNum":" 1070","line":"}"},
{"lineNum":" 1071","line":""},
{"lineNum":" 1072","line":"// vector operator - : subtract"},
{"lineNum":" 1073","line":"static inline Vec16uc operator - (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1074","line":"    return Vec16uc (Vec16c(a) - Vec16c(b));"},
{"lineNum":" 1075","line":"}"},
{"lineNum":" 1076","line":""},
{"lineNum":" 1077","line":"// vector operator * : multiply"},
{"lineNum":" 1078","line":"static inline Vec16uc operator * (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1079","line":"    return Vec16uc (Vec16c(a) * Vec16c(b));"},
{"lineNum":" 1080","line":"}"},
{"lineNum":" 1081","line":""},
{"lineNum":" 1082","line":"// vector operator & : bitwise and"},
{"lineNum":" 1083","line":"static inline Vec16uc operator & (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1084","line":"    return Vec16uc(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 1085","line":"}"},
{"lineNum":" 1086","line":"static inline Vec16uc operator && (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1087","line":"    return a & b;"},
{"lineNum":" 1088","line":"}"},
{"lineNum":" 1089","line":""},
{"lineNum":" 1090","line":"// vector operator | : bitwise or"},
{"lineNum":" 1091","line":"static inline Vec16uc operator | (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1092","line":"    return Vec16uc(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 1093","line":"}"},
{"lineNum":" 1094","line":"static inline Vec16uc operator || (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1095","line":"    return a | b;"},
{"lineNum":" 1096","line":"}"},
{"lineNum":" 1097","line":""},
{"lineNum":" 1098","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 1099","line":"static inline Vec16uc operator ^ (Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1100","line":"    return Vec16uc(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 1101","line":"}"},
{"lineNum":" 1102","line":""},
{"lineNum":" 1103","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 1104","line":"static inline Vec16uc operator ~ (Vec16uc const & a) {"},
{"lineNum":" 1105","line":"    return Vec16uc( ~ Vec128b(a));"},
{"lineNum":" 1106","line":"}"},
{"lineNum":" 1107","line":""},
{"lineNum":" 1108","line":"// Functions for this class"},
{"lineNum":" 1109","line":""},
{"lineNum":" 1110","line":"// Select between two operands. Corresponds to this pseudocode:"},
{"lineNum":" 1111","line":"// for (int i = 0; i < 16; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":" 1112","line":"// Each byte in s must be either 0 (false) or -1 (true). No other values are allowed."},
{"lineNum":" 1113","line":"// (s is signed)"},
{"lineNum":" 1114","line":"static inline Vec16uc select (Vec16cb const & s, Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1115","line":"    return selectb(s,a,b);"},
{"lineNum":" 1116","line":"}"},
{"lineNum":" 1117","line":""},
{"lineNum":" 1118","line":"// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]"},
{"lineNum":" 1119","line":"static inline Vec16uc if_add (Vec16cb const & f, Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1120","line":"    return a + (Vec16uc(f) & b);"},
{"lineNum":" 1121","line":"}"},
{"lineNum":" 1122","line":""},
{"lineNum":" 1123","line":"// Conditional sub: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]"},
{"lineNum":" 1124","line":"static inline Vec16uc if_sub (Vec16cb const & f, Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1125","line":"    return a - (Vec16uc(f) & b);"},
{"lineNum":" 1126","line":"}"},
{"lineNum":" 1127","line":""},
{"lineNum":" 1128","line":"// Conditional mul: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]"},
{"lineNum":" 1129","line":"static inline Vec16uc if_mul (Vec16cb const & f, Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1130","line":"    return select(f, a*b, a);"},
{"lineNum":" 1131","line":"}"},
{"lineNum":" 1132","line":""},
{"lineNum":" 1133","line":"// Horizontal add: Calculates the sum of all vector elements."},
{"lineNum":" 1134","line":"// Overflow will wrap around"},
{"lineNum":" 1135","line":"// (Note: horizontal_add_x(Vec16uc) is slightly faster)"},
{"lineNum":" 1136","line":"static inline uint32_t horizontal_add (Vec16uc const & a) {"},
{"lineNum":" 1137","line":"    __m128i sum1 = _mm_sad_epu8(a,_mm_setzero_si128());"},
{"lineNum":" 1138","line":"    __m128i sum2 = _mm_unpackhi_epi64(sum1,sum1);"},
{"lineNum":" 1139","line":"    __m128i sum3 = _mm_add_epi16(sum1,sum2);"},
{"lineNum":" 1140","line":"    uint16_t sum4 = (uint16_t)_mm_cvtsi128_si32(sum3);      // truncate to 16 bits"},
{"lineNum":" 1141","line":"    return  sum4;"},
{"lineNum":" 1142","line":"}"},
{"lineNum":" 1143","line":""},
{"lineNum":" 1144","line":"// Horizontal add extended: Calculates the sum of all vector elements."},
{"lineNum":" 1145","line":"// Each element is zero-extended before addition to avoid overflow"},
{"lineNum":" 1146","line":"static inline uint32_t horizontal_add_x (Vec16uc const & a) {"},
{"lineNum":" 1147","line":"    __m128i sum1 = _mm_sad_epu8(a,_mm_setzero_si128());"},
{"lineNum":" 1148","line":"    __m128i sum2 = _mm_unpackhi_epi64(sum1,sum1);"},
{"lineNum":" 1149","line":"    __m128i sum3 = _mm_add_epi16(sum1,sum2);"},
{"lineNum":" 1150","line":"    return (uint32_t)_mm_cvtsi128_si32(sum3);"},
{"lineNum":" 1151","line":"}"},
{"lineNum":" 1152","line":""},
{"lineNum":" 1153","line":"// function add_saturated: add element by element, unsigned with saturation"},
{"lineNum":" 1154","line":"static inline Vec16uc add_saturated(Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1155","line":"    return _mm_adds_epu8(a, b);"},
{"lineNum":" 1156","line":"}"},
{"lineNum":" 1157","line":""},
{"lineNum":" 1158","line":"// function sub_saturated: subtract element by element, unsigned with saturation"},
{"lineNum":" 1159","line":"static inline Vec16uc sub_saturated(Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1160","line":"    return _mm_subs_epu8(a, b);"},
{"lineNum":" 1161","line":"}"},
{"lineNum":" 1162","line":""},
{"lineNum":" 1163","line":"// function max: a > b ? a : b"},
{"lineNum":" 1164","line":"static inline Vec16uc max(Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1165","line":"    return _mm_max_epu8(a,b);"},
{"lineNum":" 1166","line":"}"},
{"lineNum":" 1167","line":""},
{"lineNum":" 1168","line":"// function min: a < b ? a : b"},
{"lineNum":" 1169","line":"static inline Vec16uc min(Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 1170","line":"    return _mm_min_epu8(a,b);"},
{"lineNum":" 1171","line":"}"},
{"lineNum":" 1172","line":""},
{"lineNum":" 1173","line":""},
{"lineNum":" 1174","line":""},
{"lineNum":" 1175","line":"/*****************************************************************************"},
{"lineNum":" 1176","line":"*"},
{"lineNum":" 1177","line":"*          Vector of 8 16-bit signed integers"},
{"lineNum":" 1178","line":"*"},
{"lineNum":" 1179","line":"*****************************************************************************/"},
{"lineNum":" 1180","line":""},
{"lineNum":" 1181","line":"class Vec8s : public Vec128b {"},
{"lineNum":" 1182","line":"public:"},
{"lineNum":" 1183","line":"    // Default constructor:"},
{"lineNum":" 1184","line":"    Vec8s() {"},
{"lineNum":" 1185","line":"    }"},
{"lineNum":" 1186","line":"    // Constructor to broadcast the same value into all elements:"},
{"lineNum":" 1187","line":"    Vec8s(int i) {"},
{"lineNum":" 1188","line":"        xmm = _mm_set1_epi16((int16_t)i);"},
{"lineNum":" 1189","line":"    }"},
{"lineNum":" 1190","line":"    // Constructor to build from all elements:"},
{"lineNum":" 1191","line":"    Vec8s(int16_t i0, int16_t i1, int16_t i2, int16_t i3, int16_t i4, int16_t i5, int16_t i6, int16_t i7) {"},
{"lineNum":" 1192","line":"        xmm = _mm_setr_epi16(i0, i1, i2, i3, i4, i5, i6, i7);"},
{"lineNum":" 1193","line":"    }"},
{"lineNum":" 1194","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 1195","line":"    Vec8s(__m128i const & x) {"},
{"lineNum":" 1196","line":"        xmm = x;"},
{"lineNum":" 1197","line":"    }"},
{"lineNum":" 1198","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 1199","line":"    Vec8s & operator = (__m128i const & x) {"},
{"lineNum":" 1200","line":"        xmm = x;"},
{"lineNum":" 1201","line":"        return *this;"},
{"lineNum":" 1202","line":"    }"},
{"lineNum":" 1203","line":"    // Type cast operator to convert to __m128i used in intrinsics"},
{"lineNum":" 1204","line":"    operator __m128i() const {"},
{"lineNum":" 1205","line":"        return xmm;"},
{"lineNum":" 1206","line":"    }"},
{"lineNum":" 1207","line":"    // Member function to load from array (unaligned)"},
{"lineNum":" 1208","line":"    Vec8s & load(void const * p) {"},
{"lineNum":" 1209","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":" 1210","line":"        return *this;"},
{"lineNum":" 1211","line":"    }"},
{"lineNum":" 1212","line":"    // Member function to load from array (aligned)"},
{"lineNum":" 1213","line":"    Vec8s & load_a(void const * p) {"},
{"lineNum":" 1214","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":" 1215","line":"        return *this;"},
{"lineNum":" 1216","line":"    }"},
{"lineNum":" 1217","line":"    // Partial load. Load n elements and set the rest to 0"},
{"lineNum":" 1218","line":"    Vec8s & load_partial(int n, void const * p) {"},
{"lineNum":" 1219","line":"#if INSTRSET >= 10  // AVX512VL + AVX512BW"},
{"lineNum":" 1220","line":"        xmm = _mm_maskz_loadu_epi16(__mmask8((1u << n) - 1), p);"},
{"lineNum":" 1221","line":"#else"},
{"lineNum":" 1222","line":"        if      (n >= 8) load(p);"},
{"lineNum":" 1223","line":"        else if (n <= 0)  *this = 0;"},
{"lineNum":" 1224","line":"        else if (((int)(intptr_t)p & 0xFFF) < 0xFF0) {"},
{"lineNum":" 1225","line":"            // p is at least 16 bytes from a page boundary. OK to read 16 bytes"},
{"lineNum":" 1226","line":"            load(p);"},
{"lineNum":" 1227","line":"        }"},
{"lineNum":" 1228","line":"        else {"},
{"lineNum":" 1229","line":"            // worst case. read 1 byte at a time and suffer store forwarding penalty"},
{"lineNum":" 1230","line":"            int16_t x[8];"},
{"lineNum":" 1231","line":"            for (int i = 0; i < n; i++) x[i] = ((int16_t const *)p)[i];"},
{"lineNum":" 1232","line":"            load(x);"},
{"lineNum":" 1233","line":"        }"},
{"lineNum":" 1234","line":"        cutoff(n);"},
{"lineNum":" 1235","line":"#endif"},
{"lineNum":" 1236","line":"        return *this;"},
{"lineNum":" 1237","line":"    }"},
{"lineNum":" 1238","line":"    // Partial store. Store n elements"},
{"lineNum":" 1239","line":"    void store_partial(int n, void * p) const {"},
{"lineNum":" 1240","line":"#if INSTRSET >= 10  // AVX512VL + AVX512BW"},
{"lineNum":" 1241","line":"        _mm_mask_storeu_epi16(p, __mmask8((1u << n) - 1), xmm);"},
{"lineNum":" 1242","line":"#else"},
{"lineNum":" 1243","line":"        if (n >= 8) {"},
{"lineNum":" 1244","line":"            store(p);"},
{"lineNum":" 1245","line":"            return;"},
{"lineNum":" 1246","line":"        }"},
{"lineNum":" 1247","line":"        if (n <= 0) return;"},
{"lineNum":" 1248","line":"        // we are not using _mm_maskmoveu_si128 because it is too slow on many processors"},
{"lineNum":" 1249","line":"        union {"},
{"lineNum":" 1250","line":"            int8_t  c[16];"},
{"lineNum":" 1251","line":"            int16_t s[8];"},
{"lineNum":" 1252","line":"            int32_t i[4];"},
{"lineNum":" 1253","line":"            int64_t q[2];"},
{"lineNum":" 1254","line":"        } u;"},
{"lineNum":" 1255","line":"        store(u.c);"},
{"lineNum":" 1256","line":"        int j = 0;"},
{"lineNum":" 1257","line":"        if (n & 4) {"},
{"lineNum":" 1258","line":"            *(int64_t*)p = u.q[0];"},
{"lineNum":" 1259","line":"            j += 8;"},
{"lineNum":" 1260","line":"        }"},
{"lineNum":" 1261","line":"        if (n & 2) {"},
{"lineNum":" 1262","line":"            ((int32_t*)p)[j/4] = u.i[j/4];"},
{"lineNum":" 1263","line":"            j += 4;"},
{"lineNum":" 1264","line":"        }"},
{"lineNum":" 1265","line":"        if (n & 1) {"},
{"lineNum":" 1266","line":"            ((int16_t*)p)[j/2] = u.s[j/2];"},
{"lineNum":" 1267","line":"        }"},
{"lineNum":" 1268","line":"#endif"},
{"lineNum":" 1269","line":"    }"},
{"lineNum":" 1270","line":"    // cut off vector to n elements. The last 8-n elements are set to zero"},
{"lineNum":" 1271","line":"    Vec8s & cutoff(int n) {"},
{"lineNum":" 1272","line":"#if INSTRSET >= 10"},
{"lineNum":" 1273","line":"        xmm = _mm_maskz_mov_epi16(__mmask8((1u << n) - 1), xmm);"},
{"lineNum":" 1274","line":"#else"},
{"lineNum":" 1275","line":"        *this = Vec16c(xmm).cutoff(n * 2);"},
{"lineNum":" 1276","line":"#endif"},
{"lineNum":" 1277","line":"        return *this;"},
{"lineNum":" 1278","line":"    }"},
{"lineNum":" 1279","line":"    // Member function to change a single element in vector"},
{"lineNum":" 1280","line":"    Vec8s const & insert(int index, int16_t value) {"},
{"lineNum":" 1281","line":"#if INSTRSET >= 10"},
{"lineNum":" 1282","line":"        xmm = _mm_mask_set1_epi16(xmm, __mmask8(1u << index), value);"},
{"lineNum":" 1283","line":"#else"},
{"lineNum":" 1284","line":"        switch(index) {"},
{"lineNum":" 1285","line":"        case 0:"},
{"lineNum":" 1286","line":"            xmm = _mm_insert_epi16(xmm,value,0);  break;"},
{"lineNum":" 1287","line":"        case 1:"},
{"lineNum":" 1288","line":"            xmm = _mm_insert_epi16(xmm,value,1);  break;"},
{"lineNum":" 1289","line":"        case 2:"},
{"lineNum":" 1290","line":"            xmm = _mm_insert_epi16(xmm,value,2);  break;"},
{"lineNum":" 1291","line":"        case 3:"},
{"lineNum":" 1292","line":"            xmm = _mm_insert_epi16(xmm,value,3);  break;"},
{"lineNum":" 1293","line":"        case 4:"},
{"lineNum":" 1294","line":"            xmm = _mm_insert_epi16(xmm,value,4);  break;"},
{"lineNum":" 1295","line":"        case 5:"},
{"lineNum":" 1296","line":"            xmm = _mm_insert_epi16(xmm,value,5);  break;"},
{"lineNum":" 1297","line":"        case 6:"},
{"lineNum":" 1298","line":"            xmm = _mm_insert_epi16(xmm,value,6);  break;"},
{"lineNum":" 1299","line":"        case 7:"},
{"lineNum":" 1300","line":"            xmm = _mm_insert_epi16(xmm,value,7);  break;"},
{"lineNum":" 1301","line":"        }"},
{"lineNum":" 1302","line":"#endif"},
{"lineNum":" 1303","line":"        return *this;"},
{"lineNum":" 1304","line":"    }"},
{"lineNum":" 1305","line":"    // Member function extract a single element from vector"},
{"lineNum":" 1306","line":"    // Note: This function is inefficient. Use store function if extracting more than one element"},
{"lineNum":" 1307","line":"    int16_t extract(int index) const {"},
{"lineNum":" 1308","line":"#if INSTRSET >= 10 && defined (__AVX512VBMI2__)"},
{"lineNum":" 1309","line":"        __m128i x = _mm_maskz_compress_epi16 (__mmask8(1u << index), xmm);"},
{"lineNum":" 1310","line":"        return (int16_t)_mm_cvtsi128_si32(x);"},
{"lineNum":" 1311","line":"#else"},
{"lineNum":" 1312","line":"        switch(index) {"},
{"lineNum":" 1313","line":"        case 0:"},
{"lineNum":" 1314","line":"            return (int16_t)_mm_extract_epi16(xmm,0);"},
{"lineNum":" 1315","line":"        case 1:"},
{"lineNum":" 1316","line":"            return (int16_t)_mm_extract_epi16(xmm,1);"},
{"lineNum":" 1317","line":"        case 2:"},
{"lineNum":" 1318","line":"            return (int16_t)_mm_extract_epi16(xmm,2);"},
{"lineNum":" 1319","line":"        case 3:"},
{"lineNum":" 1320","line":"            return (int16_t)_mm_extract_epi16(xmm,3);"},
{"lineNum":" 1321","line":"        case 4:"},
{"lineNum":" 1322","line":"            return (int16_t)_mm_extract_epi16(xmm,4);"},
{"lineNum":" 1323","line":"        case 5:"},
{"lineNum":" 1324","line":"            return (int16_t)_mm_extract_epi16(xmm,5);"},
{"lineNum":" 1325","line":"        case 6:"},
{"lineNum":" 1326","line":"            return (int16_t)_mm_extract_epi16(xmm,6);"},
{"lineNum":" 1327","line":"        case 7:"},
{"lineNum":" 1328","line":"            return (int16_t)_mm_extract_epi16(xmm,7);"},
{"lineNum":" 1329","line":"        }"},
{"lineNum":" 1330","line":"        return 0;"},
{"lineNum":" 1331","line":"#endif"},
{"lineNum":" 1332","line":"    }"},
{"lineNum":" 1333","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 1334","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 1335","line":"    int16_t operator [] (int index) const {"},
{"lineNum":" 1336","line":"        return extract(index);"},
{"lineNum":" 1337","line":"    }"},
{"lineNum":" 1338","line":"    static int size() {"},
{"lineNum":" 1339","line":"        return 8;"},
{"lineNum":" 1340","line":"    }"},
{"lineNum":" 1341","line":"    static int elementtype() {"},
{"lineNum":" 1342","line":"        return 6;"},
{"lineNum":" 1343","line":"    }"},
{"lineNum":" 1344","line":"};"},
{"lineNum":" 1345","line":""},
{"lineNum":" 1346","line":"/*****************************************************************************"},
{"lineNum":" 1347","line":"*"},
{"lineNum":" 1348","line":"*          Vec8sb: Vector of 8 Booleans for use with Vec8s and Vec8us"},
{"lineNum":" 1349","line":"*"},
{"lineNum":" 1350","line":"*****************************************************************************/"},
{"lineNum":" 1351","line":""},
{"lineNum":" 1352","line":"class Vec8sb : public Vec8s {"},
{"lineNum":" 1353","line":"public:"},
{"lineNum":" 1354","line":"    // Constructor to build from all elements:"},
{"lineNum":" 1355","line":"    Vec8sb(bool x0, bool x1, bool x2, bool x3, bool x4, bool x5, bool x6, bool x7) {"},
{"lineNum":" 1356","line":"        xmm = Vec8s(-int16_t(x0), -int16_t(x1), -int16_t(x2), -int16_t(x3), -int16_t(x4), -int16_t(x5), -int16_t(x6), -int16_t(x7));"},
{"lineNum":" 1357","line":"    }"},
{"lineNum":" 1358","line":"    // Default constructor:"},
{"lineNum":" 1359","line":"    Vec8sb() {"},
{"lineNum":" 1360","line":"    }"},
{"lineNum":" 1361","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 1362","line":"    Vec8sb(__m128i const & x) {"},
{"lineNum":" 1363","line":"        xmm = x;"},
{"lineNum":" 1364","line":"    }"},
{"lineNum":" 1365","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 1366","line":"    Vec8sb & operator = (__m128i const & x) {"},
{"lineNum":" 1367","line":"        xmm = x;"},
{"lineNum":" 1368","line":"        return *this;"},
{"lineNum":" 1369","line":"    }"},
{"lineNum":" 1370","line":"    // Constructor to broadcast scalar value:"},
{"lineNum":" 1371","line":"    Vec8sb(bool b) : Vec8s(-int16_t(b)) {"},
{"lineNum":" 1372","line":"    }"},
{"lineNum":" 1373","line":"    // Assignment operator to broadcast scalar value:"},
{"lineNum":" 1374","line":"    Vec8sb & operator = (bool b) {"},
{"lineNum":" 1375","line":"        *this = Vec8sb(b);"},
{"lineNum":" 1376","line":"        return *this;"},
{"lineNum":" 1377","line":"    }"},
{"lineNum":" 1378","line":"    Vec8sb & insert (int index, bool a) {"},
{"lineNum":" 1379","line":"        Vec8s::insert(index, -(int16_t)a);"},
{"lineNum":" 1380","line":"        return *this;"},
{"lineNum":" 1381","line":"    }"},
{"lineNum":" 1382","line":"    // Member function extract a single element from vector"},
{"lineNum":" 1383","line":"    // Note: This function is inefficient. Use store function if extracting more than one element"},
{"lineNum":" 1384","line":"    bool extract(int index) const {"},
{"lineNum":" 1385","line":"        return Vec8s::extract(index) != 0;"},
{"lineNum":" 1386","line":"    }"},
{"lineNum":" 1387","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 1388","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 1389","line":"    bool operator [] (int index) const {"},
{"lineNum":" 1390","line":"        return extract(index);"},
{"lineNum":" 1391","line":"    }"},
{"lineNum":" 1392","line":"    // Member function to change a bitfield to a boolean vector"},
{"lineNum":" 1393","line":"    Vec8sb & load_bits(uint8_t a) {"},
{"lineNum":" 1394","line":"        __m128i b1 = _mm_set1_epi8((int8_t)a);  // broadcast byte. Invert because we have no compare-not-equal"},
{"lineNum":" 1395","line":"        __m128i m1 = constant4ui<0x00020001,0x00080004,0x00200010,0x00800040>();"},
{"lineNum":" 1396","line":"        __m128i c1 = _mm_and_si128(b1, m1); // isolate one bit in each byte"},
{"lineNum":" 1397","line":"        xmm = _mm_cmpgt_epi16(c1, _mm_setzero_si128());  // compare with 0"},
{"lineNum":" 1398","line":"        return *this;"},
{"lineNum":" 1399","line":"    }"},
{"lineNum":" 1400","line":"    static int elementtype() {"},
{"lineNum":" 1401","line":"        return 3;"},
{"lineNum":" 1402","line":"    }"},
{"lineNum":" 1403","line":"private: // Prevent constructing from int, etc."},
{"lineNum":" 1404","line":"    Vec8sb(int b);"},
{"lineNum":" 1405","line":"    Vec8sb & operator = (int x);"},
{"lineNum":" 1406","line":"};"},
{"lineNum":" 1407","line":""},
{"lineNum":" 1408","line":""},
{"lineNum":" 1409","line":"/*****************************************************************************"},
{"lineNum":" 1410","line":"*"},
{"lineNum":" 1411","line":"*          Define operators for Vec8sb"},
{"lineNum":" 1412","line":"*"},
{"lineNum":" 1413","line":"*****************************************************************************/"},
{"lineNum":" 1414","line":""},
{"lineNum":" 1415","line":"// vector operator & : bitwise and"},
{"lineNum":" 1416","line":"static inline Vec8sb operator & (Vec8sb const & a, Vec8sb const & b) {"},
{"lineNum":" 1417","line":"    return Vec8sb(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 1418","line":"}"},
{"lineNum":" 1419","line":"static inline Vec8sb operator && (Vec8sb const & a, Vec8sb const & b) {"},
{"lineNum":" 1420","line":"    return a & b;"},
{"lineNum":" 1421","line":"}"},
{"lineNum":" 1422","line":"// vector operator &= : bitwise and"},
{"lineNum":" 1423","line":"static inline Vec8sb & operator &= (Vec8sb & a, Vec8sb const & b) {"},
{"lineNum":" 1424","line":"    a = a & b;"},
{"lineNum":" 1425","line":"    return a;"},
{"lineNum":" 1426","line":"}"},
{"lineNum":" 1427","line":""},
{"lineNum":" 1428","line":"// vector operator | : bitwise or"},
{"lineNum":" 1429","line":"static inline Vec8sb operator | (Vec8sb const & a, Vec8sb const & b) {"},
{"lineNum":" 1430","line":"    return Vec8sb(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 1431","line":"}"},
{"lineNum":" 1432","line":"static inline Vec8sb operator || (Vec8sb const & a, Vec8sb const & b) {"},
{"lineNum":" 1433","line":"    return a | b;"},
{"lineNum":" 1434","line":"}"},
{"lineNum":" 1435","line":"// vector operator |= : bitwise or"},
{"lineNum":" 1436","line":"static inline Vec8sb & operator |= (Vec8sb & a, Vec8sb const & b) {"},
{"lineNum":" 1437","line":"    a = a | b;"},
{"lineNum":" 1438","line":"    return a;"},
{"lineNum":" 1439","line":"}"},
{"lineNum":" 1440","line":""},
{"lineNum":" 1441","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 1442","line":"static inline Vec8sb operator ^ (Vec8sb const & a, Vec8sb const & b) {"},
{"lineNum":" 1443","line":"    return Vec8sb(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 1444","line":"}"},
{"lineNum":" 1445","line":"// vector operator ^= : bitwise xor"},
{"lineNum":" 1446","line":"static inline Vec8sb & operator ^= (Vec8sb & a, Vec8sb const & b) {"},
{"lineNum":" 1447","line":"    a = a ^ b;"},
{"lineNum":" 1448","line":"    return a;"},
{"lineNum":" 1449","line":"}"},
{"lineNum":" 1450","line":""},
{"lineNum":" 1451","line":"// vector operator == : xnor"},
{"lineNum":" 1452","line":"static inline Vec8sb operator == (Vec8sb const & a, Vec8sb const & b) {"},
{"lineNum":" 1453","line":"    return Vec8sb(a ^ (~b));"},
{"lineNum":" 1454","line":"}"},
{"lineNum":" 1455","line":""},
{"lineNum":" 1456","line":"// vector operator != : xor"},
{"lineNum":" 1457","line":"static inline Vec8sb operator != (Vec8sb const & a, Vec8sb const & b) {"},
{"lineNum":" 1458","line":"    return Vec8sb(a ^ b);"},
{"lineNum":" 1459","line":"}"},
{"lineNum":" 1460","line":""},
{"lineNum":" 1461","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 1462","line":"static inline Vec8sb operator ~ (Vec8sb const & a) {"},
{"lineNum":" 1463","line":"    return Vec8sb( ~ Vec128b(a));"},
{"lineNum":" 1464","line":"}"},
{"lineNum":" 1465","line":""},
{"lineNum":" 1466","line":"// vector operator ! : element not"},
{"lineNum":" 1467","line":"static inline Vec8sb operator ! (Vec8sb const & a) {"},
{"lineNum":" 1468","line":"    return ~ a;"},
{"lineNum":" 1469","line":"}"},
{"lineNum":" 1470","line":""},
{"lineNum":" 1471","line":"// vector function andnot"},
{"lineNum":" 1472","line":"static inline Vec8sb andnot (Vec8sb const & a, Vec8sb const & b) {"},
{"lineNum":" 1473","line":"    return Vec8sb(andnot(Vec128b(a), Vec128b(b)));"},
{"lineNum":" 1474","line":"}"},
{"lineNum":" 1475","line":""},
{"lineNum":" 1476","line":"// Horizontal Boolean functions for Vec8sb"},
{"lineNum":" 1477","line":""},
{"lineNum":" 1478","line":"// horizontal_and. Returns true if all elements are true"},
{"lineNum":" 1479","line":"static inline bool horizontal_and(Vec8sb const & a) {"},
{"lineNum":" 1480","line":"    return _mm_movemask_epi8(a) == 0xFFFF;"},
{"lineNum":" 1481","line":"}"},
{"lineNum":" 1482","line":""},
{"lineNum":" 1483","line":"// horizontal_or. Returns true if at least one element is true"},
{"lineNum":" 1484","line":"static inline bool horizontal_or(Vec8sb const & a) {"},
{"lineNum":" 1485","line":"#if INSTRSET >= 5   // SSE4.1 supported. Use PTEST"},
{"lineNum":" 1486","line":"    return !_mm_testz_si128(a, a);"},
{"lineNum":" 1487","line":"#else"},
{"lineNum":" 1488","line":"    return _mm_movemask_epi8(a) != 0;"},
{"lineNum":" 1489","line":"#endif"},
{"lineNum":" 1490","line":"}"},
{"lineNum":" 1491","line":""},
{"lineNum":" 1492","line":""},
{"lineNum":" 1493","line":"/*****************************************************************************"},
{"lineNum":" 1494","line":"*"},
{"lineNum":" 1495","line":"*         operators for Vec8s"},
{"lineNum":" 1496","line":"*"},
{"lineNum":" 1497","line":"*****************************************************************************/"},
{"lineNum":" 1498","line":""},
{"lineNum":" 1499","line":"// vector operator + : add element by element"},
{"lineNum":" 1500","line":"static inline Vec8s operator + (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1501","line":"    return _mm_add_epi16(a, b);"},
{"lineNum":" 1502","line":"}"},
{"lineNum":" 1503","line":""},
{"lineNum":" 1504","line":"// vector operator += : add"},
{"lineNum":" 1505","line":"static inline Vec8s & operator += (Vec8s & a, Vec8s const & b) {"},
{"lineNum":" 1506","line":"    a = a + b;"},
{"lineNum":" 1507","line":"    return a;"},
{"lineNum":" 1508","line":"}"},
{"lineNum":" 1509","line":""},
{"lineNum":" 1510","line":"// postfix operator ++"},
{"lineNum":" 1511","line":"static inline Vec8s operator ++ (Vec8s & a, int) {"},
{"lineNum":" 1512","line":"    Vec8s a0 = a;"},
{"lineNum":" 1513","line":"    a = a + 1;"},
{"lineNum":" 1514","line":"    return a0;"},
{"lineNum":" 1515","line":"}"},
{"lineNum":" 1516","line":""},
{"lineNum":" 1517","line":"// prefix operator ++"},
{"lineNum":" 1518","line":"static inline Vec8s & operator ++ (Vec8s & a) {"},
{"lineNum":" 1519","line":"    a = a + 1;"},
{"lineNum":" 1520","line":"    return a;"},
{"lineNum":" 1521","line":"}"},
{"lineNum":" 1522","line":""},
{"lineNum":" 1523","line":"// vector operator - : subtract element by element"},
{"lineNum":" 1524","line":"static inline Vec8s operator - (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1525","line":"    return _mm_sub_epi16(a, b);"},
{"lineNum":" 1526","line":"}"},
{"lineNum":" 1527","line":""},
{"lineNum":" 1528","line":"// vector operator - : unary minus"},
{"lineNum":" 1529","line":"static inline Vec8s operator - (Vec8s const & a) {"},
{"lineNum":" 1530","line":"    return _mm_sub_epi16(_mm_setzero_si128(), a);"},
{"lineNum":" 1531","line":"}"},
{"lineNum":" 1532","line":""},
{"lineNum":" 1533","line":"// vector operator -= : subtract"},
{"lineNum":" 1534","line":"static inline Vec8s & operator -= (Vec8s & a, Vec8s const & b) {"},
{"lineNum":" 1535","line":"    a = a - b;"},
{"lineNum":" 1536","line":"    return a;"},
{"lineNum":" 1537","line":"}"},
{"lineNum":" 1538","line":""},
{"lineNum":" 1539","line":"// postfix operator --"},
{"lineNum":" 1540","line":"static inline Vec8s operator -- (Vec8s & a, int) {"},
{"lineNum":" 1541","line":"    Vec8s a0 = a;"},
{"lineNum":" 1542","line":"    a = a - 1;"},
{"lineNum":" 1543","line":"    return a0;"},
{"lineNum":" 1544","line":"}"},
{"lineNum":" 1545","line":""},
{"lineNum":" 1546","line":"// prefix operator --"},
{"lineNum":" 1547","line":"static inline Vec8s & operator -- (Vec8s & a) {"},
{"lineNum":" 1548","line":"    a = a - 1;"},
{"lineNum":" 1549","line":"    return a;"},
{"lineNum":" 1550","line":"}"},
{"lineNum":" 1551","line":""},
{"lineNum":" 1552","line":"// vector operator * : multiply element by element"},
{"lineNum":" 1553","line":"static inline Vec8s operator * (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1554","line":"    return _mm_mullo_epi16(a, b);"},
{"lineNum":" 1555","line":"}"},
{"lineNum":" 1556","line":""},
{"lineNum":" 1557","line":"// vector operator *= : multiply"},
{"lineNum":" 1558","line":"static inline Vec8s & operator *= (Vec8s & a, Vec8s const & b) {"},
{"lineNum":" 1559","line":"    a = a * b;"},
{"lineNum":" 1560","line":"    return a;"},
{"lineNum":" 1561","line":"}"},
{"lineNum":" 1562","line":""},
{"lineNum":" 1563","line":"// vector operator / : divide all elements by same integer"},
{"lineNum":" 1564","line":"// See bottom of file"},
{"lineNum":" 1565","line":""},
{"lineNum":" 1566","line":""},
{"lineNum":" 1567","line":"// vector operator << : shift left"},
{"lineNum":" 1568","line":"static inline Vec8s operator << (Vec8s const & a, int b) {"},
{"lineNum":" 1569","line":"    return _mm_sll_epi16(a,_mm_cvtsi32_si128(b));"},
{"lineNum":" 1570","line":"}"},
{"lineNum":" 1571","line":""},
{"lineNum":" 1572","line":"// vector operator <<= : shift left"},
{"lineNum":" 1573","line":"static inline Vec8s & operator <<= (Vec8s & a, int b) {"},
{"lineNum":" 1574","line":"    a = a << b;"},
{"lineNum":" 1575","line":"    return a;"},
{"lineNum":" 1576","line":"}"},
{"lineNum":" 1577","line":""},
{"lineNum":" 1578","line":"// vector operator >> : shift right arithmetic"},
{"lineNum":" 1579","line":"static inline Vec8s operator >> (Vec8s const & a, int b) {"},
{"lineNum":" 1580","line":"    return _mm_sra_epi16(a,_mm_cvtsi32_si128(b));"},
{"lineNum":" 1581","line":"}"},
{"lineNum":" 1582","line":""},
{"lineNum":" 1583","line":"// vector operator >>= : shift right arithmetic"},
{"lineNum":" 1584","line":"static inline Vec8s & operator >>= (Vec8s & a, int b) {"},
{"lineNum":" 1585","line":"    a = a >> b;"},
{"lineNum":" 1586","line":"    return a;"},
{"lineNum":" 1587","line":"}"},
{"lineNum":" 1588","line":""},
{"lineNum":" 1589","line":"// vector operator == : returns true for elements for which a == b"},
{"lineNum":" 1590","line":"static inline Vec8sb operator == (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1591","line":"    return _mm_cmpeq_epi16(a, b);"},
{"lineNum":" 1592","line":"}"},
{"lineNum":" 1593","line":""},
{"lineNum":" 1594","line":"// vector operator != : returns true for elements for which a != b"},
{"lineNum":" 1595","line":"static inline Vec8sb operator != (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1596","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 1597","line":"    return (Vec8sb)_mm_comneq_epi16(a,b);"},
{"lineNum":" 1598","line":"#else  // SSE2 instruction set"},
{"lineNum":" 1599","line":"    return Vec8sb (~(a == b));"},
{"lineNum":" 1600","line":"#endif"},
{"lineNum":" 1601","line":"}"},
{"lineNum":" 1602","line":""},
{"lineNum":" 1603","line":"// vector operator > : returns true for elements for which a > b"},
{"lineNum":" 1604","line":"static inline Vec8sb operator > (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1605","line":"    return _mm_cmpgt_epi16(a, b);"},
{"lineNum":" 1606","line":"}"},
{"lineNum":" 1607","line":""},
{"lineNum":" 1608","line":"// vector operator < : returns true for elements for which a < b"},
{"lineNum":" 1609","line":"static inline Vec8sb operator < (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1610","line":"    return b > a;"},
{"lineNum":" 1611","line":"}"},
{"lineNum":" 1612","line":""},
{"lineNum":" 1613","line":"// vector operator >= : returns true for elements for which a >= b (signed)"},
{"lineNum":" 1614","line":"static inline Vec8sb operator >= (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1615","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 1616","line":"    return (Vec8sb)_mm_comge_epi16(a,b);"},
{"lineNum":" 1617","line":"#else  // SSE2 instruction set"},
{"lineNum":" 1618","line":"    return Vec8sb (~(b > a));"},
{"lineNum":" 1619","line":"#endif"},
{"lineNum":" 1620","line":"}"},
{"lineNum":" 1621","line":""},
{"lineNum":" 1622","line":"// vector operator <= : returns true for elements for which a <= b (signed)"},
{"lineNum":" 1623","line":"static inline Vec8sb operator <= (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1624","line":"    return b >= a;"},
{"lineNum":" 1625","line":"}"},
{"lineNum":" 1626","line":""},
{"lineNum":" 1627","line":"// vector operator & : bitwise and"},
{"lineNum":" 1628","line":"static inline Vec8s operator & (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1629","line":"    return Vec8s(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 1630","line":"}"},
{"lineNum":" 1631","line":"static inline Vec8s operator && (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1632","line":"    return a & b;"},
{"lineNum":" 1633","line":"}"},
{"lineNum":" 1634","line":"// vector operator &= : bitwise and"},
{"lineNum":" 1635","line":"static inline Vec8s & operator &= (Vec8s & a, Vec8s const & b) {"},
{"lineNum":" 1636","line":"    a = a & b;"},
{"lineNum":" 1637","line":"    return a;"},
{"lineNum":" 1638","line":"}"},
{"lineNum":" 1639","line":""},
{"lineNum":" 1640","line":"// vector operator | : bitwise or"},
{"lineNum":" 1641","line":"static inline Vec8s operator | (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1642","line":"    return Vec8s(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 1643","line":"}"},
{"lineNum":" 1644","line":"static inline Vec8s operator || (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1645","line":"    return a | b;"},
{"lineNum":" 1646","line":"}"},
{"lineNum":" 1647","line":"// vector operator |= : bitwise or"},
{"lineNum":" 1648","line":"static inline Vec8s & operator |= (Vec8s & a, Vec8s const & b) {"},
{"lineNum":" 1649","line":"    a = a | b;"},
{"lineNum":" 1650","line":"    return a;"},
{"lineNum":" 1651","line":"}"},
{"lineNum":" 1652","line":""},
{"lineNum":" 1653","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 1654","line":"static inline Vec8s operator ^ (Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1655","line":"    return Vec8s(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 1656","line":"}"},
{"lineNum":" 1657","line":"// vector operator ^= : bitwise xor"},
{"lineNum":" 1658","line":"static inline Vec8s & operator ^= (Vec8s & a, Vec8s const & b) {"},
{"lineNum":" 1659","line":"    a = a ^ b;"},
{"lineNum":" 1660","line":"    return a;"},
{"lineNum":" 1661","line":"}"},
{"lineNum":" 1662","line":""},
{"lineNum":" 1663","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 1664","line":"static inline Vec8s operator ~ (Vec8s const & a) {"},
{"lineNum":" 1665","line":"    return Vec8s( ~ Vec128b(a));"},
{"lineNum":" 1666","line":"}"},
{"lineNum":" 1667","line":""},
{"lineNum":" 1668","line":"// Functions for this class"},
{"lineNum":" 1669","line":""},
{"lineNum":" 1670","line":"// Select between two operands. Corresponds to this pseudocode:"},
{"lineNum":" 1671","line":"// for (int i = 0; i < 8; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":" 1672","line":"// Each byte in s must be either 0 (false) or -1 (true). No other values are allowed."},
{"lineNum":" 1673","line":"// (s is signed)"},
{"lineNum":" 1674","line":"static inline Vec8s select (Vec8sb const & s, Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1675","line":"    return selectb(s,a,b);"},
{"lineNum":" 1676","line":"}"},
{"lineNum":" 1677","line":""},
{"lineNum":" 1678","line":"// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]"},
{"lineNum":" 1679","line":"static inline Vec8s if_add (Vec8sb const & f, Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1680","line":"    return a + (Vec8s(f) & b);"},
{"lineNum":" 1681","line":"}"},
{"lineNum":" 1682","line":""},
{"lineNum":" 1683","line":"// Conditional sub: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]"},
{"lineNum":" 1684","line":"static inline Vec8s if_sub (Vec8sb const & f, Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1685","line":"    return a - (Vec8s(f) & b);"},
{"lineNum":" 1686","line":"}"},
{"lineNum":" 1687","line":""},
{"lineNum":" 1688","line":"// Conditional mul: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]"},
{"lineNum":" 1689","line":"static inline Vec8s if_mul (Vec8sb const & f, Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1690","line":"    return select(f, a*b, a);"},
{"lineNum":" 1691","line":"}"},
{"lineNum":" 1692","line":""},
{"lineNum":" 1693","line":"// Horizontal add: Calculates the sum of all vector elements."},
{"lineNum":" 1694","line":"// Overflow will wrap around"},
{"lineNum":" 1695","line":"static inline int16_t horizontal_add (Vec8s const & a) {"},
{"lineNum":" 1696","line":"#ifdef __XOP__       // AMD XOP instruction set"},
{"lineNum":" 1697","line":"    __m128i sum1  = _mm_haddq_epi16(a);"},
{"lineNum":" 1698","line":"    __m128i sum2  = _mm_shuffle_epi32(sum1,0x0E);          // high element"},
{"lineNum":" 1699","line":"    __m128i sum3  = _mm_add_epi32(sum1,sum2);              // sum"},
{"lineNum":" 1700","line":"    int16_t sum4  = _mm_cvtsi128_si32(sum3);               // truncate to 16 bits"},
{"lineNum":" 1701","line":"    return  sum4;                                          // sign extend to 32 bits"},
{"lineNum":" 1702","line":"    // The hadd instruction is inefficient, and may be split into two instructions for faster decoding"},
{"lineNum":" 1703","line":"#elif  INSTRSET >= 4 && false // SSSE3"},
{"lineNum":" 1704","line":"    __m128i sum1  = _mm_hadd_epi16(a,a);                   // horizontally add 8 elements in 3 steps"},
{"lineNum":" 1705","line":"    __m128i sum2  = _mm_hadd_epi16(sum1,sum1);"},
{"lineNum":" 1706","line":"    __m128i sum3  = _mm_hadd_epi16(sum2,sum2);"},
{"lineNum":" 1707","line":"    int16_t sum4  = (int16_t)_mm_cvtsi128_si32(sum3);      // 16 bit sum"},
{"lineNum":" 1708","line":"    return  sum4;                                          // sign extend to 32 bits"},
{"lineNum":" 1709","line":"#else                 // SSE2"},
{"lineNum":" 1710","line":"    __m128i sum1  = _mm_unpackhi_epi64(a,a);               // 4 high elements"},
{"lineNum":" 1711","line":"    __m128i sum2  = _mm_add_epi16(a,sum1);                 // 4 sums"},
{"lineNum":" 1712","line":"    __m128i sum3  = _mm_shuffle_epi32(sum2,0x01);          // 2 high elements"},
{"lineNum":" 1713","line":"    __m128i sum4  = _mm_add_epi16(sum2,sum3);              // 2 sums"},
{"lineNum":" 1714","line":"    __m128i sum5  = _mm_shufflelo_epi16(sum4,0x01);        // 1 high element"},
{"lineNum":" 1715","line":"    __m128i sum6  = _mm_add_epi16(sum4,sum5);              // 1 sum"},
{"lineNum":" 1716","line":"    int16_t sum7  = (int16_t)_mm_cvtsi128_si32(sum6);      // 16 bit sum"},
{"lineNum":" 1717","line":"    return  sum7;                                          // sign extend to 32 bits"},
{"lineNum":" 1718","line":"#endif"},
{"lineNum":" 1719","line":"}"},
{"lineNum":" 1720","line":""},
{"lineNum":" 1721","line":"// Horizontal add extended: Calculates the sum of all vector elements."},
{"lineNum":" 1722","line":"// Elements are sign extended before adding to avoid overflow"},
{"lineNum":" 1723","line":"static inline int32_t horizontal_add_x (Vec8s const & a) {"},
{"lineNum":" 1724","line":"#ifdef __XOP__       // AMD XOP instruction set"},
{"lineNum":" 1725","line":"    __m128i sum1  = _mm_haddq_epi16(a);"},
{"lineNum":" 1726","line":"    __m128i sum2  = _mm_shuffle_epi32(sum1,0x0E);          // high element"},
{"lineNum":" 1727","line":"    __m128i sum3  = _mm_add_epi32(sum1,sum2);              // sum"},
{"lineNum":" 1728","line":"    return          _mm_cvtsi128_si32(sum3);"},
{"lineNum":" 1729","line":"#else"},
{"lineNum":" 1730","line":"    __m128i aeven = _mm_slli_epi32(a,16);                  // even numbered elements of a. get sign bit in position"},
{"lineNum":" 1731","line":"            aeven = _mm_srai_epi32(aeven,16);              // sign extend even numbered elements"},
{"lineNum":" 1732","line":"    __m128i aodd  = _mm_srai_epi32(a,16);                  // sign extend odd  numbered elements"},
{"lineNum":" 1733","line":"    __m128i sum1  = _mm_add_epi32(aeven,aodd);             // add even and odd elements"},
{"lineNum":" 1734","line":"#if  INSTRSET >= 4 && false // SSSE3"},
{"lineNum":" 1735","line":"    // The hadd instruction is inefficient, and may be split into two instructions for faster decoding"},
{"lineNum":" 1736","line":"    __m128i sum2  = _mm_hadd_epi32(sum1,sum1);             // horizontally add 4 elements in 2 steps"},
{"lineNum":" 1737","line":"    __m128i sum3  = _mm_hadd_epi32(sum2,sum2);"},
{"lineNum":" 1738","line":"    return  _mm_cvtsi128_si32(sum3);"},
{"lineNum":" 1739","line":"#else                 // SSE2"},
{"lineNum":" 1740","line":"    __m128i sum2  = _mm_unpackhi_epi64(sum1,sum1);         // 2 high elements"},
{"lineNum":" 1741","line":"    __m128i sum3  = _mm_add_epi32(sum1,sum2);"},
{"lineNum":" 1742","line":"    __m128i sum4  = _mm_shuffle_epi32(sum3,1);             // 1 high elements"},
{"lineNum":" 1743","line":"    __m128i sum5  = _mm_add_epi32(sum3,sum4);"},
{"lineNum":" 1744","line":"    return  _mm_cvtsi128_si32(sum5);                       // 32 bit sum"},
{"lineNum":" 1745","line":"#endif"},
{"lineNum":" 1746","line":"#endif"},
{"lineNum":" 1747","line":"}"},
{"lineNum":" 1748","line":""},
{"lineNum":" 1749","line":"// function add_saturated: add element by element, signed with saturation"},
{"lineNum":" 1750","line":"static inline Vec8s add_saturated(Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1751","line":"    return _mm_adds_epi16(a, b);"},
{"lineNum":" 1752","line":"}"},
{"lineNum":" 1753","line":""},
{"lineNum":" 1754","line":"// function sub_saturated: subtract element by element, signed with saturation"},
{"lineNum":" 1755","line":"static inline Vec8s sub_saturated(Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1756","line":"    return _mm_subs_epi16(a, b);"},
{"lineNum":" 1757","line":"}"},
{"lineNum":" 1758","line":""},
{"lineNum":" 1759","line":"// function max: a > b ? a : b"},
{"lineNum":" 1760","line":"static inline Vec8s max(Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1761","line":"    return _mm_max_epi16(a,b);"},
{"lineNum":" 1762","line":"}"},
{"lineNum":" 1763","line":""},
{"lineNum":" 1764","line":"// function min: a < b ? a : b"},
{"lineNum":" 1765","line":"static inline Vec8s min(Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 1766","line":"    return _mm_min_epi16(a,b);"},
{"lineNum":" 1767","line":"}"},
{"lineNum":" 1768","line":""},
{"lineNum":" 1769","line":"// function abs: a >= 0 ? a : -a"},
{"lineNum":" 1770","line":"static inline Vec8s abs(Vec8s const & a) {"},
{"lineNum":" 1771","line":"#if INSTRSET >= 4     // SSSE3 supported"},
{"lineNum":" 1772","line":"    return _mm_abs_epi16(a);"},
{"lineNum":" 1773","line":"#else                 // SSE2"},
{"lineNum":" 1774","line":"    __m128i nega = _mm_sub_epi16(_mm_setzero_si128(), a);"},
{"lineNum":" 1775","line":"    return _mm_max_epi16(a, nega);"},
{"lineNum":" 1776","line":"#endif"},
{"lineNum":" 1777","line":"}"},
{"lineNum":" 1778","line":""},
{"lineNum":" 1779","line":"// function abs_saturated: same as abs, saturate if overflow"},
{"lineNum":" 1780","line":"static inline Vec8s abs_saturated(Vec8s const & a) {"},
{"lineNum":" 1781","line":"    __m128i absa   = abs(a);                               // abs(a)"},
{"lineNum":" 1782","line":"    __m128i overfl = _mm_srai_epi16(absa,15);              // sign"},
{"lineNum":" 1783","line":"    return           _mm_add_epi16(absa,overfl);           // subtract 1 if 0x8000"},
{"lineNum":" 1784","line":"}"},
{"lineNum":" 1785","line":""},
{"lineNum":" 1786","line":"// function rotate_left all elements"},
{"lineNum":" 1787","line":"// Use negative count to rotate right"},
{"lineNum":" 1788","line":"static inline Vec8s rotate_left(Vec8s const & a, int b) {"},
{"lineNum":" 1789","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 1790","line":"    return (Vec8s)_mm_rot_epi16(a,_mm_set1_epi16(b));"},
{"lineNum":" 1791","line":"#else  // SSE2 instruction set"},
{"lineNum":" 1792","line":"    __m128i left  = _mm_sll_epi16(a,_mm_cvtsi32_si128(b & 0x0F));      // a << b"},
{"lineNum":" 1793","line":"    __m128i right = _mm_srl_epi16(a,_mm_cvtsi32_si128((-b) & 0x0F));   // a >> (16 - b)"},
{"lineNum":" 1794","line":"    __m128i rot   = _mm_or_si128(left,right);                          // or"},
{"lineNum":" 1795","line":"    return  rot;"},
{"lineNum":" 1796","line":"#endif"},
{"lineNum":" 1797","line":"}"},
{"lineNum":" 1798","line":""},
{"lineNum":" 1799","line":""},
{"lineNum":" 1800","line":"/*****************************************************************************"},
{"lineNum":" 1801","line":"*"},
{"lineNum":" 1802","line":"*          Vector of 8 16-bit unsigned integers"},
{"lineNum":" 1803","line":"*"},
{"lineNum":" 1804","line":"*****************************************************************************/"},
{"lineNum":" 1805","line":""},
{"lineNum":" 1806","line":"class Vec8us : public Vec8s {"},
{"lineNum":" 1807","line":"public:"},
{"lineNum":" 1808","line":"    // Default constructor:"},
{"lineNum":" 1809","line":"    Vec8us() {"},
{"lineNum":" 1810","line":"    }"},
{"lineNum":" 1811","line":"    // Constructor to broadcast the same value into all elements:"},
{"lineNum":" 1812","line":"    Vec8us(uint32_t i) {"},
{"lineNum":" 1813","line":"        xmm = _mm_set1_epi16((int16_t)i);"},
{"lineNum":" 1814","line":"    }"},
{"lineNum":" 1815","line":"    // Constructor to build from all elements:"},
{"lineNum":" 1816","line":"    Vec8us(uint16_t i0, uint16_t i1, uint16_t i2, uint16_t i3, uint16_t i4, uint16_t i5, uint16_t i6, uint16_t i7) {"},
{"lineNum":" 1817","line":"        xmm = _mm_setr_epi16((int16_t)i0, (int16_t)i1, (int16_t)i2, (int16_t)i3, (int16_t)i4, (int16_t)i5, (int16_t)i6, (int16_t)i7);"},
{"lineNum":" 1818","line":"    }"},
{"lineNum":" 1819","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 1820","line":"    Vec8us(__m128i const & x) {"},
{"lineNum":" 1821","line":"        xmm = x;"},
{"lineNum":" 1822","line":"    }"},
{"lineNum":" 1823","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 1824","line":"    Vec8us & operator = (__m128i const & x) {"},
{"lineNum":" 1825","line":"        xmm = x;"},
{"lineNum":" 1826","line":"        return *this;"},
{"lineNum":" 1827","line":"    }"},
{"lineNum":" 1828","line":"    // Member function to load from array (unaligned)"},
{"lineNum":" 1829","line":"    Vec8us & load(void const * p) {"},
{"lineNum":" 1830","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":" 1831","line":"        return *this;"},
{"lineNum":" 1832","line":"    }"},
{"lineNum":" 1833","line":"    // Member function to load from array (aligned)"},
{"lineNum":" 1834","line":"    Vec8us & load_a(void const * p) {"},
{"lineNum":" 1835","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":" 1836","line":"        return *this;"},
{"lineNum":" 1837","line":"    }"},
{"lineNum":" 1838","line":"    // Member function to change a single element in vector"},
{"lineNum":" 1839","line":"    // Note: This function is inefficient. Use load function if changing more than one element"},
{"lineNum":" 1840","line":"    Vec8us const & insert(int index, uint16_t value) {"},
{"lineNum":" 1841","line":"        Vec8s::insert(index, (int16_t)value);"},
{"lineNum":" 1842","line":"        return *this;"},
{"lineNum":" 1843","line":"    }"},
{"lineNum":" 1844","line":"    // Member function extract a single element from vector"},
{"lineNum":" 1845","line":"    uint16_t extract(int index) const {"},
{"lineNum":" 1846","line":"        return (uint16_t)Vec8s::extract(index);"},
{"lineNum":" 1847","line":"    }"},
{"lineNum":" 1848","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 1849","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 1850","line":"    uint16_t operator [] (int index) const {"},
{"lineNum":" 1851","line":"        return extract(index);"},
{"lineNum":" 1852","line":"    }"},
{"lineNum":" 1853","line":"    static int elementtype() {"},
{"lineNum":" 1854","line":"        return 7;"},
{"lineNum":" 1855","line":"    }"},
{"lineNum":" 1856","line":"};"},
{"lineNum":" 1857","line":""},
{"lineNum":" 1858","line":"// Define operators for this class"},
{"lineNum":" 1859","line":""},
{"lineNum":" 1860","line":"// vector operator + : add"},
{"lineNum":" 1861","line":"static inline Vec8us operator + (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1862","line":"    return Vec8us (Vec8s(a) + Vec8s(b));"},
{"lineNum":" 1863","line":"}"},
{"lineNum":" 1864","line":""},
{"lineNum":" 1865","line":"// vector operator - : subtract"},
{"lineNum":" 1866","line":"static inline Vec8us operator - (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1867","line":"    return Vec8us (Vec8s(a) - Vec8s(b));"},
{"lineNum":" 1868","line":"}"},
{"lineNum":" 1869","line":""},
{"lineNum":" 1870","line":"// vector operator * : multiply"},
{"lineNum":" 1871","line":"static inline Vec8us operator * (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1872","line":"    return Vec8us (Vec8s(a) * Vec8s(b));"},
{"lineNum":" 1873","line":"}"},
{"lineNum":" 1874","line":""},
{"lineNum":" 1875","line":"// vector operator / : divide"},
{"lineNum":" 1876","line":"// See bottom of file"},
{"lineNum":" 1877","line":""},
{"lineNum":" 1878","line":"// vector operator >> : shift right logical all elements"},
{"lineNum":" 1879","line":"static inline Vec8us operator >> (Vec8us const & a, uint32_t b) {"},
{"lineNum":" 1880","line":"    return _mm_srl_epi16(a,_mm_cvtsi32_si128((int)b));"},
{"lineNum":" 1881","line":"}"},
{"lineNum":" 1882","line":""},
{"lineNum":" 1883","line":"// vector operator >> : shift right logical all elements"},
{"lineNum":" 1884","line":"static inline Vec8us operator >> (Vec8us const & a, int32_t b) {"},
{"lineNum":" 1885","line":"    return a >> (uint32_t)b;"},
{"lineNum":" 1886","line":"}"},
{"lineNum":" 1887","line":""},
{"lineNum":" 1888","line":"// vector operator >>= : shift right logical"},
{"lineNum":" 1889","line":"static inline Vec8us & operator >>= (Vec8us & a, int b) {"},
{"lineNum":" 1890","line":"    a = a >> b;"},
{"lineNum":" 1891","line":"    return a;"},
{"lineNum":" 1892","line":"}"},
{"lineNum":" 1893","line":""},
{"lineNum":" 1894","line":"// vector operator << : shift left all elements"},
{"lineNum":" 1895","line":"static inline Vec8us operator << (Vec8us const & a, uint32_t b) {"},
{"lineNum":" 1896","line":"    return _mm_sll_epi16(a,_mm_cvtsi32_si128((int)b));"},
{"lineNum":" 1897","line":"}"},
{"lineNum":" 1898","line":""},
{"lineNum":" 1899","line":"// vector operator << : shift left all elements"},
{"lineNum":" 1900","line":"static inline Vec8us operator << (Vec8us const & a, int32_t b) {"},
{"lineNum":" 1901","line":"    return a << (uint32_t)b;"},
{"lineNum":" 1902","line":"}"},
{"lineNum":" 1903","line":""},
{"lineNum":" 1904","line":"// vector operator >= : returns true for elements for which a >= b (unsigned)"},
{"lineNum":" 1905","line":"static inline Vec8sb operator >= (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1906","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 1907","line":"    return (Vec8sb)_mm_comge_epu16(a,b);"},
{"lineNum":" 1908","line":"#elif INSTRSET >= 5   // SSE4.1"},
{"lineNum":" 1909","line":"    __m128i max_ab = _mm_max_epu16(a,b);                   // max(a,b), unsigned"},
{"lineNum":" 1910","line":"    return _mm_cmpeq_epi16(a,max_ab);                      // a == max(a,b)"},
{"lineNum":" 1911","line":"#else  // SSE2 instruction set"},
{"lineNum":" 1912","line":"    __m128i s = _mm_subs_epu16(b,a);                       // b-a, saturated"},
{"lineNum":" 1913","line":"    return  _mm_cmpeq_epi16(s, _mm_setzero_si128());       // s == 0"},
{"lineNum":" 1914","line":"#endif"},
{"lineNum":" 1915","line":"}"},
{"lineNum":" 1916","line":""},
{"lineNum":" 1917","line":"// vector operator <= : returns true for elements for which a <= b (unsigned)"},
{"lineNum":" 1918","line":"static inline Vec8sb operator <= (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1919","line":"    return b >= a;"},
{"lineNum":" 1920","line":"}"},
{"lineNum":" 1921","line":""},
{"lineNum":" 1922","line":"// vector operator > : returns true for elements for which a > b (unsigned)"},
{"lineNum":" 1923","line":"static inline Vec8sb operator > (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1924","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 1925","line":"    return (Vec8sb)_mm_comgt_epu16(a,b);"},
{"lineNum":" 1926","line":"#else  // SSE2 instruction set"},
{"lineNum":" 1927","line":"    return Vec8sb (~(b >= a));"},
{"lineNum":" 1928","line":"#endif"},
{"lineNum":" 1929","line":"}"},
{"lineNum":" 1930","line":""},
{"lineNum":" 1931","line":"// vector operator < : returns true for elements for which a < b (unsigned)"},
{"lineNum":" 1932","line":"static inline Vec8sb operator < (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1933","line":"    return b > a;"},
{"lineNum":" 1934","line":"}"},
{"lineNum":" 1935","line":""},
{"lineNum":" 1936","line":"// vector operator & : bitwise and"},
{"lineNum":" 1937","line":"static inline Vec8us operator & (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1938","line":"    return Vec8us(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 1939","line":"}"},
{"lineNum":" 1940","line":"static inline Vec8us operator && (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1941","line":"    return a & b;"},
{"lineNum":" 1942","line":"}"},
{"lineNum":" 1943","line":""},
{"lineNum":" 1944","line":"// vector operator | : bitwise or"},
{"lineNum":" 1945","line":"static inline Vec8us operator | (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1946","line":"    return Vec8us(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 1947","line":"}"},
{"lineNum":" 1948","line":"static inline Vec8us operator || (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1949","line":"    return a | b;"},
{"lineNum":" 1950","line":"}"},
{"lineNum":" 1951","line":""},
{"lineNum":" 1952","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 1953","line":"static inline Vec8us operator ^ (Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1954","line":"    return Vec8us(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 1955","line":"}"},
{"lineNum":" 1956","line":""},
{"lineNum":" 1957","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 1958","line":"static inline Vec8us operator ~ (Vec8us const & a) {"},
{"lineNum":" 1959","line":"    return Vec8us( ~ Vec128b(a));"},
{"lineNum":" 1960","line":"}"},
{"lineNum":" 1961","line":""},
{"lineNum":" 1962","line":"// Functions for this class"},
{"lineNum":" 1963","line":""},
{"lineNum":" 1964","line":"// Select between two operands. Corresponds to this pseudocode:"},
{"lineNum":" 1965","line":"// for (int i = 0; i < 8; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":" 1966","line":"// Each word in s must be either 0 (false) or -1 (true). No other values are allowed."},
{"lineNum":" 1967","line":"// (s is signed)"},
{"lineNum":" 1968","line":"static inline Vec8us select (Vec8sb const & s, Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1969","line":"    return selectb(s,a,b);"},
{"lineNum":" 1970","line":"}"},
{"lineNum":" 1971","line":""},
{"lineNum":" 1972","line":"// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]"},
{"lineNum":" 1973","line":"static inline Vec8us if_add (Vec8sb const & f, Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1974","line":"    return a + (Vec8us(f) & b);"},
{"lineNum":" 1975","line":"}"},
{"lineNum":" 1976","line":""},
{"lineNum":" 1977","line":"// Conditional sub: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]"},
{"lineNum":" 1978","line":"static inline Vec8us if_sub (Vec8sb const & f, Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1979","line":"    return a - (Vec8us(f) & b);"},
{"lineNum":" 1980","line":"}"},
{"lineNum":" 1981","line":""},
{"lineNum":" 1982","line":"// Conditional mul: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]"},
{"lineNum":" 1983","line":"static inline Vec8us if_mul (Vec8sb const & f, Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 1984","line":"    return select(f, a*b, a);"},
{"lineNum":" 1985","line":"}"},
{"lineNum":" 1986","line":""},
{"lineNum":" 1987","line":"// Horizontal add: Calculates the sum of all vector elements."},
{"lineNum":" 1988","line":"// Overflow will wrap around"},
{"lineNum":" 1989","line":"static inline uint32_t horizontal_add (Vec8us const & a) {"},
{"lineNum":" 1990","line":"#ifdef __XOP__     // AMD XOP instruction set"},
{"lineNum":" 1991","line":"    __m128i sum1  = _mm_haddq_epu16(a);"},
{"lineNum":" 1992","line":"    __m128i sum2  = _mm_shuffle_epi32(sum1,0x0E);          // high element"},
{"lineNum":" 1993","line":"    __m128i sum3  = _mm_add_epi32(sum1,sum2);              // sum"},
{"lineNum":" 1994","line":"    uint16_t sum4 = _mm_cvtsi128_si32(sum3);               // truncate to 16 bits"},
{"lineNum":" 1995","line":"    return  sum4;                                          // zero extend to 32 bits"},
{"lineNum":" 1996","line":"#elif  INSTRSET >= 4 && false // SSSE3"},
{"lineNum":" 1997","line":"    // The hadd instruction is inefficient, and may be split into two instructions for faster decoding"},
{"lineNum":" 1998","line":"    __m128i sum1  = _mm_hadd_epi16(a,a);                   // horizontally add 8 elements in 3 steps"},
{"lineNum":" 1999","line":"    __m128i sum2  = _mm_hadd_epi16(sum1,sum1);"},
{"lineNum":" 2000","line":"    __m128i sum3  = _mm_hadd_epi16(sum2,sum2);"},
{"lineNum":" 2001","line":"    uint16_t sum4 = (uint16_t)_mm_cvtsi128_si32(sum3);     // 16 bit sum"},
{"lineNum":" 2002","line":"    return  sum4;                                          // zero extend to 32 bits"},
{"lineNum":" 2003","line":"#else                 // SSE2"},
{"lineNum":" 2004","line":"    __m128i sum1  = _mm_unpackhi_epi64(a,a);               // 4 high elements"},
{"lineNum":" 2005","line":"    __m128i sum2  = _mm_add_epi16(a,sum1);                 // 4 sums"},
{"lineNum":" 2006","line":"    __m128i sum3  = _mm_shuffle_epi32(sum2,0x01);          // 2 high elements"},
{"lineNum":" 2007","line":"    __m128i sum4  = _mm_add_epi16(sum2,sum3);              // 2 sums"},
{"lineNum":" 2008","line":"    __m128i sum5  = _mm_shufflelo_epi16(sum4,0x01);        // 1 high element"},
{"lineNum":" 2009","line":"    __m128i sum6  = _mm_add_epi16(sum4,sum5);              // 1 sum"},
{"lineNum":" 2010","line":"    uint16_t sum7 = (uint16_t)_mm_cvtsi128_si32(sum6);     // 16 bit sum"},
{"lineNum":" 2011","line":"    return  sum7;                                          // zero extend to 32 bits"},
{"lineNum":" 2012","line":"#endif"},
{"lineNum":" 2013","line":"}"},
{"lineNum":" 2014","line":""},
{"lineNum":" 2015","line":"// Horizontal add extended: Calculates the sum of all vector elements."},
{"lineNum":" 2016","line":"// Each element is zero-extended before addition to avoid overflow"},
{"lineNum":" 2017","line":"static inline uint32_t horizontal_add_x (Vec8us const & a) {"},
{"lineNum":" 2018","line":"#ifdef __XOP__     // AMD XOP instruction set"},
{"lineNum":" 2019","line":"    __m128i sum1  = _mm_haddq_epu16(a);"},
{"lineNum":" 2020","line":"    __m128i sum2  = _mm_shuffle_epi32(sum1,0x0E);          // high element"},
{"lineNum":" 2021","line":"    __m128i sum3  = _mm_add_epi32(sum1,sum2);              // sum"},
{"lineNum":" 2022","line":"    return  (uint32_t)_mm_cvtsi128_si32(sum3);"},
{"lineNum":" 2023","line":"    /*"},
{"lineNum":" 2024","line":"#elif INSTRSET >= 4  // SSSE3"},
{"lineNum":" 2025","line":"    // The hadd instruction is inefficient, and may be split into two instructions for faster decoding"},
{"lineNum":" 2026","line":"    __m128i mask  = _mm_set1_epi32(0x0000FFFF);            // mask for even positions"},
{"lineNum":" 2027","line":"    __m128i aeven = _mm_and_si128(a,mask);                 // even numbered elements of a"},
{"lineNum":" 2028","line":"    __m128i aodd  = _mm_srli_epi32(a,16);                  // zero extend odd numbered elements"},
{"lineNum":" 2029","line":"    __m128i sum1  = _mm_add_epi32(aeven,aodd);             // add even and odd elements"},
{"lineNum":" 2030","line":"    __m128i sum2  = _mm_hadd_epi32(sum1,sum1);             // horizontally add 4 elements in 2 steps"},
{"lineNum":" 2031","line":"    __m128i sum3  = _mm_hadd_epi32(sum2,sum2);"},
{"lineNum":" 2032","line":"    return  (uint32_t)_mm_cvtsi128_si32(sum3);"},
{"lineNum":" 2033","line":"    */"},
{"lineNum":" 2034","line":"#else                 // SSE2"},
{"lineNum":" 2035","line":"#if INSTRSET >= 10  // AVX512VL + AVX512BW"},
{"lineNum":" 2036","line":"    __m128i aeven = _mm_maskz_mov_epi16(0x55, a);"},
{"lineNum":" 2037","line":"#else"},
{"lineNum":" 2038","line":"    __m128i mask  = _mm_set1_epi32(0x0000FFFF);            // mask for even positions"},
{"lineNum":" 2039","line":"    __m128i aeven = _mm_and_si128(a,mask);                 // even numbered elements of a"},
{"lineNum":" 2040","line":"#endif"},
{"lineNum":" 2041","line":"    __m128i aodd  = _mm_srli_epi32(a,16);                  // zero extend odd numbered elements"},
{"lineNum":" 2042","line":"    __m128i sum1  = _mm_add_epi32(aeven,aodd);             // add even and odd elements"},
{"lineNum":" 2043","line":"    __m128i sum2  = _mm_unpackhi_epi64(sum1,sum1);          // 2 high elements"},
{"lineNum":" 2044","line":"    __m128i sum3  = _mm_add_epi32(sum1,sum2);"},
{"lineNum":" 2045","line":"    __m128i sum4  = _mm_shuffle_epi32(sum3,0x01);          // 1 high elements"},
{"lineNum":" 2046","line":"    __m128i sum5  = _mm_add_epi32(sum3,sum4);"},
{"lineNum":" 2047","line":"    return  (uint32_t)_mm_cvtsi128_si32(sum5);               // 16 bit sum"},
{"lineNum":" 2048","line":"#endif"},
{"lineNum":" 2049","line":"}"},
{"lineNum":" 2050","line":""},
{"lineNum":" 2051","line":"// function add_saturated: add element by element, unsigned with saturation"},
{"lineNum":" 2052","line":"static inline Vec8us add_saturated(Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 2053","line":"    return _mm_adds_epu16(a, b);"},
{"lineNum":" 2054","line":"}"},
{"lineNum":" 2055","line":""},
{"lineNum":" 2056","line":"// function sub_saturated: subtract element by element, unsigned with saturation"},
{"lineNum":" 2057","line":"static inline Vec8us sub_saturated(Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 2058","line":"    return _mm_subs_epu16(a, b);"},
{"lineNum":" 2059","line":"}"},
{"lineNum":" 2060","line":""},
{"lineNum":" 2061","line":"// function max: a > b ? a : b"},
{"lineNum":" 2062","line":"static inline Vec8us max(Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 2063","line":"#if INSTRSET >= 5   // SSE4.1"},
{"lineNum":" 2064","line":"    return _mm_max_epu16(a,b);"},
{"lineNum":" 2065","line":"#else  // SSE2"},
{"lineNum":" 2066","line":"    __m128i signbit = _mm_set1_epi32(0x80008000);"},
{"lineNum":" 2067","line":"    __m128i a1      = _mm_xor_si128(a,signbit);            // add 0x8000"},
{"lineNum":" 2068","line":"    __m128i b1      = _mm_xor_si128(b,signbit);            // add 0x8000"},
{"lineNum":" 2069","line":"    __m128i m1      = _mm_max_epi16(a1,b1);                // signed max"},
{"lineNum":" 2070","line":"    return  _mm_xor_si128(m1,signbit);                     // sub 0x8000"},
{"lineNum":" 2071","line":"#endif"},
{"lineNum":" 2072","line":"}"},
{"lineNum":" 2073","line":""},
{"lineNum":" 2074","line":"// function min: a < b ? a : b"},
{"lineNum":" 2075","line":"static inline Vec8us min(Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 2076","line":"#if INSTRSET >= 5   // SSE4.1"},
{"lineNum":" 2077","line":"    return _mm_min_epu16(a,b);"},
{"lineNum":" 2078","line":"#else  // SSE2"},
{"lineNum":" 2079","line":"    __m128i signbit = _mm_set1_epi32(0x80008000);"},
{"lineNum":" 2080","line":"    __m128i a1      = _mm_xor_si128(a,signbit);            // add 0x8000"},
{"lineNum":" 2081","line":"    __m128i b1      = _mm_xor_si128(b,signbit);            // add 0x8000"},
{"lineNum":" 2082","line":"    __m128i m1      = _mm_min_epi16(a1,b1);                // signed min"},
{"lineNum":" 2083","line":"    return  _mm_xor_si128(m1,signbit);                     // sub 0x8000"},
{"lineNum":" 2084","line":"#endif"},
{"lineNum":" 2085","line":"}"},
{"lineNum":" 2086","line":""},
{"lineNum":" 2087","line":""},
{"lineNum":" 2088","line":""},
{"lineNum":" 2089","line":"/*****************************************************************************"},
{"lineNum":" 2090","line":"*"},
{"lineNum":" 2091","line":"*          Vector of 4 32-bit signed integers"},
{"lineNum":" 2092","line":"*"},
{"lineNum":" 2093","line":"*****************************************************************************/"},
{"lineNum":" 2094","line":""},
{"lineNum":" 2095","line":"class Vec4i : public Vec128b {"},
{"lineNum":" 2096","line":"public:"},
{"lineNum":" 2097","line":"    // Default constructor:"},
{"lineNum":" 2098","line":"    Vec4i() {"},
{"lineNum":" 2099","line":"    }"},
{"lineNum":" 2100","line":"    // Constructor to broadcast the same value into all elements:"},
{"lineNum":" 2101","line":"    Vec4i(int i) {"},
{"lineNum":" 2102","line":"        xmm = _mm_set1_epi32(i);"},
{"lineNum":" 2103","line":"    }"},
{"lineNum":" 2104","line":"    // Constructor to build from all elements:"},
{"lineNum":" 2105","line":"    Vec4i(int32_t i0, int32_t i1, int32_t i2, int32_t i3) {"},
{"lineNum":" 2106","line":"        xmm = _mm_setr_epi32(i0, i1, i2, i3);"},
{"lineNum":" 2107","line":"    }"},
{"lineNum":" 2108","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 2109","line":"    Vec4i(__m128i const & x) {"},
{"lineNum":" 2110","line":"        xmm = x;"},
{"lineNum":" 2111","line":"    }"},
{"lineNum":" 2112","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 2113","line":"    Vec4i & operator = (__m128i const & x) {"},
{"lineNum":" 2114","line":"        xmm = x;"},
{"lineNum":" 2115","line":"        return *this;"},
{"lineNum":" 2116","line":"    }"},
{"lineNum":" 2117","line":"    // Type cast operator to convert to __m128i used in intrinsics"},
{"lineNum":" 2118","line":"    operator __m128i() const {"},
{"lineNum":" 2119","line":"        return xmm;"},
{"lineNum":" 2120","line":"    }"},
{"lineNum":" 2121","line":"    // Member function to load from array (unaligned)"},
{"lineNum":" 2122","line":"    Vec4i & load(void const * p) {"},
{"lineNum":" 2123","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":" 2124","line":"        return *this;"},
{"lineNum":" 2125","line":"    }"},
{"lineNum":" 2126","line":"    // Member function to load from array (aligned)"},
{"lineNum":" 2127","line":"    Vec4i & load_a(void const * p) {"},
{"lineNum":" 2128","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":" 2129","line":"        return *this;"},
{"lineNum":" 2130","line":"    }"},
{"lineNum":" 2131","line":"    // Partial load. Load n elements and set the rest to 0"},
{"lineNum":" 2132","line":"    Vec4i & load_partial(int n, void const * p) {"},
{"lineNum":" 2133","line":"#if INSTRSET >= 10  // AVX512VL"},
{"lineNum":" 2134","line":"        xmm = _mm_maskz_loadu_epi32(__mmask8((1u << n) - 1), p);"},
{"lineNum":" 2135","line":"#else"},
{"lineNum":" 2136","line":"        switch (n) {"},
{"lineNum":" 2137","line":"        case 0:"},
{"lineNum":" 2138","line":"            *this = 0;  break;"},
{"lineNum":" 2139","line":"        case 1:"},
{"lineNum":" 2140","line":"            xmm = _mm_cvtsi32_si128(*(int32_t const*)p);  break;"},
{"lineNum":" 2141","line":"        case 2:"},
{"lineNum":" 2142","line":"            // intrinsic for movq is missing!"},
{"lineNum":" 2143","line":"            xmm = _mm_setr_epi32(((int32_t const*)p)[0], ((int32_t const*)p)[1], 0, 0);  break;"},
{"lineNum":" 2144","line":"        case 3:"},
{"lineNum":" 2145","line":"            xmm = _mm_setr_epi32(((int32_t const*)p)[0], ((int32_t const*)p)[1], ((int32_t const*)p)[2], 0);  break;"},
{"lineNum":" 2146","line":"        case 4:"},
{"lineNum":" 2147","line":"            load(p);  break;"},
{"lineNum":" 2148","line":"        default:"},
{"lineNum":" 2149","line":"            break;"},
{"lineNum":" 2150","line":"        }"},
{"lineNum":" 2151","line":"#endif"},
{"lineNum":" 2152","line":"        return *this;"},
{"lineNum":" 2153","line":"    }"},
{"lineNum":" 2154","line":"    // Partial store. Store n elements"},
{"lineNum":" 2155","line":"    void store_partial(int n, void * p) const {"},
{"lineNum":" 2156","line":"#if INSTRSET >= 10  // AVX512VL + AVX512BW"},
{"lineNum":" 2157","line":"        _mm_mask_storeu_epi32(p, __mmask8((1u << n) - 1), xmm);"},
{"lineNum":" 2158","line":"#else"},
{"lineNum":" 2159","line":"        union {"},
{"lineNum":" 2160","line":"            int32_t i[4];"},
{"lineNum":" 2161","line":"            int64_t q[2];"},
{"lineNum":" 2162","line":"        } u;"},
{"lineNum":" 2163","line":"        switch (n) {"},
{"lineNum":" 2164","line":"        case 1:"},
{"lineNum":" 2165","line":"            *(int32_t*)p = _mm_cvtsi128_si32(xmm);  break;"},
{"lineNum":" 2166","line":"        case 2:"},
{"lineNum":" 2167","line":"            // intrinsic for movq is missing!"},
{"lineNum":" 2168","line":"            store(u.i);"},
{"lineNum":" 2169","line":"            *(int64_t*)p = u.q[0];  break;"},
{"lineNum":" 2170","line":"        case 3:"},
{"lineNum":" 2171","line":"            store(u.i);"},
{"lineNum":" 2172","line":"            *(int64_t*)p     = u.q[0];"},
{"lineNum":" 2173","line":"            ((int32_t*)p)[2] = u.i[2];  break;"},
{"lineNum":" 2174","line":"        case 4:"},
{"lineNum":" 2175","line":"            store(p);  break;"},
{"lineNum":" 2176","line":"        default:"},
{"lineNum":" 2177","line":"            break;"},
{"lineNum":" 2178","line":"        }"},
{"lineNum":" 2179","line":"#endif"},
{"lineNum":" 2180","line":"    }"},
{"lineNum":" 2181","line":"    // cut off vector to n elements. The last 4-n elements are set to zero"},
{"lineNum":" 2182","line":"    Vec4i & cutoff(int n) {"},
{"lineNum":" 2183","line":"#if INSTRSET >= 10"},
{"lineNum":" 2184","line":"        xmm = _mm_maskz_mov_epi32(__mmask8((1u << n) - 1), xmm);"},
{"lineNum":" 2185","line":"#else"},
{"lineNum":" 2186","line":"        *this = Vec16c(xmm).cutoff(n * 4);"},
{"lineNum":" 2187","line":"#endif"},
{"lineNum":" 2188","line":"        return *this;"},
{"lineNum":" 2189","line":"    }"},
{"lineNum":" 2190","line":"    // Member function to change a single element in vector"},
{"lineNum":" 2191","line":"    Vec4i const & insert(int index, int32_t value) {"},
{"lineNum":" 2192","line":"#if INSTRSET >= 10"},
{"lineNum":" 2193","line":"        xmm = _mm_mask_set1_epi32(xmm, __mmask8(1u << index), value);"},
{"lineNum":" 2194","line":"#else"},
{"lineNum":" 2195","line":"        __m128i broad = _mm_set1_epi32(value);  // broadcast value into all elements"},
{"lineNum":" 2196","line":"        static const int32_t maskl[8] = {0,0,0,0,-1,0,0,0};"},
{"lineNum":" 2197","line":"        __m128i mask  = _mm_loadu_si128((__m128i const*)(maskl+4-(index & 3))); // mask with FFFFFFFF at index position"},
{"lineNum":" 2198","line":"        xmm = selectb(mask,broad,xmm);"},
{"lineNum":" 2199","line":"#endif"},
{"lineNum":" 2200","line":"        return *this;"},
{"lineNum":" 2201","line":"    }"},
{"lineNum":" 2202","line":"    // Member function extract a single element from vector"},
{"lineNum":" 2203","line":"    int32_t extract(int index) const {"},
{"lineNum":" 2204","line":"#if INSTRSET >= 10"},
{"lineNum":" 2205","line":"        __m128i x = _mm_maskz_compress_epi32 (__mmask8(1u << index), xmm);"},
{"lineNum":" 2206","line":"        return _mm_cvtsi128_si32(x);"},
{"lineNum":" 2207","line":"#else"},
{"lineNum":" 2208","line":"        int32_t x[4];"},
{"lineNum":" 2209","line":"        store(x);"},
{"lineNum":" 2210","line":"        return x[index & 3];"},
{"lineNum":" 2211","line":"#endif"},
{"lineNum":" 2212","line":"    }"},
{"lineNum":" 2213","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 2214","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 2215","line":"    int32_t operator [] (int index) const {"},
{"lineNum":" 2216","line":"        return extract(index);"},
{"lineNum":" 2217","line":"    }"},
{"lineNum":" 2218","line":"    static int size() {"},
{"lineNum":" 2219","line":"        return 4;"},
{"lineNum":" 2220","line":"    }"},
{"lineNum":" 2221","line":"    static int elementtype() {"},
{"lineNum":" 2222","line":"        return 8;"},
{"lineNum":" 2223","line":"    }"},
{"lineNum":" 2224","line":"};"},
{"lineNum":" 2225","line":""},
{"lineNum":" 2226","line":""},
{"lineNum":" 2227","line":"/*****************************************************************************"},
{"lineNum":" 2228","line":"*"},
{"lineNum":" 2229","line":"*          Vec4ib: Vector of 4 Booleans for use with Vec4i and Vec4ui"},
{"lineNum":" 2230","line":"*"},
{"lineNum":" 2231","line":"*****************************************************************************/"},
{"lineNum":" 2232","line":"class Vec4ib : public Vec4i {"},
{"lineNum":" 2233","line":"public:"},
{"lineNum":" 2234","line":"    // Default constructor:"},
{"lineNum":" 2235","line":"    Vec4ib() {"},
{"lineNum":" 2236","line":"    }"},
{"lineNum":" 2237","line":"    // Constructor to build from all elements:"},
{"lineNum":" 2238","line":"    Vec4ib(bool x0, bool x1, bool x2, bool x3) {"},
{"lineNum":" 2239","line":"        xmm = Vec4i(-int32_t(x0), -int32_t(x1), -int32_t(x2), -int32_t(x3));"},
{"lineNum":" 2240","line":"    }"},
{"lineNum":" 2241","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 2242","line":"    Vec4ib(__m128i const & x) {"},
{"lineNum":" 2243","line":"        xmm = x;"},
{"lineNum":" 2244","line":"    }"},
{"lineNum":" 2245","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 2246","line":"    Vec4ib & operator = (__m128i const & x) {"},
{"lineNum":" 2247","line":"        xmm = x;"},
{"lineNum":" 2248","line":"        return *this;"},
{"lineNum":" 2249","line":"    }"},
{"lineNum":" 2250","line":"    // Constructor to broadcast scalar value:"},
{"lineNum":" 2251","line":"    Vec4ib(bool b) : Vec4i(-int32_t(b)) {"},
{"lineNum":" 2252","line":"    }"},
{"lineNum":" 2253","line":"    // Assignment operator to broadcast scalar value:"},
{"lineNum":" 2254","line":"    Vec4ib & operator = (bool b) {"},
{"lineNum":" 2255","line":"        *this = Vec4ib(b);"},
{"lineNum":" 2256","line":"        return *this;"},
{"lineNum":" 2257","line":"    }"},
{"lineNum":" 2258","line":"    Vec4ib & insert (int index, bool a) {"},
{"lineNum":" 2259","line":"        Vec4i::insert(index, -(int)a);"},
{"lineNum":" 2260","line":"        return *this;"},
{"lineNum":" 2261","line":"    }"},
{"lineNum":" 2262","line":"    // Member function extract a single element from vector"},
{"lineNum":" 2263","line":"    bool extract(int index) const {"},
{"lineNum":" 2264","line":"        return Vec4i::extract(index) != 0;"},
{"lineNum":" 2265","line":"    }"},
{"lineNum":" 2266","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 2267","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 2268","line":"    bool operator [] (int index) const {"},
{"lineNum":" 2269","line":"        return extract(index);"},
{"lineNum":" 2270","line":"    }"},
{"lineNum":" 2271","line":"    // Member function to change a bitfield to a boolean vector"},
{"lineNum":" 2272","line":"    Vec4ib & load_bits(uint8_t a) {"},
{"lineNum":" 2273","line":"        __m128i b1 = _mm_set1_epi8((int8_t)a);  // broadcast byte"},
{"lineNum":" 2274","line":"        __m128i m1 = constant4ui<1,2,4,8>();"},
{"lineNum":" 2275","line":"        __m128i c1 = _mm_and_si128(b1, m1); // isolate one bit in each byte"},
{"lineNum":" 2276","line":"        xmm = _mm_cmpgt_epi32(c1, _mm_setzero_si128());  // compare signed because no numbers are negative"},
{"lineNum":" 2277","line":"        return *this;"},
{"lineNum":" 2278","line":"    }"},
{"lineNum":" 2279","line":"    static int elementtype() {"},
{"lineNum":" 2280","line":"        return 3;"},
{"lineNum":" 2281","line":"    }"},
{"lineNum":" 2282","line":"private: // Prevent constructing from int, etc."},
{"lineNum":" 2283","line":"    Vec4ib(int b);"},
{"lineNum":" 2284","line":"    Vec4ib & operator = (int x);"},
{"lineNum":" 2285","line":"};"},
{"lineNum":" 2286","line":""},
{"lineNum":" 2287","line":""},
{"lineNum":" 2288","line":"/*****************************************************************************"},
{"lineNum":" 2289","line":"*"},
{"lineNum":" 2290","line":"*          Define operators for Vec4ib"},
{"lineNum":" 2291","line":"*"},
{"lineNum":" 2292","line":"*****************************************************************************/"},
{"lineNum":" 2293","line":""},
{"lineNum":" 2294","line":"// vector operator & : bitwise and"},
{"lineNum":" 2295","line":"static inline Vec4ib operator & (Vec4ib const & a, Vec4ib const & b) {"},
{"lineNum":" 2296","line":"    return Vec4ib(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 2297","line":"}"},
{"lineNum":" 2298","line":"static inline Vec4ib operator && (Vec4ib const & a, Vec4ib const & b) {"},
{"lineNum":" 2299","line":"    return a & b;"},
{"lineNum":" 2300","line":"}"},
{"lineNum":" 2301","line":"// vector operator &= : bitwise and"},
{"lineNum":" 2302","line":"static inline Vec4ib & operator &= (Vec4ib & a, Vec4ib const & b) {"},
{"lineNum":" 2303","line":"    a = a & b;"},
{"lineNum":" 2304","line":"    return a;"},
{"lineNum":" 2305","line":"}"},
{"lineNum":" 2306","line":""},
{"lineNum":" 2307","line":"// vector operator | : bitwise or"},
{"lineNum":" 2308","line":"static inline Vec4ib operator | (Vec4ib const & a, Vec4ib const & b) {"},
{"lineNum":" 2309","line":"    return Vec4ib(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 2310","line":"}"},
{"lineNum":" 2311","line":"static inline Vec4ib operator || (Vec4ib const & a, Vec4ib const & b) {"},
{"lineNum":" 2312","line":"    return a | b;"},
{"lineNum":" 2313","line":"}"},
{"lineNum":" 2314","line":"// vector operator |= : bitwise or"},
{"lineNum":" 2315","line":"static inline Vec4ib & operator |= (Vec4ib & a, Vec4ib const & b) {"},
{"lineNum":" 2316","line":"    a = a | b;"},
{"lineNum":" 2317","line":"    return a;"},
{"lineNum":" 2318","line":"}"},
{"lineNum":" 2319","line":""},
{"lineNum":" 2320","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 2321","line":"static inline Vec4ib operator ^ (Vec4ib const & a, Vec4ib const & b) {"},
{"lineNum":" 2322","line":"    return Vec4ib(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 2323","line":"}"},
{"lineNum":" 2324","line":"// vector operator ^= : bitwise xor"},
{"lineNum":" 2325","line":"static inline Vec4ib & operator ^= (Vec4ib & a, Vec4ib const & b) {"},
{"lineNum":" 2326","line":"    a = a ^ b;"},
{"lineNum":" 2327","line":"    return a;"},
{"lineNum":" 2328","line":"}"},
{"lineNum":" 2329","line":""},
{"lineNum":" 2330","line":"// vector operator == : xnor"},
{"lineNum":" 2331","line":"static inline Vec4ib operator == (Vec4ib const & a, Vec4ib const & b) {"},
{"lineNum":" 2332","line":"    return Vec4ib(a ^ (~b));"},
{"lineNum":" 2333","line":"}"},
{"lineNum":" 2334","line":""},
{"lineNum":" 2335","line":"// vector operator != : xor"},
{"lineNum":" 2336","line":"static inline Vec4ib operator != (Vec4ib const & a, Vec4ib const & b) {"},
{"lineNum":" 2337","line":"    return Vec4ib(a ^ b);"},
{"lineNum":" 2338","line":"}"},
{"lineNum":" 2339","line":""},
{"lineNum":" 2340","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 2341","line":"static inline Vec4ib operator ~ (Vec4ib const & a) {"},
{"lineNum":" 2342","line":"    return Vec4ib( ~ Vec128b(a));"},
{"lineNum":" 2343","line":"}"},
{"lineNum":" 2344","line":""},
{"lineNum":" 2345","line":"// vector operator ! : element not"},
{"lineNum":" 2346","line":"static inline Vec4ib operator ! (Vec4ib const & a) {"},
{"lineNum":" 2347","line":"    return ~ a;"},
{"lineNum":" 2348","line":"}"},
{"lineNum":" 2349","line":""},
{"lineNum":" 2350","line":"// vector function andnot"},
{"lineNum":" 2351","line":"static inline Vec4ib andnot (Vec4ib const & a, Vec4ib const & b) {"},
{"lineNum":" 2352","line":"    return Vec4ib(andnot(Vec128b(a), Vec128b(b)));"},
{"lineNum":" 2353","line":"}"},
{"lineNum":" 2354","line":""},
{"lineNum":" 2355","line":"// Horizontal Boolean functions for Vec4ib"},
{"lineNum":" 2356","line":""},
{"lineNum":" 2357","line":"// horizontal_and. Returns true if all elements are true"},
{"lineNum":" 2358","line":"static inline bool horizontal_and(Vec4ib const & a) {"},
{"lineNum":" 2359","line":"    return _mm_movemask_epi8(a) == 0xFFFF;"},
{"lineNum":" 2360","line":"}"},
{"lineNum":" 2361","line":""},
{"lineNum":" 2362","line":"// horizontal_or. Returns true if at least one element is true"},
{"lineNum":" 2363","line":"static inline bool horizontal_or(Vec4ib const & a) {"},
{"lineNum":" 2364","line":"#if INSTRSET >= 5   // SSE4.1 supported. Use PTEST"},
{"lineNum":" 2365","line":"    return !_mm_testz_si128(a, a);"},
{"lineNum":" 2366","line":"#else"},
{"lineNum":" 2367","line":"    return _mm_movemask_epi8(a) != 0;"},
{"lineNum":" 2368","line":"#endif"},
{"lineNum":" 2369","line":"}"},
{"lineNum":" 2370","line":""},
{"lineNum":" 2371","line":""},
{"lineNum":" 2372","line":"/*****************************************************************************"},
{"lineNum":" 2373","line":"*"},
{"lineNum":" 2374","line":"*          Operators for Vec4i"},
{"lineNum":" 2375","line":"*"},
{"lineNum":" 2376","line":"*****************************************************************************/"},
{"lineNum":" 2377","line":""},
{"lineNum":" 2378","line":"// vector operator + : add element by element"},
{"lineNum":" 2379","line":"static inline Vec4i operator + (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2380","line":"    return _mm_add_epi32(a, b);"},
{"lineNum":" 2381","line":"}"},
{"lineNum":" 2382","line":""},
{"lineNum":" 2383","line":"// vector operator += : add"},
{"lineNum":" 2384","line":"static inline Vec4i & operator += (Vec4i & a, Vec4i const & b) {"},
{"lineNum":" 2385","line":"    a = a + b;"},
{"lineNum":" 2386","line":"    return a;"},
{"lineNum":" 2387","line":"}"},
{"lineNum":" 2388","line":""},
{"lineNum":" 2389","line":"// postfix operator ++"},
{"lineNum":" 2390","line":"static inline Vec4i operator ++ (Vec4i & a, int) {"},
{"lineNum":" 2391","line":"    Vec4i a0 = a;"},
{"lineNum":" 2392","line":"    a = a + 1;"},
{"lineNum":" 2393","line":"    return a0;"},
{"lineNum":" 2394","line":"}"},
{"lineNum":" 2395","line":""},
{"lineNum":" 2396","line":"// prefix operator ++"},
{"lineNum":" 2397","line":"static inline Vec4i & operator ++ (Vec4i & a) {"},
{"lineNum":" 2398","line":"    a = a + 1;"},
{"lineNum":" 2399","line":"    return a;"},
{"lineNum":" 2400","line":"}"},
{"lineNum":" 2401","line":""},
{"lineNum":" 2402","line":"// vector operator - : subtract element by element"},
{"lineNum":" 2403","line":"static inline Vec4i operator - (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2404","line":"    return _mm_sub_epi32(a, b);"},
{"lineNum":" 2405","line":"}"},
{"lineNum":" 2406","line":""},
{"lineNum":" 2407","line":"// vector operator - : unary minus"},
{"lineNum":" 2408","line":"static inline Vec4i operator - (Vec4i const & a) {"},
{"lineNum":" 2409","line":"    return _mm_sub_epi32(_mm_setzero_si128(), a);"},
{"lineNum":" 2410","line":"}"},
{"lineNum":" 2411","line":""},
{"lineNum":" 2412","line":"// vector operator -= : subtract"},
{"lineNum":" 2413","line":"static inline Vec4i & operator -= (Vec4i & a, Vec4i const & b) {"},
{"lineNum":" 2414","line":"    a = a - b;"},
{"lineNum":" 2415","line":"    return a;"},
{"lineNum":" 2416","line":"}"},
{"lineNum":" 2417","line":""},
{"lineNum":" 2418","line":"// postfix operator --"},
{"lineNum":" 2419","line":"static inline Vec4i operator -- (Vec4i & a, int) {"},
{"lineNum":" 2420","line":"    Vec4i a0 = a;"},
{"lineNum":" 2421","line":"    a = a - 1;"},
{"lineNum":" 2422","line":"    return a0;"},
{"lineNum":" 2423","line":"}"},
{"lineNum":" 2424","line":""},
{"lineNum":" 2425","line":"// prefix operator --"},
{"lineNum":" 2426","line":"static inline Vec4i & operator -- (Vec4i & a) {"},
{"lineNum":" 2427","line":"    a = a - 1;"},
{"lineNum":" 2428","line":"    return a;"},
{"lineNum":" 2429","line":"}"},
{"lineNum":" 2430","line":""},
{"lineNum":" 2431","line":"// vector operator * : multiply element by element"},
{"lineNum":" 2432","line":"static inline Vec4i operator * (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2433","line":"#if INSTRSET >= 5  // SSE4.1 instruction set"},
{"lineNum":" 2434","line":"    return _mm_mullo_epi32(a, b);"},
{"lineNum":" 2435","line":"#else"},
{"lineNum":" 2436","line":"   __m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)"},
{"lineNum":" 2437","line":"   __m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)"},
{"lineNum":" 2438","line":"   __m128i prod02 = _mm_mul_epu32(a, b);                 // (-,a2*b2,-,a0*b0)"},
{"lineNum":" 2439","line":"   __m128i prod13 = _mm_mul_epu32(a13, b13);             // (-,a3*b3,-,a1*b1)"},
{"lineNum":" 2440","line":"   __m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (-,-,a1*b1,a0*b0)"},
{"lineNum":" 2441","line":"   __m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (-,-,a3*b3,a2*b2)"},
{"lineNum":" 2442","line":"   return           _mm_unpacklo_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)"},
{"lineNum":" 2443","line":"#endif"},
{"lineNum":" 2444","line":"}"},
{"lineNum":" 2445","line":""},
{"lineNum":" 2446","line":"// vector operator *= : multiply"},
{"lineNum":" 2447","line":"static inline Vec4i & operator *= (Vec4i & a, Vec4i const & b) {"},
{"lineNum":" 2448","line":"    a = a * b;"},
{"lineNum":" 2449","line":"    return a;"},
{"lineNum":" 2450","line":"}"},
{"lineNum":" 2451","line":""},
{"lineNum":" 2452","line":"// vector operator / : divide all elements by same integer"},
{"lineNum":" 2453","line":"// See bottom of file"},
{"lineNum":" 2454","line":""},
{"lineNum":" 2455","line":""},
{"lineNum":" 2456","line":"// vector operator << : shift left"},
{"lineNum":" 2457","line":"static inline Vec4i operator << (Vec4i const & a, int32_t b) {"},
{"lineNum":" 2458","line":"    return _mm_sll_epi32(a,_mm_cvtsi32_si128(b));"},
{"lineNum":" 2459","line":"}"},
{"lineNum":" 2460","line":""},
{"lineNum":" 2461","line":"// vector operator <<= : shift left"},
{"lineNum":" 2462","line":"static inline Vec4i & operator <<= (Vec4i & a, int32_t b) {"},
{"lineNum":" 2463","line":"    a = a << b;"},
{"lineNum":" 2464","line":"    return a;"},
{"lineNum":" 2465","line":"}"},
{"lineNum":" 2466","line":""},
{"lineNum":" 2467","line":"// vector operator >> : shift right arithmetic"},
{"lineNum":" 2468","line":"static inline Vec4i operator >> (Vec4i const & a, int32_t b) {"},
{"lineNum":" 2469","line":"    return _mm_sra_epi32(a,_mm_cvtsi32_si128(b));"},
{"lineNum":" 2470","line":"}"},
{"lineNum":" 2471","line":""},
{"lineNum":" 2472","line":"// vector operator >>= : shift right arithmetic"},
{"lineNum":" 2473","line":"static inline Vec4i & operator >>= (Vec4i & a, int32_t b) {"},
{"lineNum":" 2474","line":"    a = a >> b;"},
{"lineNum":" 2475","line":"    return a;"},
{"lineNum":" 2476","line":"}"},
{"lineNum":" 2477","line":""},
{"lineNum":" 2478","line":"// vector operator == : returns true for elements for which a == b"},
{"lineNum":" 2479","line":"static inline Vec4ib operator == (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2480","line":"    return _mm_cmpeq_epi32(a, b);"},
{"lineNum":" 2481","line":"}"},
{"lineNum":" 2482","line":""},
{"lineNum":" 2483","line":"// vector operator != : returns true for elements for which a != b"},
{"lineNum":" 2484","line":"static inline Vec4ib operator != (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2485","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 2486","line":"    return (Vec4ib)_mm_comneq_epi32(a,b);"},
{"lineNum":" 2487","line":"#else  // SSE2 instruction set"},
{"lineNum":" 2488","line":"    return Vec4ib(Vec4i (~(a == b)));"},
{"lineNum":" 2489","line":"#endif"},
{"lineNum":" 2490","line":"}"},
{"lineNum":" 2491","line":""},
{"lineNum":" 2492","line":"// vector operator > : returns true for elements for which a > b"},
{"lineNum":" 2493","line":"static inline Vec4ib operator > (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2494","line":"    return _mm_cmpgt_epi32(a, b);"},
{"lineNum":" 2495","line":"}"},
{"lineNum":" 2496","line":""},
{"lineNum":" 2497","line":"// vector operator < : returns true for elements for which a < b"},
{"lineNum":" 2498","line":"static inline Vec4ib operator < (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2499","line":"    return b > a;"},
{"lineNum":" 2500","line":"}"},
{"lineNum":" 2501","line":""},
{"lineNum":" 2502","line":"// vector operator >= : returns true for elements for which a >= b (signed)"},
{"lineNum":" 2503","line":"static inline Vec4ib operator >= (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2504","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 2505","line":"    return (Vec4ib)_mm_comge_epi32(a,b);"},
{"lineNum":" 2506","line":"#else  // SSE2 instruction set"},
{"lineNum":" 2507","line":"    return Vec4ib(Vec4i (~(b > a)));"},
{"lineNum":" 2508","line":"#endif"},
{"lineNum":" 2509","line":"}"},
{"lineNum":" 2510","line":""},
{"lineNum":" 2511","line":"// vector operator <= : returns true for elements for which a <= b (signed)"},
{"lineNum":" 2512","line":"static inline Vec4ib operator <= (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2513","line":"    return b >= a;"},
{"lineNum":" 2514","line":"}"},
{"lineNum":" 2515","line":""},
{"lineNum":" 2516","line":"// vector operator & : bitwise and"},
{"lineNum":" 2517","line":"static inline Vec4i operator & (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2518","line":"    return Vec4i(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 2519","line":"}"},
{"lineNum":" 2520","line":"static inline Vec4i operator && (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2521","line":"    return a & b;"},
{"lineNum":" 2522","line":"}"},
{"lineNum":" 2523","line":"// vector operator &= : bitwise and"},
{"lineNum":" 2524","line":"static inline Vec4i & operator &= (Vec4i & a, Vec4i const & b) {"},
{"lineNum":" 2525","line":"    a = a & b;"},
{"lineNum":" 2526","line":"    return a;"},
{"lineNum":" 2527","line":"}"},
{"lineNum":" 2528","line":""},
{"lineNum":" 2529","line":"// vector operator | : bitwise or"},
{"lineNum":" 2530","line":"static inline Vec4i operator | (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2531","line":"    return Vec4i(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 2532","line":"}"},
{"lineNum":" 2533","line":"static inline Vec4i operator || (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2534","line":"    return a | b;"},
{"lineNum":" 2535","line":"}"},
{"lineNum":" 2536","line":"// vector operator |= : bitwise and"},
{"lineNum":" 2537","line":"static inline Vec4i & operator |= (Vec4i & a, Vec4i const & b) {"},
{"lineNum":" 2538","line":"    a = a | b;"},
{"lineNum":" 2539","line":"    return a;"},
{"lineNum":" 2540","line":"}"},
{"lineNum":" 2541","line":""},
{"lineNum":" 2542","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 2543","line":"static inline Vec4i operator ^ (Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2544","line":"    return Vec4i(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 2545","line":"}"},
{"lineNum":" 2546","line":"// vector operator ^= : bitwise and"},
{"lineNum":" 2547","line":"static inline Vec4i & operator ^= (Vec4i & a, Vec4i const & b) {"},
{"lineNum":" 2548","line":"    a = a ^ b;"},
{"lineNum":" 2549","line":"    return a;"},
{"lineNum":" 2550","line":"}"},
{"lineNum":" 2551","line":""},
{"lineNum":" 2552","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 2553","line":"static inline Vec4i operator ~ (Vec4i const & a) {"},
{"lineNum":" 2554","line":"    return Vec4i( ~ Vec128b(a));"},
{"lineNum":" 2555","line":"}"},
{"lineNum":" 2556","line":""},
{"lineNum":" 2557","line":"// vector operator ! : returns true for elements == 0"},
{"lineNum":" 2558","line":"static inline Vec4ib operator ! (Vec4i const & a) {"},
{"lineNum":" 2559","line":"    return _mm_cmpeq_epi32(a,_mm_setzero_si128());"},
{"lineNum":" 2560","line":"}"},
{"lineNum":" 2561","line":""},
{"lineNum":" 2562","line":"// Functions for this class"},
{"lineNum":" 2563","line":""},
{"lineNum":" 2564","line":"// Select between two operands. Corresponds to this pseudocode:"},
{"lineNum":" 2565","line":"// for (int i = 0; i < 4; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":" 2566","line":"// Each byte in s must be either 0 (false) or -1 (true). No other values are allowed."},
{"lineNum":" 2567","line":"// (s is signed)"},
{"lineNum":" 2568","line":"static inline Vec4i select (Vec4ib const & s, Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2569","line":"    return selectb(s,a,b);"},
{"lineNum":" 2570","line":"}"},
{"lineNum":" 2571","line":""},
{"lineNum":" 2572","line":"// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]"},
{"lineNum":" 2573","line":"static inline Vec4i if_add (Vec4ib const & f, Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2574","line":"    return a + (Vec4i(f) & b);"},
{"lineNum":" 2575","line":"}"},
{"lineNum":" 2576","line":""},
{"lineNum":" 2577","line":"// Conditional sub: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]"},
{"lineNum":" 2578","line":"static inline Vec4i if_sub (Vec4ib const & f, Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2579","line":"    return a - (Vec4i(f) & b);"},
{"lineNum":" 2580","line":"}"},
{"lineNum":" 2581","line":""},
{"lineNum":" 2582","line":"// Conditional mul: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]"},
{"lineNum":" 2583","line":"static inline Vec4i if_mul (Vec4ib const & f, Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2584","line":"    return select(f, a*b, a);"},
{"lineNum":" 2585","line":"}"},
{"lineNum":" 2586","line":""},
{"lineNum":" 2587","line":"// Horizontal add: Calculates the sum of all vector elements."},
{"lineNum":" 2588","line":"// Overflow will wrap around"},
{"lineNum":" 2589","line":"static inline int32_t horizontal_add (Vec4i const & a) {"},
{"lineNum":" 2590","line":"#ifdef __XOP__       // AMD XOP instruction set"},
{"lineNum":" 2591","line":"    __m128i sum1  = _mm_haddq_epi32(a);"},
{"lineNum":" 2592","line":"    __m128i sum2  = _mm_shuffle_epi32(sum1,0x0E);          // high element"},
{"lineNum":" 2593","line":"    __m128i sum3  = _mm_add_epi32(sum1,sum2);              // sum"},
{"lineNum":" 2594","line":"    return          _mm_cvtsi128_si32(sum3);               // truncate to 32 bits"},
{"lineNum":" 2595","line":"#elif  INSTRSET >= 4 & false // SSSE3"},
{"lineNum":" 2596","line":"    // The hadd instruction is inefficient, and may be split into two instructions for faster decoding"},
{"lineNum":" 2597","line":"    __m128i sum1  = _mm_hadd_epi32(a,a);                   // horizontally add 4 elements in 2 steps"},
{"lineNum":" 2598","line":"    __m128i sum2  = _mm_hadd_epi32(sum1,sum1);"},
{"lineNum":" 2599","line":"    return          _mm_cvtsi128_si32(sum2);               // 32 bit sum"},
{"lineNum":" 2600","line":"#else                 // SSE2"},
{"lineNum":" 2601","line":"    __m128i sum1  = _mm_unpackhi_epi64(a,a);               // 2 high elements"},
{"lineNum":" 2602","line":"    __m128i sum2  = _mm_add_epi32(a,sum1);                 // 2 sums"},
{"lineNum":" 2603","line":"    __m128i sum3  = _mm_shuffle_epi32(sum2,0x01);          // 1 high element"},
{"lineNum":" 2604","line":"    __m128i sum4  = _mm_add_epi32(sum2,sum3);              // 2 sums"},
{"lineNum":" 2605","line":"    return          _mm_cvtsi128_si32(sum4);               // 32 bit sum"},
{"lineNum":" 2606","line":"#endif"},
{"lineNum":" 2607","line":"}"},
{"lineNum":" 2608","line":""},
{"lineNum":" 2609","line":"static inline int64_t _emulate_movq(__m128i const & x) {"},
{"lineNum":" 2610","line":"#ifdef __x86_64__"},
{"lineNum":" 2611","line":"    return _mm_cvtsi128_si64(x);"},
{"lineNum":" 2612","line":"#else"},
{"lineNum":" 2613","line":"    // 64 bit registers not available"},
{"lineNum":" 2614","line":"    union {"},
{"lineNum":" 2615","line":"        __m128i m;"},
{"lineNum":" 2616","line":"        int64_t y;"},
{"lineNum":" 2617","line":"    } u;"},
{"lineNum":" 2618","line":"    _mm_storel_epi64(&u.m, x);"},
{"lineNum":" 2619","line":"    return u.y;"},
{"lineNum":" 2620","line":"#endif"},
{"lineNum":" 2621","line":"}"},
{"lineNum":" 2622","line":""},
{"lineNum":" 2623","line":"// Horizontal add extended: Calculates the sum of all vector elements."},
{"lineNum":" 2624","line":"// Elements are sign extended before adding to avoid overflow"},
{"lineNum":" 2625","line":"static inline int64_t horizontal_add_x (Vec4i const & a) {"},
{"lineNum":" 2626","line":"#ifdef __XOP__     // AMD XOP instruction set"},
{"lineNum":" 2627","line":"    __m128i sum1  = _mm_haddq_epi32(a);"},
{"lineNum":" 2628","line":"#else              // SSE2"},
{"lineNum":" 2629","line":"    __m128i signs = _mm_srai_epi32(a,31);                  // sign of all elements"},
{"lineNum":" 2630","line":"    __m128i a01   = _mm_unpacklo_epi32(a,signs);           // sign-extended a0, a1"},
{"lineNum":" 2631","line":"    __m128i a23   = _mm_unpackhi_epi32(a,signs);           // sign-extended a2, a3"},
{"lineNum":" 2632","line":"    __m128i sum1  = _mm_add_epi64(a01,a23);                // add"},
{"lineNum":" 2633","line":"#endif"},
{"lineNum":" 2634","line":"    __m128i sum2  = _mm_unpackhi_epi64(sum1,sum1);         // high qword"},
{"lineNum":" 2635","line":"    __m128i sum3  = _mm_add_epi64(sum1,sum2);              // add"},
{"lineNum":" 2636","line":"    return _emulate_movq(sum3);"},
{"lineNum":" 2637","line":"}"},
{"lineNum":" 2638","line":""},
{"lineNum":" 2639","line":"// function add_saturated: add element by element, signed with saturation"},
{"lineNum":" 2640","line":"static inline Vec4i add_saturated(Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2641","line":"    __m128i sum    = _mm_add_epi32(a, b);                  // a + b"},
{"lineNum":" 2642","line":"    __m128i axb    = _mm_xor_si128(a, b);                  // check if a and b have different sign"},
{"lineNum":" 2643","line":"    __m128i axs    = _mm_xor_si128(a, sum);                // check if a and sum have different sign"},
{"lineNum":" 2644","line":"    __m128i overf1 = _mm_andnot_si128(axb,axs);            // check if sum has wrong sign"},
{"lineNum":" 2645","line":"    __m128i overf2 = _mm_srai_epi32(overf1,31);            // -1 if overflow"},
{"lineNum":" 2646","line":"    __m128i asign  = _mm_srli_epi32(a,31);                 // 1  if a < 0"},
{"lineNum":" 2647","line":"    __m128i sat1   = _mm_srli_epi32(overf2,1);             // 7FFFFFFF if overflow"},
{"lineNum":" 2648","line":"    __m128i sat2   = _mm_add_epi32(sat1,asign);            // 7FFFFFFF if positive overflow 80000000 if negative overflow"},
{"lineNum":" 2649","line":"    return  selectb(overf2,sat2,sum);                      // sum if not overflow, else sat2"},
{"lineNum":" 2650","line":"}"},
{"lineNum":" 2651","line":""},
{"lineNum":" 2652","line":"// function sub_saturated: subtract element by element, signed with saturation"},
{"lineNum":" 2653","line":"static inline Vec4i sub_saturated(Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2654","line":"    __m128i diff   = _mm_sub_epi32(a, b);                  // a + b"},
{"lineNum":" 2655","line":"    __m128i axb    = _mm_xor_si128(a, b);                  // check if a and b have different sign"},
{"lineNum":" 2656","line":"    __m128i axs    = _mm_xor_si128(a, diff);               // check if a and sum have different sign"},
{"lineNum":" 2657","line":"    __m128i overf1 = _mm_and_si128(axb,axs);               // check if sum has wrong sign"},
{"lineNum":" 2658","line":"    __m128i overf2 = _mm_srai_epi32(overf1,31);            // -1 if overflow"},
{"lineNum":" 2659","line":"    __m128i asign  = _mm_srli_epi32(a,31);                 // 1  if a < 0"},
{"lineNum":" 2660","line":"    __m128i sat1   = _mm_srli_epi32(overf2,1);             // 7FFFFFFF if overflow"},
{"lineNum":" 2661","line":"    __m128i sat2   = _mm_add_epi32(sat1,asign);            // 7FFFFFFF if positive overflow 80000000 if negative overflow"},
{"lineNum":" 2662","line":"    return  selectb(overf2,sat2,diff);                     // diff if not overflow, else sat2"},
{"lineNum":" 2663","line":"}"},
{"lineNum":" 2664","line":""},
{"lineNum":" 2665","line":"// function max: a > b ? a : b"},
{"lineNum":" 2666","line":"static inline Vec4i max(Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2667","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 2668","line":"    return _mm_max_epi32(a,b);"},
{"lineNum":" 2669","line":"#else"},
{"lineNum":" 2670","line":"    __m128i greater = _mm_cmpgt_epi32(a,b);"},
{"lineNum":" 2671","line":"    return selectb(greater,a,b);"},
{"lineNum":" 2672","line":"#endif"},
{"lineNum":" 2673","line":"}"},
{"lineNum":" 2674","line":""},
{"lineNum":" 2675","line":"// function min: a < b ? a : b"},
{"lineNum":" 2676","line":"static inline Vec4i min(Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 2677","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 2678","line":"    return _mm_min_epi32(a,b);"},
{"lineNum":" 2679","line":"#else"},
{"lineNum":" 2680","line":"    __m128i greater = _mm_cmpgt_epi32(a,b);"},
{"lineNum":" 2681","line":"    return selectb(greater,b,a);"},
{"lineNum":" 2682","line":"#endif"},
{"lineNum":" 2683","line":"}"},
{"lineNum":" 2684","line":""},
{"lineNum":" 2685","line":"// function abs: a >= 0 ? a : -a"},
{"lineNum":" 2686","line":"static inline Vec4i abs(Vec4i const & a) {"},
{"lineNum":" 2687","line":"#if INSTRSET >= 4     // SSSE3 supported"},
{"lineNum":" 2688","line":"    return _mm_abs_epi32(a);"},
{"lineNum":" 2689","line":"#else                 // SSE2"},
{"lineNum":" 2690","line":"    __m128i sign = _mm_srai_epi32(a,31);                   // sign of a"},
{"lineNum":" 2691","line":"    __m128i inv  = _mm_xor_si128(a,sign);                  // invert bits if negative"},
{"lineNum":" 2692","line":"    return         _mm_sub_epi32(inv,sign);                // add 1"},
{"lineNum":" 2693","line":"#endif"},
{"lineNum":" 2694","line":"}"},
{"lineNum":" 2695","line":""},
{"lineNum":" 2696","line":"// function abs_saturated: same as abs, saturate if overflow"},
{"lineNum":" 2697","line":"static inline Vec4i abs_saturated(Vec4i const & a) {"},
{"lineNum":" 2698","line":"    __m128i absa   = abs(a);                               // abs(a)"},
{"lineNum":" 2699","line":"    __m128i overfl = _mm_srai_epi32(absa,31);              // sign"},
{"lineNum":" 2700","line":"    return           _mm_add_epi32(absa,overfl);           // subtract 1 if 0x80000000"},
{"lineNum":" 2701","line":"}"},
{"lineNum":" 2702","line":""},
{"lineNum":" 2703","line":"// function rotate_left all elements"},
{"lineNum":" 2704","line":"// Use negative count to rotate right"},
{"lineNum":" 2705","line":"static inline Vec4i rotate_left(Vec4i const & a, int b) {"},
{"lineNum":" 2706","line":"#if INSTRSET >= 10  // __AVX512VL__"},
{"lineNum":" 2707","line":"    return _mm_rolv_epi32(a, _mm_set1_epi32(b));"},
{"lineNum":" 2708","line":"#elif defined __XOP__  // AMD XOP instruction set"},
{"lineNum":" 2709","line":"    return _mm_rot_epi32(a,_mm_set1_epi32(b));"},
{"lineNum":" 2710","line":"#else  // SSE2 instruction set"},
{"lineNum":" 2711","line":"    __m128i left  = _mm_sll_epi32(a,_mm_cvtsi32_si128(b & 0x1F));      // a << b"},
{"lineNum":" 2712","line":"    __m128i right = _mm_srl_epi32(a,_mm_cvtsi32_si128((-b) & 0x1F));   // a >> (32 - b)"},
{"lineNum":" 2713","line":"    __m128i rot   = _mm_or_si128(left,right);                          // or"},
{"lineNum":" 2714","line":"    return  rot;"},
{"lineNum":" 2715","line":"#endif"},
{"lineNum":" 2716","line":"}"},
{"lineNum":" 2717","line":""},
{"lineNum":" 2718","line":""},
{"lineNum":" 2719","line":"/*****************************************************************************"},
{"lineNum":" 2720","line":"*"},
{"lineNum":" 2721","line":"*          Vector of 4 32-bit unsigned integers"},
{"lineNum":" 2722","line":"*"},
{"lineNum":" 2723","line":"*****************************************************************************/"},
{"lineNum":" 2724","line":""},
{"lineNum":" 2725","line":"class Vec4ui : public Vec4i {"},
{"lineNum":" 2726","line":"public:"},
{"lineNum":" 2727","line":"    // Default constructor:"},
{"lineNum":" 2728","line":"    Vec4ui() {"},
{"lineNum":" 2729","line":"    }"},
{"lineNum":" 2730","line":"    // Constructor to broadcast the same value into all elements:"},
{"lineNum":" 2731","line":"    Vec4ui(uint32_t i) {"},
{"lineNum":" 2732","line":"        xmm = _mm_set1_epi32((int32_t)i);"},
{"lineNum":" 2733","line":"    }"},
{"lineNum":" 2734","line":"    // Constructor to build from all elements:"},
{"lineNum":" 2735","line":"    Vec4ui(uint32_t i0, uint32_t i1, uint32_t i2, uint32_t i3) {"},
{"lineNum":" 2736","line":"        xmm = _mm_setr_epi32((int32_t)i0, (int32_t)i1, (int32_t)i2, (int32_t)i3);"},
{"lineNum":" 2737","line":"    }"},
{"lineNum":" 2738","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 2739","line":"    Vec4ui(__m128i const & x) {"},
{"lineNum":" 2740","line":"        xmm = x;"},
{"lineNum":" 2741","line":"    }"},
{"lineNum":" 2742","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 2743","line":"    Vec4ui & operator = (__m128i const & x) {"},
{"lineNum":" 2744","line":"        xmm = x;"},
{"lineNum":" 2745","line":"        return *this;"},
{"lineNum":" 2746","line":"    }"},
{"lineNum":" 2747","line":"    // Member function to load from array (unaligned)"},
{"lineNum":" 2748","line":"    Vec4ui & load(void const * p) {"},
{"lineNum":" 2749","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":" 2750","line":"        return *this;"},
{"lineNum":" 2751","line":"    }"},
{"lineNum":" 2752","line":"    // Member function to load from array (aligned)"},
{"lineNum":" 2753","line":"    Vec4ui & load_a(void const * p) {"},
{"lineNum":" 2754","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":" 2755","line":"        return *this;"},
{"lineNum":" 2756","line":"    }"},
{"lineNum":" 2757","line":"    // Member function to change a single element in vector"},
{"lineNum":" 2758","line":"    // Note: This function is inefficient. Use load function if changing more than one element"},
{"lineNum":" 2759","line":"    Vec4ui const & insert(int index, uint32_t value) {"},
{"lineNum":" 2760","line":"        Vec4i::insert(index, (int32_t)value);"},
{"lineNum":" 2761","line":"        return *this;"},
{"lineNum":" 2762","line":"    }"},
{"lineNum":" 2763","line":"    // Member function extract a single element from vector"},
{"lineNum":" 2764","line":"    uint32_t extract(int index) const {"},
{"lineNum":" 2765","line":"        return (uint32_t)Vec4i::extract(index);"},
{"lineNum":" 2766","line":"    }"},
{"lineNum":" 2767","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 2768","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 2769","line":"    uint32_t operator [] (int index) const {"},
{"lineNum":" 2770","line":"        return extract(index);"},
{"lineNum":" 2771","line":"    }"},
{"lineNum":" 2772","line":"    static int elementtype() {"},
{"lineNum":" 2773","line":"        return 9;"},
{"lineNum":" 2774","line":"    }"},
{"lineNum":" 2775","line":"};"},
{"lineNum":" 2776","line":""},
{"lineNum":" 2777","line":"// Define operators for this class"},
{"lineNum":" 2778","line":""},
{"lineNum":" 2779","line":"// vector operator + : add"},
{"lineNum":" 2780","line":"static inline Vec4ui operator + (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2781","line":"    return Vec4ui (Vec4i(a) + Vec4i(b));"},
{"lineNum":" 2782","line":"}"},
{"lineNum":" 2783","line":""},
{"lineNum":" 2784","line":"// vector operator - : subtract"},
{"lineNum":" 2785","line":"static inline Vec4ui operator - (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2786","line":"    return Vec4ui (Vec4i(a) - Vec4i(b));"},
{"lineNum":" 2787","line":"}"},
{"lineNum":" 2788","line":""},
{"lineNum":" 2789","line":"// vector operator * : multiply"},
{"lineNum":" 2790","line":"static inline Vec4ui operator * (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2791","line":"    return Vec4ui (Vec4i(a) * Vec4i(b));"},
{"lineNum":" 2792","line":"}"},
{"lineNum":" 2793","line":""},
{"lineNum":" 2794","line":"// vector operator / : divide"},
{"lineNum":" 2795","line":"// See bottom of file"},
{"lineNum":" 2796","line":""},
{"lineNum":" 2797","line":"// vector operator >> : shift right logical all elements"},
{"lineNum":" 2798","line":"static inline Vec4ui operator >> (Vec4ui const & a, uint32_t b) {"},
{"lineNum":" 2799","line":"    return _mm_srl_epi32(a,_mm_cvtsi32_si128((int)b));"},
{"lineNum":" 2800","line":"}"},
{"lineNum":" 2801","line":""},
{"lineNum":" 2802","line":"// vector operator >> : shift right logical all elements"},
{"lineNum":" 2803","line":"static inline Vec4ui operator >> (Vec4ui const & a, int32_t b) {"},
{"lineNum":" 2804","line":"    return a >> (uint32_t)b;"},
{"lineNum":" 2805","line":"}"},
{"lineNum":" 2806","line":""},
{"lineNum":" 2807","line":"// vector operator >>= : shift right logical"},
{"lineNum":" 2808","line":"static inline Vec4ui & operator >>= (Vec4ui & a, int b) {"},
{"lineNum":" 2809","line":"    a = a >> b;"},
{"lineNum":" 2810","line":"    return a;"},
{"lineNum":" 2811","line":"}"},
{"lineNum":" 2812","line":""},
{"lineNum":" 2813","line":"// vector operator << : shift left all elements"},
{"lineNum":" 2814","line":"static inline Vec4ui operator << (Vec4ui const & a, uint32_t b) {"},
{"lineNum":" 2815","line":"    return Vec4ui ((Vec4i)a << (int32_t)b);"},
{"lineNum":" 2816","line":"}"},
{"lineNum":" 2817","line":""},
{"lineNum":" 2818","line":"// vector operator << : shift left all elements"},
{"lineNum":" 2819","line":"static inline Vec4ui operator << (Vec4ui const & a, int32_t b) {"},
{"lineNum":" 2820","line":"    return Vec4ui ((Vec4i)a << (int32_t)b);"},
{"lineNum":" 2821","line":"}"},
{"lineNum":" 2822","line":""},
{"lineNum":" 2823","line":"// vector operator > : returns true for elements for which a > b (unsigned)"},
{"lineNum":" 2824","line":"static inline Vec4ib operator > (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2825","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 2826","line":"    return (Vec4ib)_mm_comgt_epu32(a,b);"},
{"lineNum":" 2827","line":"#else  // SSE2 instruction set"},
{"lineNum":" 2828","line":"    __m128i signbit = _mm_set1_epi32(0x80000000);"},
{"lineNum":" 2829","line":"    __m128i a1      = _mm_xor_si128(a,signbit);"},
{"lineNum":" 2830","line":"    __m128i b1      = _mm_xor_si128(b,signbit);"},
{"lineNum":" 2831","line":"    return (Vec4ib)_mm_cmpgt_epi32(a1,b1);                         // signed compare"},
{"lineNum":" 2832","line":"#endif"},
{"lineNum":" 2833","line":"}"},
{"lineNum":" 2834","line":""},
{"lineNum":" 2835","line":"// vector operator < : returns true for elements for which a < b (unsigned)"},
{"lineNum":" 2836","line":"static inline Vec4ib operator < (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2837","line":"    return b > a;"},
{"lineNum":" 2838","line":"}"},
{"lineNum":" 2839","line":""},
{"lineNum":" 2840","line":"// vector operator >= : returns true for elements for which a >= b (unsigned)"},
{"lineNum":" 2841","line":"static inline Vec4ib operator >= (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2842","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 2843","line":"    return (Vec4ib)_mm_comge_epu32(a,b);"},
{"lineNum":" 2844","line":"#elif INSTRSET >= 5   // SSE4.1"},
{"lineNum":" 2845","line":"    __m128i max_ab = _mm_max_epu32(a,b);                   // max(a,b), unsigned"},
{"lineNum":" 2846","line":"    return (Vec4ib)_mm_cmpeq_epi32(a,max_ab);                      // a == max(a,b)"},
{"lineNum":" 2847","line":"#else  // SSE2 instruction set"},
{"lineNum":" 2848","line":"    return Vec4ib(Vec4i (~(b > a)));"},
{"lineNum":" 2849","line":"#endif"},
{"lineNum":" 2850","line":"}"},
{"lineNum":" 2851","line":""},
{"lineNum":" 2852","line":"// vector operator <= : returns true for elements for which a <= b (unsigned)"},
{"lineNum":" 2853","line":"static inline Vec4ib operator <= (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2854","line":"    return b >= a;"},
{"lineNum":" 2855","line":"}"},
{"lineNum":" 2856","line":""},
{"lineNum":" 2857","line":"// vector operator & : bitwise and"},
{"lineNum":" 2858","line":"static inline Vec4ui operator & (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2859","line":"    return Vec4ui(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 2860","line":"}"},
{"lineNum":" 2861","line":"static inline Vec4ui operator && (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2862","line":"    return a & b;"},
{"lineNum":" 2863","line":"}"},
{"lineNum":" 2864","line":""},
{"lineNum":" 2865","line":"// vector operator | : bitwise or"},
{"lineNum":" 2866","line":"static inline Vec4ui operator | (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2867","line":"    return Vec4ui(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 2868","line":"}"},
{"lineNum":" 2869","line":"static inline Vec4ui operator || (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2870","line":"    return a | b;"},
{"lineNum":" 2871","line":"}"},
{"lineNum":" 2872","line":""},
{"lineNum":" 2873","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 2874","line":"static inline Vec4ui operator ^ (Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2875","line":"    return Vec4ui(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 2876","line":"}"},
{"lineNum":" 2877","line":""},
{"lineNum":" 2878","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 2879","line":"static inline Vec4ui operator ~ (Vec4ui const & a) {"},
{"lineNum":" 2880","line":"    return Vec4ui( ~ Vec128b(a));"},
{"lineNum":" 2881","line":"}"},
{"lineNum":" 2882","line":""},
{"lineNum":" 2883","line":"// Functions for this class"},
{"lineNum":" 2884","line":""},
{"lineNum":" 2885","line":"// Select between two operands. Corresponds to this pseudocode:"},
{"lineNum":" 2886","line":"// for (int i = 0; i < 8; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":" 2887","line":"// Each word in s must be either 0 (false) or -1 (true). No other values are allowed."},
{"lineNum":" 2888","line":"// (s is signed)"},
{"lineNum":" 2889","line":"static inline Vec4ui select (Vec4ib const & s, Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2890","line":"    return selectb(s,a,b);"},
{"lineNum":" 2891","line":"}"},
{"lineNum":" 2892","line":""},
{"lineNum":" 2893","line":"// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]"},
{"lineNum":" 2894","line":"static inline Vec4ui if_add (Vec4ib const & f, Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2895","line":"    return a + (Vec4ui(f) & b);"},
{"lineNum":" 2896","line":"}"},
{"lineNum":" 2897","line":""},
{"lineNum":" 2898","line":"// Conditional sub: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]"},
{"lineNum":" 2899","line":"static inline Vec4ui if_sub (Vec4ib const & f, Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2900","line":"    return a - (Vec4ui(f) & b);"},
{"lineNum":" 2901","line":"}"},
{"lineNum":" 2902","line":""},
{"lineNum":" 2903","line":"// Conditional mul: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]"},
{"lineNum":" 2904","line":"static inline Vec4ui if_mul (Vec4ib const & f, Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2905","line":"    return select(f, a*b, a);"},
{"lineNum":" 2906","line":"}"},
{"lineNum":" 2907","line":""},
{"lineNum":" 2908","line":"// Horizontal add: Calculates the sum of all vector elements."},
{"lineNum":" 2909","line":"// Overflow will wrap around"},
{"lineNum":" 2910","line":"static inline uint32_t horizontal_add (Vec4ui const & a) {"},
{"lineNum":" 2911","line":"    return (uint32_t)horizontal_add((Vec4i)a);"},
{"lineNum":" 2912","line":"}"},
{"lineNum":" 2913","line":""},
{"lineNum":" 2914","line":"// Horizontal add extended: Calculates the sum of all vector elements."},
{"lineNum":" 2915","line":"// Elements are zero extended before adding to avoid overflow"},
{"lineNum":" 2916","line":"static inline uint64_t horizontal_add_x (Vec4ui const & a) {"},
{"lineNum":" 2917","line":"#ifdef __XOP__     // AMD XOP instruction set"},
{"lineNum":" 2918","line":"    __m128i sum1  = _mm_haddq_epu32(a);"},
{"lineNum":" 2919","line":"#else              // SSE2"},
{"lineNum":" 2920","line":"    __m128i zero  = _mm_setzero_si128();                   // 0"},
{"lineNum":" 2921","line":"    __m128i a01   = _mm_unpacklo_epi32(a,zero);            // zero-extended a0, a1"},
{"lineNum":" 2922","line":"    __m128i a23   = _mm_unpackhi_epi32(a,zero);            // zero-extended a2, a3"},
{"lineNum":" 2923","line":"    __m128i sum1  = _mm_add_epi64(a01,a23);                // add"},
{"lineNum":" 2924","line":"#endif"},
{"lineNum":" 2925","line":"    __m128i sum2  = _mm_unpackhi_epi64(sum1,sum1);         // high qword"},
{"lineNum":" 2926","line":"    __m128i sum3  = _mm_add_epi64(sum1,sum2);              // add"},
{"lineNum":" 2927","line":"    return (uint64_t)_emulate_movq(sum3);"},
{"lineNum":" 2928","line":"}"},
{"lineNum":" 2929","line":""},
{"lineNum":" 2930","line":"// function add_saturated: add element by element, unsigned with saturation"},
{"lineNum":" 2931","line":"static inline Vec4ui add_saturated(Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2932","line":"    Vec4ui sum      = a + b;"},
{"lineNum":" 2933","line":"    Vec4ui aorb     = Vec4ui(a | b);"},
{"lineNum":" 2934","line":"    Vec4ui overflow = Vec4ui(sum < aorb);                  // overflow if a + b < (a | b)"},
{"lineNum":" 2935","line":"    return Vec4ui (sum | overflow);                        // return 0xFFFFFFFF if overflow"},
{"lineNum":" 2936","line":"}"},
{"lineNum":" 2937","line":""},
{"lineNum":" 2938","line":"// function sub_saturated: subtract element by element, unsigned with saturation"},
{"lineNum":" 2939","line":"static inline Vec4ui sub_saturated(Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2940","line":"    Vec4ui diff      = a - b;"},
{"lineNum":" 2941","line":"    Vec4ui underflow = Vec4ui(diff > a);                   // underflow if a - b > a"},
{"lineNum":" 2942","line":"    return _mm_andnot_si128(underflow,diff);               // return 0 if underflow"},
{"lineNum":" 2943","line":"}"},
{"lineNum":" 2944","line":""},
{"lineNum":" 2945","line":"// function max: a > b ? a : b"},
{"lineNum":" 2946","line":"static inline Vec4ui max(Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2947","line":"#if INSTRSET >= 5   // SSE4.1"},
{"lineNum":" 2948","line":"    return _mm_max_epu32(a,b);"},
{"lineNum":" 2949","line":"#else  // SSE2"},
{"lineNum":" 2950","line":"    return select(a > b, a, b);"},
{"lineNum":" 2951","line":"#endif"},
{"lineNum":" 2952","line":"}"},
{"lineNum":" 2953","line":""},
{"lineNum":" 2954","line":"// function min: a < b ? a : b"},
{"lineNum":" 2955","line":"static inline Vec4ui min(Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 2956","line":"#if INSTRSET >= 5   // SSE4.1"},
{"lineNum":" 2957","line":"    return _mm_min_epu32(a,b);"},
{"lineNum":" 2958","line":"#else  // SSE2"},
{"lineNum":" 2959","line":"    return select(a > b, b, a);"},
{"lineNum":" 2960","line":"#endif"},
{"lineNum":" 2961","line":"}"},
{"lineNum":" 2962","line":""},
{"lineNum":" 2963","line":""},
{"lineNum":" 2964","line":"/*****************************************************************************"},
{"lineNum":" 2965","line":"*"},
{"lineNum":" 2966","line":"*          Vector of 2 64-bit signed integers"},
{"lineNum":" 2967","line":"*"},
{"lineNum":" 2968","line":"*****************************************************************************/"},
{"lineNum":" 2969","line":""},
{"lineNum":" 2970","line":"class Vec2q : public Vec128b {"},
{"lineNum":" 2971","line":"public:"},
{"lineNum":" 2972","line":"    // Default constructor:"},
{"lineNum":" 2973","line":"    Vec2q() {"},
{"lineNum":" 2974","line":"    }"},
{"lineNum":" 2975","line":"    // Constructor to broadcast the same value into all elements:"},
{"lineNum":" 2976","line":"    Vec2q(int64_t i) {"},
{"lineNum":" 2977","line":"#if defined (_MSC_VER) && _MSC_VER < 1900 && ! defined(__INTEL_COMPILER)"},
{"lineNum":" 2978","line":"        // MS compiler has no _mm_set1_epi64x in 32 bit mode"},
{"lineNum":" 2979","line":"#if defined(__x86_64__)                                    // 64 bit mode"},
{"lineNum":" 2980","line":"#if _MSC_VER < 1700"},
{"lineNum":" 2981","line":"        __m128i x1 = _mm_cvtsi64_si128(i);                 // 64 bit load"},
{"lineNum":" 2982","line":"        xmm = _mm_unpacklo_epi64(x1,x1);                   // broadcast"},
{"lineNum":" 2983","line":"#else"},
{"lineNum":" 2984","line":"\t\txmm =  _mm_set1_epi64x(i);"},
{"lineNum":" 2985","line":"#endif"},
{"lineNum":" 2986","line":"#else"},
{"lineNum":" 2987","line":"        union {"},
{"lineNum":" 2988","line":"            int64_t q[2];"},
{"lineNum":" 2989","line":"            int32_t r[4];"},
{"lineNum":" 2990","line":"        } u;"},
{"lineNum":" 2991","line":"        u.q[0] = u.q[1] = i;"},
{"lineNum":" 2992","line":"        xmm = _mm_setr_epi32(u.r[0], u.r[1], u.r[2], u.r[3]);"},
{"lineNum":" 2993","line":"        /*    // this will use an mm register and produce store forwarding stall:"},
{"lineNum":" 2994","line":"        union {"},
{"lineNum":" 2995","line":"            __m64 m;"},
{"lineNum":" 2996","line":"            int64_t ii;"},
{"lineNum":" 2997","line":"        } u;"},
{"lineNum":" 2998","line":"        u.ii = i;"},
{"lineNum":" 2999","line":"        xmm = _mm_set1_epi64(u.m);"},
{"lineNum":" 3000","line":"\t\t_m_empty();        */"},
{"lineNum":" 3001","line":""},
{"lineNum":" 3002","line":"#endif  // __x86_64__"},
{"lineNum":" 3003","line":"#else   // Other compilers"},
{"lineNum":" 3004","line":"        xmm = _mm_set1_epi64x(i);"},
{"lineNum":" 3005","line":"#endif"},
{"lineNum":" 3006","line":"    }"},
{"lineNum":" 3007","line":"    // Constructor to build from all elements:"},
{"lineNum":" 3008","line":"    Vec2q(int64_t i0, int64_t i1) {"},
{"lineNum":" 3009","line":"#if defined (_MSC_VER)  && _MSC_VER < 1900 && ! defined(__INTEL_COMPILER)"},
{"lineNum":" 3010","line":"        // MS compiler has no _mm_set_epi64x in 32 bit mode"},
{"lineNum":" 3011","line":"#if defined(__x86_64__)                                    // 64 bit mode"},
{"lineNum":" 3012","line":"#if _MSC_VER < 1700"},
{"lineNum":" 3013","line":"        __m128i x0 = _mm_cvtsi64_si128(i0);                // 64 bit load"},
{"lineNum":" 3014","line":"        __m128i x1 = _mm_cvtsi64_si128(i1);                // 64 bit load"},
{"lineNum":" 3015","line":"        xmm = _mm_unpacklo_epi64(x0,x1);                   // combine"},
{"lineNum":" 3016","line":"#else"},
{"lineNum":" 3017","line":"\t\txmm = _mm_set_epi64x(i1, i0);"},
{"lineNum":" 3018","line":"#endif"},
{"lineNum":" 3019","line":"#else   // MS compiler in 32-bit mode"},
{"lineNum":" 3020","line":"        union {"},
{"lineNum":" 3021","line":"            int64_t q[2];"},
{"lineNum":" 3022","line":"            int32_t r[4];"},
{"lineNum":" 3023","line":"        } u;"},
{"lineNum":" 3024","line":"        u.q[0] = i0;  u.q[1] = i1;"},
{"lineNum":" 3025","line":"\t\t// this is inefficient, but other solutions are worse"},
{"lineNum":" 3026","line":"        xmm = _mm_setr_epi32(u.r[0], u.r[1], u.r[2], u.r[3]);"},
{"lineNum":" 3027","line":"#endif  // __x86_64__"},
{"lineNum":" 3028","line":"#else   // Other compilers"},
{"lineNum":" 3029","line":"        xmm = _mm_set_epi64x(i1, i0);","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":" 3030","line":"#endif"},
{"lineNum":" 3031","line":"    }"},
{"lineNum":" 3032","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 3033","line":"    Vec2q(__m128i const & x) {"},
{"lineNum":" 3034","line":"        xmm = x;","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":" 3035","line":"    }"},
{"lineNum":" 3036","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 3037","line":"    Vec2q & operator = (__m128i const & x) {"},
{"lineNum":" 3038","line":"        xmm = x;"},
{"lineNum":" 3039","line":"        return *this;"},
{"lineNum":" 3040","line":"    }"},
{"lineNum":" 3041","line":"    // Type cast operator to convert to __m128i used in intrinsics"},
{"lineNum":" 3042","line":"    operator __m128i() const {"},
{"lineNum":" 3043","line":"        return xmm;","class":"lineNoCov","hits":"0","possible_hits":"40",},
{"lineNum":" 3044","line":"    }"},
{"lineNum":" 3045","line":"    // Member function to load from array (unaligned)"},
{"lineNum":" 3046","line":"    Vec2q & load(void const * p) {"},
{"lineNum":" 3047","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":" 3048","line":"        return *this;"},
{"lineNum":" 3049","line":"    }"},
{"lineNum":" 3050","line":"    // Member function to load from array (aligned)"},
{"lineNum":" 3051","line":"    Vec2q & load_a(void const * p) {"},
{"lineNum":" 3052","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":" 3053","line":"        return *this;"},
{"lineNum":" 3054","line":"    }"},
{"lineNum":" 3055","line":"    // Partial load. Load n elements and set the rest to 0"},
{"lineNum":" 3056","line":"    Vec2q & load_partial(int n, void const * p) {"},
{"lineNum":" 3057","line":"#if INSTRSET >= 10  // AVX512VL"},
{"lineNum":" 3058","line":"        xmm = _mm_maskz_loadu_epi64(__mmask8((1u << n) - 1), p);"},
{"lineNum":" 3059","line":"#else"},
{"lineNum":" 3060","line":"        switch (n) {"},
{"lineNum":" 3061","line":"        case 0:"},
{"lineNum":" 3062","line":"            *this = 0;  break;"},
{"lineNum":" 3063","line":"        case 1:"},
{"lineNum":" 3064","line":"            // intrinsic for movq is missing!"},
{"lineNum":" 3065","line":"            *this = Vec2q(*(int64_t const*)p, 0);  break;"},
{"lineNum":" 3066","line":"        case 2:"},
{"lineNum":" 3067","line":"            load(p);  break;"},
{"lineNum":" 3068","line":"        default:"},
{"lineNum":" 3069","line":"            break;"},
{"lineNum":" 3070","line":"        }"},
{"lineNum":" 3071","line":"#endif"},
{"lineNum":" 3072","line":"        return *this;"},
{"lineNum":" 3073","line":"    }"},
{"lineNum":" 3074","line":"    // Partial store. Store n elements"},
{"lineNum":" 3075","line":"    void store_partial(int n, void * p) const {"},
{"lineNum":" 3076","line":"#if INSTRSET >= 10  // AVX512VL + AVX512BW"},
{"lineNum":" 3077","line":"        _mm_mask_storeu_epi64(p, __mmask8((1u << n) - 1), xmm);"},
{"lineNum":" 3078","line":"#else"},
{"lineNum":" 3079","line":"        switch (n) {"},
{"lineNum":" 3080","line":"        case 1:"},
{"lineNum":" 3081","line":"            int64_t q[2];"},
{"lineNum":" 3082","line":"            store(q);"},
{"lineNum":" 3083","line":"            *(int64_t*)p = q[0];  break;"},
{"lineNum":" 3084","line":"        case 2:"},
{"lineNum":" 3085","line":"            store(p);  break;"},
{"lineNum":" 3086","line":"        default:"},
{"lineNum":" 3087","line":"            break;"},
{"lineNum":" 3088","line":"        }"},
{"lineNum":" 3089","line":"#endif"},
{"lineNum":" 3090","line":"    }"},
{"lineNum":" 3091","line":"    // cut off vector to n elements. The last 2-n elements are set to zero"},
{"lineNum":" 3092","line":"    Vec2q & cutoff(int n) {"},
{"lineNum":" 3093","line":"#if INSTRSET >= 10"},
{"lineNum":" 3094","line":"        xmm = _mm_maskz_mov_epi64(__mmask8((1u << n) - 1), xmm);"},
{"lineNum":" 3095","line":"#else"},
{"lineNum":" 3096","line":"        *this = Vec16c(xmm).cutoff(n * 8);"},
{"lineNum":" 3097","line":"#endif"},
{"lineNum":" 3098","line":"        return *this;"},
{"lineNum":" 3099","line":"    }"},
{"lineNum":" 3100","line":"    // Member function to change a single element in vector"},
{"lineNum":" 3101","line":"    // Note: This function is inefficient. Use load function if changing more than one element"},
{"lineNum":" 3102","line":"    Vec2q const & insert(int index, int64_t value) {"},
{"lineNum":" 3103","line":"#if INSTRSET >= 10"},
{"lineNum":" 3104","line":"        xmm = _mm_mask_set1_epi64(xmm, __mmask8(1u << index), value);"},
{"lineNum":" 3105","line":"#elif INSTRSET >= 5 && defined(__x86_64__)  // SSE4.1 supported, 64 bit mode"},
{"lineNum":" 3106","line":"        if (index == 0) {"},
{"lineNum":" 3107","line":"            xmm = _mm_insert_epi64(xmm,value,0);"},
{"lineNum":" 3108","line":"        }"},
{"lineNum":" 3109","line":"        else {"},
{"lineNum":" 3110","line":"            xmm = _mm_insert_epi64(xmm,value,1);"},
{"lineNum":" 3111","line":"        }"},
{"lineNum":" 3112","line":"#else               // SSE2"},
{"lineNum":" 3113","line":"#if defined(__x86_64__)                                      // 64 bit mode"},
{"lineNum":" 3114","line":"        __m128i v = _mm_cvtsi64_si128(value);                // 64 bit load"},
{"lineNum":" 3115","line":"#else"},
{"lineNum":" 3116","line":"        union {"},
{"lineNum":" 3117","line":"            __m128i m;"},
{"lineNum":" 3118","line":"            int64_t ii;"},
{"lineNum":" 3119","line":"        } u;"},
{"lineNum":" 3120","line":"        u.ii = value;"},
{"lineNum":" 3121","line":"        __m128i v = _mm_loadl_epi64(&u.m);"},
{"lineNum":" 3122","line":"#endif"},
{"lineNum":" 3123","line":"        if (index == 0) {"},
{"lineNum":" 3124","line":"            v = _mm_unpacklo_epi64(v,v);"},
{"lineNum":" 3125","line":"            xmm = _mm_unpackhi_epi64(v,xmm);"},
{"lineNum":" 3126","line":"        }"},
{"lineNum":" 3127","line":"        else {  // index = 1"},
{"lineNum":" 3128","line":"            xmm = _mm_unpacklo_epi64(xmm,v);"},
{"lineNum":" 3129","line":"        }"},
{"lineNum":" 3130","line":"#endif"},
{"lineNum":" 3131","line":"        return *this;"},
{"lineNum":" 3132","line":"    }"},
{"lineNum":" 3133","line":"    // Member function extract a single element from vector"},
{"lineNum":" 3134","line":"    int64_t extract(int index) const {"},
{"lineNum":" 3135","line":"#if INSTRSET >= 10"},
{"lineNum":" 3136","line":"        __m128i x = _mm_mask_unpackhi_epi64 (xmm, __mmask8(index), xmm, xmm);"},
{"lineNum":" 3137","line":"        return _emulate_movq(x);"},
{"lineNum":" 3138","line":"#else"},
{"lineNum":" 3139","line":"        int64_t x[2];"},
{"lineNum":" 3140","line":"        store(x);"},
{"lineNum":" 3141","line":"        return x[index & 1];"},
{"lineNum":" 3142","line":"#endif"},
{"lineNum":" 3143","line":"    }"},
{"lineNum":" 3144","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 3145","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 3146","line":"    int64_t operator [] (int index) const {"},
{"lineNum":" 3147","line":"        return extract(index);"},
{"lineNum":" 3148","line":"    }"},
{"lineNum":" 3149","line":"    static int size() {"},
{"lineNum":" 3150","line":"        return 2;"},
{"lineNum":" 3151","line":"    }"},
{"lineNum":" 3152","line":"    static int elementtype() {"},
{"lineNum":" 3153","line":"        return 10;"},
{"lineNum":" 3154","line":"    }"},
{"lineNum":" 3155","line":"};"},
{"lineNum":" 3156","line":""},
{"lineNum":" 3157","line":"/*****************************************************************************"},
{"lineNum":" 3158","line":"*"},
{"lineNum":" 3159","line":"*          Vec2qb: Vector of 2 Booleans for use with Vec2q and Vec2uq"},
{"lineNum":" 3160","line":"*"},
{"lineNum":" 3161","line":"*****************************************************************************/"},
{"lineNum":" 3162","line":"// Definition will be different for the AVX512 instruction set"},
{"lineNum":" 3163","line":"class Vec2qb : public Vec2q {"},
{"lineNum":" 3164","line":"public:"},
{"lineNum":" 3165","line":"    // Default constructor:"},
{"lineNum":" 3166","line":"    Vec2qb() {"},
{"lineNum":" 3167","line":"    }"},
{"lineNum":" 3168","line":"    // Constructor to build from all elements:"},
{"lineNum":" 3169","line":"    Vec2qb(bool x0, bool x1) {"},
{"lineNum":" 3170","line":"        xmm = Vec2q(-int64_t(x0), -int64_t(x1));"},
{"lineNum":" 3171","line":"    }"},
{"lineNum":" 3172","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 3173","line":"    Vec2qb(__m128i const & x) {"},
{"lineNum":" 3174","line":"        xmm = x;"},
{"lineNum":" 3175","line":"    }"},
{"lineNum":" 3176","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 3177","line":"    Vec2qb & operator = (__m128i const & x) {"},
{"lineNum":" 3178","line":"        xmm = x;"},
{"lineNum":" 3179","line":"        return *this;"},
{"lineNum":" 3180","line":"    }"},
{"lineNum":" 3181","line":"    // Constructor to broadcast scalar value:"},
{"lineNum":" 3182","line":"    Vec2qb(bool b) : Vec2q(-int64_t(b)) {"},
{"lineNum":" 3183","line":"    }"},
{"lineNum":" 3184","line":"    // Assignment operator to broadcast scalar value:"},
{"lineNum":" 3185","line":"    Vec2qb & operator = (bool b) {"},
{"lineNum":" 3186","line":"        *this = Vec2qb(b);"},
{"lineNum":" 3187","line":"        return *this;"},
{"lineNum":" 3188","line":"    }"},
{"lineNum":" 3189","line":"    Vec2qb & insert (int index, bool a) {"},
{"lineNum":" 3190","line":"        Vec2q::insert(index, -(int64_t)a);"},
{"lineNum":" 3191","line":"        return *this;"},
{"lineNum":" 3192","line":"    }"},
{"lineNum":" 3193","line":"    // Member function extract a single element from vector"},
{"lineNum":" 3194","line":"    bool extract(int index) const {"},
{"lineNum":" 3195","line":"        return Vec2q::extract(index) != 0;"},
{"lineNum":" 3196","line":"    }"},
{"lineNum":" 3197","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 3198","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 3199","line":"    bool operator [] (int index) const {"},
{"lineNum":" 3200","line":"        return extract(index);"},
{"lineNum":" 3201","line":"    }"},
{"lineNum":" 3202","line":"    // Member function to change a bitfield to a boolean vector"},
{"lineNum":" 3203","line":"    Vec2qb & load_bits(uint8_t a) {"},
{"lineNum":" 3204","line":"        __m128i b1 = _mm_set1_epi8((int8_t)a);  // broadcast byte"},
{"lineNum":" 3205","line":"        __m128i m1 = constant4ui<1,1,2,2>();"},
{"lineNum":" 3206","line":"        __m128i c1 = _mm_and_si128(b1, m1); // isolate one bit in each byte"},
{"lineNum":" 3207","line":"        xmm = _mm_cmpgt_epi32(c1, _mm_setzero_si128());  // compare with 0 (64 bit compare requires SSE4.1)"},
{"lineNum":" 3208","line":"        return *this;"},
{"lineNum":" 3209","line":"    }"},
{"lineNum":" 3210","line":"    static int elementtype() {"},
{"lineNum":" 3211","line":"        return 3;"},
{"lineNum":" 3212","line":"    }"},
{"lineNum":" 3213","line":"private: // Prevent constructing from int, etc."},
{"lineNum":" 3214","line":"    Vec2qb(int b);"},
{"lineNum":" 3215","line":"    Vec2qb & operator = (int x);"},
{"lineNum":" 3216","line":"};"},
{"lineNum":" 3217","line":""},
{"lineNum":" 3218","line":""},
{"lineNum":" 3219","line":"/*****************************************************************************"},
{"lineNum":" 3220","line":"*"},
{"lineNum":" 3221","line":"*          Define operators for Vec2qb"},
{"lineNum":" 3222","line":"*"},
{"lineNum":" 3223","line":"*****************************************************************************/"},
{"lineNum":" 3224","line":""},
{"lineNum":" 3225","line":"// vector operator & : bitwise and"},
{"lineNum":" 3226","line":"static inline Vec2qb operator & (Vec2qb const & a, Vec2qb const & b) {"},
{"lineNum":" 3227","line":"    return Vec2qb(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 3228","line":"}"},
{"lineNum":" 3229","line":"static inline Vec2qb operator && (Vec2qb const & a, Vec2qb const & b) {"},
{"lineNum":" 3230","line":"    return a & b;"},
{"lineNum":" 3231","line":"}"},
{"lineNum":" 3232","line":"// vector operator &= : bitwise and"},
{"lineNum":" 3233","line":"static inline Vec2qb & operator &= (Vec2qb & a, Vec2qb const & b) {"},
{"lineNum":" 3234","line":"    a = a & b;"},
{"lineNum":" 3235","line":"    return a;"},
{"lineNum":" 3236","line":"}"},
{"lineNum":" 3237","line":""},
{"lineNum":" 3238","line":"// vector operator | : bitwise or"},
{"lineNum":" 3239","line":"static inline Vec2qb operator | (Vec2qb const & a, Vec2qb const & b) {"},
{"lineNum":" 3240","line":"    return Vec2qb(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 3241","line":"}"},
{"lineNum":" 3242","line":"static inline Vec2qb operator || (Vec2qb const & a, Vec2qb const & b) {"},
{"lineNum":" 3243","line":"    return a | b;"},
{"lineNum":" 3244","line":"}"},
{"lineNum":" 3245","line":"// vector operator |= : bitwise or"},
{"lineNum":" 3246","line":"static inline Vec2qb & operator |= (Vec2qb & a, Vec2qb const & b) {"},
{"lineNum":" 3247","line":"    a = a | b;"},
{"lineNum":" 3248","line":"    return a;"},
{"lineNum":" 3249","line":"}"},
{"lineNum":" 3250","line":""},
{"lineNum":" 3251","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 3252","line":"static inline Vec2qb operator ^ (Vec2qb const & a, Vec2qb const & b) {"},
{"lineNum":" 3253","line":"    return Vec2qb(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 3254","line":"}"},
{"lineNum":" 3255","line":"// vector operator ^= : bitwise xor"},
{"lineNum":" 3256","line":"static inline Vec2qb & operator ^= (Vec2qb & a, Vec2qb const & b) {"},
{"lineNum":" 3257","line":"    a = a ^ b;"},
{"lineNum":" 3258","line":"    return a;"},
{"lineNum":" 3259","line":"}"},
{"lineNum":" 3260","line":""},
{"lineNum":" 3261","line":"// vector operator == : xnor"},
{"lineNum":" 3262","line":"static inline Vec2qb operator == (Vec2qb const & a, Vec2qb const & b) {"},
{"lineNum":" 3263","line":"    return Vec2qb(a ^ (~b));"},
{"lineNum":" 3264","line":"}"},
{"lineNum":" 3265","line":""},
{"lineNum":" 3266","line":"// vector operator != : xor"},
{"lineNum":" 3267","line":"static inline Vec2qb operator != (Vec2qb const & a, Vec2qb const & b) {"},
{"lineNum":" 3268","line":"    return Vec2qb(a ^ b);"},
{"lineNum":" 3269","line":"}"},
{"lineNum":" 3270","line":""},
{"lineNum":" 3271","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 3272","line":"static inline Vec2qb operator ~ (Vec2qb const & a) {"},
{"lineNum":" 3273","line":"    return Vec2qb( ~ Vec128b(a));"},
{"lineNum":" 3274","line":"}"},
{"lineNum":" 3275","line":""},
{"lineNum":" 3276","line":"// vector operator ! : element not"},
{"lineNum":" 3277","line":"static inline Vec2qb operator ! (Vec2qb const & a) {"},
{"lineNum":" 3278","line":"    return ~ a;"},
{"lineNum":" 3279","line":"}"},
{"lineNum":" 3280","line":""},
{"lineNum":" 3281","line":"// vector function andnot"},
{"lineNum":" 3282","line":"static inline Vec2qb andnot (Vec2qb const & a, Vec2qb const & b) {"},
{"lineNum":" 3283","line":"    return Vec2qb(andnot(Vec128b(a), Vec128b(b)));"},
{"lineNum":" 3284","line":"}"},
{"lineNum":" 3285","line":""},
{"lineNum":" 3286","line":"// Horizontal Boolean functions for Vec2qb"},
{"lineNum":" 3287","line":""},
{"lineNum":" 3288","line":"// horizontal_and. Returns true if all elements are true"},
{"lineNum":" 3289","line":"static inline bool horizontal_and(Vec2qb const & a) {"},
{"lineNum":" 3290","line":"    return _mm_movemask_epi8(a) == 0xFFFF;"},
{"lineNum":" 3291","line":"}"},
{"lineNum":" 3292","line":""},
{"lineNum":" 3293","line":"// horizontal_or. Returns true if at least one element is true"},
{"lineNum":" 3294","line":"static inline bool horizontal_or(Vec2qb const & a) {"},
{"lineNum":" 3295","line":"#if INSTRSET >= 5   // SSE4.1 supported. Use PTEST"},
{"lineNum":" 3296","line":"    return !_mm_testz_si128(a, a);"},
{"lineNum":" 3297","line":"#else"},
{"lineNum":" 3298","line":"    return _mm_movemask_epi8(a) != 0;"},
{"lineNum":" 3299","line":"#endif"},
{"lineNum":" 3300","line":"}"},
{"lineNum":" 3301","line":""},
{"lineNum":" 3302","line":""},
{"lineNum":" 3303","line":"/*****************************************************************************"},
{"lineNum":" 3304","line":"*"},
{"lineNum":" 3305","line":"*          Operators for Vec2q"},
{"lineNum":" 3306","line":"*"},
{"lineNum":" 3307","line":"*****************************************************************************/"},
{"lineNum":" 3308","line":""},
{"lineNum":" 3309","line":"// vector operator + : add element by element"},
{"lineNum":" 3310","line":"static inline Vec2q operator + (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3311","line":"    return _mm_add_epi64(a, b);"},
{"lineNum":" 3312","line":"}"},
{"lineNum":" 3313","line":""},
{"lineNum":" 3314","line":"// vector operator += : add"},
{"lineNum":" 3315","line":"static inline Vec2q & operator += (Vec2q & a, Vec2q const & b) {"},
{"lineNum":" 3316","line":"    a = a + b;"},
{"lineNum":" 3317","line":"    return a;"},
{"lineNum":" 3318","line":"}"},
{"lineNum":" 3319","line":""},
{"lineNum":" 3320","line":"// postfix operator ++"},
{"lineNum":" 3321","line":"static inline Vec2q operator ++ (Vec2q & a, int) {"},
{"lineNum":" 3322","line":"    Vec2q a0 = a;"},
{"lineNum":" 3323","line":"    a = a + 1;"},
{"lineNum":" 3324","line":"    return a0;"},
{"lineNum":" 3325","line":"}"},
{"lineNum":" 3326","line":""},
{"lineNum":" 3327","line":"// prefix operator ++"},
{"lineNum":" 3328","line":"static inline Vec2q & operator ++ (Vec2q & a) {"},
{"lineNum":" 3329","line":"    a = a + 1;"},
{"lineNum":" 3330","line":"    return a;"},
{"lineNum":" 3331","line":"}"},
{"lineNum":" 3332","line":""},
{"lineNum":" 3333","line":"// vector operator - : subtract element by element"},
{"lineNum":" 3334","line":"static inline Vec2q operator - (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3335","line":"    return _mm_sub_epi64(a, b);"},
{"lineNum":" 3336","line":"}"},
{"lineNum":" 3337","line":""},
{"lineNum":" 3338","line":"// vector operator - : unary minus"},
{"lineNum":" 3339","line":"static inline Vec2q operator - (Vec2q const & a) {"},
{"lineNum":" 3340","line":"    return _mm_sub_epi64(_mm_setzero_si128(), a);"},
{"lineNum":" 3341","line":"}"},
{"lineNum":" 3342","line":""},
{"lineNum":" 3343","line":"// vector operator -= : subtract"},
{"lineNum":" 3344","line":"static inline Vec2q & operator -= (Vec2q & a, Vec2q const & b) {"},
{"lineNum":" 3345","line":"    a = a - b;"},
{"lineNum":" 3346","line":"    return a;"},
{"lineNum":" 3347","line":"}"},
{"lineNum":" 3348","line":""},
{"lineNum":" 3349","line":"// postfix operator --"},
{"lineNum":" 3350","line":"static inline Vec2q operator -- (Vec2q & a, int) {"},
{"lineNum":" 3351","line":"    Vec2q a0 = a;"},
{"lineNum":" 3352","line":"    a = a - 1;"},
{"lineNum":" 3353","line":"    return a0;"},
{"lineNum":" 3354","line":"}"},
{"lineNum":" 3355","line":""},
{"lineNum":" 3356","line":"// prefix operator --"},
{"lineNum":" 3357","line":"static inline Vec2q & operator -- (Vec2q & a) {"},
{"lineNum":" 3358","line":"    a = a - 1;"},
{"lineNum":" 3359","line":"    return a;"},
{"lineNum":" 3360","line":"}"},
{"lineNum":" 3361","line":""},
{"lineNum":" 3362","line":"// vector operator * : multiply element by element"},
{"lineNum":" 3363","line":"static inline Vec2q operator * (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3364","line":"#if INSTRSET >= 10 // __AVX512DQ__ __AVX512VL__"},
{"lineNum":" 3365","line":"    return _mm_mullo_epi64(a, b);"},
{"lineNum":" 3366","line":"#elif INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 3367","line":"    // Split into 32-bit multiplies"},
{"lineNum":" 3368","line":"    __m128i bswap   = _mm_shuffle_epi32(b,0xB1);           // b0H,b0L,b1H,b1L (swap H<->L)"},
{"lineNum":" 3369","line":"    __m128i prodlh  = _mm_mullo_epi32(a,bswap);            // a0Lb0H,a0Hb0L,a1Lb1H,a1Hb1L, 32 bit L*H products"},
{"lineNum":" 3370","line":"    __m128i zero    = _mm_setzero_si128();                 // 0"},
{"lineNum":" 3371","line":"    __m128i prodlh2 = _mm_hadd_epi32(prodlh,zero);         // a0Lb0H+a0Hb0L,a1Lb1H+a1Hb1L,0,0"},
{"lineNum":" 3372","line":"    __m128i prodlh3 = _mm_shuffle_epi32(prodlh2,0x73);     // 0, a0Lb0H+a0Hb0L, 0, a1Lb1H+a1Hb1L"},
{"lineNum":" 3373","line":"    __m128i prodll  = _mm_mul_epu32(a,b);                  // a0Lb0L,a1Lb1L, 64 bit unsigned products"},
{"lineNum":" 3374","line":"    __m128i prod    = _mm_add_epi64(prodll,prodlh3);       // a0Lb0L+(a0Lb0H+a0Hb0L)<<32, a1Lb1L+(a1Lb1H+a1Hb1L)<<32"},
{"lineNum":" 3375","line":"    return  prod;"},
{"lineNum":" 3376","line":"#else               // SSE2"},
{"lineNum":" 3377","line":"    int64_t aa[2], bb[2];"},
{"lineNum":" 3378","line":"    a.store(aa);                                           // split into elements"},
{"lineNum":" 3379","line":"    b.store(bb);"},
{"lineNum":" 3380","line":"    return Vec2q(aa[0]*bb[0], aa[1]*bb[1]);                // multiply elements separetely"},
{"lineNum":" 3381","line":"#endif"},
{"lineNum":" 3382","line":"}"},
{"lineNum":" 3383","line":""},
{"lineNum":" 3384","line":"// vector operator *= : multiply"},
{"lineNum":" 3385","line":"static inline Vec2q & operator *= (Vec2q & a, Vec2q const & b) {"},
{"lineNum":" 3386","line":"    a = a * b;"},
{"lineNum":" 3387","line":"    return a;"},
{"lineNum":" 3388","line":"}"},
{"lineNum":" 3389","line":""},
{"lineNum":" 3390","line":"// vector operator << : shift left"},
{"lineNum":" 3391","line":"static inline Vec2q operator << (Vec2q const & a, int32_t b) {"},
{"lineNum":" 3392","line":"    return _mm_sll_epi64(a,_mm_cvtsi32_si128(b));","class":"lineNoCov","hits":"0","possible_hits":"38",},
{"lineNum":" 3393","line":"}"},
{"lineNum":" 3394","line":""},
{"lineNum":" 3395","line":"// vector operator <<= : shift left"},
{"lineNum":" 3396","line":"static inline Vec2q & operator <<= (Vec2q & a, int32_t b) {"},
{"lineNum":" 3397","line":"    a = a << b;"},
{"lineNum":" 3398","line":"    return a;"},
{"lineNum":" 3399","line":"}"},
{"lineNum":" 3400","line":""},
{"lineNum":" 3401","line":"// vector operator >> : shift right arithmetic"},
{"lineNum":" 3402","line":"static inline Vec2q operator >> (Vec2q const & a, int32_t b) {"},
{"lineNum":" 3403","line":"#if INSTRSET >= 10   // AVX512VL"},
{"lineNum":" 3404","line":"    return _mm_sra_epi64(a, _mm_cvtsi32_si128(b));"},
{"lineNum":" 3405","line":"#else"},
{"lineNum":" 3406","line":"    __m128i bb, shi, slo, sra2;"},
{"lineNum":" 3407","line":"    if (b <= 32) {"},
{"lineNum":" 3408","line":"        bb   = _mm_cvtsi32_si128(b);               // b"},
{"lineNum":" 3409","line":"        shi  = _mm_sra_epi32(a,bb);                // a >> b signed dwords"},
{"lineNum":" 3410","line":"        slo  = _mm_srl_epi64(a,bb);                // a >> b unsigned qwords"},
{"lineNum":" 3411","line":"    }"},
{"lineNum":" 3412","line":"    else {  // b > 32"},
{"lineNum":" 3413","line":"        bb   = _mm_cvtsi32_si128(b-32);            // b - 32"},
{"lineNum":" 3414","line":"        shi  = _mm_srai_epi32(a,31);               // sign of a","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":" 3415","line":"        sra2 = _mm_sra_epi32(a,bb);                // a >> (b-32) signed dwords"},
{"lineNum":" 3416","line":"        slo  = _mm_srli_epi64(sra2,32);            // a >> (b-32) >> 32 (second shift unsigned qword)"},
{"lineNum":" 3417","line":"    }"},
{"lineNum":" 3418","line":"#if INSTRSET >= 5  // SSE4.1"},
{"lineNum":" 3419","line":"    return _mm_blend_epi16(slo,shi,0xCC);"},
{"lineNum":" 3420","line":"#else"},
{"lineNum":" 3421","line":"    __m128i mask = _mm_setr_epi32(0,-1,0,-1);          // mask for high part containing only sign"},
{"lineNum":" 3422","line":"    return  selectb(mask,shi,slo);"},
{"lineNum":" 3423","line":"#endif"},
{"lineNum":" 3424","line":"#endif"},
{"lineNum":" 3425","line":"}"},
{"lineNum":" 3426","line":""},
{"lineNum":" 3427","line":"// vector operator >>= : shift right arithmetic"},
{"lineNum":" 3428","line":"static inline Vec2q & operator >>= (Vec2q & a, int32_t b) {"},
{"lineNum":" 3429","line":"    a = a >> b;"},
{"lineNum":" 3430","line":"    return a;"},
{"lineNum":" 3431","line":"}"},
{"lineNum":" 3432","line":""},
{"lineNum":" 3433","line":"// vector operator == : returns true for elements for which a == b"},
{"lineNum":" 3434","line":"static inline Vec2qb operator == (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3435","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 3436","line":"    return _mm_cmpeq_epi64(a, b);"},
{"lineNum":" 3437","line":"#else               // SSE2"},
{"lineNum":" 3438","line":"    // no 64 compare instruction. Do two 32 bit compares"},
{"lineNum":" 3439","line":"    __m128i com32  = _mm_cmpeq_epi32(a,b);                 // 32 bit compares","class":"lineNoCov","hits":"0","possible_hits":"72",},
{"lineNum":" 3440","line":"    __m128i com32s = _mm_shuffle_epi32(com32,0xB1);        // swap low and high dwords"},
{"lineNum":" 3441","line":"    __m128i test   = _mm_and_si128(com32,com32s);          // low & high"},
{"lineNum":" 3442","line":"    __m128i teste  = _mm_srai_epi32(test,31);              // extend sign bit to 32 bits"},
{"lineNum":" 3443","line":"    __m128i testee = _mm_shuffle_epi32(teste,0xF5);        // extend sign bit to 64 bits","class":"lineNoCov","hits":"0","possible_hits":"71",},
{"lineNum":" 3444","line":"    return  Vec2qb(Vec2q(testee));"},
{"lineNum":" 3445","line":"#endif"},
{"lineNum":" 3446","line":"}"},
{"lineNum":" 3447","line":""},
{"lineNum":" 3448","line":"// vector operator != : returns true for elements for which a != b"},
{"lineNum":" 3449","line":"static inline Vec2qb operator != (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3450","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 3451","line":"    return Vec2qb(_mm_comneq_epi64(a,b));"},
{"lineNum":" 3452","line":"#else  // SSE2 instruction set"},
{"lineNum":" 3453","line":"    return Vec2qb(Vec2q(~(a == b)));"},
{"lineNum":" 3454","line":"#endif"},
{"lineNum":" 3455","line":"}"},
{"lineNum":" 3456","line":""},
{"lineNum":" 3457","line":"// vector operator < : returns true for elements for which a < b"},
{"lineNum":" 3458","line":"static inline Vec2qb operator < (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3459","line":"#if INSTRSET >= 6   // SSE4.2 supported"},
{"lineNum":" 3460","line":"    return Vec2qb(Vec2q(_mm_cmpgt_epi64(b, a)));"},
{"lineNum":" 3461","line":"#else               // SSE2"},
{"lineNum":" 3462","line":"    // no 64 compare instruction. Subtract"},
{"lineNum":" 3463","line":"    __m128i s      = _mm_sub_epi64(a,b);                   // a-b","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":" 3464","line":"    // a < b if a and b have same sign and s < 0 or (a < 0 and b >= 0)"},
{"lineNum":" 3465","line":"    // The latter () corrects for overflow"},
{"lineNum":" 3466","line":"    __m128i axb    = _mm_xor_si128(a,b);                   // a ^ b"},
{"lineNum":" 3467","line":"    __m128i anb    = _mm_andnot_si128(b,a);                // a & ~b"},
{"lineNum":" 3468","line":"    __m128i snaxb  = _mm_andnot_si128(axb,s);              // s & ~(a ^ b)","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":" 3469","line":"    __m128i or1    = _mm_or_si128(anb,snaxb);              // (a & ~b) | (s & ~(a ^ b))"},
{"lineNum":" 3470","line":"    __m128i teste  = _mm_srai_epi32(or1,31);               // extend sign bit to 32 bits","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":" 3471","line":"    __m128i testee = _mm_shuffle_epi32(teste,0xF5);        // extend sign bit to 64 bits","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":" 3472","line":"    return  testee;"},
{"lineNum":" 3473","line":"#endif"},
{"lineNum":" 3474","line":"}"},
{"lineNum":" 3475","line":""},
{"lineNum":" 3476","line":"// vector operator > : returns true for elements for which a > b"},
{"lineNum":" 3477","line":"static inline Vec2qb operator > (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3478","line":"    return b < a;"},
{"lineNum":" 3479","line":"}"},
{"lineNum":" 3480","line":""},
{"lineNum":" 3481","line":"// vector operator >= : returns true for elements for which a >= b (signed)"},
{"lineNum":" 3482","line":"static inline Vec2qb operator >= (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3483","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 3484","line":"    return Vec2qb(_mm_comge_epi64(a,b));"},
{"lineNum":" 3485","line":"#else  // SSE2 instruction set"},
{"lineNum":" 3486","line":"    return Vec2qb(Vec2q(~(a < b)));"},
{"lineNum":" 3487","line":"#endif"},
{"lineNum":" 3488","line":"}"},
{"lineNum":" 3489","line":""},
{"lineNum":" 3490","line":"// vector operator <= : returns true for elements for which a <= b (signed)"},
{"lineNum":" 3491","line":"static inline Vec2qb operator <= (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3492","line":"    return b >= a;"},
{"lineNum":" 3493","line":"}"},
{"lineNum":" 3494","line":""},
{"lineNum":" 3495","line":"// vector operator & : bitwise and"},
{"lineNum":" 3496","line":"static inline Vec2q operator & (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3497","line":"    return Vec2q(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 3498","line":"}"},
{"lineNum":" 3499","line":"static inline Vec2q operator && (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3500","line":"    return a & b;"},
{"lineNum":" 3501","line":"}"},
{"lineNum":" 3502","line":"// vector operator &= : bitwise and"},
{"lineNum":" 3503","line":"static inline Vec2q & operator &= (Vec2q & a, Vec2q const & b) {"},
{"lineNum":" 3504","line":"    a = a & b;"},
{"lineNum":" 3505","line":"    return a;"},
{"lineNum":" 3506","line":"}"},
{"lineNum":" 3507","line":""},
{"lineNum":" 3508","line":"// vector operator | : bitwise or"},
{"lineNum":" 3509","line":"static inline Vec2q operator | (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3510","line":"    return Vec2q(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 3511","line":"}"},
{"lineNum":" 3512","line":"static inline Vec2q operator || (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3513","line":"    return a | b;"},
{"lineNum":" 3514","line":"}"},
{"lineNum":" 3515","line":"// vector operator |= : bitwise or"},
{"lineNum":" 3516","line":"static inline Vec2q & operator |= (Vec2q & a, Vec2q const & b) {"},
{"lineNum":" 3517","line":"    a = a | b;"},
{"lineNum":" 3518","line":"    return a;"},
{"lineNum":" 3519","line":"}"},
{"lineNum":" 3520","line":""},
{"lineNum":" 3521","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 3522","line":"static inline Vec2q operator ^ (Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3523","line":"    return Vec2q(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 3524","line":"}"},
{"lineNum":" 3525","line":"// vector operator ^= : bitwise xor"},
{"lineNum":" 3526","line":"static inline Vec2q & operator ^= (Vec2q & a, Vec2q const & b) {"},
{"lineNum":" 3527","line":"    a = a ^ b;"},
{"lineNum":" 3528","line":"    return a;"},
{"lineNum":" 3529","line":"}"},
{"lineNum":" 3530","line":""},
{"lineNum":" 3531","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 3532","line":"static inline Vec2q operator ~ (Vec2q const & a) {"},
{"lineNum":" 3533","line":"    return Vec2q( ~ Vec128b(a));"},
{"lineNum":" 3534","line":"}"},
{"lineNum":" 3535","line":""},
{"lineNum":" 3536","line":"// vector operator ! : logical not, returns true for elements == 0"},
{"lineNum":" 3537","line":"static inline Vec2qb operator ! (Vec2q const & a) {"},
{"lineNum":" 3538","line":"    return a == Vec2q(_mm_setzero_si128());"},
{"lineNum":" 3539","line":"}"},
{"lineNum":" 3540","line":""},
{"lineNum":" 3541","line":"// Functions for this class"},
{"lineNum":" 3542","line":""},
{"lineNum":" 3543","line":"// Select between two operands. Corresponds to this pseudocode:"},
{"lineNum":" 3544","line":"// for (int i = 0; i < 8; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":" 3545","line":"// Each byte in s must be either 0 (false) or -1 (true). No other values are allowed."},
{"lineNum":" 3546","line":"// (s is signed)"},
{"lineNum":" 3547","line":"static inline Vec2q select (Vec2qb const & s, Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3548","line":"    return selectb(s,a,b);"},
{"lineNum":" 3549","line":"}"},
{"lineNum":" 3550","line":""},
{"lineNum":" 3551","line":"// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]"},
{"lineNum":" 3552","line":"static inline Vec2q if_add (Vec2qb const & f, Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3553","line":"    return a + (Vec2q(f) & b);"},
{"lineNum":" 3554","line":"}"},
{"lineNum":" 3555","line":""},
{"lineNum":" 3556","line":"// Conditional sub: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]"},
{"lineNum":" 3557","line":"static inline Vec2q if_sub (Vec2qb const & f, Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3558","line":"    return a - (Vec2q(f) & b);"},
{"lineNum":" 3559","line":"}"},
{"lineNum":" 3560","line":""},
{"lineNum":" 3561","line":"// Conditional mul: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]"},
{"lineNum":" 3562","line":"static inline Vec2q if_mul (Vec2qb const & f, Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3563","line":"    return select(f, a*b, a);"},
{"lineNum":" 3564","line":"}"},
{"lineNum":" 3565","line":""},
{"lineNum":" 3566","line":"// Horizontal add: Calculates the sum of all vector elements."},
{"lineNum":" 3567","line":"// Overflow will wrap around"},
{"lineNum":" 3568","line":"static inline int64_t horizontal_add (Vec2q const & a) {"},
{"lineNum":" 3569","line":"    __m128i sum1  = _mm_unpackhi_epi64(a,a);               // high element"},
{"lineNum":" 3570","line":"    __m128i sum2  = _mm_add_epi64(a,sum1);                 // sum"},
{"lineNum":" 3571","line":"    return _emulate_movq(sum2);"},
{"lineNum":" 3572","line":"}"},
{"lineNum":" 3573","line":""},
{"lineNum":" 3574","line":"// function max: a > b ? a : b"},
{"lineNum":" 3575","line":"static inline Vec2q max(Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3576","line":"    return select(a > b, a, b);"},
{"lineNum":" 3577","line":"}"},
{"lineNum":" 3578","line":""},
{"lineNum":" 3579","line":"// function min: a < b ? a : b"},
{"lineNum":" 3580","line":"static inline Vec2q min(Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 3581","line":"    return select(a < b, a, b);"},
{"lineNum":" 3582","line":"}"},
{"lineNum":" 3583","line":""},
{"lineNum":" 3584","line":"// function abs: a >= 0 ? a : -a"},
{"lineNum":" 3585","line":"static inline Vec2q abs(Vec2q const & a) {"},
{"lineNum":" 3586","line":"#if INSTRSET >= 10     // AVX512VL"},
{"lineNum":" 3587","line":"    return _mm_abs_epi64(a);"},
{"lineNum":" 3588","line":"#elif INSTRSET >= 6     // SSE4.2 supported"},
{"lineNum":" 3589","line":"    __m128i sign  = _mm_cmpgt_epi64(_mm_setzero_si128(),a);// 0 > a"},
{"lineNum":" 3590","line":"    __m128i inv   = _mm_xor_si128(a,sign);                 // invert bits if negative"},
{"lineNum":" 3591","line":"    return          _mm_sub_epi64(inv,sign);               // add 1"},
{"lineNum":" 3592","line":"#else                 // SSE2"},
{"lineNum":" 3593","line":"    __m128i signh = _mm_srai_epi32(a,31);                  // sign in high dword"},
{"lineNum":" 3594","line":"    __m128i sign  = _mm_shuffle_epi32(signh,0xF5);         // copy sign to low dword"},
{"lineNum":" 3595","line":"    __m128i inv   = _mm_xor_si128(a,sign);                 // invert bits if negative"},
{"lineNum":" 3596","line":"    return          _mm_sub_epi64(inv,sign);               // add 1"},
{"lineNum":" 3597","line":"#endif"},
{"lineNum":" 3598","line":"}"},
{"lineNum":" 3599","line":""},
{"lineNum":" 3600","line":"// function abs_saturated: same as abs, saturate if overflow"},
{"lineNum":" 3601","line":"static inline Vec2q abs_saturated(Vec2q const & a) {"},
{"lineNum":" 3602","line":"    __m128i absa   = abs(a);                               // abs(a)"},
{"lineNum":" 3603","line":"#if INSTRSET >= 6     // SSE4.2 supported"},
{"lineNum":" 3604","line":"    __m128i overfl = _mm_cmpgt_epi64(_mm_setzero_si128(),absa);// 0 > a"},
{"lineNum":" 3605","line":"#else                 // SSE2"},
{"lineNum":" 3606","line":"    __m128i signh = _mm_srai_epi32(absa,31);               // sign in high dword"},
{"lineNum":" 3607","line":"    __m128i overfl= _mm_shuffle_epi32(signh,0xF5);         // copy sign to low dword"},
{"lineNum":" 3608","line":"#endif"},
{"lineNum":" 3609","line":"    return           _mm_add_epi64(absa,overfl);           // subtract 1 if 0x8000000000000000"},
{"lineNum":" 3610","line":"}"},
{"lineNum":" 3611","line":""},
{"lineNum":" 3612","line":"// function rotate_left all elements"},
{"lineNum":" 3613","line":"// Use negative count to rotate right"},
{"lineNum":" 3614","line":"static inline Vec2q rotate_left(Vec2q const & a, int b) {"},
{"lineNum":" 3615","line":"#if INSTRSET >= 10  // __AVX512VL__"},
{"lineNum":" 3616","line":"    return _mm_rolv_epi64(a, _mm_set1_epi64x(int64_t(b)));"},
{"lineNum":" 3617","line":"#elif defined __XOP__  // AMD XOP instruction set"},
{"lineNum":" 3618","line":"    return (Vec2q)_mm_rot_epi64(a,Vec2q(b));"},
{"lineNum":" 3619","line":"#else  // SSE2 instruction set"},
{"lineNum":" 3620","line":"    __m128i left  = _mm_sll_epi64(a,_mm_cvtsi32_si128(b & 0x3F));      // a << b"},
{"lineNum":" 3621","line":"    __m128i right = _mm_srl_epi64(a,_mm_cvtsi32_si128((-b) & 0x3F));   // a >> (64 - b)"},
{"lineNum":" 3622","line":"    __m128i rot   = _mm_or_si128(left,right);                          // or"},
{"lineNum":" 3623","line":"    return  (Vec2q)rot;"},
{"lineNum":" 3624","line":"#endif"},
{"lineNum":" 3625","line":"}"},
{"lineNum":" 3626","line":""},
{"lineNum":" 3627","line":""},
{"lineNum":" 3628","line":"/*****************************************************************************"},
{"lineNum":" 3629","line":"*"},
{"lineNum":" 3630","line":"*          Vector of 2 64-bit unsigned integers"},
{"lineNum":" 3631","line":"*"},
{"lineNum":" 3632","line":"*****************************************************************************/"},
{"lineNum":" 3633","line":""},
{"lineNum":" 3634","line":"class Vec2uq : public Vec2q {"},
{"lineNum":" 3635","line":"public:"},
{"lineNum":" 3636","line":"    // Default constructor:"},
{"lineNum":" 3637","line":"    Vec2uq() {"},
{"lineNum":" 3638","line":"    }"},
{"lineNum":" 3639","line":"    // Constructor to broadcast the same value into all elements:"},
{"lineNum":" 3640","line":"    Vec2uq(uint64_t i) {"},
{"lineNum":" 3641","line":"        xmm = Vec2q((int64_t)i);"},
{"lineNum":" 3642","line":"    }"},
{"lineNum":" 3643","line":"    // Constructor to build from all elements:"},
{"lineNum":" 3644","line":"    Vec2uq(uint64_t i0, uint64_t i1) {"},
{"lineNum":" 3645","line":"        xmm = Vec2q((int64_t)i0, (int64_t)i1);"},
{"lineNum":" 3646","line":"    }"},
{"lineNum":" 3647","line":"    // Constructor to convert from type __m128i used in intrinsics:"},
{"lineNum":" 3648","line":"    Vec2uq(__m128i const & x) {"},
{"lineNum":" 3649","line":"        xmm = x;"},
{"lineNum":" 3650","line":"    }"},
{"lineNum":" 3651","line":"    // Assignment operator to convert from type __m128i used in intrinsics:"},
{"lineNum":" 3652","line":"    Vec2uq & operator = (__m128i const & x) {"},
{"lineNum":" 3653","line":"        xmm = x;"},
{"lineNum":" 3654","line":"        return *this;"},
{"lineNum":" 3655","line":"    }"},
{"lineNum":" 3656","line":"    // Member function to load from array (unaligned)"},
{"lineNum":" 3657","line":"    Vec2uq & load(void const * p) {"},
{"lineNum":" 3658","line":"        xmm = _mm_loadu_si128((__m128i const*)p);"},
{"lineNum":" 3659","line":"        return *this;"},
{"lineNum":" 3660","line":"    }"},
{"lineNum":" 3661","line":"    // Member function to load from array (aligned)"},
{"lineNum":" 3662","line":"    Vec2uq & load_a(void const * p) {"},
{"lineNum":" 3663","line":"        xmm = _mm_load_si128((__m128i const*)p);"},
{"lineNum":" 3664","line":"        return *this;"},
{"lineNum":" 3665","line":"    }"},
{"lineNum":" 3666","line":"    // Member function to change a single element in vector"},
{"lineNum":" 3667","line":"    // Note: This function is inefficient. Use load function if changing more than one element"},
{"lineNum":" 3668","line":"    Vec2uq const & insert(int index, uint64_t value) {"},
{"lineNum":" 3669","line":"        Vec2q::insert(index, (int64_t)value);"},
{"lineNum":" 3670","line":"        return *this;"},
{"lineNum":" 3671","line":"    }"},
{"lineNum":" 3672","line":"    // Member function extract a single element from vector"},
{"lineNum":" 3673","line":"    uint64_t extract(int index) const {"},
{"lineNum":" 3674","line":"        return (uint64_t)Vec2q::extract(index);"},
{"lineNum":" 3675","line":"    }"},
{"lineNum":" 3676","line":"    // Extract a single element. Use store function if extracting more than one element."},
{"lineNum":" 3677","line":"    // Operator [] can only read an element, not write."},
{"lineNum":" 3678","line":"    uint64_t operator [] (int index) const {"},
{"lineNum":" 3679","line":"        return extract(index);"},
{"lineNum":" 3680","line":"    }"},
{"lineNum":" 3681","line":"    static int elementtype() {"},
{"lineNum":" 3682","line":"        return 11;"},
{"lineNum":" 3683","line":"    }"},
{"lineNum":" 3684","line":"};"},
{"lineNum":" 3685","line":""},
{"lineNum":" 3686","line":"// Define operators for this class"},
{"lineNum":" 3687","line":""},
{"lineNum":" 3688","line":"// vector operator + : add"},
{"lineNum":" 3689","line":"static inline Vec2uq operator + (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3690","line":"    return Vec2uq (Vec2q(a) + Vec2q(b));"},
{"lineNum":" 3691","line":"}"},
{"lineNum":" 3692","line":""},
{"lineNum":" 3693","line":"// vector operator - : subtract"},
{"lineNum":" 3694","line":"static inline Vec2uq operator - (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3695","line":"    return Vec2uq (Vec2q(a) - Vec2q(b));"},
{"lineNum":" 3696","line":"}"},
{"lineNum":" 3697","line":""},
{"lineNum":" 3698","line":"// vector operator * : multiply element by element"},
{"lineNum":" 3699","line":"static inline Vec2uq operator * (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3700","line":"    return Vec2uq (Vec2q(a) * Vec2q(b));"},
{"lineNum":" 3701","line":"}"},
{"lineNum":" 3702","line":""},
{"lineNum":" 3703","line":"// vector operator >> : shift right logical all elements"},
{"lineNum":" 3704","line":"static inline Vec2uq operator >> (Vec2uq const & a, uint32_t b) {"},
{"lineNum":" 3705","line":"    return _mm_srl_epi64(a,_mm_cvtsi32_si128((int)b));","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":" 3706","line":"}"},
{"lineNum":" 3707","line":""},
{"lineNum":" 3708","line":"// vector operator >> : shift right logical all elements"},
{"lineNum":" 3709","line":"static inline Vec2uq operator >> (Vec2uq const & a, int32_t b) {"},
{"lineNum":" 3710","line":"    return a >> (uint32_t)b;"},
{"lineNum":" 3711","line":"}"},
{"lineNum":" 3712","line":""},
{"lineNum":" 3713","line":"// vector operator >>= : shift right logical"},
{"lineNum":" 3714","line":"static inline Vec2uq & operator >>= (Vec2uq & a, int b) {"},
{"lineNum":" 3715","line":"    a = a >> b;"},
{"lineNum":" 3716","line":"    return a;"},
{"lineNum":" 3717","line":"}"},
{"lineNum":" 3718","line":""},
{"lineNum":" 3719","line":"// vector operator << : shift left all elements"},
{"lineNum":" 3720","line":"static inline Vec2uq operator << (Vec2uq const & a, uint32_t b) {"},
{"lineNum":" 3721","line":"    return Vec2uq ((Vec2q)a << (int32_t)b);"},
{"lineNum":" 3722","line":"}"},
{"lineNum":" 3723","line":""},
{"lineNum":" 3724","line":"// vector operator << : shift left all elements"},
{"lineNum":" 3725","line":"static inline Vec2uq operator << (Vec2uq const & a, int32_t b) {"},
{"lineNum":" 3726","line":"    return Vec2uq ((Vec2q)a << b);"},
{"lineNum":" 3727","line":"}"},
{"lineNum":" 3728","line":""},
{"lineNum":" 3729","line":"// vector operator > : returns true for elements for which a > b (unsigned)"},
{"lineNum":" 3730","line":"static inline Vec2qb operator > (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3731","line":"#if defined ( __XOP__ ) // AMD XOP instruction set"},
{"lineNum":" 3732","line":"    return Vec2qb(_mm_comgt_epu64(a,b));"},
{"lineNum":" 3733","line":"#elif INSTRSET >= 6 // SSE4.2"},
{"lineNum":" 3734","line":"    __m128i sign64 = constant4ui<0,0x80000000,0,0x80000000>();"},
{"lineNum":" 3735","line":"    __m128i aflip  = _mm_xor_si128(a, sign64);             // flip sign bits to use signed compare"},
{"lineNum":" 3736","line":"    __m128i bflip  = _mm_xor_si128(b, sign64);"},
{"lineNum":" 3737","line":"    Vec2q   cmp    = _mm_cmpgt_epi64(aflip,bflip);"},
{"lineNum":" 3738","line":"    return Vec2qb(cmp);"},
{"lineNum":" 3739","line":"#else  // SSE2 instruction set"},
{"lineNum":" 3740","line":"    __m128i sign32  = _mm_set1_epi32(0x80000000);          // sign bit of each dword"},
{"lineNum":" 3741","line":"    __m128i aflip   = _mm_xor_si128(a,sign32);             // a with sign bits flipped to use signed compare"},
{"lineNum":" 3742","line":"    __m128i bflip   = _mm_xor_si128(b,sign32);             // b with sign bits flipped to use signed compare"},
{"lineNum":" 3743","line":"    __m128i equal   = _mm_cmpeq_epi32(a,b);                // a == b, dwords"},
{"lineNum":" 3744","line":"    __m128i bigger  = _mm_cmpgt_epi32(aflip,bflip);        // a > b, dwords"},
{"lineNum":" 3745","line":"    __m128i biggerl = _mm_shuffle_epi32(bigger,0xA0);      // a > b, low dwords copied to high dwords"},
{"lineNum":" 3746","line":"    __m128i eqbig   = _mm_and_si128(equal,biggerl);        // high part equal and low part bigger"},
{"lineNum":" 3747","line":"    __m128i hibig   = _mm_or_si128(bigger,eqbig);          // high part bigger or high part equal and low part bigger"},
{"lineNum":" 3748","line":"    __m128i big     = _mm_shuffle_epi32(hibig,0xF5);       // result copied to low part"},
{"lineNum":" 3749","line":"    return  Vec2qb(Vec2q(big));"},
{"lineNum":" 3750","line":"#endif"},
{"lineNum":" 3751","line":"}"},
{"lineNum":" 3752","line":""},
{"lineNum":" 3753","line":"// vector operator < : returns true for elements for which a < b (unsigned)"},
{"lineNum":" 3754","line":"static inline Vec2qb operator < (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3755","line":"    return b > a;"},
{"lineNum":" 3756","line":"}"},
{"lineNum":" 3757","line":""},
{"lineNum":" 3758","line":"// vector operator >= : returns true for elements for which a >= b (unsigned)"},
{"lineNum":" 3759","line":"static inline Vec2qb operator >= (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3760","line":"#ifdef __XOP__  // AMD XOP instruction set"},
{"lineNum":" 3761","line":"    return Vec2qb(_mm_comge_epu64(a,b));"},
{"lineNum":" 3762","line":"#else  // SSE2 instruction set"},
{"lineNum":" 3763","line":"    return  Vec2qb(Vec2q(~(b > a)));"},
{"lineNum":" 3764","line":"#endif"},
{"lineNum":" 3765","line":"}"},
{"lineNum":" 3766","line":""},
{"lineNum":" 3767","line":"// vector operator <= : returns true for elements for which a <= b (unsigned)"},
{"lineNum":" 3768","line":"static inline Vec2qb operator <= (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3769","line":"    return b >= a;"},
{"lineNum":" 3770","line":"}"},
{"lineNum":" 3771","line":""},
{"lineNum":" 3772","line":"// vector operator & : bitwise and"},
{"lineNum":" 3773","line":"static inline Vec2uq operator & (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3774","line":"    return Vec2uq(Vec128b(a) & Vec128b(b));"},
{"lineNum":" 3775","line":"}"},
{"lineNum":" 3776","line":"static inline Vec2uq operator && (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3777","line":"    return a & b;"},
{"lineNum":" 3778","line":"}"},
{"lineNum":" 3779","line":""},
{"lineNum":" 3780","line":"// vector operator | : bitwise or"},
{"lineNum":" 3781","line":"static inline Vec2uq operator | (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3782","line":"    return Vec2uq(Vec128b(a) | Vec128b(b));"},
{"lineNum":" 3783","line":"}"},
{"lineNum":" 3784","line":"static inline Vec2uq operator || (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3785","line":"    return a | b;"},
{"lineNum":" 3786","line":"}"},
{"lineNum":" 3787","line":""},
{"lineNum":" 3788","line":"// vector operator ^ : bitwise xor"},
{"lineNum":" 3789","line":"static inline Vec2uq operator ^ (Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3790","line":"    return Vec2uq(Vec128b(a) ^ Vec128b(b));"},
{"lineNum":" 3791","line":"}"},
{"lineNum":" 3792","line":""},
{"lineNum":" 3793","line":"// vector operator ~ : bitwise not"},
{"lineNum":" 3794","line":"static inline Vec2uq operator ~ (Vec2uq const & a) {"},
{"lineNum":" 3795","line":"    return Vec2uq( ~ Vec128b(a));"},
{"lineNum":" 3796","line":"}"},
{"lineNum":" 3797","line":""},
{"lineNum":" 3798","line":""},
{"lineNum":" 3799","line":"// Functions for this class"},
{"lineNum":" 3800","line":""},
{"lineNum":" 3801","line":"// Select between two operands. Corresponds to this pseudocode:"},
{"lineNum":" 3802","line":"// for (int i = 0; i < 2; i++) result[i] = s[i] ? a[i] : b[i];"},
{"lineNum":" 3803","line":"// Each word in s must be either 0 (false) or -1 (true). No other values are allowed."},
{"lineNum":" 3804","line":"// (s is signed)"},
{"lineNum":" 3805","line":"static inline Vec2uq select (Vec2qb const & s, Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3806","line":"    return selectb(s,a,b);"},
{"lineNum":" 3807","line":"}"},
{"lineNum":" 3808","line":""},
{"lineNum":" 3809","line":"// Conditional add: For all vector elements i: result[i] = f[i] ? (a[i] + b[i]) : a[i]"},
{"lineNum":" 3810","line":"static inline Vec2uq if_add (Vec2qb const & f, Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3811","line":"    return a + (Vec2uq(f) & b);"},
{"lineNum":" 3812","line":"}"},
{"lineNum":" 3813","line":""},
{"lineNum":" 3814","line":"// Conditional sub: For all vector elements i: result[i] = f[i] ? (a[i] - b[i]) : a[i]"},
{"lineNum":" 3815","line":"static inline Vec2uq if_sub (Vec2qb const & f, Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3816","line":"    return a - (Vec2uq(f) & b);"},
{"lineNum":" 3817","line":"}"},
{"lineNum":" 3818","line":""},
{"lineNum":" 3819","line":"// Conditional mul: For all vector elements i: result[i] = f[i] ? (a[i] * b[i]) : a[i]"},
{"lineNum":" 3820","line":"static inline Vec2uq if_mul (Vec2qb const & f, Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3821","line":"    return select(f, a*b, a);"},
{"lineNum":" 3822","line":"}"},
{"lineNum":" 3823","line":""},
{"lineNum":" 3824","line":"// Horizontal add: Calculates the sum of all vector elements."},
{"lineNum":" 3825","line":"// Overflow will wrap around"},
{"lineNum":" 3826","line":"static inline uint64_t horizontal_add (Vec2uq const & a) {"},
{"lineNum":" 3827","line":"    return (uint64_t)horizontal_add((Vec2q)a);"},
{"lineNum":" 3828","line":"}"},
{"lineNum":" 3829","line":""},
{"lineNum":" 3830","line":"// function max: a > b ? a : b"},
{"lineNum":" 3831","line":"static inline Vec2uq max(Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3832","line":"    return select(a > b, a, b);"},
{"lineNum":" 3833","line":"}"},
{"lineNum":" 3834","line":""},
{"lineNum":" 3835","line":"// function min: a < b ? a : b"},
{"lineNum":" 3836","line":"static inline Vec2uq min(Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 3837","line":"    return select(a > b, b, a);"},
{"lineNum":" 3838","line":"}"},
{"lineNum":" 3839","line":""},
{"lineNum":" 3840","line":""},
{"lineNum":" 3841","line":"/*****************************************************************************"},
{"lineNum":" 3842","line":"*"},
{"lineNum":" 3843","line":"*          Vector permute functions"},
{"lineNum":" 3844","line":"*"},
{"lineNum":" 3845","line":"******************************************************************************"},
{"lineNum":" 3846","line":"*"},
{"lineNum":" 3847","line":"* These permute functions can reorder the elements of a vector and optionally"},
{"lineNum":" 3848","line":"* set some elements to zero."},
{"lineNum":" 3849","line":"*"},
{"lineNum":" 3850","line":"* The indexes are inserted as template parameters in <>. These indexes must be"},
{"lineNum":" 3851","line":"* constants. Each template parameter is an index to the element you want to"},
{"lineNum":" 3852","line":"* select. A negative index will generate zero. an index of -256 means don\'t care."},
{"lineNum":" 3853","line":"*"},
{"lineNum":" 3854","line":"* Example:"},
{"lineNum":" 3855","line":"* Vec4i a(10,11,12,13);         // a is (10,11,12,13)"},
{"lineNum":" 3856","line":"* Vec4i b, c;"},
{"lineNum":" 3857","line":"* b = permute4<0,0,2,2>(a);    // b is (10,10,12,12)"},
{"lineNum":" 3858","line":"* c = permute4<3,2,-1,-1>(a);  // c is (13,12, 0, 0)"},
{"lineNum":" 3859","line":"*"},
{"lineNum":" 3860","line":"* The permute functions for vectors of 8-bit integers are inefficient if"},
{"lineNum":" 3861","line":"* the SSSE3 instruction set or later is not enabled."},
{"lineNum":" 3862","line":"*"},
{"lineNum":" 3863","line":"* A lot of the code here is metaprogramming aiming to find the instructions"},
{"lineNum":" 3864","line":"* that best fit the template parameters and instruction set. The metacode"},
{"lineNum":" 3865","line":"* will be reduced out to leave only a few vector instructions in release"},
{"lineNum":" 3866","line":"* mode with optimization on."},
{"lineNum":" 3867","line":"*****************************************************************************/"},
{"lineNum":" 3868","line":""},
{"lineNum":" 3869","line":"template <int i0, int i1>"},
{"lineNum":" 3870","line":"static inline Vec2q permute2(Vec2q const & a) {"},
{"lineNum":" 3871","line":"    if (i0 == 0) {"},
{"lineNum":" 3872","line":"        if (i1 == 0) {       // 0,0"},
{"lineNum":" 3873","line":"            return _mm_unpacklo_epi64(a, a);"},
{"lineNum":" 3874","line":"        }"},
{"lineNum":" 3875","line":"        else if (i1 == 1 || i1 == -0x100) {  // 0,1"},
{"lineNum":" 3876","line":"            return a;"},
{"lineNum":" 3877","line":"        }"},
{"lineNum":" 3878","line":"        else {               // 0,-1"},
{"lineNum":" 3879","line":"            // return _mm_mov_epi64(a); // doesn\'t work with MS VS 2008"},
{"lineNum":" 3880","line":"            return _mm_and_si128(a, constant4i<-1,-1,0,0>());"},
{"lineNum":" 3881","line":"        }"},
{"lineNum":" 3882","line":"    }"},
{"lineNum":" 3883","line":"    else if (i0 == 1) {"},
{"lineNum":" 3884","line":"        if (i1 == 0) {       // 1,0"},
{"lineNum":" 3885","line":"            return _mm_shuffle_epi32(a, 0x4E);"},
{"lineNum":" 3886","line":"        }"},
{"lineNum":" 3887","line":"        else if (i1 == 1) {  // 1,1"},
{"lineNum":" 3888","line":"            return _mm_unpackhi_epi64(a, a);"},
{"lineNum":" 3889","line":"        }"},
{"lineNum":" 3890","line":"        else {               // 1,-1"},
{"lineNum":" 3891","line":"            return _mm_srli_si128(a, 8);"},
{"lineNum":" 3892","line":"        }"},
{"lineNum":" 3893","line":"    }"},
{"lineNum":" 3894","line":"    else { // i0 < 0"},
{"lineNum":" 3895","line":"        if (i1 == 0) {       // -1,0"},
{"lineNum":" 3896","line":"            return _mm_slli_si128(a, 8);"},
{"lineNum":" 3897","line":"        }"},
{"lineNum":" 3898","line":"        else if (i1 == 1) {  // -1,1"},
{"lineNum":" 3899","line":"            if (i0 == -0x100) return a;"},
{"lineNum":" 3900","line":"            return _mm_and_si128(a, constant4i<0,0,-1,-1>());"},
{"lineNum":" 3901","line":"        }"},
{"lineNum":" 3902","line":"        else {               // -1,-1"},
{"lineNum":" 3903","line":"            return _mm_setzero_si128();"},
{"lineNum":" 3904","line":"        }"},
{"lineNum":" 3905","line":"    }"},
{"lineNum":" 3906","line":"}"},
{"lineNum":" 3907","line":""},
{"lineNum":" 3908","line":"template <int i0, int i1>"},
{"lineNum":" 3909","line":"static inline Vec2uq permute2(Vec2uq const & a) {"},
{"lineNum":" 3910","line":"    return Vec2uq (permute2 <i0, i1> ((Vec2q)a));"},
{"lineNum":" 3911","line":"}"},
{"lineNum":" 3912","line":""},
{"lineNum":" 3913","line":"// permute vector Vec4i"},
{"lineNum":" 3914","line":"template <int i0, int i1, int i2, int i3>"},
{"lineNum":" 3915","line":"static inline Vec4i permute4(Vec4i const & a) {"},
{"lineNum":" 3916","line":""},
{"lineNum":" 3917","line":"    // Combine all the indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 3918","line":"    const uint32_t m1 = (i0&3) | (i1&3)<<4 | (i2&3)<<8 | (i3&3)<<12;"},
{"lineNum":" 3919","line":""},
{"lineNum":" 3920","line":"    // Mask to zero out negative indexes"},
{"lineNum":" 3921","line":"    const uint32_t mz = (i0<0?0:0xF) | (i1<0?0:0xF)<<4 | (i2<0?0:0xF)<<8 | (i3<0?0:0xF)<<12;"},
{"lineNum":" 3922","line":""},
{"lineNum":" 3923","line":"    // Mask indicating required zeroing of all indexes, with 4 bits for each, 0 for index = -1, 0xF for index >= 0 or -256"},
{"lineNum":" 3924","line":"    const uint32_t ssz = ((i0 & 0x80) ? 0 : 0xF) | ((i1 & 0x80) ? 0 : 0xF) << 4 | ((i2 & 0x80) ? 0 : 0xF) << 8 | ((i3 & 0x80) ? 0 : 0xF) << 12;"},
{"lineNum":" 3925","line":""},
{"lineNum":" 3926","line":"    // Mask indicating 0 for don\'t care, 0xF for non-negative value of required zeroing"},
{"lineNum":" 3927","line":"    const uint32_t md = mz | ~ ssz;"},
{"lineNum":" 3928","line":""},
{"lineNum":" 3929","line":"    // Test if permutation needed"},
{"lineNum":" 3930","line":"    const bool do_shuffle = ((m1 ^ 0x00003210) & mz) != 0;"},
{"lineNum":" 3931","line":""},
{"lineNum":" 3932","line":"    // is zeroing needed"},
{"lineNum":" 3933","line":"    const bool do_zero    = (ssz != 0xFFFF);"},
{"lineNum":" 3934","line":""},
{"lineNum":" 3935","line":"    if (mz == 0) {"},
{"lineNum":" 3936","line":"        return _mm_setzero_si128();    // special case: all zero or don\'t care"},
{"lineNum":" 3937","line":"    }"},
{"lineNum":" 3938","line":"    // Test if we can do with 64-bit permute only"},
{"lineNum":" 3939","line":"    if ((m1 & 0x0101 & mz) == 0        // even indexes are even or negative"},
{"lineNum":" 3940","line":"    && (~m1 & 0x1010 & mz) == 0        // odd  indexes are odd  or negative"},
{"lineNum":" 3941","line":"    && ((m1 ^ ((m1 + 0x0101) << 4)) & 0xF0F0 & mz & (mz << 4)) == 0  // odd index == preceding even index +1 or at least one of them negative"},
{"lineNum":" 3942","line":"    && ((mz ^ (mz << 4)) & 0xF0F0 & md & md << 4) == 0) {      // each pair of indexes are both negative or both positive or one of them don\'t care"},
{"lineNum":" 3943","line":"        const int j0 = i0 >= 0 ? i0 / 2 : (i0 & 0x80) ? i0 : i1 >= 0 ? i1/2 : i1;"},
{"lineNum":" 3944","line":"        const int j1 = i2 >= 0 ? i2 / 2 : (i2 & 0x80) ? i2 : i3 >= 0 ? i3/2 : i3;"},
{"lineNum":" 3945","line":"        return Vec4i(permute2<j0, j1> (Vec2q(a)));    // 64 bit permute"},
{"lineNum":" 3946","line":"    }"},
{"lineNum":" 3947","line":"#if  INSTRSET >= 4  // SSSE3"},
{"lineNum":" 3948","line":"    if (do_shuffle && do_zero) {"},
{"lineNum":" 3949","line":"        // With SSSE3 we can do both with the PSHUFB instruction"},
{"lineNum":" 3950","line":"        const int j0 = (i0 & 3) << 2;"},
{"lineNum":" 3951","line":"        const int j1 = (i1 & 3) << 2;"},
{"lineNum":" 3952","line":"        const int j2 = (i2 & 3) << 2;"},
{"lineNum":" 3953","line":"        const int j3 = (i3 & 3) << 2;"},
{"lineNum":" 3954","line":"        __m128i mask1 = constant4i <"},
{"lineNum":" 3955","line":"            i0 < 0 ? -1 : j0 | (j0+1)<<8 | (j0+2)<<16 | (j0+3) << 24,"},
{"lineNum":" 3956","line":"            i1 < 0 ? -1 : j1 | (j1+1)<<8 | (j1+2)<<16 | (j1+3) << 24,"},
{"lineNum":" 3957","line":"            i2 < 0 ? -1 : j2 | (j2+1)<<8 | (j2+2)<<16 | (j2+3) << 24,"},
{"lineNum":" 3958","line":"            i3 < 0 ? -1 : j3 | (j3+1)<<8 | (j3+2)<<16 | (j3+3) << 24 > ();"},
{"lineNum":" 3959","line":"        return _mm_shuffle_epi8(a,mask1);"},
{"lineNum":" 3960","line":"    }"},
{"lineNum":" 3961","line":"#endif"},
{"lineNum":" 3962","line":"    __m128i t1;"},
{"lineNum":" 3963","line":""},
{"lineNum":" 3964","line":"    if (do_shuffle) {  // permute"},
{"lineNum":" 3965","line":"        t1 = _mm_shuffle_epi32(a, (i0 & 3) | (i1 & 3) << 2 | (i2 & 3) << 4 | (i3 & 3) << 6);"},
{"lineNum":" 3966","line":"    }"},
{"lineNum":" 3967","line":"    else {"},
{"lineNum":" 3968","line":"        t1 = a;"},
{"lineNum":" 3969","line":"    }"},
{"lineNum":" 3970","line":"    if (do_zero) {     // set some elements to zero"},
{"lineNum":" 3971","line":"        __m128i mask2 = constant4i< -int(i0>=0), -int(i1>=0), -int(i2>=0), -int(i3>=0) >();"},
{"lineNum":" 3972","line":"        t1 = _mm_and_si128(t1,mask2);"},
{"lineNum":" 3973","line":"    }"},
{"lineNum":" 3974","line":"    return t1;"},
{"lineNum":" 3975","line":"}"},
{"lineNum":" 3976","line":""},
{"lineNum":" 3977","line":"template <int i0, int i1, int i2, int i3>"},
{"lineNum":" 3978","line":"static inline Vec4ui permute4(Vec4ui const & a) {"},
{"lineNum":" 3979","line":"    return Vec4ui (permute4 <i0,i1,i2,i3> (Vec4i(a)));"},
{"lineNum":" 3980","line":"}"},
{"lineNum":" 3981","line":""},
{"lineNum":" 3982","line":"template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>"},
{"lineNum":" 3983","line":"static inline Vec8s permute8(Vec8s const & a) {"},
{"lineNum":" 3984","line":"    if ((i0 & i1 & i2 & i3 & i4 & i5 & i6 & i7) < 0) {"},
{"lineNum":" 3985","line":"        return _mm_setzero_si128();  // special case: all zero"},
{"lineNum":" 3986","line":"    }"},
{"lineNum":" 3987","line":"#if  INSTRSET >= 4  // SSSE3"},
{"lineNum":" 3988","line":""},
{"lineNum":" 3989","line":"    // special case: rotate"},
{"lineNum":" 3990","line":"    if (i0>=0 && i0 < 8 && i1==((i0+1)&7) && i2==((i0+2)&7) && i3==((i0+3)&7) && i4==((i0+4)&7) && i5==((i0+5)&7) && i6==((i0+6)&7) && i7==((i0+7)&7)) {"},
{"lineNum":" 3991","line":"        if (i0 == 0) return a;  // do nothing"},
{"lineNum":" 3992","line":"        return _mm_alignr_epi8(a, a, (i0 & 7) * 2);"},
{"lineNum":" 3993","line":"    }"},
{"lineNum":" 3994","line":""},
{"lineNum":" 3995","line":"    // General case: Use PSHUFB"},
{"lineNum":" 3996","line":"    const int j0 = i0 < 0 ? 0xFFFF : ( (i0 & 7) * 2 | ((i0 & 7) * 2 + 1) << 8 );"},
{"lineNum":" 3997","line":"    const int j1 = i1 < 0 ? 0xFFFF : ( (i1 & 7) * 2 | ((i1 & 7) * 2 + 1) << 8 );"},
{"lineNum":" 3998","line":"    const int j2 = i2 < 0 ? 0xFFFF : ( (i2 & 7) * 2 | ((i2 & 7) * 2 + 1) << 8 );"},
{"lineNum":" 3999","line":"    const int j3 = i3 < 0 ? 0xFFFF : ( (i3 & 7) * 2 | ((i3 & 7) * 2 + 1) << 8 );"},
{"lineNum":" 4000","line":"    const int j4 = i4 < 0 ? 0xFFFF : ( (i4 & 7) * 2 | ((i4 & 7) * 2 + 1) << 8 );"},
{"lineNum":" 4001","line":"    const int j5 = i5 < 0 ? 0xFFFF : ( (i5 & 7) * 2 | ((i5 & 7) * 2 + 1) << 8 );"},
{"lineNum":" 4002","line":"    const int j6 = i6 < 0 ? 0xFFFF : ( (i6 & 7) * 2 | ((i6 & 7) * 2 + 1) << 8 );"},
{"lineNum":" 4003","line":"    const int j7 = i7 < 0 ? 0xFFFF : ( (i7 & 7) * 2 | ((i7 & 7) * 2 + 1) << 8 );"},
{"lineNum":" 4004","line":"    __m128i mask = constant4i < j0 | j1 << 16, j2 | j3 << 16, j4 | j5 << 16, j6 | j7 << 16 > ();"},
{"lineNum":" 4005","line":"    return _mm_shuffle_epi8(a,mask);"},
{"lineNum":" 4006","line":""},
{"lineNum":" 4007","line":"#else   // SSE2 has no simple solution. Find the optimal permute method."},
{"lineNum":" 4008","line":"    // Without proper metaprogramming features, we have to use constant expressions"},
{"lineNum":" 4009","line":"    // and if-statements to make sure these calculations are resolved at compile time."},
{"lineNum":" 4010","line":"    // All this should produce at most 8 instructions in the final code, depending"},
{"lineNum":" 4011","line":"    // on the template parameters."},
{"lineNum":" 4012","line":""},
{"lineNum":" 4013","line":"    // Temporary vectors"},
{"lineNum":" 4014","line":"    __m128i t1, t2, t3, t4, t5, t6, t7;"},
{"lineNum":" 4015","line":""},
{"lineNum":" 4016","line":"    // Combine all the indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 4017","line":"    const int m1 = (i0&7) | (i1&7)<<4 | (i2&7)<<8 | (i3&7)<<12"},
{"lineNum":" 4018","line":"        | (i4&7)<<16 | (i5&7)<<20 | (i6&7)<<24 | (i7&7)<<28;"},
{"lineNum":" 4019","line":""},
{"lineNum":" 4020","line":"    // Mask to zero out negative indexes"},
{"lineNum":" 4021","line":"    const int m2 = (i0<0?0:0xF) | (i1<0?0:0xF)<<4 | (i2<0?0:0xF)<<8 | (i3<0?0:0xF)<<12"},
{"lineNum":" 4022","line":"        | (i4<0?0:0xF)<<16 | (i5<0?0:0xF)<<20 | (i6<0?0:0xF)<<24 | (i7<0?0:0xF)<<28;"},
{"lineNum":" 4023","line":""},
{"lineNum":" 4024","line":"    // Test if we can do without permute"},
{"lineNum":" 4025","line":"    const bool case0 = ((m1 ^ 0x76543210) & m2) == 0; // all indexes point to their own place or negative"},
{"lineNum":" 4026","line":""},
{"lineNum":" 4027","line":"    // Test if we can do with 32-bit permute only"},
{"lineNum":" 4028","line":"    const bool case1 ="},
{"lineNum":" 4029","line":"        (m1 & 0x01010101 & m2) == 0        // even indexes are even or negative"},
{"lineNum":" 4030","line":"        && (~m1 & 0x10101010 & m2) == 0    // odd  indexes are odd  or negative"},
{"lineNum":" 4031","line":"        && ((m1 ^ ((m1 + 0x01010101ull) << 4)) & 0xF0F0F0F0 & m2 & ((uint64_t)m2 << 4)) == 0; // odd index == preceding even index +1 or at least one of them negative"},
{"lineNum":" 4032","line":""},
{"lineNum":" 4033","line":"    // Test if we can do with 16-bit permute only"},
{"lineNum":" 4034","line":"    const bool case2 ="},
{"lineNum":" 4035","line":"        (((m1 & 0x44444444) ^ 0x44440000) & m2) == 0;  // indexes 0-3 point to lower 64 bits, 1-7 to higher 64 bits, or negative"},
{"lineNum":" 4036","line":""},
{"lineNum":" 4037","line":"    if (case0) {"},
{"lineNum":" 4038","line":"        // no permute needed"},
{"lineNum":" 4039","line":"        t7 = a;"},
{"lineNum":" 4040","line":"    }"},
{"lineNum":" 4041","line":"    else if (case1) {"},
{"lineNum":" 4042","line":"        // 32 bit permute only"},
{"lineNum":" 4043","line":"        const int j0 = i0 >= 0 ? i0/2 : i1 >= 0 ? i1/2 : 0;"},
{"lineNum":" 4044","line":"        const int j1 = i2 >= 0 ? i2/2 : i3 >= 0 ? i3/2 : 0;"},
{"lineNum":" 4045","line":"        const int j2 = i4 >= 0 ? i4/2 : i5 >= 0 ? i5/2 : 0;"},
{"lineNum":" 4046","line":"        const int j3 = i6 >= 0 ? i6/2 : i7 >= 0 ? i7/2 : 0;"},
{"lineNum":" 4047","line":"        t7 = _mm_shuffle_epi32(a, (j0 & 3) | (j1 & 3) << 2 | (j2 & 3) << 4 | (j3 & 3) << 6);"},
{"lineNum":" 4048","line":"    }"},
{"lineNum":" 4049","line":"    else if (case2) {"},
{"lineNum":" 4050","line":"        // 16 bit permute"},
{"lineNum":" 4051","line":"        const int j0 = i0 >= 0 ? i0&3 : 0;"},
{"lineNum":" 4052","line":"        const int j1 = i1 >= 0 ? i1&3 : 1;"},
{"lineNum":" 4053","line":"        const int j2 = i2 >= 0 ? i2&3 : 2;"},
{"lineNum":" 4054","line":"        const int j3 = i3 >= 0 ? i3&3 : 3;"},
{"lineNum":" 4055","line":"        const int j4 = i4 >= 0 ? i4&3 : 0;"},
{"lineNum":" 4056","line":"        const int j5 = i5 >= 0 ? i5&3 : 1;"},
{"lineNum":" 4057","line":"        const int j6 = i6 >= 0 ? i6&3 : 2;"},
{"lineNum":" 4058","line":"        const int j7 = i7 >= 0 ? i7&3 : 3;"},
{"lineNum":" 4059","line":"        if (j0!=0 || j1!=1 || j2!=2 || j3!=3) {"},
{"lineNum":" 4060","line":"            t1 = _mm_shufflelo_epi16(a, j0 | j1 << 2 | j2 << 4 | j3 << 6);"},
{"lineNum":" 4061","line":"        }"},
{"lineNum":" 4062","line":"        else t1 = a;"},
{"lineNum":" 4063","line":"        if (j4!=0 || j5!=1 || j6!=2 || j7!=3) {"},
{"lineNum":" 4064","line":"            t7 = _mm_shufflehi_epi16(t1, j4 | j5 << 2 | j6 << 4 | j7 << 6);"},
{"lineNum":" 4065","line":"        }"},
{"lineNum":" 4066","line":"        else t7 = t1;"},
{"lineNum":" 4067","line":"    }"},
{"lineNum":" 4068","line":"    else {"},
{"lineNum":" 4069","line":"        // Need at least two permute steps"},
{"lineNum":" 4070","line":""},
{"lineNum":" 4071","line":"        // Index to where each dword of a is needed"},
{"lineNum":" 4072","line":"        const int nn = (m1 & 0x66666666) | 0x88888888; // indicate which dwords are needed"},
{"lineNum":" 4073","line":"        const int n0 = ((((uint32_t)(nn ^ 0x00000000) - 0x22222222) & 0x88888888) ^ 0x88888888) & m2;"},
{"lineNum":" 4074","line":"        const int n1 = ((((uint32_t)(nn ^ 0x22222222) - 0x22222222) & 0x88888888) ^ 0x88888888) & m2;"},
{"lineNum":" 4075","line":"        const int n2 = ((((uint32_t)(nn ^ 0x44444444) - 0x22222222) & 0x88888888) ^ 0x88888888) & m2;"},
{"lineNum":" 4076","line":"        const int n3 = ((((uint32_t)(nn ^ 0x66666666) - 0x22222222) & 0x88888888) ^ 0x88888888) & m2;"},
{"lineNum":" 4077","line":"        // indicate which dwords are needed in low half"},
{"lineNum":" 4078","line":"        const int l0 = (n0 & 0xFFFF) != 0;"},
{"lineNum":" 4079","line":"        const int l1 = (n1 & 0xFFFF) != 0;"},
{"lineNum":" 4080","line":"        const int l2 = (n2 & 0xFFFF) != 0;"},
{"lineNum":" 4081","line":"        const int l3 = (n3 & 0xFFFF) != 0;"},
{"lineNum":" 4082","line":"        // indicate which dwords are needed in high half"},
{"lineNum":" 4083","line":"        const int h0 = (n0 & 0xFFFF0000) != 0;"},
{"lineNum":" 4084","line":"        const int h1 = (n1 & 0xFFFF0000) != 0;"},
{"lineNum":" 4085","line":"        const int h2 = (n2 & 0xFFFF0000) != 0;"},
{"lineNum":" 4086","line":"        const int h3 = (n3 & 0xFFFF0000) != 0;"},
{"lineNum":" 4087","line":""},
{"lineNum":" 4088","line":"        // Test if we can do with two permute steps"},
{"lineNum":" 4089","line":"        const bool case3 = l0 + l1 + l2 + l3 <= 2  &&  h0 + h1 + h2 + h3 <= 2;"},
{"lineNum":" 4090","line":""},
{"lineNum":" 4091","line":"        if (case3) {"},
{"lineNum":" 4092","line":"            // one 32-bit permute followed by one 16-bit permute in each half."},
{"lineNum":" 4093","line":"            // Find permute indices for 32-bit permute"},
{"lineNum":" 4094","line":"            const int j0 = l0 ? 0 : l1 ? 1 : l2 ? 2 : 3;"},
{"lineNum":" 4095","line":"            const int j1 = l3 ? 3 : l2 ? 2 : l1 ? 1 : 0;"},
{"lineNum":" 4096","line":"            const int j2 = h0 ? 0 : h1 ? 1 : h2 ? 2 : 3;"},
{"lineNum":" 4097","line":"            const int j3 = h3 ? 3 : h2 ? 2 : h1 ? 1 : 0;"},
{"lineNum":" 4098","line":""},
{"lineNum":" 4099","line":"            // Find permute indices for low 16-bit permute"},
{"lineNum":" 4100","line":"            const int r0 = i0 < 0 ? 0 : (i0>>1 == j0 ? 0 : 2) + (i0 & 1);"},
{"lineNum":" 4101","line":"            const int r1 = i1 < 0 ? 1 : (i1>>1 == j0 ? 0 : 2) + (i1 & 1);"},
{"lineNum":" 4102","line":"            const int r2 = i2 < 0 ? 2 : (i2>>1 == j1 ? 2 : 0) + (i2 & 1);"},
{"lineNum":" 4103","line":"            const int r3 = i3 < 0 ? 3 : (i3>>1 == j1 ? 2 : 0) + (i3 & 1);"},
{"lineNum":" 4104","line":""},
{"lineNum":" 4105","line":"            // Find permute indices for high 16-bit permute"},
{"lineNum":" 4106","line":"            const int s0 = i4 < 0 ? 0 : (i4>>1 == j2 ? 0 : 2) + (i4 & 1);"},
{"lineNum":" 4107","line":"            const int s1 = i5 < 0 ? 1 : (i5>>1 == j2 ? 0 : 2) + (i5 & 1);"},
{"lineNum":" 4108","line":"            const int s2 = i6 < 0 ? 2 : (i6>>1 == j3 ? 2 : 0) + (i6 & 1);"},
{"lineNum":" 4109","line":"            const int s3 = i7 < 0 ? 3 : (i7>>1 == j3 ? 2 : 0) + (i7 & 1);"},
{"lineNum":" 4110","line":""},
{"lineNum":" 4111","line":"            // 32-bit permute + two 16-bit permutes"},
{"lineNum":" 4112","line":"            t1 = _mm_shuffle_epi32 (a, j0 | j1<<2 | j2<<4 | j3<<6);"},
{"lineNum":" 4113","line":""},
{"lineNum":" 4114","line":"            if (r0!=0 || r1!=1 || r2!=2 || r3!=3) {  // 16 bit permute of low  half"},
{"lineNum":" 4115","line":"                t2 = _mm_shufflelo_epi16(t1, r0 | r1<<2 | r2<<4 | r3<<6);"},
{"lineNum":" 4116","line":"            }"},
{"lineNum":" 4117","line":"            else t2 = t1;"},
{"lineNum":" 4118","line":"            if (s0!=0 || s1!=1 || s2!=2 || s3!=3) {  // 16 bit permute of high half"},
{"lineNum":" 4119","line":"                t7 = _mm_shufflehi_epi16(t2, s0 | s1<<2 | s2<<4 | s3<<6);"},
{"lineNum":" 4120","line":"            }"},
{"lineNum":" 4121","line":"            else t7 = t2;"},
{"lineNum":" 4122","line":"        }"},
{"lineNum":" 4123","line":"        else {"},
{"lineNum":" 4124","line":"            // Worst case. We need two sets of 16-bit permutes"},
{"lineNum":" 4125","line":"            t1 = _mm_shuffle_epi32(a, 0x4E);  // swap low and high 64-bits"},
{"lineNum":" 4126","line":""},
{"lineNum":" 4127","line":"            // Find permute indices for low 16-bit permute from swapped t1"},
{"lineNum":" 4128","line":"            const int r0 = i0 < 4 ? 0 : i0 & 3;"},
{"lineNum":" 4129","line":"            const int r1 = i1 < 4 ? 1 : i1 & 3;"},
{"lineNum":" 4130","line":"            const int r2 = i2 < 4 ? 2 : i2 & 3;"},
{"lineNum":" 4131","line":"            const int r3 = i3 < 4 ? 3 : i3 & 3;"},
{"lineNum":" 4132","line":"            // Find permute indices for high 16-bit permute from swapped t1"},
{"lineNum":" 4133","line":"            const int s0 = i4 < 0 || i4 >= 4 ? 0 : i4 & 3;"},
{"lineNum":" 4134","line":"            const int s1 = i5 < 0 || i5 >= 4 ? 1 : i5 & 3;"},
{"lineNum":" 4135","line":"            const int s2 = i6 < 0 || i6 >= 4 ? 2 : i6 & 3;"},
{"lineNum":" 4136","line":"            const int s3 = i7 < 0 || i7 >= 4 ? 3 : i7 & 3;"},
{"lineNum":" 4137","line":"            // Find permute indices for low 16-bit permute from direct a"},
{"lineNum":" 4138","line":"            const int u0 = i0 < 0 || i0 >= 4 ? 0 : i0 & 3;"},
{"lineNum":" 4139","line":"            const int u1 = i1 < 0 || i1 >= 4 ? 1 : i1 & 3;"},
{"lineNum":" 4140","line":"            const int u2 = i2 < 0 || i2 >= 4 ? 2 : i2 & 3;"},
{"lineNum":" 4141","line":"            const int u3 = i3 < 0 || i3 >= 4 ? 3 : i3 & 3;"},
{"lineNum":" 4142","line":"            // Find permute indices for high 16-bit permute from direct a"},
{"lineNum":" 4143","line":"            const int v0 = i4 < 4 ? 0 : i4 & 3;"},
{"lineNum":" 4144","line":"            const int v1 = i5 < 4 ? 1 : i5 & 3;"},
{"lineNum":" 4145","line":"            const int v2 = i6 < 4 ? 2 : i6 & 3;"},
{"lineNum":" 4146","line":"            const int v3 = i7 < 4 ? 3 : i7 & 3;"},
{"lineNum":" 4147","line":""},
{"lineNum":" 4148","line":"            // 16-bit permutes"},
{"lineNum":" 4149","line":"            if (r0!=0 || r1!=1 || r2!=2 || r3!=3) {  // 16 bit permute of low  half"},
{"lineNum":" 4150","line":"                t2 = _mm_shufflelo_epi16(t1, r0 | r1<<2 | r2<<4 | r3<<6);"},
{"lineNum":" 4151","line":"            }"},
{"lineNum":" 4152","line":"            else t2 = t1;"},
{"lineNum":" 4153","line":"            if (u0!=0 || u1!=1 || u2!=2 || u3!=3) {  // 16 bit permute of low  half"},
{"lineNum":" 4154","line":"                t3 = _mm_shufflelo_epi16(a, u0 | u1<<2 | u2<<4 | u3<<6);"},
{"lineNum":" 4155","line":"            }"},
{"lineNum":" 4156","line":"            else t3 = a;"},
{"lineNum":" 4157","line":"            if (s0!=0 || s1!=1 || s2!=2 || s3!=3) {  // 16 bit permute of low  half"},
{"lineNum":" 4158","line":"                t4 = _mm_shufflehi_epi16(t2, s0 | s1<<2 | s2<<4 | s3<<6);"},
{"lineNum":" 4159","line":"            }"},
{"lineNum":" 4160","line":"            else t4 = t2;"},
{"lineNum":" 4161","line":"            if (v0!=0 || v1!=1 || v2!=2 || v3!=3) {  // 16 bit permute of low  half"},
{"lineNum":" 4162","line":"                t5 = _mm_shufflehi_epi16(t3, v0 | v1<<2 | v2<<4 | v3<<6);"},
{"lineNum":" 4163","line":"            }"},
{"lineNum":" 4164","line":"            else t5 = t3;"},
{"lineNum":" 4165","line":"            // merge data from t4 and t5"},
{"lineNum":" 4166","line":"            t6  = constant4i <"},
{"lineNum":" 4167","line":"                ((i0 & 4) ? 0xFFFF : 0) | ((i1 & 4) ? (int)0xFFFF0000 : 0),"},
{"lineNum":" 4168","line":"                ((i2 & 4) ? 0xFFFF : 0) | ((i3 & 4) ? (int)0xFFFF0000 : 0),"},
{"lineNum":" 4169","line":"                ((i4 & 4) ? 0 : 0xFFFF) | ((i5 & 4) ? 0 : (int)0xFFFF0000),"},
{"lineNum":" 4170","line":"                ((i6 & 4) ? 0 : 0xFFFF) | ((i7 & 4) ? 0 : (int)0xFFFF0000) > ();"},
{"lineNum":" 4171","line":"            t7 = selectb(t6,t4,t5);  // select between permuted data t4 and t5"},
{"lineNum":" 4172","line":"        }"},
{"lineNum":" 4173","line":"    }"},
{"lineNum":" 4174","line":"    // Set any elements to zero if required"},
{"lineNum":" 4175","line":"    if (m2 != -1 && ((i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7) & 0x80)) {"},
{"lineNum":" 4176","line":"        // some elements need to be set to 0"},
{"lineNum":" 4177","line":"        __m128i mask = constant4i <"},
{"lineNum":" 4178","line":"            (i0 < 0 ? (int)0xFFFF0000 : -1) & (i1 < 0 ? 0x0000FFFF : -1),"},
{"lineNum":" 4179","line":"            (i2 < 0 ? (int)0xFFFF0000 : -1) & (i3 < 0 ? 0x0000FFFF : -1),"},
{"lineNum":" 4180","line":"            (i4 < 0 ? (int)0xFFFF0000 : -1) & (i5 < 0 ? 0x0000FFFF : -1),"},
{"lineNum":" 4181","line":"            (i6 < 0 ? (int)0xFFFF0000 : -1) & (i7 < 0 ? 0x0000FFFF : -1) > ();"},
{"lineNum":" 4182","line":"        return _mm_and_si128(t7, mask);"},
{"lineNum":" 4183","line":"    }"},
{"lineNum":" 4184","line":"    else {"},
{"lineNum":" 4185","line":"        return  t7;"},
{"lineNum":" 4186","line":"    }"},
{"lineNum":" 4187","line":"#endif"},
{"lineNum":" 4188","line":"}"},
{"lineNum":" 4189","line":""},
{"lineNum":" 4190","line":"template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>"},
{"lineNum":" 4191","line":"static inline Vec8us permute8(Vec8us const & a) {"},
{"lineNum":" 4192","line":"    return Vec8us (permute8 <i0,i1,i2,i3,i4,i5,i6,i7> (Vec8s(a)));"},
{"lineNum":" 4193","line":"}"},
{"lineNum":" 4194","line":""},
{"lineNum":" 4195","line":""},
{"lineNum":" 4196","line":"template <int i0, int i1, int i2,  int i3,  int i4,  int i5,  int i6,  int i7,"},
{"lineNum":" 4197","line":"          int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15 >"},
{"lineNum":" 4198","line":"static inline Vec16c permute16(Vec16c const & a) {"},
{"lineNum":" 4199","line":""},
{"lineNum":" 4200","line":"    __m128i temp;"},
{"lineNum":" 4201","line":""},
{"lineNum":" 4202","line":"    // Combine all even indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 4203","line":"    const uint32_t me = (i0&15) | (i2&15)<<4 | (i4&15)<<8 | (i6&15)<<12"},
{"lineNum":" 4204","line":"        | (i8&15)<<16 | (i10&15)<<20 | (i12&15)<<24 | (i14&15)<<28;"},
{"lineNum":" 4205","line":""},
{"lineNum":" 4206","line":"    // Combine all odd indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 4207","line":"    const uint32_t mo = (i1&15) | (i3&15)<<4 | (i5&15)<<8 | (i7&15)<<12"},
{"lineNum":" 4208","line":"        | (i9&15)<<16 | (i11&15)<<20 | (i13&15)<<24 | (i15&15)<<28;"},
{"lineNum":" 4209","line":""},
{"lineNum":" 4210","line":"    // Mask indicating sign of all even indexes, with 4 bits for each, 0 for negative, 0xF for non-negative"},
{"lineNum":" 4211","line":"    const uint32_t se = (i0<0?0:0xF) | (i2<0?0:0xF)<<4 | (i4<0?0:0xF)<<8 | (i6<0?0:0xF)<<12"},
{"lineNum":" 4212","line":"        | (i8<0?0:0xF)<<16 | (i10<0?0:0xF)<<20 | (i12<0?0:0xF)<<24 | (i14<0?0:0xF)<<28;"},
{"lineNum":" 4213","line":""},
{"lineNum":" 4214","line":"    // Mask indicating sign of all odd indexes, with 4 bits for each, 0 for negative, 0xF for non-negative"},
{"lineNum":" 4215","line":"    const uint32_t so = (i1<0?0:0xF) | (i3<0?0:0xF)<<4 | (i5<0?0:0xF)<<8 | (i7<0?0:0xF)<<12"},
{"lineNum":" 4216","line":"        | (i9<0?0:0xF)<<16 | (i11<0?0:0xF)<<20 | (i13<0?0:0xF)<<24 | (i15<0?0:0xF)<<28;"},
{"lineNum":" 4217","line":""},
{"lineNum":" 4218","line":"    // Mask indicating sign of all indexes, with 2 bits for each, 0 for negative (means set to zero or don\'t care), 0x3 for non-negative"},
{"lineNum":" 4219","line":"    const uint32_t ss = (se & 0x33333333) | (so & 0xCCCCCCCC);"},
{"lineNum":" 4220","line":""},
{"lineNum":" 4221","line":"    // Mask indicating required zeroing of all indexes, with 2 bits for each, 0 for index = -1, 3 for index >= 0 or -256"},
{"lineNum":" 4222","line":"    const uint32_t ssz = ((i0&0x80)?0:3) | ((i1 &0x80)?0:3)<< 2 | ((i2 &0x80)?0:3)<< 4 | ((i3 &0x80)?0:3)<< 6 |"},
{"lineNum":" 4223","line":"                    ((i4 &0x80)?0:3)<< 8 | ((i5 &0x80)?0:3)<<10 | ((i6 &0x80)?0:3)<<12 | ((i7 &0x80)?0:3)<<14 |"},
{"lineNum":" 4224","line":"                    ((i8 &0x80)?0:3)<<16 | ((i9 &0x80)?0:3)<<18 | ((i10&0x80)?0:3)<<20 | ((i11&0x80)?0:3)<<22 |"},
{"lineNum":" 4225","line":"                    ((i12&0x80)?0:3)<<24 | ((i13&0x80)?0:3)<<26 | ((i14&0x80)?0:3)<<28 | ((i15&0x80)?0:3)<<30 ;"},
{"lineNum":" 4226","line":""},
{"lineNum":" 4227","line":"    // These indexes are used only to avoid bogus compiler warnings in false branches"},
{"lineNum":" 4228","line":"    const int I0  = i0  > 0 ? (i0  & 0xF) : 0;"},
{"lineNum":" 4229","line":"    const int I15 = i15 > 0 ? (i15 & 0xF) : 0;"},
{"lineNum":" 4230","line":""},
{"lineNum":" 4231","line":"    // special case: all zero"},
{"lineNum":" 4232","line":"    if (ss == 0) {"},
{"lineNum":" 4233","line":"        return _mm_setzero_si128();"},
{"lineNum":" 4234","line":"    }"},
{"lineNum":" 4235","line":""},
{"lineNum":" 4236","line":"    // remember if extra zeroing is needed"},
{"lineNum":" 4237","line":"    bool do_and_zero = (ssz != 0xFFFFFFFFu);"},
{"lineNum":" 4238","line":""},
{"lineNum":" 4239","line":"    // check for special shortcut cases"},
{"lineNum":" 4240","line":"    int shortcut = 0;"},
{"lineNum":" 4241","line":""},
{"lineNum":" 4242","line":"    // check if any permutation"},
{"lineNum":" 4243","line":"    if (((me ^ 0xECA86420) & se) == 0 && ((mo ^ 0xFDB97531) & so) == 0) {"},
{"lineNum":" 4244","line":"        shortcut = 1;"},
{"lineNum":" 4245","line":"    }"},
{"lineNum":" 4246","line":"    // check if we can use punpcklbw"},
{"lineNum":" 4247","line":"    else if (((me ^ 0x76543210) & se) == 0 && ((mo ^ 0x76543210) & so) == 0) {"},
{"lineNum":" 4248","line":"        shortcut = 2;"},
{"lineNum":" 4249","line":"    }"},
{"lineNum":" 4250","line":"    // check if we can use punpckhbw"},
{"lineNum":" 4251","line":"    else if (((me ^ 0xFEDCBA98) & se) == 0 && ((mo ^ 0xFEDCBA98) & so) == 0) {"},
{"lineNum":" 4252","line":"        shortcut = 3;"},
{"lineNum":" 4253","line":"    }"},
{"lineNum":" 4254","line":""},
{"lineNum":" 4255","line":"    #if defined (_MSC_VER) && ! defined(__INTEL_COMPILER)"},
{"lineNum":" 4256","line":"    #pragma warning(disable: 4307)  // disable MS warning C4307: \'+\' : integral constant overflow"},
{"lineNum":" 4257","line":"    #endif"},
{"lineNum":" 4258","line":""},
{"lineNum":" 4259","line":"    // check if we can use byte shift right"},
{"lineNum":" 4260","line":"    else if (i0 > 0 && ((me ^ (uint32_t(I0)*0x11111111u + 0xECA86420u)) & se) == 0 &&"},
{"lineNum":" 4261","line":"    ((mo ^ (uint32_t(I0)*0x11111111u + 0xFDB97531u)) & so) == 0) {"},
{"lineNum":" 4262","line":"        shortcut = 4;"},
{"lineNum":" 4263","line":"        do_and_zero = ((0xFFFFFFFFu >> 2*I0) & ~ ssz) != 0;"},
{"lineNum":" 4264","line":"    }"},
{"lineNum":" 4265","line":"    // check if we can use byte shift left"},
{"lineNum":" 4266","line":"    else if (i15 >= 0 && i15 < 15 &&"},
{"lineNum":" 4267","line":"    ((mo ^ (uint32_t(I15*0x11111111u) - (0x02468ACEu & so))) & so) == 0 &&"},
{"lineNum":" 4268","line":"    ((me ^ (uint32_t(I15*0x11111111u) - (0x13579BDFu & se))) & se) == 0) {"},
{"lineNum":" 4269","line":"        shortcut = 5;"},
{"lineNum":" 4270","line":"        do_and_zero = ((0xFFFFFFFFu << 2*(15-I15)) & ~ ssz) != 0;"},
{"lineNum":" 4271","line":"    }"},
{"lineNum":" 4272","line":""},
{"lineNum":" 4273","line":"#if  INSTRSET >= 4  // SSSE3 (PSHUFB available only under SSSE3)"},
{"lineNum":" 4274","line":""},
{"lineNum":" 4275","line":"    // special case: rotate"},
{"lineNum":" 4276","line":"    if (i0>0 && i0 < 16    && i1==((i0+1)&15) && i2 ==((i0+2 )&15) && i3 ==((i0+3 )&15) && i4 ==((i0+4 )&15) && i5 ==((i0+5 )&15) && i6 ==((i0+6 )&15) && i7 ==((i0+7 )&15)"},
{"lineNum":" 4277","line":"    && i8==((i0+8)&15) && i9==((i0+9)&15) && i10==((i0+10)&15) && i11==((i0+11)&15) && i12==((i0+12)&15) && i13==((i0+13)&15) && i14==((i0+14)&15) && i15==((i0+15)&15)) {"},
{"lineNum":" 4278","line":"        temp = _mm_alignr_epi8(a, a, i0 & 15);"},
{"lineNum":" 4279","line":"        shortcut = -1;"},
{"lineNum":" 4280","line":"    }"},
{"lineNum":" 4281","line":"    if (shortcut == 0 || do_and_zero) {"},
{"lineNum":" 4282","line":"        // general case: use PSHUFB"},
{"lineNum":" 4283","line":"        __m128i mask = constant4i<"},
{"lineNum":" 4284","line":"            (i0  & 0xFF) | (i1  & 0xFF) << 8 | (i2  & 0xFF) << 16 | (i3  & 0xFF) << 24 ,"},
{"lineNum":" 4285","line":"            (i4  & 0xFF) | (i5  & 0xFF) << 8 | (i6  & 0xFF) << 16 | (i7  & 0xFF) << 24 ,"},
{"lineNum":" 4286","line":"            (i8  & 0xFF) | (i9  & 0xFF) << 8 | (i10 & 0xFF) << 16 | (i11 & 0xFF) << 24 ,"},
{"lineNum":" 4287","line":"            (i12 & 0xFF) | (i13 & 0xFF) << 8 | (i14 & 0xFF) << 16 | (i15 & 0xFF) << 24 > ();"},
{"lineNum":" 4288","line":"        temp = _mm_shuffle_epi8(a,mask);"},
{"lineNum":" 4289","line":"        shortcut = -1;"},
{"lineNum":" 4290","line":"        do_and_zero = false;"},
{"lineNum":" 4291","line":"    }"},
{"lineNum":" 4292","line":""},
{"lineNum":" 4293","line":"#endif"},
{"lineNum":" 4294","line":""},
{"lineNum":" 4295","line":"    // Check if we can use 16-bit permute. Even numbered indexes must be even and odd numbered"},
{"lineNum":" 4296","line":"    // indexes must be equal to the preceding index + 1, except for negative indexes."},
{"lineNum":" 4297","line":"    if (shortcut == 0 && (me & 0x11111111 & se) == 0 && ((mo ^ 0x11111111) & 0x11111111 & so) == 0 && ((me ^ mo) & 0xEEEEEEEE & se & so) == 0) {"},
{"lineNum":" 4298","line":"        temp = permute8 <"},
{"lineNum":" 4299","line":"            i0  >= 0 ? i0 /2 : i1  >= 0 ? i1 /2 : (i0  | i1 ),"},
{"lineNum":" 4300","line":"            i2  >= 0 ? i2 /2 : i3  >= 0 ? i3 /2 : (i2  | i3 ),"},
{"lineNum":" 4301","line":"            i4  >= 0 ? i4 /2 : i5  >= 0 ? i5 /2 : (i4  | i5 ),"},
{"lineNum":" 4302","line":"            i6  >= 0 ? i6 /2 : i7  >= 0 ? i7 /2 : (i6  | i7 ),"},
{"lineNum":" 4303","line":"            i8  >= 0 ? i8 /2 : i9  >= 0 ? i9 /2 : (i8  | i9 ),"},
{"lineNum":" 4304","line":"            i10 >= 0 ? i10/2 : i11 >= 0 ? i11/2 : (i10 | i11),"},
{"lineNum":" 4305","line":"            i12 >= 0 ? i12/2 : i13 >= 0 ? i13/2 : (i12 | i13),"},
{"lineNum":" 4306","line":"            i14 >= 0 ? i14/2 : i15 >= 0 ? i15/2 : (i14 | i15) > (Vec8s(a));"},
{"lineNum":" 4307","line":"        shortcut = 100;"},
{"lineNum":" 4308","line":"        do_and_zero = (se != so && ssz != 0xFFFFFFFFu);"},
{"lineNum":" 4309","line":"    }"},
{"lineNum":" 4310","line":""},
{"lineNum":" 4311","line":"    // Check if we can use 16-bit permute with bytes swapped. Even numbered indexes must be odd and odd"},
{"lineNum":" 4312","line":"    // numbered indexes must be equal to the preceding index - 1, except for negative indexes."},
{"lineNum":" 4313","line":"    // (this case occurs when reversing byte order)"},
{"lineNum":" 4314","line":"    if (shortcut == 0 && ((me ^ 0x11111111) & 0x11111111 & se) == 0 && (mo & 0x11111111 & so) == 0 && ((me ^ mo) & 0xEEEEEEEE & se & so) == 0) {"},
{"lineNum":" 4315","line":"        Vec16c swapped = Vec16c(rotate_left(Vec8s(a), 8)); // swap odd and even bytes"},
{"lineNum":" 4316","line":"        temp = permute8 <"},
{"lineNum":" 4317","line":"            i0  >= 0 ? i0 /2 : i1  >= 0 ? i1 /2 : (i0  | i1 ),"},
{"lineNum":" 4318","line":"            i2  >= 0 ? i2 /2 : i3  >= 0 ? i3 /2 : (i2  | i3 ),"},
{"lineNum":" 4319","line":"            i4  >= 0 ? i4 /2 : i5  >= 0 ? i5 /2 : (i4  | i5 ),"},
{"lineNum":" 4320","line":"            i6  >= 0 ? i6 /2 : i7  >= 0 ? i7 /2 : (i6  | i7 ),"},
{"lineNum":" 4321","line":"            i8  >= 0 ? i8 /2 : i9  >= 0 ? i9 /2 : (i8  | i9 ),"},
{"lineNum":" 4322","line":"            i10 >= 0 ? i10/2 : i11 >= 0 ? i11/2 : (i10 | i11),"},
{"lineNum":" 4323","line":"            i12 >= 0 ? i12/2 : i13 >= 0 ? i13/2 : (i12 | i13),"},
{"lineNum":" 4324","line":"            i14 >= 0 ? i14/2 : i15 >= 0 ? i15/2 : (i14 | i15) > (Vec8s(swapped));"},
{"lineNum":" 4325","line":"        shortcut = 101;"},
{"lineNum":" 4326","line":"        do_and_zero = (se != so && ssz != 0xFFFFFFFFu);"},
{"lineNum":" 4327","line":"    }"},
{"lineNum":" 4328","line":""},
{"lineNum":" 4329","line":"    // all shortcuts end here"},
{"lineNum":" 4330","line":"    if (shortcut) {"},
{"lineNum":" 4331","line":"        switch (shortcut) {"},
{"lineNum":" 4332","line":"        case 1:"},
{"lineNum":" 4333","line":"            temp = a;  break;"},
{"lineNum":" 4334","line":"        case 2:"},
{"lineNum":" 4335","line":"            temp = _mm_unpacklo_epi8(a,a);  break;"},
{"lineNum":" 4336","line":"        case 3:"},
{"lineNum":" 4337","line":"            temp = _mm_unpackhi_epi8(a,a);  break;"},
{"lineNum":" 4338","line":"        case 4:"},
{"lineNum":" 4339","line":"            temp = _mm_srli_si128(a, I0);  break;"},
{"lineNum":" 4340","line":"        case 5:"},
{"lineNum":" 4341","line":"            temp = _mm_slli_si128(a, 15-I15);  break;"},
{"lineNum":" 4342","line":"        default:"},
{"lineNum":" 4343","line":"            break;  // result is already in temp"},
{"lineNum":" 4344","line":"        }"},
{"lineNum":" 4345","line":"        if (do_and_zero) {"},
{"lineNum":" 4346","line":"            // additional zeroing needed"},
{"lineNum":" 4347","line":"            __m128i maskz = constant4i <"},
{"lineNum":" 4348","line":"                (i0  < 0 ? 0 : 0xFF) | (i1  < 0 ? 0 : 0xFF00) | (i2  < 0 ? 0 : 0xFF0000) | (i3  < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4349","line":"                (i4  < 0 ? 0 : 0xFF) | (i5  < 0 ? 0 : 0xFF00) | (i6  < 0 ? 0 : 0xFF0000) | (i7  < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4350","line":"                (i8  < 0 ? 0 : 0xFF) | (i9  < 0 ? 0 : 0xFF00) | (i10 < 0 ? 0 : 0xFF0000) | (i11 < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4351","line":"                (i12 < 0 ? 0 : 0xFF) | (i13 < 0 ? 0 : 0xFF00) | (i14 < 0 ? 0 : 0xFF0000) | (i15 < 0 ? 0 : (int)0xFF000000) > ();"},
{"lineNum":" 4352","line":"            temp = _mm_and_si128(temp, maskz);"},
{"lineNum":" 4353","line":"        }"},
{"lineNum":" 4354","line":"        return temp;"},
{"lineNum":" 4355","line":"    }"},
{"lineNum":" 4356","line":""},
{"lineNum":" 4357","line":"    // complicated cases: use 16-bit permute up to four times"},
{"lineNum":" 4358","line":"    const bool e2e = (~me & 0x11111111 & se) != 0;  // even bytes of source to even bytes of destination"},
{"lineNum":" 4359","line":"    const bool e2o = (~mo & 0x11111111 & so) != 0;  // even bytes of source to odd  bytes of destination"},
{"lineNum":" 4360","line":"    const bool o2e = (me  & 0x11111111 & se) != 0;  // odd  bytes of source to even bytes of destination"},
{"lineNum":" 4361","line":"    const bool o2o = (mo  & 0x11111111 & so) != 0;  // odd  bytes of source to odd  bytes of destination"},
{"lineNum":" 4362","line":""},
{"lineNum":" 4363","line":"    Vec16c swapped, te2e, te2o, to2e, to2o, combeven, combodd;"},
{"lineNum":" 4364","line":""},
{"lineNum":" 4365","line":"    if (e2o || o2e) swapped = rotate_left(Vec8s(a), 8); // swap odd and even bytes"},
{"lineNum":" 4366","line":""},
{"lineNum":" 4367","line":"    // even-to-even bytes"},
{"lineNum":" 4368","line":"    if (e2e) te2e = permute8 <(i0&1)?-1:i0/2, (i2&1)?-1:i2/2, (i4&1)?-1:i4/2, (i6&1)?-1:i6/2,"},
{"lineNum":" 4369","line":"        (i8&1)?-1:i8/2, (i10&1)?-1:i10/2, (i12&1)?-1:i12/2, (i14&1)?-1:i14/2> (Vec8s(a));"},
{"lineNum":" 4370","line":"    // odd-to-even bytes"},
{"lineNum":" 4371","line":"    if (o2e) to2e = permute8 <(i0&1)?i0/2:-1, (i2&1)?i2/2:-1, (i4&1)?i4/2:-1, (i6&1)?i6/2:-1,"},
{"lineNum":" 4372","line":"        (i8&1)?i8/2:-1, (i10&1)?i10/2:-1, (i12&1)?i12/2:-1, (i14&1)?i14/2:-1> (Vec8s(swapped));"},
{"lineNum":" 4373","line":"    // even-to-odd bytes"},
{"lineNum":" 4374","line":"    if (e2o) te2o = permute8 <(i1&1)?-1:i1/2, (i3&1)?-1:i3/2, (i5&1)?-1:i5/2, (i7&1)?-1:i7/2,"},
{"lineNum":" 4375","line":"        (i9&1)?-1:i9/2, (i11&1)?-1:i11/2, (i13&1)?-1:i13/2, (i15&1)?-1:i15/2> (Vec8s(swapped));"},
{"lineNum":" 4376","line":"    // odd-to-odd bytes"},
{"lineNum":" 4377","line":"    if (o2o) to2o = permute8 <(i1&1)?i1/2:-1, (i3&1)?i3/2:-1, (i5&1)?i5/2:-1, (i7&1)?i7/2:-1,"},
{"lineNum":" 4378","line":"        (i9&1)?i9/2:-1, (i11&1)?i11/2:-1, (i13&1)?i13/2:-1, (i15&1)?i15/2:-1> (Vec8s(a));"},
{"lineNum":" 4379","line":""},
{"lineNum":" 4380","line":"    if (e2e && o2e) combeven = te2e | to2e;"},
{"lineNum":" 4381","line":"    else if (e2e)   combeven = te2e;"},
{"lineNum":" 4382","line":"    else if (o2e)   combeven = to2e;"},
{"lineNum":" 4383","line":"    else            combeven = _mm_setzero_si128();"},
{"lineNum":" 4384","line":""},
{"lineNum":" 4385","line":"    if (e2o && o2o) combodd  = te2o | to2o;"},
{"lineNum":" 4386","line":"    else if (e2o)   combodd  = te2o;"},
{"lineNum":" 4387","line":"    else if (o2o)   combodd  = to2o;"},
{"lineNum":" 4388","line":"    else            combodd  = _mm_setzero_si128();"},
{"lineNum":" 4389","line":""},
{"lineNum":" 4390","line":"    __m128i maske = constant4i <     // mask used even bytes"},
{"lineNum":" 4391","line":"        (i0  < 0 ? 0 : 0xFF) | (i2  < 0 ? 0 : 0xFF0000),"},
{"lineNum":" 4392","line":"        (i4  < 0 ? 0 : 0xFF) | (i6  < 0 ? 0 : 0xFF0000),"},
{"lineNum":" 4393","line":"        (i8  < 0 ? 0 : 0xFF) | (i10 < 0 ? 0 : 0xFF0000),"},
{"lineNum":" 4394","line":"        (i12 < 0 ? 0 : 0xFF) | (i14 < 0 ? 0 : 0xFF0000) > ();"},
{"lineNum":" 4395","line":"    __m128i masko = constant4i <     // mask used odd bytes"},
{"lineNum":" 4396","line":"        (i1  < 0 ? 0 : 0xFF00) | (i3  < 0 ? 0 : (int)0xFF000000),"},
{"lineNum":" 4397","line":"        (i5  < 0 ? 0 : 0xFF00) | (i7  < 0 ? 0 : (int)0xFF000000),"},
{"lineNum":" 4398","line":"        (i9  < 0 ? 0 : 0xFF00) | (i11 < 0 ? 0 : (int)0xFF000000),"},
{"lineNum":" 4399","line":"        (i13 < 0 ? 0 : 0xFF00) | (i15 < 0 ? 0 : (int)0xFF000000) > ();"},
{"lineNum":" 4400","line":""},
{"lineNum":" 4401","line":"    return  _mm_or_si128(            // combine even and odd bytes"},
{"lineNum":" 4402","line":"        _mm_and_si128(combeven, maske),"},
{"lineNum":" 4403","line":"        _mm_and_si128(combodd, masko));"},
{"lineNum":" 4404","line":"}"},
{"lineNum":" 4405","line":""},
{"lineNum":" 4406","line":"template <int i0, int i1, int i2,  int i3,  int i4,  int i5,  int i6,  int i7,"},
{"lineNum":" 4407","line":"          int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15 >"},
{"lineNum":" 4408","line":"static inline Vec16uc permute16(Vec16uc const & a) {"},
{"lineNum":" 4409","line":"    return Vec16uc (permute16 <i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15> (Vec16c(a)));"},
{"lineNum":" 4410","line":"}"},
{"lineNum":" 4411","line":""},
{"lineNum":" 4412","line":"// Support names prior to version 1.40 (now deprecated)"},
{"lineNum":" 4413","line":"#define permute2q   permute2"},
{"lineNum":" 4414","line":"#define permute2uq  permute2"},
{"lineNum":" 4415","line":"#define permute4i   permute4"},
{"lineNum":" 4416","line":"#define permute4ui  permute4"},
{"lineNum":" 4417","line":"#define permute8s   permute8"},
{"lineNum":" 4418","line":"#define permute8us  permute8"},
{"lineNum":" 4419","line":"#define permute16c  permute16"},
{"lineNum":" 4420","line":"#define permute16uc permute16"},
{"lineNum":" 4421","line":""},
{"lineNum":" 4422","line":""},
{"lineNum":" 4423","line":"/*****************************************************************************"},
{"lineNum":" 4424","line":"*"},
{"lineNum":" 4425","line":"*          Vector blend functions"},
{"lineNum":" 4426","line":"*"},
{"lineNum":" 4427","line":"******************************************************************************"},
{"lineNum":" 4428","line":"*"},
{"lineNum":" 4429","line":"* These blend functions can mix elements from two different vectors and"},
{"lineNum":" 4430","line":"* optionally set some elements to zero."},
{"lineNum":" 4431","line":"*"},
{"lineNum":" 4432","line":"* The indexes are inserted as template parameters in <>. These indexes must be"},
{"lineNum":" 4433","line":"* constants. Each template parameter is an index to the element you want to"},
{"lineNum":" 4434","line":"* select, where higher indexes indicate an element from the second source"},
{"lineNum":" 4435","line":"* vector. For example, if each vector has 4 elements, then indexes 0 - 3"},
{"lineNum":" 4436","line":"* will select an element from the first vector and indexes 4 - 7 will select"},
{"lineNum":" 4437","line":"* an element from the second vector. A negative index will generate zero."},
{"lineNum":" 4438","line":"*"},
{"lineNum":" 4439","line":"* The blend functions for vectors of 8-bit integers are inefficient if"},
{"lineNum":" 4440","line":"* the SSSE3 instruction set or later is not enabled."},
{"lineNum":" 4441","line":"*"},
{"lineNum":" 4442","line":"* Example:"},
{"lineNum":" 4443","line":"* Vec4i a(100,101,102,103);         // a is (100, 101, 102, 103)"},
{"lineNum":" 4444","line":"* Vec4i b(200,201,202,203);         // b is (200, 201, 202, 203)"},
{"lineNum":" 4445","line":"* Vec4i c;"},
{"lineNum":" 4446","line":"* c = blend4<1,4,-1,7> (a,b);      // c is (101, 200,   0, 203)"},
{"lineNum":" 4447","line":"*"},
{"lineNum":" 4448","line":"* A lot of the code here is metaprogramming aiming to find the instructions"},
{"lineNum":" 4449","line":"* that best fit the template parameters and instruction set. The metacode"},
{"lineNum":" 4450","line":"* will be reduced out to leave only a few vector instructions in release"},
{"lineNum":" 4451","line":"* mode with optimization on."},
{"lineNum":" 4452","line":"*****************************************************************************/"},
{"lineNum":" 4453","line":""},
{"lineNum":" 4454","line":"template <int i0, int i1, int i2,  int i3,  int i4,  int i5,  int i6,  int i7,"},
{"lineNum":" 4455","line":"          int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15 >"},
{"lineNum":" 4456","line":"static inline Vec16c blend16(Vec16c const & a, Vec16c const & b) {"},
{"lineNum":" 4457","line":""},
{"lineNum":" 4458","line":"    // Combine bit 0-3 of all even indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 4459","line":"    const int me = (i0&15) | (i2&15)<<4 | (i4&15)<<8 | (i6&15)<<12"},
{"lineNum":" 4460","line":"        | (i8&15)<<16 | (i10&15)<<20 | (i12&15)<<24 | (i14&15)<<28;"},
{"lineNum":" 4461","line":""},
{"lineNum":" 4462","line":"    // Combine bit 0-3 of all odd indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 4463","line":"    const int mo = (i1&15) | (i3&15)<<4 | (i5&15)<<8 | (i7&15)<<12"},
{"lineNum":" 4464","line":"        | (i9&15)<<16 | (i11&15)<<20 | (i13&15)<<24 | (i15&15)<<28;"},
{"lineNum":" 4465","line":""},
{"lineNum":" 4466","line":"    // Mask indicating sign of all even indexes, with 4 bits for each, 0 for negative, 0xF for non-negative"},
{"lineNum":" 4467","line":"    const int se = (i0<0?0:0xF) | (i2<0?0:0xF)<<4 | (i4<0?0:0xF)<<8 | (i6<0?0:0xF)<<12"},
{"lineNum":" 4468","line":"        | (i8<0?0:0xF)<<16 | (i10<0?0:0xF)<<20 | (i12<0?0:0xF)<<24 | (i14<0?0:0xF)<<28;"},
{"lineNum":" 4469","line":""},
{"lineNum":" 4470","line":"    // Mask indicating sign of all odd indexes, with 4 bits for each, 0 for negative, 0xF for non-negative"},
{"lineNum":" 4471","line":"    const int so = (i1<0?0:0xF) | (i3<0?0:0xF)<<4 | (i5<0?0:0xF)<<8 | (i7<0?0:0xF)<<12"},
{"lineNum":" 4472","line":"        | (i9<0?0:0xF)<<16 | (i11<0?0:0xF)<<20 | (i13<0?0:0xF)<<24 | (i15<0?0:0xF)<<28;"},
{"lineNum":" 4473","line":""},
{"lineNum":" 4474","line":"    // Combine bit 4 of all even indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 4475","line":"    const int ne = (i0&16)>>4 | (i2&16) | (i4&16)<<4 | (i6&16)<<8"},
{"lineNum":" 4476","line":"        | (i8&16)<<12 | (i10&16)<<16 | (i12&16)<<20 | (i14&16)<<24;"},
{"lineNum":" 4477","line":""},
{"lineNum":" 4478","line":"    // Combine bit 4 of all odd indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 4479","line":"    const int no = (i1&16)>>4 | (i3&16) | (i5&16)<<4 | (i7&16)<<8"},
{"lineNum":" 4480","line":"        | (i9&16)<<12 | (i11&16)<<16 | (i13&16)<<20 | (i15&16)<<24;"},
{"lineNum":" 4481","line":""},
{"lineNum":" 4482","line":"    // Check if zeroing needed"},
{"lineNum":" 4483","line":"    const bool do_zero = ((i0|i1|i2|i3|i4|i5|i6|i7|i8|i9|i10|i11|i12|i13|i14|i15) & 0x80) != 0; // needs zeroing"},
{"lineNum":" 4484","line":""},
{"lineNum":" 4485","line":"    // no elements from b"},
{"lineNum":" 4486","line":"    if (((ne & se) | (no & so)) == 0) {"},
{"lineNum":" 4487","line":"        return permute16 <i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15>(a);"},
{"lineNum":" 4488","line":"    }"},
{"lineNum":" 4489","line":""},
{"lineNum":" 4490","line":"    // no elements from a"},
{"lineNum":" 4491","line":"    if ((((ne^0x11111111) & se) | ((no^0x11111111) & so)) == 0) {"},
{"lineNum":" 4492","line":"        return permute16 <i0 ^ 16, i1 ^ 16, i2 ^ 16, i3 ^ 16, i4 ^ 16, i5 ^ 16, i6 ^ 16, i7 ^ 16, i8 ^ 16, i9 ^ 16, i10 ^ 16, i11 ^ 16, i12 ^ 16, i13 ^ 16, i14 ^ 16, i15 ^ 16>(b);"},
{"lineNum":" 4493","line":"    }"},
{"lineNum":" 4494","line":"    __m128i t;"},
{"lineNum":" 4495","line":""},
{"lineNum":" 4496","line":"    // check if we can use punpcklbw"},
{"lineNum":" 4497","line":"    if (((me ^ 0x76543210) & se) == 0 && ((mo ^ 0x76543210) & so) == 0) {"},
{"lineNum":" 4498","line":"        if ((ne & se) == 0 && ((no ^ 0x11111111) & so) == 0) {"},
{"lineNum":" 4499","line":"            t = _mm_unpacklo_epi8(a, b);"},
{"lineNum":" 4500","line":"        }"},
{"lineNum":" 4501","line":"        if ((no & so) == 0 && ((ne ^ 0x11111111) & se) == 0) {"},
{"lineNum":" 4502","line":"            t = _mm_unpacklo_epi8(b, a);"},
{"lineNum":" 4503","line":"        }"},
{"lineNum":" 4504","line":"        if (do_zero) {"},
{"lineNum":" 4505","line":"            // additional zeroing needed"},
{"lineNum":" 4506","line":"            __m128i maskz = constant4i <"},
{"lineNum":" 4507","line":"                (i0  < 0 ? 0 : 0xFF) | (i1  < 0 ? 0 : 0xFF00) | (i2  < 0 ? 0 : 0xFF0000) | (i3  < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4508","line":"                (i4  < 0 ? 0 : 0xFF) | (i5  < 0 ? 0 : 0xFF00) | (i6  < 0 ? 0 : 0xFF0000) | (i7  < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4509","line":"                (i8  < 0 ? 0 : 0xFF) | (i9  < 0 ? 0 : 0xFF00) | (i10 < 0 ? 0 : 0xFF0000) | (i11 < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4510","line":"                (i12 < 0 ? 0 : 0xFF) | (i13 < 0 ? 0 : 0xFF00) | (i14 < 0 ? 0 : 0xFF0000) | (i15 < 0 ? 0 : (int)0xFF000000) > ();"},
{"lineNum":" 4511","line":"            t = _mm_and_si128(t, maskz);"},
{"lineNum":" 4512","line":"        }"},
{"lineNum":" 4513","line":"        return t;"},
{"lineNum":" 4514","line":"    }"},
{"lineNum":" 4515","line":""},
{"lineNum":" 4516","line":"    // check if we can use punpckhbw"},
{"lineNum":" 4517","line":"    if (((me ^ 0xFEDCBA98) & se) == 0 && ((mo ^ 0xFEDCBA98) & so) == 0) {"},
{"lineNum":" 4518","line":"        if ((ne & se) == 0 && ((no ^ 0x11111111) & so) == 0) {"},
{"lineNum":" 4519","line":"            t = _mm_unpackhi_epi8(a, b);"},
{"lineNum":" 4520","line":"        }"},
{"lineNum":" 4521","line":"        if ((no & so) == 0 && ((ne ^ 0x11111111) & se) == 0) {"},
{"lineNum":" 4522","line":"            t = _mm_unpackhi_epi8(b, a);"},
{"lineNum":" 4523","line":"        }"},
{"lineNum":" 4524","line":"        if (do_zero) {"},
{"lineNum":" 4525","line":"            // additional zeroing needed"},
{"lineNum":" 4526","line":"            __m128i maskz = constant4i <"},
{"lineNum":" 4527","line":"                (i0  < 0 ? 0 : 0xFF) | (i1  < 0 ? 0 : 0xFF00) | (i2  < 0 ? 0 : 0xFF0000) | (i3  < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4528","line":"                (i4  < 0 ? 0 : 0xFF) | (i5  < 0 ? 0 : 0xFF00) | (i6  < 0 ? 0 : 0xFF0000) | (i7  < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4529","line":"                (i8  < 0 ? 0 : 0xFF) | (i9  < 0 ? 0 : 0xFF00) | (i10 < 0 ? 0 : 0xFF0000) | (i11 < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4530","line":"                (i12 < 0 ? 0 : 0xFF) | (i13 < 0 ? 0 : 0xFF00) | (i14 < 0 ? 0 : 0xFF0000) | (i15 < 0 ? 0 : (int)0xFF000000) > ();"},
{"lineNum":" 4531","line":"            t = _mm_and_si128(t, maskz);"},
{"lineNum":" 4532","line":"        }"},
{"lineNum":" 4533","line":"        return t;"},
{"lineNum":" 4534","line":"    }"},
{"lineNum":" 4535","line":""},
{"lineNum":" 4536","line":"#if  INSTRSET >= 4  // SSSE3"},
{"lineNum":" 4537","line":"    // special case: shift left"},
{"lineNum":" 4538","line":"    if (i0 > 0 && i0 < 16 && i1==i0+1 && i2==i0+2 && i3==i0+3 && i4==i0+4 && i5==i0+5 && i6==i0+6 && i7==i0+7 &&"},
{"lineNum":" 4539","line":"        i8==i0+8 && i9==i0+9 && i10==i0+10 && i11==i0+11 && i12==i0+12 && i13==i0+13 && i14==i0+14 && i15==i0+15) {"},
{"lineNum":" 4540","line":"        return _mm_alignr_epi8(b, a, (i0 & 15));"},
{"lineNum":" 4541","line":"    }"},
{"lineNum":" 4542","line":""},
{"lineNum":" 4543","line":"    // special case: shift right"},
{"lineNum":" 4544","line":"    if (i0 > 15 && i0 < 32 && i1==((i0+1)&31) && i2 ==((i0+2 )&31) && i3 ==((i0+3 )&31) && i4 ==((i0+4 )&31) && i5 ==((i0+5 )&31) && i6 ==((i0+6 )&31) && i7 ==((i0+7 )&31) &&"},
{"lineNum":" 4545","line":"        i8==((i0+8 )&31)   && i9==((i0+9)&31) && i10==((i0+10)&31) && i11==((i0+11)&31) && i12==((i0+12)&31) && i13==((i0+13)&31) && i14==((i0+14)&31) && i15==((i0+15)&31)) {"},
{"lineNum":" 4546","line":"        return _mm_alignr_epi8(a, b, (i0 & 15));"},
{"lineNum":" 4547","line":"    }"},
{"lineNum":" 4548","line":"#endif"},
{"lineNum":" 4549","line":""},
{"lineNum":" 4550","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 4551","line":"    // special case: blend without permute"},
{"lineNum":" 4552","line":"    if (((me ^ 0xECA86420) & se) == 0 && ((mo ^ 0xFDB97531) & so) == 0) {"},
{"lineNum":" 4553","line":"        __m128i maskbl = constant4i<"},
{"lineNum":" 4554","line":"            ((i0 & 16) ? 0xFF : 0) | ((i1 & 16) ? 0xFF00 : 0) | ((i2 & 16) ? 0xFF0000 : 0) | ((i3 & 16) ? (int)0xFF000000 : 0) ,"},
{"lineNum":" 4555","line":"            ((i4 & 16) ? 0xFF : 0) | ((i5 & 16) ? 0xFF00 : 0) | ((i6 & 16) ? 0xFF0000 : 0) | ((i7 & 16) ? (int)0xFF000000 : 0) ,"},
{"lineNum":" 4556","line":"            ((i8 & 16) ? 0xFF : 0) | ((i9 & 16) ? 0xFF00 : 0) | ((i10& 16) ? 0xFF0000 : 0) | ((i11& 16) ? (int)0xFF000000 : 0) ,"},
{"lineNum":" 4557","line":"            ((i12& 16) ? 0xFF : 0) | ((i13& 16) ? 0xFF00 : 0) | ((i14& 16) ? 0xFF0000 : 0) | ((i15& 16) ? (int)0xFF000000 : 0) > ();"},
{"lineNum":" 4558","line":"        t = _mm_blendv_epi8(a, b, maskbl);"},
{"lineNum":" 4559","line":"        if (do_zero) {"},
{"lineNum":" 4560","line":"            // additional zeroing needed"},
{"lineNum":" 4561","line":"            __m128i maskz = constant4i <"},
{"lineNum":" 4562","line":"                (i0  < 0 ? 0 : 0xFF) | (i1  < 0 ? 0 : 0xFF00) | (i2  < 0 ? 0 : 0xFF0000) | (i3  < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4563","line":"                (i4  < 0 ? 0 : 0xFF) | (i5  < 0 ? 0 : 0xFF00) | (i6  < 0 ? 0 : 0xFF0000) | (i7  < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4564","line":"                (i8  < 0 ? 0 : 0xFF) | (i9  < 0 ? 0 : 0xFF00) | (i10 < 0 ? 0 : 0xFF0000) | (i11 < 0 ? 0 : (int)0xFF000000) ,"},
{"lineNum":" 4565","line":"                (i12 < 0 ? 0 : 0xFF) | (i13 < 0 ? 0 : 0xFF00) | (i14 < 0 ? 0 : 0xFF0000) | (i15 < 0 ? 0 : (int)0xFF000000) > ();"},
{"lineNum":" 4566","line":"            t = _mm_and_si128(t, maskz);"},
{"lineNum":" 4567","line":"        }"},
{"lineNum":" 4568","line":"        return t;"},
{"lineNum":" 4569","line":"    }"},
{"lineNum":" 4570","line":"#endif // SSE4.1"},
{"lineNum":" 4571","line":""},
{"lineNum":" 4572","line":"#if defined ( __XOP__ )    // Use AMD XOP instruction VPPERM"},
{"lineNum":" 4573","line":"    __m128i mask = constant4i<"},
{"lineNum":" 4574","line":"        (i0 <0 ? 0x80 : (i0 &31)) | (i1 <0 ? 0x80 : (i1 &31)) << 8 | (i2 <0 ? 0x80 : (i2 &31)) << 16 | (i3 <0 ? 0x80 : (i3 &31)) << 24,"},
{"lineNum":" 4575","line":"        (i4 <0 ? 0x80 : (i4 &31)) | (i5 <0 ? 0x80 : (i5 &31)) << 8 | (i6 <0 ? 0x80 : (i6 &31)) << 16 | (i7 <0 ? 0x80 : (i7 &31)) << 24,"},
{"lineNum":" 4576","line":"        (i8 <0 ? 0x80 : (i8 &31)) | (i9 <0 ? 0x80 : (i9 &31)) << 8 | (i10<0 ? 0x80 : (i10&31)) << 16 | (i11<0 ? 0x80 : (i11&31)) << 24,"},
{"lineNum":" 4577","line":"        (i12<0 ? 0x80 : (i12&31)) | (i13<0 ? 0x80 : (i13&31)) << 8 | (i14<0 ? 0x80 : (i14&31)) << 16 | (i15<0 ? 0x80 : (i15&31)) << 24 > ();"},
{"lineNum":" 4578","line":"    return _mm_perm_epi8(a, b, mask);"},
{"lineNum":" 4579","line":""},
{"lineNum":" 4580","line":"#elif  INSTRSET >= 4  // SSSE3"},
{"lineNum":" 4581","line":""},
{"lineNum":" 4582","line":"    // general case. Use PSHUFB"},
{"lineNum":" 4583","line":"    __m128i maska = constant4i<"},
{"lineNum":" 4584","line":"        ((i0 & 0x90) ? 0xFF : (i0 &15)) | ((i1 & 0x90) ? 0xFF : (i1 &15)) << 8 | ((i2 & 0x90) ? 0xFF : (i2 &15)) << 16 | ((i3 & 0x90) ? 0xFF : (i3 &15)) << 24,"},
{"lineNum":" 4585","line":"        ((i4 & 0x90) ? 0xFF : (i4 &15)) | ((i5 & 0x90) ? 0xFF : (i5 &15)) << 8 | ((i6 & 0x90) ? 0xFF : (i6 &15)) << 16 | ((i7 & 0x90) ? 0xFF : (i7 &15)) << 24,"},
{"lineNum":" 4586","line":"        ((i8 & 0x90) ? 0xFF : (i8 &15)) | ((i9 & 0x90) ? 0xFF : (i9 &15)) << 8 | ((i10& 0x90) ? 0xFF : (i10&15)) << 16 | ((i11& 0x90) ? 0xFF : (i11&15)) << 24,"},
{"lineNum":" 4587","line":"        ((i12& 0x90) ? 0xFF : (i12&15)) | ((i13& 0x90) ? 0xFF : (i13&15)) << 8 | ((i14& 0x90) ? 0xFF : (i14&15)) << 16 | ((i15& 0x90) ? 0xFF : (i15&15)) << 24 > ();"},
{"lineNum":" 4588","line":"    __m128i maskb = constant4i<"},
{"lineNum":" 4589","line":"        (((i0 ^ 0x10) & 0x90) ? 0xFF : (i0 & 15)) | (((i1 ^ 0x10) & 0x90) ? 0xFF : (i1 & 15)) << 8 | (((i2 ^ 0x10) & 0x90) ? 0xFF : (i2 & 15)) << 16 | (((i3 ^ 0x10) & 0x90) ? 0xFF : (i3 & 15)) << 24,"},
{"lineNum":" 4590","line":"        (((i4^0x10) & 0x90) ? 0xFF : (i4 &15)) | (((i5^0x10) & 0x90) ? 0xFF : (i5 &15)) << 8 | (((i6^0x10) & 0x90) ? 0xFF : (i6 &15)) << 16 | (((i7^0x10) & 0x90) ? 0xFF : (i7 &15)) << 24,"},
{"lineNum":" 4591","line":"        (((i8^0x10) & 0x90) ? 0xFF : (i8 &15)) | (((i9^0x10) & 0x90) ? 0xFF : (i9 &15)) << 8 | (((i10^0x10)& 0x90) ? 0xFF : (i10&15)) << 16 | (((i11^0x10)& 0x90) ? 0xFF : (i11&15)) << 24,"},
{"lineNum":" 4592","line":"        (((i12^0x10)& 0x90) ? 0xFF : (i12&15)) | (((i13^0x10)& 0x90) ? 0xFF : (i13&15)) << 8 | (((i14^0x10)& 0x90) ? 0xFF : (i14&15)) << 16 | (((i15^0x10)& 0x90) ? 0xFF : (i15&15)) << 24 > ();"},
{"lineNum":" 4593","line":"    __m128i a1 = _mm_shuffle_epi8(a, maska);"},
{"lineNum":" 4594","line":"    __m128i b1 = _mm_shuffle_epi8(b,maskb);"},
{"lineNum":" 4595","line":"    return       _mm_or_si128(a1, b1);"},
{"lineNum":" 4596","line":""},
{"lineNum":" 4597","line":"#else                 // SSE2"},
{"lineNum":" 4598","line":"    // combine two permutes"},
{"lineNum":" 4599","line":"    __m128i a1 = permute16 <"},
{"lineNum":" 4600","line":"        (uint32_t)i0  < 16 ? i0  : -1,"},
{"lineNum":" 4601","line":"        (uint32_t)i1  < 16 ? i1  : -1,"},
{"lineNum":" 4602","line":"        (uint32_t)i2  < 16 ? i2  : -1,"},
{"lineNum":" 4603","line":"        (uint32_t)i3  < 16 ? i3  : -1,"},
{"lineNum":" 4604","line":"        (uint32_t)i4  < 16 ? i4  : -1,"},
{"lineNum":" 4605","line":"        (uint32_t)i5  < 16 ? i5  : -1,"},
{"lineNum":" 4606","line":"        (uint32_t)i6  < 16 ? i6  : -1,"},
{"lineNum":" 4607","line":"        (uint32_t)i7  < 16 ? i7  : -1,"},
{"lineNum":" 4608","line":"        (uint32_t)i8  < 16 ? i8  : -1,"},
{"lineNum":" 4609","line":"        (uint32_t)i9  < 16 ? i9  : -1,"},
{"lineNum":" 4610","line":"        (uint32_t)i10 < 16 ? i10 : -1,"},
{"lineNum":" 4611","line":"        (uint32_t)i11 < 16 ? i11 : -1,"},
{"lineNum":" 4612","line":"        (uint32_t)i12 < 16 ? i12 : -1,"},
{"lineNum":" 4613","line":"        (uint32_t)i13 < 16 ? i13 : -1,"},
{"lineNum":" 4614","line":"        (uint32_t)i14 < 16 ? i14 : -1,"},
{"lineNum":" 4615","line":"        (uint32_t)i15 < 16 ? i15 : -1 > (a);"},
{"lineNum":" 4616","line":"    __m128i b1 = permute16 <"},
{"lineNum":" 4617","line":"        (uint32_t)(i0 ^16) < 16 ? (i0 ^16) : -1,"},
{"lineNum":" 4618","line":"        (uint32_t)(i1 ^16) < 16 ? (i1 ^16) : -1,"},
{"lineNum":" 4619","line":"        (uint32_t)(i2 ^16) < 16 ? (i2 ^16) : -1,"},
{"lineNum":" 4620","line":"        (uint32_t)(i3 ^16) < 16 ? (i3 ^16) : -1,"},
{"lineNum":" 4621","line":"        (uint32_t)(i4 ^16) < 16 ? (i4 ^16) : -1,"},
{"lineNum":" 4622","line":"        (uint32_t)(i5 ^16) < 16 ? (i5 ^16) : -1,"},
{"lineNum":" 4623","line":"        (uint32_t)(i6 ^16) < 16 ? (i6 ^16) : -1,"},
{"lineNum":" 4624","line":"        (uint32_t)(i7 ^16) < 16 ? (i7 ^16) : -1,"},
{"lineNum":" 4625","line":"        (uint32_t)(i8 ^16) < 16 ? (i8 ^16) : -1,"},
{"lineNum":" 4626","line":"        (uint32_t)(i9 ^16) < 16 ? (i9 ^16) : -1,"},
{"lineNum":" 4627","line":"        (uint32_t)(i10^16) < 16 ? (i10^16) : -1,"},
{"lineNum":" 4628","line":"        (uint32_t)(i11^16) < 16 ? (i11^16) : -1,"},
{"lineNum":" 4629","line":"        (uint32_t)(i12^16) < 16 ? (i12^16) : -1,"},
{"lineNum":" 4630","line":"        (uint32_t)(i13^16) < 16 ? (i13^16) : -1,"},
{"lineNum":" 4631","line":"        (uint32_t)(i14^16) < 16 ? (i14^16) : -1,"},
{"lineNum":" 4632","line":"        (uint32_t)(i15^16) < 16 ? (i15^16) : -1 > (b);"},
{"lineNum":" 4633","line":"    return   _mm_or_si128(a1, b1);"},
{"lineNum":" 4634","line":""},
{"lineNum":" 4635","line":"#endif"},
{"lineNum":" 4636","line":"}"},
{"lineNum":" 4637","line":""},
{"lineNum":" 4638","line":"template <int i0, int i1, int i2,  int i3,  int i4,  int i5,  int i6,  int i7,"},
{"lineNum":" 4639","line":"          int i8, int i9, int i10, int i11, int i12, int i13, int i14, int i15 >"},
{"lineNum":" 4640","line":"static inline Vec16uc blend16(Vec16uc const & a, Vec16uc const & b) {"},
{"lineNum":" 4641","line":"    return Vec16uc( blend16<i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15> (Vec16c(a),Vec16c(b)));"},
{"lineNum":" 4642","line":"}"},
{"lineNum":" 4643","line":""},
{"lineNum":" 4644","line":""},
{"lineNum":" 4645","line":"template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>"},
{"lineNum":" 4646","line":"static inline Vec8s blend8(Vec8s const & a, Vec8s const & b) {"},
{"lineNum":" 4647","line":""},
{"lineNum":" 4648","line":"    // Combine all the indexes into a single bitfield, with 4 bits for each"},
{"lineNum":" 4649","line":"    const int m1 = (i0&0xF) | (i1&0xF)<<4 | (i2&0xF)<<8 | (i3&0xF)<<12"},
{"lineNum":" 4650","line":"        | (i4&0xF)<<16 | (i5&0xF)<<20 | (i6&0xF)<<24 | (i7&0xF)<<28;"},
{"lineNum":" 4651","line":""},
{"lineNum":" 4652","line":"    // Mask to zero out negative indexes"},
{"lineNum":" 4653","line":"    const int mz = (i0<0?0:0xF) | (i1<0?0:0xF)<<4 | (i2<0?0:0xF)<<8 | (i3<0?0:0xF)<<12"},
{"lineNum":" 4654","line":"        | (i4<0?0:0xF)<<16 | (i5<0?0:0xF)<<20 | (i6<0?0:0xF)<<24 | (i7<0?0:0xF)<<28;"},
{"lineNum":" 4655","line":""},
{"lineNum":" 4656","line":"    // Some elements must be set to zero"},
{"lineNum":" 4657","line":"    const bool do_zero = (mz != -1) && ((i0 | i1 | i2 | i3 | i4 | i5 | i6 | i7) & 0x80) != 0;"},
{"lineNum":" 4658","line":""},
{"lineNum":" 4659","line":"    // temp contains temporary result, some zeroing needs to be done"},
{"lineNum":" 4660","line":"    bool zeroing_pending = false;"},
{"lineNum":" 4661","line":""},
{"lineNum":" 4662","line":"    // partially finished result"},
{"lineNum":" 4663","line":"    __m128i temp = _mm_setzero_si128();"},
{"lineNum":" 4664","line":""},
{"lineNum":" 4665","line":"    if ((m1 & 0x88888888 & mz) == 0) {"},
{"lineNum":" 4666","line":"        // no elements from b"},
{"lineNum":" 4667","line":"        return permute8 <i0, i1, i2, i3, i4, i5, i6, i7> (a);"},
{"lineNum":" 4668","line":"    }"},
{"lineNum":" 4669","line":""},
{"lineNum":" 4670","line":"    if (((m1^0x88888888) & 0x88888888 & mz) == 0) {"},
{"lineNum":" 4671","line":"        // no elements from a"},
{"lineNum":" 4672","line":"        return permute8 <i0&~8, i1&~8, i2&~8, i3&~8, i4&~8, i5&~8, i6&~8, i7&~8> (b);"},
{"lineNum":" 4673","line":"    }"},
{"lineNum":" 4674","line":""},
{"lineNum":" 4675","line":"    // special case: PUNPCKLWD"},
{"lineNum":" 4676","line":"    if (((m1 ^ 0xB3A29180) & mz) == 0) {"},
{"lineNum":" 4677","line":"        temp = _mm_unpacklo_epi16(a, b);"},
{"lineNum":" 4678","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4679","line":"    }"},
{"lineNum":" 4680","line":"    if (((m1 ^ 0x3B2A1908) & mz) == 0) {"},
{"lineNum":" 4681","line":"        temp = _mm_unpacklo_epi16(b, a);"},
{"lineNum":" 4682","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4683","line":"    }"},
{"lineNum":" 4684","line":"    // special case: PUNPCKHWD"},
{"lineNum":" 4685","line":"    if (((m1 ^ 0xF7E6D5C4) & mz) == 0) {"},
{"lineNum":" 4686","line":"        temp = _mm_unpackhi_epi16(a, b);"},
{"lineNum":" 4687","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4688","line":"    }"},
{"lineNum":" 4689","line":"    if (((m1 ^ 0x7F6E5D4C) & mz) == 0) {"},
{"lineNum":" 4690","line":"        temp = _mm_unpackhi_epi16(b, a);"},
{"lineNum":" 4691","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4692","line":"    }"},
{"lineNum":" 4693","line":""},
{"lineNum":" 4694","line":"#if  INSTRSET >= 4  // SSSE3"},
{"lineNum":" 4695","line":"    // special case: shift left"},
{"lineNum":" 4696","line":"    if (i0 > 0 && i0 < 8 && ((m1 ^ ((i0 & 7) * 0x11111111u + 0x76543210u)) & mz) == 0) {"},
{"lineNum":" 4697","line":"        temp = _mm_alignr_epi8(b, a, (i0 & 7) * 2);"},
{"lineNum":" 4698","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4699","line":"    }"},
{"lineNum":" 4700","line":""},
{"lineNum":" 4701","line":"    // special case: shift right"},
{"lineNum":" 4702","line":"    if (i0 > 8 && i0 < 16 && ((m1 ^ 0x88888888 ^ ((i0 & 7) * 0x11111111u + 0x76543210u)) & mz) == 0) {"},
{"lineNum":" 4703","line":"        temp = _mm_alignr_epi8(a, b, (i0 & 7) * 2);"},
{"lineNum":" 4704","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4705","line":"    }"},
{"lineNum":" 4706","line":"#endif // SSSE3"},
{"lineNum":" 4707","line":""},
{"lineNum":" 4708","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 4709","line":"    // special case: blending without permuting"},
{"lineNum":" 4710","line":"    if ((((m1 & ~0x88888888) ^ 0x76543210) & mz) == 0) {"},
{"lineNum":" 4711","line":"        temp = _mm_blend_epi16(a, b, (i0>>3&1) | (i1>>3&1)<<1 | (i2>>3&1)<<2 | (i3>>3&1)<<3"},
{"lineNum":" 4712","line":"            | (i4>>3&1)<<4 | (i5>>3&1)<<5 | (i6>>3&1)<<6 | (i7>>3&1)<<7);"},
{"lineNum":" 4713","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4714","line":"    }"},
{"lineNum":" 4715","line":"#endif // SSE4.1"},
{"lineNum":" 4716","line":""},
{"lineNum":" 4717","line":"    if (zeroing_pending) {"},
{"lineNum":" 4718","line":"        // additional zeroing of temp needed"},
{"lineNum":" 4719","line":"        __m128i maskz = constant4i <"},
{"lineNum":" 4720","line":"            (i0 < 0 ? 0 : 0xFFFF) | (i1 < 0 ? 0 : (int)0xFFFF0000) ,"},
{"lineNum":" 4721","line":"            (i2 < 0 ? 0 : 0xFFFF) | (i3 < 0 ? 0 : (int)0xFFFF0000) ,"},
{"lineNum":" 4722","line":"            (i4 < 0 ? 0 : 0xFFFF) | (i5 < 0 ? 0 : (int)0xFFFF0000) ,"},
{"lineNum":" 4723","line":"            (i6 < 0 ? 0 : 0xFFFF) | (i7 < 0 ? 0 : (int)0xFFFF0000) > ();"},
{"lineNum":" 4724","line":"        return _mm_and_si128(temp, maskz);"},
{"lineNum":" 4725","line":"    }"},
{"lineNum":" 4726","line":""},
{"lineNum":" 4727","line":"    // general case"},
{"lineNum":" 4728","line":"#ifdef __XOP__     // Use AMD XOP instruction PPERM"},
{"lineNum":" 4729","line":"    __m128i mask = constant4i <"},
{"lineNum":" 4730","line":"        (i0 < 0 ? (int32_t)0x8080 : (i0*2 & 31) | ((i0*2 & 31)+1)<<8) | (i1 < 0 ? (int32_t)0x80800000 : ((i1*2 & 31)<<16) | ((i1*2 & 31)+1)<<24),"},
{"lineNum":" 4731","line":"        (i2 < 0 ? (int32_t)0x8080 : (i2*2 & 31) | ((i2*2 & 31)+1)<<8) | (i3 < 0 ? (int32_t)0x80800000 : ((i3*2 & 31)<<16) | ((i3*2 & 31)+1)<<24),"},
{"lineNum":" 4732","line":"        (i4 < 0 ? (int32_t)0x8080 : (i4*2 & 31) | ((i4*2 & 31)+1)<<8) | (i5 < 0 ? (int32_t)0x80800000 : ((i5*2 & 31)<<16) | ((i5*2 & 31)+1)<<24),"},
{"lineNum":" 4733","line":"        (i6 < 0 ? (int32_t)0x8080 : (i6*2 & 31) | ((i6*2 & 31)+1)<<8) | (i7 < 0 ? (int32_t)0x80800000 : ((i7*2 & 31)<<16) | ((i7*2 & 31)+1)<<24) > ();"},
{"lineNum":" 4734","line":"    return _mm_perm_epi8(a, b, mask);"},
{"lineNum":" 4735","line":"#else"},
{"lineNum":" 4736","line":"    // combine two permutes"},
{"lineNum":" 4737","line":"    __m128i a1 = permute8 <"},
{"lineNum":" 4738","line":"        (uint32_t)i0 < 8 ? i0 : -1,"},
{"lineNum":" 4739","line":"        (uint32_t)i1 < 8 ? i1 : -1,"},
{"lineNum":" 4740","line":"        (uint32_t)i2 < 8 ? i2 : -1,"},
{"lineNum":" 4741","line":"        (uint32_t)i3 < 8 ? i3 : -1,"},
{"lineNum":" 4742","line":"        (uint32_t)i4 < 8 ? i4 : -1,"},
{"lineNum":" 4743","line":"        (uint32_t)i5 < 8 ? i5 : -1,"},
{"lineNum":" 4744","line":"        (uint32_t)i6 < 8 ? i6 : -1,"},
{"lineNum":" 4745","line":"        (uint32_t)i7 < 8 ? i7 : -1 > (a);"},
{"lineNum":" 4746","line":"    __m128i b1 = permute8 <"},
{"lineNum":" 4747","line":"        (uint32_t)(i0^8) < 8 ? (i0^8) : -1,"},
{"lineNum":" 4748","line":"        (uint32_t)(i1^8) < 8 ? (i1^8) : -1,"},
{"lineNum":" 4749","line":"        (uint32_t)(i2^8) < 8 ? (i2^8) : -1,"},
{"lineNum":" 4750","line":"        (uint32_t)(i3^8) < 8 ? (i3^8) : -1,"},
{"lineNum":" 4751","line":"        (uint32_t)(i4^8) < 8 ? (i4^8) : -1,"},
{"lineNum":" 4752","line":"        (uint32_t)(i5^8) < 8 ? (i5^8) : -1,"},
{"lineNum":" 4753","line":"        (uint32_t)(i6^8) < 8 ? (i6^8) : -1,"},
{"lineNum":" 4754","line":"        (uint32_t)(i7^8) < 8 ? (i7^8) : -1 > (b);"},
{"lineNum":" 4755","line":"    return   _mm_or_si128(a1,b1);"},
{"lineNum":" 4756","line":""},
{"lineNum":" 4757","line":"#endif"},
{"lineNum":" 4758","line":"}"},
{"lineNum":" 4759","line":""},
{"lineNum":" 4760","line":"template <int i0, int i1, int i2, int i3, int i4, int i5, int i6, int i7>"},
{"lineNum":" 4761","line":"static inline Vec8us blend8(Vec8us const & a, Vec8us const & b) {"},
{"lineNum":" 4762","line":"    return Vec8us(blend8<i0,i1,i2,i3,i4,i5,i6,i7> (Vec8s(a),Vec8s(b)));"},
{"lineNum":" 4763","line":"}"},
{"lineNum":" 4764","line":""},
{"lineNum":" 4765","line":"template <int i0, int i1, int i2, int i3>"},
{"lineNum":" 4766","line":"static inline Vec4i blend4(Vec4i const & a, Vec4i const & b) {"},
{"lineNum":" 4767","line":""},
{"lineNum":" 4768","line":"    // Combine all the indexes into a single bitfield, with 8 bits for each"},
{"lineNum":" 4769","line":"    const int m1 = (i0 & 7) | ((i1 & 7) << 8) | ((i2 & 7) << 16) | ((i3 & 7) << 24);"},
{"lineNum":" 4770","line":""},
{"lineNum":" 4771","line":"    // Mask to zero out negative indexes"},
{"lineNum":" 4772","line":"    const int mz = (i0 < 0 ? 0 : 0xFF) | ((i1 < 0 ? 0 : 0xFF) << 8) | ((i2 < 0 ? 0 : 0xFF) << 16) | ((i3 < 0 ? 0 : 0xFF) << 24);"},
{"lineNum":" 4773","line":""},
{"lineNum":" 4774","line":"    // Some elements must be set to zero"},
{"lineNum":" 4775","line":"    const bool do_zero = (mz != -1) && ((i0 | i1 | i2 | i3) & 0x80) != 0;"},
{"lineNum":" 4776","line":""},
{"lineNum":" 4777","line":"    // temp contains temporary result, some zeroing needs to be done"},
{"lineNum":" 4778","line":"    bool zeroing_pending = false;"},
{"lineNum":" 4779","line":""},
{"lineNum":" 4780","line":"    // partially finished result"},
{"lineNum":" 4781","line":"    __m128i temp;"},
{"lineNum":" 4782","line":"#if defined (_MSC_VER) || defined (__clang__)"},
{"lineNum":" 4783","line":"    temp = a;  // avoid spurious warning message for temp unused"},
{"lineNum":" 4784","line":"#endif"},
{"lineNum":" 4785","line":""},
{"lineNum":" 4786","line":"    // special case: no elements from b"},
{"lineNum":" 4787","line":"    if ((m1 & 0x04040404 & mz) == 0) {"},
{"lineNum":" 4788","line":"        return permute4<i0,i1,i2,i3>(a);"},
{"lineNum":" 4789","line":"    }"},
{"lineNum":" 4790","line":""},
{"lineNum":" 4791","line":"    // special case: no elements from a"},
{"lineNum":" 4792","line":"    if (((m1^0x04040404) & 0x04040404 & mz) == 0) {"},
{"lineNum":" 4793","line":"        return permute4<i0&~4, i1&~4, i2&~4, i3&~4>(b);"},
{"lineNum":" 4794","line":"    }"},
{"lineNum":" 4795","line":""},
{"lineNum":" 4796","line":"    // special case: punpckldq"},
{"lineNum":" 4797","line":"    if (((m1 ^ 0x05010400) & mz) == 0) {"},
{"lineNum":" 4798","line":"        temp = _mm_unpacklo_epi32(a, b);"},
{"lineNum":" 4799","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4800","line":"    }"},
{"lineNum":" 4801","line":"    if (((m1 ^ 0x01050004) & mz) == 0) {"},
{"lineNum":" 4802","line":"        temp = _mm_unpacklo_epi32(b, a);"},
{"lineNum":" 4803","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4804","line":"    }"},
{"lineNum":" 4805","line":""},
{"lineNum":" 4806","line":"    // special case: punpckhdq"},
{"lineNum":" 4807","line":"    if (((m1 ^ 0x07030602) & mz) == 0) {"},
{"lineNum":" 4808","line":"        temp = _mm_unpackhi_epi32(a, b);"},
{"lineNum":" 4809","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4810","line":"    }"},
{"lineNum":" 4811","line":"    if (((m1 ^ 0x03070206) & mz) == 0) {"},
{"lineNum":" 4812","line":"        temp = _mm_unpackhi_epi32(b, a);"},
{"lineNum":" 4813","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4814","line":"    }"},
{"lineNum":" 4815","line":""},
{"lineNum":" 4816","line":"#if  INSTRSET >= 4  // SSSE3"},
{"lineNum":" 4817","line":"    // special case: shift left"},
{"lineNum":" 4818","line":"    if (i0 > 0 && i0 < 4 && ((m1 ^ ((i0 & 3) * 0x01010101u + 0x03020100u)) & mz) == 0) {"},
{"lineNum":" 4819","line":"        temp = _mm_alignr_epi8(b, a, (i0 & 3) * 4);"},
{"lineNum":" 4820","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4821","line":"    }"},
{"lineNum":" 4822","line":""},
{"lineNum":" 4823","line":"    // special case: shift right"},
{"lineNum":" 4824","line":"    if (i0 > 4 && i0 < 8 && ((m1 ^ 0x04040404 ^ ((i0 & 3) * 0x01010101u + 0x03020100u)) & mz) == 0) {"},
{"lineNum":" 4825","line":"        temp = _mm_alignr_epi8(a, b, (i0 & 3) * 4);"},
{"lineNum":" 4826","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4827","line":"    }"},
{"lineNum":" 4828","line":"#endif // SSSE3"},
{"lineNum":" 4829","line":""},
{"lineNum":" 4830","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 4831","line":"    if ((((m1 & ~0x04040404) ^ 0x03020100) & mz) == 0) {"},
{"lineNum":" 4832","line":"        // blending without permuting"},
{"lineNum":" 4833","line":"        temp = _mm_blend_epi16(a, b, ((i0>>2)&1)*3 | ((((i1>>2)&1)*3)<<2) | ((((i2>>2)&1)*3)<<4) | ((((i3>>2)&1)*3)<<6));"},
{"lineNum":" 4834","line":"        if (do_zero) zeroing_pending = true; else return temp;"},
{"lineNum":" 4835","line":"    }"},
{"lineNum":" 4836","line":"#endif // SSE4.1"},
{"lineNum":" 4837","line":""},
{"lineNum":" 4838","line":"    if (zeroing_pending) {"},
{"lineNum":" 4839","line":"        // additional zeroing of temp needed"},
{"lineNum":" 4840","line":"        __m128i maskz = constant4i < (i0 < 0 ? 0 : -1), (i1 < 0 ? 0 : -1), (i2 < 0 ? 0 : -1), (i3 < 0 ? 0 : -1) > ();"},
{"lineNum":" 4841","line":"        return _mm_and_si128(temp, maskz);"},
{"lineNum":" 4842","line":"    }"},
{"lineNum":" 4843","line":""},
{"lineNum":" 4844","line":"    // general case"},
{"lineNum":" 4845","line":"#ifdef __XOP__     // Use AMD XOP instruction PPERM"},
{"lineNum":" 4846","line":"    __m128i mask = constant4i <"},
{"lineNum":" 4847","line":"        i0 < 0 ? (int32_t)0x80808080 : (i0*4 & 31) + (((i0*4 & 31) + 1) << 8) + (((i0*4 & 31) + 2) << 16) + (((i0*4 & 31) + 3) << 24),"},
{"lineNum":" 4848","line":"        i1 < 0 ? (int32_t)0x80808080 : (i1*4 & 31) + (((i1*4 & 31) + 1) << 8) + (((i1*4 & 31) + 2) << 16) + (((i1*4 & 31) + 3) << 24),"},
{"lineNum":" 4849","line":"        i2 < 0 ? (int32_t)0x80808080 : (i2*4 & 31) + (((i2*4 & 31) + 1) << 8) + (((i2*4 & 31) + 2) << 16) + (((i2*4 & 31) + 3) << 24),"},
{"lineNum":" 4850","line":"        i3 < 0 ? (int32_t)0x80808080 : (i3*4 & 31) + (((i3*4 & 31) + 1) << 8) + (((i3*4 & 31) + 2) << 16) + (((i3*4 & 31) + 3) << 24) > ();"},
{"lineNum":" 4851","line":"    return _mm_perm_epi8(a, b, mask);"},
{"lineNum":" 4852","line":""},
{"lineNum":" 4853","line":"#else  // combine two permutes"},
{"lineNum":" 4854","line":"    __m128i a1 = permute4 <"},
{"lineNum":" 4855","line":"        (uint32_t)i0 < 4 ? i0 : -1,"},
{"lineNum":" 4856","line":"        (uint32_t)i1 < 4 ? i1 : -1,"},
{"lineNum":" 4857","line":"        (uint32_t)i2 < 4 ? i2 : -1,"},
{"lineNum":" 4858","line":"        (uint32_t)i3 < 4 ? i3 : -1  > (a);"},
{"lineNum":" 4859","line":"    __m128i b1 = permute4 <"},
{"lineNum":" 4860","line":"        (uint32_t)(i0^4) < 4 ? (i0^4) : -1,"},
{"lineNum":" 4861","line":"        (uint32_t)(i1^4) < 4 ? (i1^4) : -1,"},
{"lineNum":" 4862","line":"        (uint32_t)(i2^4) < 4 ? (i2^4) : -1,"},
{"lineNum":" 4863","line":"        (uint32_t)(i3^4) < 4 ? (i3^4) : -1  > (b);"},
{"lineNum":" 4864","line":"    return  _mm_or_si128(a1,b1);"},
{"lineNum":" 4865","line":"#endif"},
{"lineNum":" 4866","line":"}"},
{"lineNum":" 4867","line":""},
{"lineNum":" 4868","line":"template <int i0, int i1, int i2, int i3>"},
{"lineNum":" 4869","line":"static inline Vec4ui blend4(Vec4ui const & a, Vec4ui const & b) {"},
{"lineNum":" 4870","line":"    return Vec4ui (blend4<i0,i1,i2,i3> (Vec4i(a),Vec4i(b)));"},
{"lineNum":" 4871","line":"}"},
{"lineNum":" 4872","line":""},
{"lineNum":" 4873","line":"template <int i0, int i1>"},
{"lineNum":" 4874","line":"static inline Vec2q blend2(Vec2q const & a, Vec2q const & b) {"},
{"lineNum":" 4875","line":""},
{"lineNum":" 4876","line":"    // Combine all the indexes into a single bitfield, with 8 bits for each"},
{"lineNum":" 4877","line":"    const int m1 = (i0&3) | (i1&3)<<8;"},
{"lineNum":" 4878","line":""},
{"lineNum":" 4879","line":"    // Mask to zero out negative indexes"},
{"lineNum":" 4880","line":"    const int mz = (i0 < 0 ? 0 : 0xFF) | (i1 < 0 ? 0 : 0xFF) << 8;"},
{"lineNum":" 4881","line":""},
{"lineNum":" 4882","line":"    // no elements from b"},
{"lineNum":" 4883","line":"    if ((m1 & 0x0202 & mz) == 0) {"},
{"lineNum":" 4884","line":"        return permute2 <i0, i1> (a);"},
{"lineNum":" 4885","line":"    }"},
{"lineNum":" 4886","line":"    // no elements from a"},
{"lineNum":" 4887","line":"    if (((m1^0x0202) & 0x0202 & mz) == 0) {"},
{"lineNum":" 4888","line":"        return permute2 <i0 & ~2, i1 & ~2> (b);"},
{"lineNum":" 4889","line":"    }"},
{"lineNum":" 4890","line":"    // (all cases where one index is -1 or -256 would go to the above cases)"},
{"lineNum":" 4891","line":""},
{"lineNum":" 4892","line":"    // special case: punpcklqdq"},
{"lineNum":" 4893","line":"    if (i0 == 0 && i1 == 2) {"},
{"lineNum":" 4894","line":"        return _mm_unpacklo_epi64(a, b);"},
{"lineNum":" 4895","line":"    }"},
{"lineNum":" 4896","line":"    if (i0 == 2 && i1 == 0) {"},
{"lineNum":" 4897","line":"        return _mm_unpacklo_epi64(b, a);"},
{"lineNum":" 4898","line":"    }"},
{"lineNum":" 4899","line":"    // special case: punpckhqdq"},
{"lineNum":" 4900","line":"    if (i0 == 1 && i1 == 3) {"},
{"lineNum":" 4901","line":"        return _mm_unpackhi_epi64(a, b);"},
{"lineNum":" 4902","line":"    }"},
{"lineNum":" 4903","line":"    if (i0 == 3 && i1 == 1) {"},
{"lineNum":" 4904","line":"        return _mm_unpackhi_epi64(b, a);"},
{"lineNum":" 4905","line":"    }"},
{"lineNum":" 4906","line":""},
{"lineNum":" 4907","line":"#if  INSTRSET >= 4  // SSSE3"},
{"lineNum":" 4908","line":"    // special case: shift left"},
{"lineNum":" 4909","line":"    if (i0 == 1 && i1 == 2) {"},
{"lineNum":" 4910","line":"        return _mm_alignr_epi8(b, a, 8);"},
{"lineNum":" 4911","line":"    }"},
{"lineNum":" 4912","line":"    // special case: shift right"},
{"lineNum":" 4913","line":"    if (i0 == 3 && i1 == 0) {"},
{"lineNum":" 4914","line":"        return _mm_alignr_epi8(a, b, 8);"},
{"lineNum":" 4915","line":"    }"},
{"lineNum":" 4916","line":"#endif // SSSE3"},
{"lineNum":" 4917","line":""},
{"lineNum":" 4918","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 4919","line":"    if (((m1 & ~0x0202) ^ 0x0100) == 0 && mz == 0xFFFF) {"},
{"lineNum":" 4920","line":"        // blending without permuting"},
{"lineNum":" 4921","line":"        return _mm_blend_epi16(a, b, (i0>>1 & 1) * 0xF | ((i1>>1 & 1) * 0xF) << 4 );"},
{"lineNum":" 4922","line":"    }"},
{"lineNum":" 4923","line":"#endif // SSE4.1"},
{"lineNum":" 4924","line":""},
{"lineNum":" 4925","line":"    // general case. combine two permutes"},
{"lineNum":" 4926","line":"    // (all cases are caught by the above special cases if SSE4.1 or higher is supported)"},
{"lineNum":" 4927","line":"    __m128i a1, b1;"},
{"lineNum":" 4928","line":"    a1 = permute2 <(uint32_t)i0 < 2 ? i0 : -1, (uint32_t)i1 < 2 ? i1 : -1 > (a);"},
{"lineNum":" 4929","line":"    b1 = permute2 <(uint32_t)(i0^2) < 2 ? (i0^2) : -1, (uint32_t)(i1^2) < 2 ? (i1^2) : -1 > (b);"},
{"lineNum":" 4930","line":"    return  _mm_or_si128(a1,b1);"},
{"lineNum":" 4931","line":"}"},
{"lineNum":" 4932","line":""},
{"lineNum":" 4933","line":"template <int i0, int i1>"},
{"lineNum":" 4934","line":"static inline Vec2uq blend2(Vec2uq const & a, Vec2uq const & b) {"},
{"lineNum":" 4935","line":"    return Vec2uq (blend2 <i0, i1> (Vec2q(a), Vec2q(b)));"},
{"lineNum":" 4936","line":"}"},
{"lineNum":" 4937","line":""},
{"lineNum":" 4938","line":"// Support names prior to version 1.40 (now deprecated)"},
{"lineNum":" 4939","line":"#define blend16c  blend16"},
{"lineNum":" 4940","line":"#define blend16uc blend16"},
{"lineNum":" 4941","line":"#define blend8s   blend8"},
{"lineNum":" 4942","line":"#define blend8us  blend8"},
{"lineNum":" 4943","line":"#define blend4i   blend4"},
{"lineNum":" 4944","line":"#define blend4ui  blend4"},
{"lineNum":" 4945","line":"#define blend2q   blend2"},
{"lineNum":" 4946","line":"#define blend2uq  blend2"},
{"lineNum":" 4947","line":""},
{"lineNum":" 4948","line":""},
{"lineNum":" 4949","line":"/*****************************************************************************"},
{"lineNum":" 4950","line":"*"},
{"lineNum":" 4951","line":"*          Vector lookup functions"},
{"lineNum":" 4952","line":"*"},
{"lineNum":" 4953","line":"******************************************************************************"},
{"lineNum":" 4954","line":"*"},
{"lineNum":" 4955","line":"* These functions use vector elements as indexes into a table."},
{"lineNum":" 4956","line":"* The table is given as one or more vectors or as an array."},
{"lineNum":" 4957","line":"*"},
{"lineNum":" 4958","line":"* This can be used for several purposes:"},
{"lineNum":" 4959","line":"*  - table lookup"},
{"lineNum":" 4960","line":"*  - permute or blend with variable indexes"},
{"lineNum":" 4961","line":"*  - blend from more than two sources"},
{"lineNum":" 4962","line":"*  - gather non-contiguous data"},
{"lineNum":" 4963","line":"*"},
{"lineNum":" 4964","line":"* An index out of range may produce any value - the actual value produced is"},
{"lineNum":" 4965","line":"* implementation dependent and may be different for different instruction"},
{"lineNum":" 4966","line":"* sets. An index out of range does not produce an error message or exception."},
{"lineNum":" 4967","line":"*"},
{"lineNum":" 4968","line":"* Example:"},
{"lineNum":" 4969","line":"* Vec4i a(2,0,0,3);           // index a is (  2,   0,   0,   3)"},
{"lineNum":" 4970","line":"* Vec4i b(100,101,102,103);   // table b is (100, 101, 102, 103)"},
{"lineNum":" 4971","line":"* Vec4i c;"},
{"lineNum":" 4972","line":"* c = lookup4 (a,b);          // c is (102, 100, 100, 103)"},
{"lineNum":" 4973","line":"*"},
{"lineNum":" 4974","line":"*****************************************************************************/"},
{"lineNum":" 4975","line":""},
{"lineNum":" 4976","line":"static inline Vec16c lookup16(Vec16c const & index, Vec16c const & table) {"},
{"lineNum":" 4977","line":"#if INSTRSET >= 5  // SSSE3"},
{"lineNum":" 4978","line":"    return _mm_shuffle_epi8(table, index);"},
{"lineNum":" 4979","line":"#else"},
{"lineNum":" 4980","line":"    uint8_t ii[16];"},
{"lineNum":" 4981","line":"    int8_t  tt[16], rr[16];"},
{"lineNum":" 4982","line":"    table.store(tt);  index.store(ii);"},
{"lineNum":" 4983","line":"    for (int j = 0; j < 16; j++) rr[j] = tt[ii[j] & 0x0F];"},
{"lineNum":" 4984","line":"    return Vec16c().load(rr);"},
{"lineNum":" 4985","line":"#endif"},
{"lineNum":" 4986","line":"}"},
{"lineNum":" 4987","line":""},
{"lineNum":" 4988","line":"static inline Vec16c lookup32(Vec16c const & index, Vec16c const & table0, Vec16c const & table1) {"},
{"lineNum":" 4989","line":"#ifdef __XOP__  // AMD XOP instruction set. Use VPPERM"},
{"lineNum":" 4990","line":"    return (Vec16c)_mm_perm_epi8(table0, table1, index);"},
{"lineNum":" 4991","line":"#elif INSTRSET >= 5  // SSSE3"},
{"lineNum":" 4992","line":"    Vec16c r0 = _mm_shuffle_epi8(table0, index + 0x70);           // make negative index for values >= 16"},
{"lineNum":" 4993","line":"    Vec16c r1 = _mm_shuffle_epi8(table1, (index ^ 0x10) + 0x70);  // make negative index for values <  16"},
{"lineNum":" 4994","line":"    return r0 | r1;"},
{"lineNum":" 4995","line":"#else"},
{"lineNum":" 4996","line":"    uint8_t ii[16];"},
{"lineNum":" 4997","line":"    int8_t  tt[32], rr[16];"},
{"lineNum":" 4998","line":"    table0.store(tt);  table1.store(tt+16);  index.store(ii);"},
{"lineNum":" 4999","line":"    for (int j = 0; j < 16; j++) rr[j] = tt[ii[j] & 0x1F];"},
{"lineNum":" 5000","line":"    return Vec16c().load(rr);"},
{"lineNum":" 5001","line":"#endif"},
{"lineNum":" 5002","line":"}"},
{"lineNum":" 5003","line":""},
{"lineNum":" 5004","line":"template <int n>"},
{"lineNum":" 5005","line":"static inline Vec16c lookup(Vec16c const & index, void const * table) {"},
{"lineNum":" 5006","line":"    if (n <=  0) return 0;"},
{"lineNum":" 5007","line":"    if (n <= 16) return lookup16(index, Vec16c().load(table));"},
{"lineNum":" 5008","line":"    if (n <= 32) return lookup32(index, Vec16c().load(table), Vec16c().load((int8_t*)table + 16));"},
{"lineNum":" 5009","line":"    // n > 32. Limit index"},
{"lineNum":" 5010","line":"    Vec16uc index1;"},
{"lineNum":" 5011","line":"    if ((n & (n-1)) == 0) {"},
{"lineNum":" 5012","line":"        // n is a power of 2, make index modulo n"},
{"lineNum":" 5013","line":"        index1 = Vec16uc(index) & uint8_t(n-1);"},
{"lineNum":" 5014","line":"    }"},
{"lineNum":" 5015","line":"    else {"},
{"lineNum":" 5016","line":"        // n is not a power of 2, limit to n-1"},
{"lineNum":" 5017","line":"        index1 = min(Vec16uc(index), uint8_t(n-1));"},
{"lineNum":" 5018","line":"    }"},
{"lineNum":" 5019","line":"    uint8_t ii[16];  index1.store(ii);"},
{"lineNum":" 5020","line":"    int8_t  rr[16];"},
{"lineNum":" 5021","line":"    for (int j = 0; j < 16; j++) {"},
{"lineNum":" 5022","line":"        rr[j] = ((int8_t*)table)[ii[j]];"},
{"lineNum":" 5023","line":"    }"},
{"lineNum":" 5024","line":"    return Vec16c().load(rr);"},
{"lineNum":" 5025","line":"}"},
{"lineNum":" 5026","line":""},
{"lineNum":" 5027","line":"static inline Vec8s lookup8(Vec8s const & index, Vec8s const & table) {"},
{"lineNum":" 5028","line":"#if INSTRSET >= 5  // SSSE3"},
{"lineNum":" 5029","line":"    return _mm_shuffle_epi8(table, index * 0x202 + 0x100);"},
{"lineNum":" 5030","line":"#else"},
{"lineNum":" 5031","line":"    int16_t ii[8], tt[8], rr[8];"},
{"lineNum":" 5032","line":"    table.store(tt);  index.store(ii);"},
{"lineNum":" 5033","line":"    for (int j = 0; j < 8; j++) rr[j] = tt[ii[j] & 0x07];"},
{"lineNum":" 5034","line":"    return Vec8s().load(rr);"},
{"lineNum":" 5035","line":"#endif"},
{"lineNum":" 5036","line":"}"},
{"lineNum":" 5037","line":""},
{"lineNum":" 5038","line":"static inline Vec8s lookup16(Vec8s const & index, Vec8s const & table0, Vec8s const & table1) {"},
{"lineNum":" 5039","line":"#ifdef __XOP__  // AMD XOP instruction set. Use VPPERM"},
{"lineNum":" 5040","line":"    return (Vec8s)_mm_perm_epi8(table0, table1, index * 0x202 + 0x100);"},
{"lineNum":" 5041","line":"#elif INSTRSET >= 5  // SSSE3"},
{"lineNum":" 5042","line":"    Vec8s r0 = _mm_shuffle_epi8(table0, Vec16c(index * 0x202) + Vec16c(Vec8s(0x7170)));"},
{"lineNum":" 5043","line":"    Vec8s r1 = _mm_shuffle_epi8(table1, Vec16c(index * 0x202 ^ 0x1010) + Vec16c(Vec8s(0x7170)));"},
{"lineNum":" 5044","line":"    return r0 | r1;"},
{"lineNum":" 5045","line":"#else"},
{"lineNum":" 5046","line":"    int16_t ii[16], tt[32], rr[16];"},
{"lineNum":" 5047","line":"    table0.store(tt);  table1.store(tt+8);  index.store(ii);"},
{"lineNum":" 5048","line":"    for (int j = 0; j < 16; j++) rr[j] = tt[ii[j] & 0x1F];"},
{"lineNum":" 5049","line":"    return Vec8s().load(rr);"},
{"lineNum":" 5050","line":"#endif"},
{"lineNum":" 5051","line":"}"},
{"lineNum":" 5052","line":""},
{"lineNum":" 5053","line":"template <int n>"},
{"lineNum":" 5054","line":"static inline Vec8s lookup(Vec8s const & index, void const * table) {"},
{"lineNum":" 5055","line":"    if (n <=  0) return 0;"},
{"lineNum":" 5056","line":"    if (n <=  8) return lookup8 (index, Vec8s().load(table));"},
{"lineNum":" 5057","line":"    if (n <= 16) return lookup16(index, Vec8s().load(table), Vec8s().load((int16_t*)table + 8));"},
{"lineNum":" 5058","line":"    // n > 16. Limit index"},
{"lineNum":" 5059","line":"    Vec8us index1;"},
{"lineNum":" 5060","line":"    if ((n & (n-1)) == 0) {"},
{"lineNum":" 5061","line":"        // n is a power of 2, make index modulo n"},
{"lineNum":" 5062","line":"        index1 = Vec8us(index) & (n-1);"},
{"lineNum":" 5063","line":"    }"},
{"lineNum":" 5064","line":"    else {"},
{"lineNum":" 5065","line":"        // n is not a power of 2, limit to n-1"},
{"lineNum":" 5066","line":"        index1 = min(Vec8us(index), n-1);"},
{"lineNum":" 5067","line":"    }"},
{"lineNum":" 5068","line":"#if INSTRSET >= 8 // AVX2. Use VPERMD"},
{"lineNum":" 5069","line":"    Vec8s t1 = _mm_i32gather_epi32((const int *)table, __m128i((Vec4i(index1)) & (Vec4i(0x0000FFFF))), 2);  // even positions"},
{"lineNum":" 5070","line":"    Vec8s t2 = _mm_i32gather_epi32((const int *)table, _mm_srli_epi32(index1, 16) , 2);  // odd  positions"},
{"lineNum":" 5071","line":"    return blend8<0,8,2,10,4,12,6,14>(t1, t2);"},
{"lineNum":" 5072","line":"#else"},
{"lineNum":" 5073","line":"    uint16_t ii[8];  index1.store(ii);"},
{"lineNum":" 5074","line":"    return Vec8s(((int16_t*)table)[ii[0]], ((int16_t*)table)[ii[1]], ((int16_t*)table)[ii[2]], ((int16_t*)table)[ii[3]],"},
{"lineNum":" 5075","line":"                 ((int16_t*)table)[ii[4]], ((int16_t*)table)[ii[5]], ((int16_t*)table)[ii[6]], ((int16_t*)table)[ii[7]]);"},
{"lineNum":" 5076","line":"#endif"},
{"lineNum":" 5077","line":"}"},
{"lineNum":" 5078","line":""},
{"lineNum":" 5079","line":""},
{"lineNum":" 5080","line":"static inline Vec4i lookup4(Vec4i const & index, Vec4i const & table) {"},
{"lineNum":" 5081","line":"#if INSTRSET >= 5  // SSSE3"},
{"lineNum":" 5082","line":"    return _mm_shuffle_epi8(table, index * 0x04040404 + 0x03020100);"},
{"lineNum":" 5083","line":"#else"},
{"lineNum":" 5084","line":"    return Vec4i(table[index[0]],table[index[1]],table[index[2]],table[index[3]]);"},
{"lineNum":" 5085","line":"#endif"},
{"lineNum":" 5086","line":"}"},
{"lineNum":" 5087","line":""},
{"lineNum":" 5088","line":"static inline Vec4i lookup8(Vec4i const & index, Vec4i const & table0, Vec4i const & table1) {"},
{"lineNum":" 5089","line":"    // return Vec4i(lookup16(Vec8s(index * 0x20002 + 0x10000), Vec8s(table0), Vec8s(table1)));"},
{"lineNum":" 5090","line":"#ifdef __XOP__  // AMD XOP instruction set. Use VPPERM"},
{"lineNum":" 5091","line":"    return (Vec4i)_mm_perm_epi8(table0, table1, index * 0x04040404 + 0x03020100);"},
{"lineNum":" 5092","line":"#elif INSTRSET >= 8 // AVX2. Use VPERMD"},
{"lineNum":" 5093","line":"    __m256i table01 = _mm256_inserti128_si256(_mm256_castsi128_si256(table0), table1, 1); // join tables into 256 bit vector"},
{"lineNum":" 5094","line":""},
{"lineNum":" 5095","line":"#if defined (_MSC_VER) && _MSC_VER < 1700 && ! defined(__INTEL_COMPILER)"},
{"lineNum":" 5096","line":"    // bug in MS VS 11 beta: operands in wrong order"},
{"lineNum":" 5097","line":"    return _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(_mm256_castsi128_si256(index), table01));"},
{"lineNum":" 5098","line":"#elif defined (GCC_VERSION) && GCC_VERSION <= 40700 && !defined(__INTEL_COMPILER) && !defined(__clang__)"},
{"lineNum":" 5099","line":"    // Gcc 4.7.0 also has operands in wrong order"},
{"lineNum":" 5100","line":"    return _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(_mm256_castsi128_si256(index), table01));"},
{"lineNum":" 5101","line":"#else"},
{"lineNum":" 5102","line":"    return _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(table01, _mm256_castsi128_si256(index)));"},
{"lineNum":" 5103","line":"#endif // bug"},
{"lineNum":" 5104","line":""},
{"lineNum":" 5105","line":"#elif INSTRSET >= 4  // SSSE3"},
{"lineNum":" 5106","line":"    Vec4i r0 = _mm_shuffle_epi8(table0, Vec16c(index * 0x04040404) + Vec16c(Vec4i(0x73727170)));"},
{"lineNum":" 5107","line":"    Vec4i r1 = _mm_shuffle_epi8(table1, Vec16c(index * 0x04040404 ^ 0x10101010) + Vec16c(Vec4i(0x73727170)));"},
{"lineNum":" 5108","line":"    return r0 | r1;"},
{"lineNum":" 5109","line":"#else    // SSE2"},
{"lineNum":" 5110","line":"    int32_t ii[4], tt[8], rr[4];"},
{"lineNum":" 5111","line":"    table0.store(tt);  table1.store(tt+4);  index.store(ii);"},
{"lineNum":" 5112","line":"    for (int j = 0; j < 4; j++) rr[j] = tt[ii[j] & 0x07];"},
{"lineNum":" 5113","line":"    return Vec4i().load(rr);"},
{"lineNum":" 5114","line":"#endif"},
{"lineNum":" 5115","line":"}"},
{"lineNum":" 5116","line":""},
{"lineNum":" 5117","line":"static inline Vec4i lookup16(Vec4i const & index, Vec4i const & table0, Vec4i const & table1, Vec4i const & table2, Vec4i const & table3) {"},
{"lineNum":" 5118","line":"#if INSTRSET >= 8 // AVX2. Use VPERMD"},
{"lineNum":" 5119","line":"    __m256i table01 = _mm256_inserti128_si256(_mm256_castsi128_si256(table0), table1, 1); // join tables into 256 bit vector"},
{"lineNum":" 5120","line":"    __m256i table23 = _mm256_inserti128_si256(_mm256_castsi128_si256(table2), table3, 1); // join tables into 256 bit vector"},
{"lineNum":" 5121","line":"#if defined (_MSC_VER) && _MSC_VER < 1700 && ! defined(__INTEL_COMPILER)"},
{"lineNum":" 5122","line":"    // bug in MS VS 11 beta: operands in wrong order"},
{"lineNum":" 5123","line":"    __m128i r0 = _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(_mm256_castsi128_si256(index    ), table01));"},
{"lineNum":" 5124","line":"    __m128i r1 = _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(_mm256_castsi128_si256(index ^ 8), table23));"},
{"lineNum":" 5125","line":"#elif defined (GCC_VERSION) && GCC_VERSION <= 40700 && !defined(__INTEL_COMPILER) && !defined(__clang__)"},
{"lineNum":" 5126","line":"    // Gcc 4.7.0 also has operands in wrong order"},
{"lineNum":" 5127","line":"    __m128i r0 = _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(_mm256_castsi128_si256(index    ), table01));"},
{"lineNum":" 5128","line":"    __m128i r1 = _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(_mm256_castsi128_si256(index ^ 8), table23));"},
{"lineNum":" 5129","line":"#else"},
{"lineNum":" 5130","line":"    __m128i r0 = _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(table01, _mm256_castsi128_si256(index)));"},
{"lineNum":" 5131","line":"    __m128i r1 = _mm256_castsi256_si128(_mm256_permutevar8x32_epi32(table23, _mm256_castsi128_si256(index ^ 8)));"},
{"lineNum":" 5132","line":"#endif // bug"},
{"lineNum":" 5133","line":"    return _mm_blendv_epi8(r0, r1, index >= 8);"},
{"lineNum":" 5134","line":""},
{"lineNum":" 5135","line":"#elif defined (__XOP__)  // AMD XOP instruction set. Use VPPERM"},
{"lineNum":" 5136","line":"    Vec4i r0 = _mm_perm_epi8(table0, table1, ((index    ) * 0x04040404u + 0x63626160u) & 0X9F9F9F9Fu);"},
{"lineNum":" 5137","line":"    Vec4i r1 = _mm_perm_epi8(table2, table3, ((index ^ 8) * 0x04040404u + 0x63626160u) & 0X9F9F9F9Fu);"},
{"lineNum":" 5138","line":"    return r0 | r1;"},
{"lineNum":" 5139","line":""},
{"lineNum":" 5140","line":"#elif INSTRSET >= 5  // SSSE3"},
{"lineNum":" 5141","line":"    Vec16c aa = Vec16c(Vec4i(0x73727170));"},
{"lineNum":" 5142","line":"    Vec4i r0 = _mm_shuffle_epi8(table0, Vec16c((index     ) * 0x04040404) + aa);"},
{"lineNum":" 5143","line":"    Vec4i r1 = _mm_shuffle_epi8(table1, Vec16c((index ^  4) * 0x04040404) + aa);"},
{"lineNum":" 5144","line":"    Vec4i r2 = _mm_shuffle_epi8(table2, Vec16c((index ^  8) * 0x04040404) + aa);"},
{"lineNum":" 5145","line":"    Vec4i r3 = _mm_shuffle_epi8(table3, Vec16c((index ^ 12) * 0x04040404) + aa);"},
{"lineNum":" 5146","line":"    return (r0 | r1) | (r2 | r3);"},
{"lineNum":" 5147","line":""},
{"lineNum":" 5148","line":"#else    // SSE2"},
{"lineNum":" 5149","line":"    int32_t ii[4], tt[16], rr[4];"},
{"lineNum":" 5150","line":"    table0.store(tt);  table1.store(tt+4);  table2.store(tt+8);  table3.store(tt+12);"},
{"lineNum":" 5151","line":"    index.store(ii);"},
{"lineNum":" 5152","line":"    for (int j = 0; j < 4; j++) rr[j] = tt[ii[j] & 0x0F];"},
{"lineNum":" 5153","line":"    return Vec4i().load(rr);"},
{"lineNum":" 5154","line":"#endif"},
{"lineNum":" 5155","line":"}"},
{"lineNum":" 5156","line":""},
{"lineNum":" 5157","line":"template <int n>"},
{"lineNum":" 5158","line":"static inline Vec4i lookup(Vec4i const & index, void const * table) {"},
{"lineNum":" 5159","line":"    if (n <= 0) return 0;"},
{"lineNum":" 5160","line":"    if (n <= 4) return lookup4(index, Vec4i().load(table));"},
{"lineNum":" 5161","line":"    if (n <= 8) return lookup8(index, Vec4i().load(table), Vec4i().load((int32_t*)table + 4));"},
{"lineNum":" 5162","line":"    // n > 8. Limit index"},
{"lineNum":" 5163","line":"    Vec4ui index1;"},
{"lineNum":" 5164","line":"    if ((n & (n-1)) == 0) {"},
{"lineNum":" 5165","line":"        // n is a power of 2, make index modulo n"},
{"lineNum":" 5166","line":"        index1 = Vec4ui(index) & (n-1);"},
{"lineNum":" 5167","line":"    }"},
{"lineNum":" 5168","line":"    else {"},
{"lineNum":" 5169","line":"        // n is not a power of 2, limit to n-1"},
{"lineNum":" 5170","line":"        index1 = min(Vec4ui(index), n-1);"},
{"lineNum":" 5171","line":"    }"},
{"lineNum":" 5172","line":"#if INSTRSET >= 8 // AVX2. Use VPERMD"},
{"lineNum":" 5173","line":"    return _mm_i32gather_epi32((const int *)table, index1, 4);"},
{"lineNum":" 5174","line":"#else"},
{"lineNum":" 5175","line":"    uint32_t ii[4];  index1.store(ii);"},
{"lineNum":" 5176","line":"    return Vec4i(((int32_t*)table)[ii[0]], ((int32_t*)table)[ii[1]], ((int32_t*)table)[ii[2]], ((int32_t*)table)[ii[3]]);"},
{"lineNum":" 5177","line":"#endif"},
{"lineNum":" 5178","line":"}"},
{"lineNum":" 5179","line":""},
{"lineNum":" 5180","line":""},
{"lineNum":" 5181","line":"static inline Vec2q lookup2(Vec2q const & index, Vec2q const & table) {"},
{"lineNum":" 5182","line":"#if INSTRSET >= 5  // SSSE3"},
{"lineNum":" 5183","line":"    return _mm_shuffle_epi8(table, index * 0x0808080808080808ll + 0x0706050403020100ll);"},
{"lineNum":" 5184","line":"#else"},
{"lineNum":" 5185","line":"    int64_t ii[2], tt[2];"},
{"lineNum":" 5186","line":"    table.store(tt);  index.store(ii);"},
{"lineNum":" 5187","line":"    return Vec2q(tt[int(ii[0])], tt[int(ii[1])]);"},
{"lineNum":" 5188","line":"#endif"},
{"lineNum":" 5189","line":"}"},
{"lineNum":" 5190","line":""},
{"lineNum":" 5191","line":"template <int n>"},
{"lineNum":" 5192","line":"static inline Vec2q lookup(Vec2q const & index, void const * table) {"},
{"lineNum":" 5193","line":"    if (n <= 0) return 0;"},
{"lineNum":" 5194","line":"    // n > 0. Limit index"},
{"lineNum":" 5195","line":"    Vec2uq index1;"},
{"lineNum":" 5196","line":"    if ((n & (n-1)) == 0) {"},
{"lineNum":" 5197","line":"        // n is a power of 2, make index modulo n"},
{"lineNum":" 5198","line":"        index1 = Vec2uq(index) & (n-1);"},
{"lineNum":" 5199","line":"    }"},
{"lineNum":" 5200","line":"    else {"},
{"lineNum":" 5201","line":"        // n is not a power of 2, limit to n-1."},
{"lineNum":" 5202","line":"        // There is no 64-bit min instruction, but we can use the 32-bit unsigned min,"},
{"lineNum":" 5203","line":"        // since n is a 32-bit integer"},
{"lineNum":" 5204","line":"        index1 = Vec2uq(min(Vec2uq(index), constant4i<n-1, 0, n-1, 0>()));"},
{"lineNum":" 5205","line":"    }"},
{"lineNum":" 5206","line":"    uint32_t ii[4];  index1.store(ii);  // use only lower 32 bits of each index"},
{"lineNum":" 5207","line":"    int64_t const * tt = (int64_t const *)table;"},
{"lineNum":" 5208","line":"    return Vec2q(tt[ii[0]], tt[ii[2]]);"},
{"lineNum":" 5209","line":"}"},
{"lineNum":" 5210","line":""},
{"lineNum":" 5211","line":""},
{"lineNum":" 5212","line":"/*****************************************************************************"},
{"lineNum":" 5213","line":"*"},
{"lineNum":" 5214","line":"*          Byte shifts"},
{"lineNum":" 5215","line":"*"},
{"lineNum":" 5216","line":"*****************************************************************************/"},
{"lineNum":" 5217","line":""},
{"lineNum":" 5218","line":"// Function shift_bytes_up: shift whole vector left by b bytes."},
{"lineNum":" 5219","line":"template <unsigned int b>"},
{"lineNum":" 5220","line":"static inline Vec16c shift_bytes_up(Vec16c const & a) {"},
{"lineNum":" 5221","line":"#if INSTRSET >= 4    // SSSE3"},
{"lineNum":" 5222","line":"    if (b < 16) {"},
{"lineNum":" 5223","line":"        return _mm_alignr_epi8(a, _mm_setzero_si128(), 16-b);"},
{"lineNum":" 5224","line":"    }"},
{"lineNum":" 5225","line":"    else {"},
{"lineNum":" 5226","line":"        return _mm_setzero_si128();                       // zero"},
{"lineNum":" 5227","line":"    }"},
{"lineNum":" 5228","line":"#else"},
{"lineNum":" 5229","line":"    int8_t dat[32];"},
{"lineNum":" 5230","line":"    if (b < 16) {"},
{"lineNum":" 5231","line":"        Vec16c(0).store(dat);"},
{"lineNum":" 5232","line":"        a.store(dat+b);"},
{"lineNum":" 5233","line":"        return Vec16c().load(dat);"},
{"lineNum":" 5234","line":"}"},
{"lineNum":" 5235","line":"    else return 0;"},
{"lineNum":" 5236","line":"#endif"},
{"lineNum":" 5237","line":"}"},
{"lineNum":" 5238","line":""},
{"lineNum":" 5239","line":"// Function shift_bytes_down: shift whole vector right by b bytes"},
{"lineNum":" 5240","line":"template <unsigned int b>"},
{"lineNum":" 5241","line":"static inline Vec16c shift_bytes_down(Vec16c const & a) {"},
{"lineNum":" 5242","line":"#if INSTRSET >= 4    // SSSE3"},
{"lineNum":" 5243","line":"    if (b < 16) {"},
{"lineNum":" 5244","line":"        return _mm_alignr_epi8(_mm_setzero_si128(), a, b);"},
{"lineNum":" 5245","line":"    }"},
{"lineNum":" 5246","line":"    else {"},
{"lineNum":" 5247","line":"        return _mm_setzero_si128();                       // zero"},
{"lineNum":" 5248","line":"    }"},
{"lineNum":" 5249","line":"#else"},
{"lineNum":" 5250","line":"    int8_t dat[32];"},
{"lineNum":" 5251","line":"    if (b < 16) {"},
{"lineNum":" 5252","line":"        a.store(dat);"},
{"lineNum":" 5253","line":"        Vec16c(0).store(dat+16);"},
{"lineNum":" 5254","line":"        return Vec16c().load(dat+b);"},
{"lineNum":" 5255","line":"    }"},
{"lineNum":" 5256","line":"    else return 0;"},
{"lineNum":" 5257","line":"#endif"},
{"lineNum":" 5258","line":"}"},
{"lineNum":" 5259","line":""},
{"lineNum":" 5260","line":""},
{"lineNum":" 5261","line":"// THIS VERSION IS DEPRECATED!"},
{"lineNum":" 5262","line":"// Function shift_bytes_up: shift whole vector left by b bytes."},
{"lineNum":" 5263","line":"static inline Vec16c shift_bytes_up(Vec16c const & a, int b) {"},
{"lineNum":" 5264","line":"    if ((uint32_t)b > 15) return _mm_setzero_si128();"},
{"lineNum":" 5265","line":"#if INSTRSET >= 4    // SSSE3"},
{"lineNum":" 5266","line":"    static const char mask[32] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};"},
{"lineNum":" 5267","line":"    return Vec16c(_mm_shuffle_epi8(a, Vec16c().load(mask+16-b)));"},
{"lineNum":" 5268","line":"#else"},
{"lineNum":" 5269","line":"    Vec2uq a1 = Vec2uq(a);"},
{"lineNum":" 5270","line":"    if (b < 8) {"},
{"lineNum":" 5271","line":"        a1 = (a1 << (b*8)) | (permute2<-1,0>(a1) >> (64 - (b*8)));"},
{"lineNum":" 5272","line":"    }"},
{"lineNum":" 5273","line":"    else {"},
{"lineNum":" 5274","line":"        a1 = permute2<-1,0>(a1) << ((b-8)*8);"},
{"lineNum":" 5275","line":"    }"},
{"lineNum":" 5276","line":"    return Vec16c(a1);"},
{"lineNum":" 5277","line":"#endif"},
{"lineNum":" 5278","line":"}"},
{"lineNum":" 5279","line":""},
{"lineNum":" 5280","line":"// THIS VERSION IS DEPRECATED!"},
{"lineNum":" 5281","line":"// Function shift_bytes_down: shift whole vector right by b bytes"},
{"lineNum":" 5282","line":"static inline Vec16c shift_bytes_down(Vec16c const & a, int b) {"},
{"lineNum":" 5283","line":"    if ((uint32_t)b > 15) return _mm_setzero_si128();"},
{"lineNum":" 5284","line":"#if INSTRSET >= 4    // SSSE3"},
{"lineNum":" 5285","line":"    static const char mask[32] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};"},
{"lineNum":" 5286","line":"    return Vec16c(_mm_shuffle_epi8(a, Vec16c().load(mask+b)));"},
{"lineNum":" 5287","line":"#else"},
{"lineNum":" 5288","line":"    Vec2uq a1 = Vec2uq(a);"},
{"lineNum":" 5289","line":"    if (b < 8) {"},
{"lineNum":" 5290","line":"        a1 = (a1 >> (b*8)) | (permute2<1,-1>(a1) << (64 - (b*8)));"},
{"lineNum":" 5291","line":"    }"},
{"lineNum":" 5292","line":"    else {"},
{"lineNum":" 5293","line":"        a1 = permute2<1,-1>(a1) >> ((b-8)*8);"},
{"lineNum":" 5294","line":"    }"},
{"lineNum":" 5295","line":"    return Vec16c(a1);"},
{"lineNum":" 5296","line":"#endif"},
{"lineNum":" 5297","line":"}"},
{"lineNum":" 5298","line":""},
{"lineNum":" 5299","line":""},
{"lineNum":" 5300","line":"/*****************************************************************************"},
{"lineNum":" 5301","line":"*"},
{"lineNum":" 5302","line":"*          Gather functions with fixed indexes"},
{"lineNum":" 5303","line":"*"},
{"lineNum":" 5304","line":"*****************************************************************************/"},
{"lineNum":" 5305","line":"// Load elements from array a with indices i0, i1, i2, i3"},
{"lineNum":" 5306","line":"template <int i0, int i1, int i2, int i3>"},
{"lineNum":" 5307","line":"static inline Vec4i gather4i(void const * a) {"},
{"lineNum":" 5308","line":"    Static_error_check<(i0|i1|i2|i3)>=0> Negative_array_index;  // Error message if index is negative"},
{"lineNum":" 5309","line":"    const int i01min = i0 < i1 ? i0 : i1;"},
{"lineNum":" 5310","line":"    const int i23min = i2 < i3 ? i2 : i3;"},
{"lineNum":" 5311","line":"    const int imin   = i01min < i23min ? i01min : i23min;"},
{"lineNum":" 5312","line":"    const int i01max = i0 > i1 ? i0 : i1;"},
{"lineNum":" 5313","line":"    const int i23max = i2 > i3 ? i2 : i3;"},
{"lineNum":" 5314","line":"    const int imax   = i01max > i23max ? i01max : i23max;"},
{"lineNum":" 5315","line":"    if (imax - imin <= 3) {"},
{"lineNum":" 5316","line":"        // load one contiguous block and permute"},
{"lineNum":" 5317","line":"        if (imax > 3) {"},
{"lineNum":" 5318","line":"            // make sure we don\'t read past the end of the array"},
{"lineNum":" 5319","line":"            Vec4i b = Vec4i().load((int32_t const *)a + imax-3);"},
{"lineNum":" 5320","line":"            return permute4<i0-imax+3, i1-imax+3, i2-imax+3, i3-imax+3>(b);"},
{"lineNum":" 5321","line":"        }"},
{"lineNum":" 5322","line":"        else {"},
{"lineNum":" 5323","line":"            Vec4i b = Vec4i().load((int32_t const *)a + imin);"},
{"lineNum":" 5324","line":"            return permute4<i0-imin, i1-imin, i2-imin, i3-imin>(b);"},
{"lineNum":" 5325","line":"        }"},
{"lineNum":" 5326","line":"    }"},
{"lineNum":" 5327","line":"    if ((i0<imin+4 || i0>imax-4) && (i1<imin+4 || i1>imax-4) && (i2<imin+4 || i2>imax-4) && (i3<imin+4 || i3>imax-4)) {"},
{"lineNum":" 5328","line":"        // load two contiguous blocks and blend"},
{"lineNum":" 5329","line":"        Vec4i b = Vec4i().load((int32_t const *)a + imin);"},
{"lineNum":" 5330","line":"        Vec4i c = Vec4i().load((int32_t const *)a + imax-3);"},
{"lineNum":" 5331","line":"        const int j0 = i0<imin+4 ? i0-imin : 7-imax+i0;"},
{"lineNum":" 5332","line":"        const int j1 = i1<imin+4 ? i1-imin : 7-imax+i1;"},
{"lineNum":" 5333","line":"        const int j2 = i2<imin+4 ? i2-imin : 7-imax+i2;"},
{"lineNum":" 5334","line":"        const int j3 = i3<imin+4 ? i3-imin : 7-imax+i3;"},
{"lineNum":" 5335","line":"        return blend4<j0, j1, j2, j3>(b, c);"},
{"lineNum":" 5336","line":"    }"},
{"lineNum":" 5337","line":"    // use AVX2 gather if available"},
{"lineNum":" 5338","line":"#if INSTRSET >= 8"},
{"lineNum":" 5339","line":"    return _mm_i32gather_epi32((const int *)a, Vec4i(i0,i1,i2,i3), 4);"},
{"lineNum":" 5340","line":"#else"},
{"lineNum":" 5341","line":"    return lookup<imax+1>(Vec4i(i0,i1,i2,i3), a);"},
{"lineNum":" 5342","line":"#endif"},
{"lineNum":" 5343","line":"}"},
{"lineNum":" 5344","line":""},
{"lineNum":" 5345","line":"// Load elements from array a with indices i0, i1"},
{"lineNum":" 5346","line":"template <int i0, int i1>"},
{"lineNum":" 5347","line":"static inline Vec2q gather2q(void const * a) {"},
{"lineNum":" 5348","line":"    Static_error_check<(i0|i1)>=0> Negative_array_index;  // Error message if index is negative"},
{"lineNum":" 5349","line":"    const int imin = i0 < i1 ? i0 : i1;"},
{"lineNum":" 5350","line":"    const int imax = i0 > i1 ? i0 : i1;"},
{"lineNum":" 5351","line":"    if (imax - imin <= 1) {"},
{"lineNum":" 5352","line":"        // load one contiguous block and permute"},
{"lineNum":" 5353","line":"        if (imax > 1) {"},
{"lineNum":" 5354","line":"            // make sure we don\'t read past the end of the array"},
{"lineNum":" 5355","line":"            Vec2q b = Vec2q().load((int64_t const *)a + imax-1);"},
{"lineNum":" 5356","line":"            return permute2<i0-imax+1, i1-imax+1>(b);"},
{"lineNum":" 5357","line":"        }"},
{"lineNum":" 5358","line":"        else {"},
{"lineNum":" 5359","line":"            Vec2q b = Vec2q().load((int64_t const *)a + imin);"},
{"lineNum":" 5360","line":"            return permute2<i0-imin, i1-imin>(b);"},
{"lineNum":" 5361","line":"        }"},
{"lineNum":" 5362","line":"    }"},
{"lineNum":" 5363","line":"    return Vec2q(((int64_t*)a)[i0], ((int64_t*)a)[i1]);"},
{"lineNum":" 5364","line":"}"},
{"lineNum":" 5365","line":""},
{"lineNum":" 5366","line":""},
{"lineNum":" 5367","line":"/*****************************************************************************"},
{"lineNum":" 5368","line":"*"},
{"lineNum":" 5369","line":"*          Vector scatter functions with fixed indexes"},
{"lineNum":" 5370","line":"*"},
{"lineNum":" 5371","line":"******************************************************************************"},
{"lineNum":" 5372","line":"*"},
{"lineNum":" 5373","line":"* These functions write the elements of a vector to arbitrary positions in an"},
{"lineNum":" 5374","line":"* array in memory. Each vector element is written to an array position"},
{"lineNum":" 5375","line":"* determined by an index. An element is not written if the corresponding"},
{"lineNum":" 5376","line":"* index is out of range."},
{"lineNum":" 5377","line":"* The indexes can be specified as constant template parameters or as an"},
{"lineNum":" 5378","line":"* integer vector."},
{"lineNum":" 5379","line":"*"},
{"lineNum":" 5380","line":"* The scatter functions are useful if the data are distributed in a sparce"},
{"lineNum":" 5381","line":"* manner into the array. If the array is dense then it is more efficient"},
{"lineNum":" 5382","line":"* to permute the data into the right positions and then write the whole"},
{"lineNum":" 5383","line":"* permuted vector into the array."},
{"lineNum":" 5384","line":"*"},
{"lineNum":" 5385","line":"* Example:"},
{"lineNum":" 5386","line":"* Vec8q a(10,11,12,13,14,15,16,17);"},
{"lineNum":" 5387","line":"* int64_t b[16] = {0};"},
{"lineNum":" 5388","line":"* scatter<0,2,14,10,1,-1,5,9>(a,b); // b = (10,14,11,0,0,16,0,0,0,17,13,0,0,0,12,0)"},
{"lineNum":" 5389","line":"*"},
{"lineNum":" 5390","line":"*****************************************************************************/"},
{"lineNum":" 5391","line":""},
{"lineNum":" 5392","line":"template <int i0, int i1, int i2, int i3>"},
{"lineNum":" 5393","line":"static inline void scatter(Vec4i const & data, void * destination) {"},
{"lineNum":" 5394","line":"#if INSTRSET >= 10 //  __AVX512VL__"},
{"lineNum":" 5395","line":"    __m128i indx = constant4i<i0,i1,i2,i3>();"},
{"lineNum":" 5396","line":"    __mmask8 mask = uint8_t((i0>=0) | ((i1>=0)<<1) | ((i2>=0)<<2) | ((i3>=0)<<3));"},
{"lineNum":" 5397","line":"    _mm_mask_i32scatter_epi32((int*)destination, mask, indx, data, 4);"},
{"lineNum":" 5398","line":""},
{"lineNum":" 5399","line":"#elif INSTRSET >= 9  //  __AVX512F__"},
{"lineNum":" 5400","line":"    __m512i indx = _mm512_castsi128_si512(constant4i<i0,i1,i2,i3>());"},
{"lineNum":" 5401","line":"    __mmask16 mask = uint16_t((i0>=0) | ((i1>=0)<<1) | ((i2>=0)<<2) | ((i3>=0)<<3));"},
{"lineNum":" 5402","line":"    _mm512_mask_i32scatter_epi32(destination, mask, indx, _mm512_castsi128_si512(data), 4);"},
{"lineNum":" 5403","line":""},
{"lineNum":" 5404","line":"#else"},
{"lineNum":" 5405","line":"    int32_t* arr = (int32_t*)destination;"},
{"lineNum":" 5406","line":"    const int index[4] = {i0,i1,i2,i3};"},
{"lineNum":" 5407","line":"    for (int i = 0; i < 4; i++) {"},
{"lineNum":" 5408","line":"        if (index[i] >= 0) arr[index[i]] = data[i];"},
{"lineNum":" 5409","line":"    }"},
{"lineNum":" 5410","line":"#endif"},
{"lineNum":" 5411","line":"}"},
{"lineNum":" 5412","line":""},
{"lineNum":" 5413","line":"template <int i0, int i1>"},
{"lineNum":" 5414","line":"static inline void scatter(Vec2q const & data, void * destination) {"},
{"lineNum":" 5415","line":"    int64_t* arr = (int64_t*)destination;"},
{"lineNum":" 5416","line":"    if (i0 >= 0) arr[i0] = data[0];"},
{"lineNum":" 5417","line":"    if (i1 >= 0) arr[i1] = data[1];"},
{"lineNum":" 5418","line":"}"},
{"lineNum":" 5419","line":""},
{"lineNum":" 5420","line":""},
{"lineNum":" 5421","line":"/*****************************************************************************"},
{"lineNum":" 5422","line":"*"},
{"lineNum":" 5423","line":"*          Scatter functions with variable indexes"},
{"lineNum":" 5424","line":"*"},
{"lineNum":" 5425","line":"*****************************************************************************/"},
{"lineNum":" 5426","line":""},
{"lineNum":" 5427","line":"static inline void scatter(Vec4i const & index, uint32_t limit, Vec4i const & data, void * destination) {"},
{"lineNum":" 5428","line":"#if INSTRSET >= 10 //  __AVX512VL__"},
{"lineNum":" 5429","line":"    __mmask8 mask = _mm_cmplt_epu32_mask(index, Vec4ui(limit));"},
{"lineNum":" 5430","line":"    _mm_mask_i32scatter_epi32((int*)destination, mask, index, data, 4);"},
{"lineNum":" 5431","line":"#elif INSTRSET >= 9 //  __AVX512F__"},
{"lineNum":" 5432","line":"    __mmask16 mask = _mm512_mask_cmplt_epu32_mask(0xF, _mm512_castsi128_si512(index), _mm512_castsi128_si512(Vec4ui(limit)));"},
{"lineNum":" 5433","line":"    _mm512_mask_i32scatter_epi32((int*)destination, mask, _mm512_castsi128_si512(index), _mm512_castsi128_si512(data), 4);"},
{"lineNum":" 5434","line":"#else"},
{"lineNum":" 5435","line":"    int32_t* arr = (int32_t*)destination;"},
{"lineNum":" 5436","line":"    for (int i = 0; i < 4; i++) {"},
{"lineNum":" 5437","line":"        if (uint32_t(index[i]) < limit) arr[index[i]] = data[i];"},
{"lineNum":" 5438","line":"    }"},
{"lineNum":" 5439","line":"#endif"},
{"lineNum":" 5440","line":"}"},
{"lineNum":" 5441","line":""},
{"lineNum":" 5442","line":"static inline void scatter(Vec2q const & index, uint32_t limit, Vec2q const & data, void * destination) {"},
{"lineNum":" 5443","line":"    int64_t* arr = (int64_t*)destination;"},
{"lineNum":" 5444","line":"    if (uint64_t(index[0]) < uint64_t(limit)) arr[index[0]] = data[0];"},
{"lineNum":" 5445","line":"    if (uint64_t(index[1]) < uint64_t(limit)) arr[index[1]] = data[1];"},
{"lineNum":" 5446","line":"}"},
{"lineNum":" 5447","line":""},
{"lineNum":" 5448","line":""},
{"lineNum":" 5449","line":"/*****************************************************************************"},
{"lineNum":" 5450","line":"*"},
{"lineNum":" 5451","line":"*          Functions for conversion between integer sizes"},
{"lineNum":" 5452","line":"*"},
{"lineNum":" 5453","line":"*****************************************************************************/"},
{"lineNum":" 5454","line":""},
{"lineNum":" 5455","line":"// Extend 8-bit integers to 16-bit integers, signed and unsigned"},
{"lineNum":" 5456","line":""},
{"lineNum":" 5457","line":"// Function extend_low : extends the low 8 elements to 16 bits with sign extension"},
{"lineNum":" 5458","line":"static inline Vec8s extend_low (Vec16c const & a) {"},
{"lineNum":" 5459","line":"    __m128i sign = _mm_cmpgt_epi8(_mm_setzero_si128(),a);  // 0 > a"},
{"lineNum":" 5460","line":"    return         _mm_unpacklo_epi8(a,sign);              // interleave with sign extensions"},
{"lineNum":" 5461","line":"}"},
{"lineNum":" 5462","line":""},
{"lineNum":" 5463","line":"// Function extend_high : extends the high 8 elements to 16 bits with sign extension"},
{"lineNum":" 5464","line":"static inline Vec8s extend_high (Vec16c const & a) {"},
{"lineNum":" 5465","line":"    __m128i sign = _mm_cmpgt_epi8(_mm_setzero_si128(),a);  // 0 > a"},
{"lineNum":" 5466","line":"    return         _mm_unpackhi_epi8(a,sign);              // interleave with sign extensions"},
{"lineNum":" 5467","line":"}"},
{"lineNum":" 5468","line":""},
{"lineNum":" 5469","line":"// Function extend_low : extends the low 8 elements to 16 bits with zero extension"},
{"lineNum":" 5470","line":"static inline Vec8us extend_low (Vec16uc const & a) {"},
{"lineNum":" 5471","line":"    return    _mm_unpacklo_epi8(a,_mm_setzero_si128());    // interleave with zero extensions"},
{"lineNum":" 5472","line":"}"},
{"lineNum":" 5473","line":""},
{"lineNum":" 5474","line":"// Function extend_high : extends the high 8 elements to 16 bits with zero extension"},
{"lineNum":" 5475","line":"static inline Vec8us extend_high (Vec16uc const & a) {"},
{"lineNum":" 5476","line":"    return    _mm_unpackhi_epi8(a,_mm_setzero_si128());    // interleave with zero extensions"},
{"lineNum":" 5477","line":"}"},
{"lineNum":" 5478","line":""},
{"lineNum":" 5479","line":"// Extend 16-bit integers to 32-bit integers, signed and unsigned"},
{"lineNum":" 5480","line":""},
{"lineNum":" 5481","line":"// Function extend_low : extends the low 4 elements to 32 bits with sign extension"},
{"lineNum":" 5482","line":"static inline Vec4i extend_low (Vec8s const & a) {"},
{"lineNum":" 5483","line":"    __m128i sign = _mm_srai_epi16(a,15);                   // sign bit"},
{"lineNum":" 5484","line":"    return         _mm_unpacklo_epi16(a,sign);             // interleave with sign extensions"},
{"lineNum":" 5485","line":"}"},
{"lineNum":" 5486","line":""},
{"lineNum":" 5487","line":"// Function extend_high : extends the high 4 elements to 32 bits with sign extension"},
{"lineNum":" 5488","line":"static inline Vec4i extend_high (Vec8s const & a) {"},
{"lineNum":" 5489","line":"    __m128i sign = _mm_srai_epi16(a,15);                   // sign bit"},
{"lineNum":" 5490","line":"    return         _mm_unpackhi_epi16(a,sign);             // interleave with sign extensions"},
{"lineNum":" 5491","line":"}"},
{"lineNum":" 5492","line":""},
{"lineNum":" 5493","line":"// Function extend_low : extends the low 4 elements to 32 bits with zero extension"},
{"lineNum":" 5494","line":"static inline Vec4ui extend_low (Vec8us const & a) {"},
{"lineNum":" 5495","line":"    return    _mm_unpacklo_epi16(a,_mm_setzero_si128());   // interleave with zero extensions"},
{"lineNum":" 5496","line":"}"},
{"lineNum":" 5497","line":""},
{"lineNum":" 5498","line":"// Function extend_high : extends the high 4 elements to 32 bits with zero extension"},
{"lineNum":" 5499","line":"static inline Vec4ui extend_high (Vec8us const & a) {"},
{"lineNum":" 5500","line":"    return    _mm_unpackhi_epi16(a,_mm_setzero_si128());   // interleave with zero extensions"},
{"lineNum":" 5501","line":"}"},
{"lineNum":" 5502","line":""},
{"lineNum":" 5503","line":"// Extend 32-bit integers to 64-bit integers, signed and unsigned"},
{"lineNum":" 5504","line":""},
{"lineNum":" 5505","line":"// Function extend_low : extends the low 2 elements to 64 bits with sign extension"},
{"lineNum":" 5506","line":"static inline Vec2q extend_low (Vec4i const & a) {"},
{"lineNum":" 5507","line":"    __m128i sign = _mm_srai_epi32(a,31);                   // sign bit"},
{"lineNum":" 5508","line":"    return         _mm_unpacklo_epi32(a,sign);             // interleave with sign extensions"},
{"lineNum":" 5509","line":"}"},
{"lineNum":" 5510","line":""},
{"lineNum":" 5511","line":"// Function extend_high : extends the high 2 elements to 64 bits with sign extension"},
{"lineNum":" 5512","line":"static inline Vec2q extend_high (Vec4i const & a) {"},
{"lineNum":" 5513","line":"    __m128i sign = _mm_srai_epi32(a,31);                   // sign bit"},
{"lineNum":" 5514","line":"    return         _mm_unpackhi_epi32(a,sign);             // interleave with sign extensions"},
{"lineNum":" 5515","line":"}"},
{"lineNum":" 5516","line":""},
{"lineNum":" 5517","line":"// Function extend_low : extends the low 2 elements to 64 bits with zero extension"},
{"lineNum":" 5518","line":"static inline Vec2uq extend_low (Vec4ui const & a) {"},
{"lineNum":" 5519","line":"    return    _mm_unpacklo_epi32(a,_mm_setzero_si128());   // interleave with zero extensions"},
{"lineNum":" 5520","line":"}"},
{"lineNum":" 5521","line":""},
{"lineNum":" 5522","line":"// Function extend_high : extends the high 2 elements to 64 bits with zero extension"},
{"lineNum":" 5523","line":"static inline Vec2uq extend_high (Vec4ui const & a) {"},
{"lineNum":" 5524","line":"    return    _mm_unpackhi_epi32(a,_mm_setzero_si128());   // interleave with zero extensions"},
{"lineNum":" 5525","line":"}"},
{"lineNum":" 5526","line":""},
{"lineNum":" 5527","line":"// Compress 16-bit integers to 8-bit integers, signed and unsigned, with and without saturation"},
{"lineNum":" 5528","line":""},
{"lineNum":" 5529","line":"// Function compress : packs two vectors of 16-bit integers into one vector of 8-bit integers"},
{"lineNum":" 5530","line":"// Overflow wraps around"},
{"lineNum":" 5531","line":"static inline Vec16c compress (Vec8s const & low, Vec8s const & high) {"},
{"lineNum":" 5532","line":"    __m128i mask  = _mm_set1_epi32(0x00FF00FF);            // mask for low bytes"},
{"lineNum":" 5533","line":"    __m128i lowm  = _mm_and_si128(low,mask);               // bytes of low"},
{"lineNum":" 5534","line":"    __m128i highm = _mm_and_si128(high,mask);              // bytes of high"},
{"lineNum":" 5535","line":"    return  _mm_packus_epi16(lowm,highm);                  // unsigned pack"},
{"lineNum":" 5536","line":"}"},
{"lineNum":" 5537","line":""},
{"lineNum":" 5538","line":"// Function compress : packs two vectors of 16-bit integers into one vector of 8-bit integers"},
{"lineNum":" 5539","line":"// Signed, with saturation"},
{"lineNum":" 5540","line":"static inline Vec16c compress_saturated (Vec8s const & low, Vec8s const & high) {"},
{"lineNum":" 5541","line":"    return  _mm_packs_epi16(low,high);"},
{"lineNum":" 5542","line":"}"},
{"lineNum":" 5543","line":""},
{"lineNum":" 5544","line":"// Function compress : packs two vectors of 16-bit integers to one vector of 8-bit integers"},
{"lineNum":" 5545","line":"// Unsigned, overflow wraps around"},
{"lineNum":" 5546","line":"static inline Vec16uc compress (Vec8us const & low, Vec8us const & high) {"},
{"lineNum":" 5547","line":"    return  Vec16uc (compress((Vec8s)low, (Vec8s)high));"},
{"lineNum":" 5548","line":"}"},
{"lineNum":" 5549","line":""},
{"lineNum":" 5550","line":"// Function compress : packs two vectors of 16-bit integers into one vector of 8-bit integers"},
{"lineNum":" 5551","line":"// Unsigned, with saturation"},
{"lineNum":" 5552","line":"static inline Vec16uc compress_saturated (Vec8us const & low, Vec8us const & high) {"},
{"lineNum":" 5553","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 5554","line":"    __m128i maxval  = _mm_set1_epi32(0x00FF00FF);          // maximum value"},
{"lineNum":" 5555","line":"    __m128i low1    = _mm_min_epu16(low,maxval);           // upper limit"},
{"lineNum":" 5556","line":"    __m128i high1   = _mm_min_epu16(high,maxval);          // upper limit"},
{"lineNum":" 5557","line":"    return            _mm_packus_epi16(low1,high1);        // this instruction saturates from signed 32 bit to unsigned 16 bit"},
{"lineNum":" 5558","line":"#else"},
{"lineNum":" 5559","line":"    __m128i zero    = _mm_setzero_si128();                 // 0"},
{"lineNum":" 5560","line":"    __m128i signlow = _mm_cmpgt_epi16(zero,low);           // sign bit of low"},
{"lineNum":" 5561","line":"    __m128i signhi  = _mm_cmpgt_epi16(zero,high);          // sign bit of high"},
{"lineNum":" 5562","line":"    __m128i slow2   = _mm_srli_epi16(signlow,8);           // FF if low negative"},
{"lineNum":" 5563","line":"    __m128i shigh2  = _mm_srli_epi16(signhi,8);            // FF if high negative"},
{"lineNum":" 5564","line":"    __m128i maskns  = _mm_set1_epi32(0x7FFF7FFF);          // mask for removing sign bit"},
{"lineNum":" 5565","line":"    __m128i lowns   = _mm_and_si128(low,maskns);           // low,  with sign bit removed"},
{"lineNum":" 5566","line":"    __m128i highns  = _mm_and_si128(high,maskns);          // high, with sign bit removed"},
{"lineNum":" 5567","line":"    __m128i lowo    = _mm_or_si128(lowns,slow2);           // low,  sign bit replaced by 00FF"},
{"lineNum":" 5568","line":"    __m128i higho   = _mm_or_si128(highns,shigh2);         // high, sign bit replaced by 00FF"},
{"lineNum":" 5569","line":"    return            _mm_packus_epi16(lowo,higho);        // this instruction saturates from signed 16 bit to unsigned 8 bit"},
{"lineNum":" 5570","line":"#endif"},
{"lineNum":" 5571","line":"}"},
{"lineNum":" 5572","line":""},
{"lineNum":" 5573","line":"// Compress 32-bit integers to 16-bit integers, signed and unsigned, with and without saturation"},
{"lineNum":" 5574","line":""},
{"lineNum":" 5575","line":"// Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers"},
{"lineNum":" 5576","line":"// Overflow wraps around"},
{"lineNum":" 5577","line":"static inline Vec8s compress (Vec4i const & low, Vec4i const & high) {"},
{"lineNum":" 5578","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 5579","line":"    __m128i mask  = _mm_set1_epi32(0x0000FFFF);            // mask for low words"},
{"lineNum":" 5580","line":"    __m128i lowm  = _mm_and_si128(low,mask);               // bytes of low"},
{"lineNum":" 5581","line":"    __m128i highm = _mm_and_si128(high,mask);              // bytes of high"},
{"lineNum":" 5582","line":"    return  _mm_packus_epi32(lowm,highm);                  // unsigned pack"},
{"lineNum":" 5583","line":"#else"},
{"lineNum":" 5584","line":"    __m128i low1  = _mm_shufflelo_epi16(low,0xD8);         // low words in place"},
{"lineNum":" 5585","line":"    __m128i high1 = _mm_shufflelo_epi16(high,0xD8);        // low words in place"},
{"lineNum":" 5586","line":"    __m128i low2  = _mm_shufflehi_epi16(low1,0xD8);        // low words in place"},
{"lineNum":" 5587","line":"    __m128i high2 = _mm_shufflehi_epi16(high1,0xD8);       // low words in place"},
{"lineNum":" 5588","line":"    __m128i low3  = _mm_shuffle_epi32(low2,0xD8);          // low dwords of low  to pos. 0 and 32"},
{"lineNum":" 5589","line":"    __m128i high3 = _mm_shuffle_epi32(high2,0xD8);         // low dwords of high to pos. 0 and 32"},
{"lineNum":" 5590","line":"    return  _mm_unpacklo_epi64(low3,high3);                // interleave"},
{"lineNum":" 5591","line":"#endif"},
{"lineNum":" 5592","line":"}"},
{"lineNum":" 5593","line":""},
{"lineNum":" 5594","line":"// Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers"},
{"lineNum":" 5595","line":"// Signed with saturation"},
{"lineNum":" 5596","line":"static inline Vec8s compress_saturated (Vec4i const & low, Vec4i const & high) {"},
{"lineNum":" 5597","line":"    return  _mm_packs_epi32(low,high);                     // pack with signed saturation"},
{"lineNum":" 5598","line":"}"},
{"lineNum":" 5599","line":""},
{"lineNum":" 5600","line":"// Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers"},
{"lineNum":" 5601","line":"// Overflow wraps around"},
{"lineNum":" 5602","line":"static inline Vec8us compress (Vec4ui const & low, Vec4ui const & high) {"},
{"lineNum":" 5603","line":"    return Vec8us (compress((Vec4i)low, (Vec4i)high));"},
{"lineNum":" 5604","line":"}"},
{"lineNum":" 5605","line":""},
{"lineNum":" 5606","line":"// Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers"},
{"lineNum":" 5607","line":"// Unsigned, with saturation"},
{"lineNum":" 5608","line":"static inline Vec8us compress_saturated (Vec4ui const & low, Vec4ui const & high) {"},
{"lineNum":" 5609","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 5610","line":"    __m128i maxval  = _mm_set1_epi32(0x0000FFFF);          // maximum value"},
{"lineNum":" 5611","line":"    __m128i low1    = _mm_min_epu32(low,maxval);           // upper limit"},
{"lineNum":" 5612","line":"    __m128i high1   = _mm_min_epu32(high,maxval);          // upper limit"},
{"lineNum":" 5613","line":"    return            _mm_packus_epi32(low1,high1);        // this instruction saturates from signed 32 bit to unsigned 16 bit"},
{"lineNum":" 5614","line":"#else"},
{"lineNum":" 5615","line":"    __m128i zero     = _mm_setzero_si128();                // 0"},
{"lineNum":" 5616","line":"    __m128i lowzero  = _mm_cmpeq_epi16(low,zero);          // for each word is zero"},
{"lineNum":" 5617","line":"    __m128i highzero = _mm_cmpeq_epi16(high,zero);         // for each word is zero"},
{"lineNum":" 5618","line":"    __m128i mone     = _mm_set1_epi32(-1);                 // FFFFFFFF"},
{"lineNum":" 5619","line":"    __m128i lownz    = _mm_xor_si128(lowzero,mone);        // for each word is nonzero"},
{"lineNum":" 5620","line":"    __m128i highnz   = _mm_xor_si128(highzero,mone);       // for each word is nonzero"},
{"lineNum":" 5621","line":"    __m128i lownz2   = _mm_srli_epi32(lownz,16);           // shift down to low dword"},
{"lineNum":" 5622","line":"    __m128i highnz2  = _mm_srli_epi32(highnz,16);          // shift down to low dword"},
{"lineNum":" 5623","line":"    __m128i lowsatur = _mm_or_si128(low,lownz2);           // low, saturated"},
{"lineNum":" 5624","line":"    __m128i hisatur  = _mm_or_si128(high,highnz2);         // high, saturated"},
{"lineNum":" 5625","line":"    return  Vec8us (compress(Vec4i(lowsatur), Vec4i(hisatur)));"},
{"lineNum":" 5626","line":"#endif"},
{"lineNum":" 5627","line":"}"},
{"lineNum":" 5628","line":""},
{"lineNum":" 5629","line":"// Compress 64-bit integers to 32-bit integers, signed and unsigned, with and without saturation"},
{"lineNum":" 5630","line":""},
{"lineNum":" 5631","line":"// Function compress : packs two vectors of 64-bit integers into one vector of 32-bit integers"},
{"lineNum":" 5632","line":"// Overflow wraps around"},
{"lineNum":" 5633","line":"static inline Vec4i compress (Vec2q const & low, Vec2q const & high) {"},
{"lineNum":" 5634","line":"    __m128i low2  = _mm_shuffle_epi32(low,0xD8);           // low dwords of low  to pos. 0 and 32"},
{"lineNum":" 5635","line":"    __m128i high2 = _mm_shuffle_epi32(high,0xD8);          // low dwords of high to pos. 0 and 32"},
{"lineNum":" 5636","line":"    return  _mm_unpacklo_epi64(low2,high2);                // interleave"},
{"lineNum":" 5637","line":"}"},
{"lineNum":" 5638","line":""},
{"lineNum":" 5639","line":"// Function compress : packs two vectors of 64-bit integers into one vector of 32-bit integers"},
{"lineNum":" 5640","line":"// Signed, with saturation"},
{"lineNum":" 5641","line":"// This function is very inefficient unless the SSE4.2 instruction set is supported"},
{"lineNum":" 5642","line":"static inline Vec4i compress_saturated (Vec2q const & low, Vec2q const & high) {"},
{"lineNum":" 5643","line":"    Vec2q maxval = _mm_set_epi32(0,0x7FFFFFFF,0,0x7FFFFFFF);"},
{"lineNum":" 5644","line":"    Vec2q minval = _mm_set_epi32(-1,0x80000000,-1,0x80000000);"},
{"lineNum":" 5645","line":"    Vec2q low1   = min(low,maxval);"},
{"lineNum":" 5646","line":"    Vec2q high1  = min(high,maxval);"},
{"lineNum":" 5647","line":"    Vec2q low2   = max(low1,minval);"},
{"lineNum":" 5648","line":"    Vec2q high2  = max(high1,minval);"},
{"lineNum":" 5649","line":"    return compress(low2,high2);"},
{"lineNum":" 5650","line":"}"},
{"lineNum":" 5651","line":""},
{"lineNum":" 5652","line":"// Function compress : packs two vectors of 32-bit integers into one vector of 16-bit integers"},
{"lineNum":" 5653","line":"// Overflow wraps around"},
{"lineNum":" 5654","line":"static inline Vec4ui compress (Vec2uq const & low, Vec2uq const & high) {"},
{"lineNum":" 5655","line":"    return Vec4ui (compress((Vec2q)low, (Vec2q)high));"},
{"lineNum":" 5656","line":"}"},
{"lineNum":" 5657","line":""},
{"lineNum":" 5658","line":"// Function compress : packs two vectors of 64-bit integers into one vector of 32-bit integers"},
{"lineNum":" 5659","line":"// Unsigned, with saturation"},
{"lineNum":" 5660","line":"static inline Vec4ui compress_saturated (Vec2uq const & low, Vec2uq const & high) {"},
{"lineNum":" 5661","line":"    __m128i zero     = _mm_setzero_si128();                // 0"},
{"lineNum":" 5662","line":"    __m128i lowzero  = _mm_cmpeq_epi32(low,zero);          // for each dword is zero"},
{"lineNum":" 5663","line":"    __m128i highzero = _mm_cmpeq_epi32(high,zero);         // for each dword is zero"},
{"lineNum":" 5664","line":"    __m128i mone     = _mm_set1_epi32(-1);                 // FFFFFFFF"},
{"lineNum":" 5665","line":"    __m128i lownz    = _mm_xor_si128(lowzero,mone);        // for each dword is nonzero"},
{"lineNum":" 5666","line":"    __m128i highnz   = _mm_xor_si128(highzero,mone);       // for each dword is nonzero"},
{"lineNum":" 5667","line":"    __m128i lownz2   = _mm_srli_epi64(lownz,32);           // shift down to low dword"},
{"lineNum":" 5668","line":"    __m128i highnz2  = _mm_srli_epi64(highnz,32);          // shift down to low dword"},
{"lineNum":" 5669","line":"    __m128i lowsatur = _mm_or_si128(low,lownz2);           // low, saturated"},
{"lineNum":" 5670","line":"    __m128i hisatur  = _mm_or_si128(high,highnz2);         // high, saturated"},
{"lineNum":" 5671","line":"    return  Vec4ui (compress(Vec2q(lowsatur), Vec2q(hisatur)));"},
{"lineNum":" 5672","line":"}"},
{"lineNum":" 5673","line":""},
{"lineNum":" 5674","line":""},
{"lineNum":" 5675","line":""},
{"lineNum":" 5676","line":"/*****************************************************************************"},
{"lineNum":" 5677","line":"*"},
{"lineNum":" 5678","line":"*          Integer division operators"},
{"lineNum":" 5679","line":"*"},
{"lineNum":" 5680","line":"******************************************************************************"},
{"lineNum":" 5681","line":"*"},
{"lineNum":" 5682","line":"* The instruction set does not support integer vector division. Instead, we"},
{"lineNum":" 5683","line":"* are using a method for fast integer division based on multiplication and"},
{"lineNum":" 5684","line":"* shift operations. This method is faster than simple integer division if the"},
{"lineNum":" 5685","line":"* same divisor is used multiple times."},
{"lineNum":" 5686","line":"*"},
{"lineNum":" 5687","line":"* All elements in a vector are divided by the same divisor. It is not possible"},
{"lineNum":" 5688","line":"* to divide different elements of the same vector by different divisors."},
{"lineNum":" 5689","line":"*"},
{"lineNum":" 5690","line":"* The parameters used for fast division are stored in an object of a"},
{"lineNum":" 5691","line":"* Divisor class. This object can be created implicitly, for example in:"},
{"lineNum":" 5692","line":"*        Vec4i a, b; int c;"},
{"lineNum":" 5693","line":"*        a = b / c;"},
{"lineNum":" 5694","line":"* or explicitly as:"},
{"lineNum":" 5695","line":"*        a = b / Divisor_i(c);"},
{"lineNum":" 5696","line":"*"},
{"lineNum":" 5697","line":"* It takes more time to compute the parameters used for fast division than to"},
{"lineNum":" 5698","line":"* do the division. Therefore, it is advantageous to use the same divisor object"},
{"lineNum":" 5699","line":"* multiple times. For example, to divide 80 unsigned short integers by 10:"},
{"lineNum":" 5700","line":"*"},
{"lineNum":" 5701","line":"*        uint16_t dividends[80], quotients[80];         // numbers to work with"},
{"lineNum":" 5702","line":"*        Divisor_us div10(10);                          // make divisor object for dividing by 10"},
{"lineNum":" 5703","line":"*        Vec8us temp;                                   // temporary vector"},
{"lineNum":" 5704","line":"*        for (int i = 0; i < 80; i += 8) {              // loop for 4 elements per iteration"},
{"lineNum":" 5705","line":"*            temp.load(dividends+i);                    // load 4 elements"},
{"lineNum":" 5706","line":"*            temp /= div10;                             // divide each element by 10"},
{"lineNum":" 5707","line":"*            temp.store(quotients+i);                   // store 4 elements"},
{"lineNum":" 5708","line":"*        }"},
{"lineNum":" 5709","line":"*"},
{"lineNum":" 5710","line":"* The parameters for fast division can also be computed at compile time. This is"},
{"lineNum":" 5711","line":"* an advantage if the divisor is known at compile time. Use the const_int or const_uint"},
{"lineNum":" 5712","line":"* macro to do this. For example, for signed integers:"},
{"lineNum":" 5713","line":"*        Vec8s a, b;"},
{"lineNum":" 5714","line":"*        a = b / const_int(10);"},
{"lineNum":" 5715","line":"* Or, for unsigned integers:"},
{"lineNum":" 5716","line":"*        Vec8us a, b;"},
{"lineNum":" 5717","line":"*        a = b / const_uint(10);"},
{"lineNum":" 5718","line":"*"},
{"lineNum":" 5719","line":"* The division of a vector of 16-bit integers is faster than division of a vector"},
{"lineNum":" 5720","line":"* of other integer sizes."},
{"lineNum":" 5721","line":"*"},
{"lineNum":" 5722","line":"*"},
{"lineNum":" 5723","line":"* Mathematical formula, used for signed division with fixed or variable divisor:"},
{"lineNum":" 5724","line":"* (From T. Granlund and P. L. Montgomery: Division by Invariant Integers Using Multiplication,"},
{"lineNum":" 5725","line":"* Proceedings of the SIGPLAN 1994 Conference on Programming Language Design and Implementation."},
{"lineNum":" 5726","line":"* http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.1.2556 )"},
{"lineNum":" 5727","line":"* x = dividend"},
{"lineNum":" 5728","line":"* d = abs(divisor)"},
{"lineNum":" 5729","line":"* w = integer word size, bits"},
{"lineNum":" 5730","line":"* L = ceil(log2(d)) = bit_scan_reverse(d-1)+1"},
{"lineNum":" 5731","line":"* L = max(L,1)"},
{"lineNum":" 5732","line":"* m = 1 + 2^(w+L-1)/d - 2^w                      [division should overflow to 0 if d = 1]"},
{"lineNum":" 5733","line":"* sh1 = L-1"},
{"lineNum":" 5734","line":"* q = x + (m*x >> w)                             [high part of signed multiplication with 2w bits]"},
{"lineNum":" 5735","line":"* q = (q >> sh1) - (x<0 ? -1 : 0)"},
{"lineNum":" 5736","line":"* if (divisor < 0) q = -q"},
{"lineNum":" 5737","line":"* result = trunc(x/d) = q"},
{"lineNum":" 5738","line":"*"},
{"lineNum":" 5739","line":"* Mathematical formula, used for unsigned division with variable divisor:"},
{"lineNum":" 5740","line":"* (Also from T. Granlund and P. L. Montgomery)"},
{"lineNum":" 5741","line":"* x = dividend"},
{"lineNum":" 5742","line":"* d = divisor"},
{"lineNum":" 5743","line":"* w = integer word size, bits"},
{"lineNum":" 5744","line":"* L = ceil(log2(d)) = bit_scan_reverse(d-1)+1"},
{"lineNum":" 5745","line":"* m = 1 + 2^w * (2^L-d) / d                      [2^L should overflow to 0 if L = w]"},
{"lineNum":" 5746","line":"* sh1 = min(L,1)"},
{"lineNum":" 5747","line":"* sh2 = max(L-1,0)"},
{"lineNum":" 5748","line":"* t = m*x >> w                                   [high part of unsigned multiplication with 2w bits]"},
{"lineNum":" 5749","line":"* result = floor(x/d) = (((x-t) >> sh1) + t) >> sh2"},
{"lineNum":" 5750","line":"*"},
{"lineNum":" 5751","line":"* Mathematical formula, used for unsigned division with fixed divisor:"},
{"lineNum":" 5752","line":"* (From Terje Mathisen, unpublished)"},
{"lineNum":" 5753","line":"* x = dividend"},
{"lineNum":" 5754","line":"* d = divisor"},
{"lineNum":" 5755","line":"* w = integer word size, bits"},
{"lineNum":" 5756","line":"* b = floor(log2(d)) = bit_scan_reverse(d)"},
{"lineNum":" 5757","line":"* f = 2^(w+b) / d                                [exact division]"},
{"lineNum":" 5758","line":"* If f is an integer then d is a power of 2 then go to case A"},
{"lineNum":" 5759","line":"* If the fractional part of f is < 0.5 then go to case B"},
{"lineNum":" 5760","line":"* If the fractional part of f is > 0.5 then go to case C"},
{"lineNum":" 5761","line":"* Case A:  [shift only]"},
{"lineNum":" 5762","line":"* result = x >> b"},
{"lineNum":" 5763","line":"* Case B:  [round down f and compensate by adding one to x]"},
{"lineNum":" 5764","line":"* result = ((x+1)*floor(f)) >> (w+b)             [high part of unsigned multiplication with 2w bits]"},
{"lineNum":" 5765","line":"* Case C:  [round up f, no compensation for rounding error]"},
{"lineNum":" 5766","line":"* result = (x*ceil(f)) >> (w+b)                  [high part of unsigned multiplication with 2w bits]"},
{"lineNum":" 5767","line":"*"},
{"lineNum":" 5768","line":"*"},
{"lineNum":" 5769","line":"*****************************************************************************/"},
{"lineNum":" 5770","line":""},
{"lineNum":" 5771","line":"// encapsulate parameters for fast division on vector of 4 32-bit signed integers"},
{"lineNum":" 5772","line":"class Divisor_i {"},
{"lineNum":" 5773","line":"protected:"},
{"lineNum":" 5774","line":"    __m128i multiplier;                                    // multiplier used in fast division"},
{"lineNum":" 5775","line":"    __m128i shift1;                                        // shift count used in fast division"},
{"lineNum":" 5776","line":"    __m128i sign;                                          // sign of divisor"},
{"lineNum":" 5777","line":"public:"},
{"lineNum":" 5778","line":"    Divisor_i() {};                                        // Default constructor"},
{"lineNum":" 5779","line":"    Divisor_i(int32_t d) {                                 // Constructor with divisor"},
{"lineNum":" 5780","line":"        set(d);"},
{"lineNum":" 5781","line":"    }"},
{"lineNum":" 5782","line":"    Divisor_i(int m, int s1, int sgn) {                    // Constructor with precalculated multiplier, shift and sign"},
{"lineNum":" 5783","line":"        multiplier = _mm_set1_epi32(m);"},
{"lineNum":" 5784","line":"        shift1     = _mm_cvtsi32_si128(s1);"},
{"lineNum":" 5785","line":"        sign       = _mm_set1_epi32(sgn);"},
{"lineNum":" 5786","line":"    }"},
{"lineNum":" 5787","line":"    void set(int32_t d) {                                  // Set or change divisor, calculate parameters"},
{"lineNum":" 5788","line":"        const int32_t d1 = ::abs(d);"},
{"lineNum":" 5789","line":"        int32_t sh, m;"},
{"lineNum":" 5790","line":"        if (d1 > 1) {"},
{"lineNum":" 5791","line":"            sh = (int)bit_scan_reverse(uint32_t(d1-1));    // shift count = ceil(log2(d1))-1 = (bit_scan_reverse(d1-1)+1)-1"},
{"lineNum":" 5792","line":"            m = int32_t((int64_t(1) << (32+sh)) / d1 - ((int64_t(1) << 32) - 1)); // calculate multiplier"},
{"lineNum":" 5793","line":"        }"},
{"lineNum":" 5794","line":"        else {"},
{"lineNum":" 5795","line":"            m  = 1;                                        // for d1 = 1"},
{"lineNum":" 5796","line":"            sh = 0;"},
{"lineNum":" 5797","line":"            if (d == 0) m /= d;                            // provoke error here if d = 0"},
{"lineNum":" 5798","line":"            if (uint32_t(d) == 0x80000000u) {              // fix overflow for this special case"},
{"lineNum":" 5799","line":"                m  = 0x80000001;"},
{"lineNum":" 5800","line":"                sh = 30;"},
{"lineNum":" 5801","line":"            }"},
{"lineNum":" 5802","line":"        }"},
{"lineNum":" 5803","line":"        multiplier = _mm_set1_epi32(m);                    // broadcast multiplier"},
{"lineNum":" 5804","line":"        shift1     = _mm_cvtsi32_si128(sh);                // shift count"},
{"lineNum":" 5805","line":"        //sign     = _mm_set1_epi32(d < 0 ? -1 : 0);       // bug in VS2019, 32 bit release. Replace by this:"},
{"lineNum":" 5806","line":"        if (d < 0) sign = _mm_set1_epi32(-1); else sign = _mm_set1_epi32(0);  // sign of divisor"},
{"lineNum":" 5807","line":"    }"},
{"lineNum":" 5808","line":"    __m128i getm() const {                                 // get multiplier"},
{"lineNum":" 5809","line":"        return multiplier;"},
{"lineNum":" 5810","line":"    }"},
{"lineNum":" 5811","line":"    __m128i gets1() const {                                // get shift count"},
{"lineNum":" 5812","line":"        return shift1;"},
{"lineNum":" 5813","line":"    }"},
{"lineNum":" 5814","line":"    __m128i getsign() const {                              // get sign of divisor"},
{"lineNum":" 5815","line":"        return sign;"},
{"lineNum":" 5816","line":"    }"},
{"lineNum":" 5817","line":"};"},
{"lineNum":" 5818","line":""},
{"lineNum":" 5819","line":"// encapsulate parameters for fast division on vector of 4 32-bit unsigned integers"},
{"lineNum":" 5820","line":"class Divisor_ui {"},
{"lineNum":" 5821","line":"protected:"},
{"lineNum":" 5822","line":"    __m128i multiplier;                                    // multiplier used in fast division"},
{"lineNum":" 5823","line":"    __m128i shift1;                                        // shift count 1 used in fast division"},
{"lineNum":" 5824","line":"    __m128i shift2;                                        // shift count 2 used in fast division"},
{"lineNum":" 5825","line":"public:"},
{"lineNum":" 5826","line":"    Divisor_ui() {};                                       // Default constructor"},
{"lineNum":" 5827","line":"    Divisor_ui(uint32_t d) {                               // Constructor with divisor"},
{"lineNum":" 5828","line":"        set(d);"},
{"lineNum":" 5829","line":"    }"},
{"lineNum":" 5830","line":"    Divisor_ui(uint32_t m, int s1, int s2) {               // Constructor with precalculated multiplier and shifts"},
{"lineNum":" 5831","line":"        multiplier = _mm_set1_epi32((int32_t)m);"},
{"lineNum":" 5832","line":"        shift1     = _mm_setr_epi32(s1, 0, 0, 0);"},
{"lineNum":" 5833","line":"        shift2     = _mm_setr_epi32(s2, 0, 0, 0);"},
{"lineNum":" 5834","line":"    }"},
{"lineNum":" 5835","line":"    void set(uint32_t d) {                                 // Set or change divisor, calculate parameters"},
{"lineNum":" 5836","line":"        uint32_t L, L2, sh1, sh2, m;"},
{"lineNum":" 5837","line":"        switch (d) {"},
{"lineNum":" 5838","line":"        case 0:"},
{"lineNum":" 5839","line":"            m = sh1 = sh2 = 1 / d;                         // provoke error for d = 0"},
{"lineNum":" 5840","line":"            break;"},
{"lineNum":" 5841","line":"        case 1:"},
{"lineNum":" 5842","line":"            m = 1; sh1 = sh2 = 0;                          // parameters for d = 1"},
{"lineNum":" 5843","line":"            break;"},
{"lineNum":" 5844","line":"        case 2:"},
{"lineNum":" 5845","line":"            m = 1; sh1 = 1; sh2 = 0;                       // parameters for d = 2"},
{"lineNum":" 5846","line":"            break;"},
{"lineNum":" 5847","line":"        default:                                           // general case for d > 2"},
{"lineNum":" 5848","line":"            L  = bit_scan_reverse(d-1)+1;                  // ceil(log2(d))"},
{"lineNum":" 5849","line":"            L2 = uint32_t(L < 32 ? 1 << L : 0);            // 2^L, overflow to 0 if L = 32"},
{"lineNum":" 5850","line":"            m  = 1 + uint32_t((uint64_t(L2 - d) << 32) / d); // multiplier"},
{"lineNum":" 5851","line":"            sh1 = 1;  sh2 = L - 1;                         // shift counts"},
{"lineNum":" 5852","line":"        }"},
{"lineNum":" 5853","line":"        multiplier = _mm_set1_epi32((int32_t)m);"},
{"lineNum":" 5854","line":"        shift1     = _mm_setr_epi32((int32_t)sh1, 0, 0, 0);"},
{"lineNum":" 5855","line":"        shift2     = _mm_setr_epi32((int32_t)sh2, 0, 0, 0);"},
{"lineNum":" 5856","line":"    }"},
{"lineNum":" 5857","line":"    __m128i getm() const {                                 // get multiplier"},
{"lineNum":" 5858","line":"        return multiplier;"},
{"lineNum":" 5859","line":"    }"},
{"lineNum":" 5860","line":"    __m128i gets1() const {                                // get shift count 1"},
{"lineNum":" 5861","line":"        return shift1;"},
{"lineNum":" 5862","line":"    }"},
{"lineNum":" 5863","line":"    __m128i gets2() const {                                // get shift count 2"},
{"lineNum":" 5864","line":"        return shift2;"},
{"lineNum":" 5865","line":"    }"},
{"lineNum":" 5866","line":"};"},
{"lineNum":" 5867","line":""},
{"lineNum":" 5868","line":""},
{"lineNum":" 5869","line":"// encapsulate parameters for fast division on vector of 8 16-bit signed integers"},
{"lineNum":" 5870","line":"class Divisor_s {"},
{"lineNum":" 5871","line":"protected:"},
{"lineNum":" 5872","line":"    __m128i multiplier;                                    // multiplier used in fast division"},
{"lineNum":" 5873","line":"    __m128i shift1;                                        // shift count used in fast division"},
{"lineNum":" 5874","line":"    __m128i sign;                                          // sign of divisor"},
{"lineNum":" 5875","line":"public:"},
{"lineNum":" 5876","line":"    Divisor_s() {};                                        // Default constructor"},
{"lineNum":" 5877","line":"    Divisor_s(int16_t d) {                                 // Constructor with divisor"},
{"lineNum":" 5878","line":"        set(d);"},
{"lineNum":" 5879","line":"    }"},
{"lineNum":" 5880","line":"    Divisor_s(int16_t m, int s1, int sgn) {                // Constructor with precalculated multiplier, shift and sign"},
{"lineNum":" 5881","line":"        multiplier = _mm_set1_epi16(m);"},
{"lineNum":" 5882","line":"        shift1     = _mm_setr_epi32(s1, 0, 0, 0);"},
{"lineNum":" 5883","line":"        sign       = _mm_set1_epi32(sgn);"},
{"lineNum":" 5884","line":"    }"},
{"lineNum":" 5885","line":"    void set(int16_t d) {                                  // Set or change divisor, calculate parameters"},
{"lineNum":" 5886","line":"        const int32_t d1 = ::abs(d);"},
{"lineNum":" 5887","line":"        int32_t sh, m;"},
{"lineNum":" 5888","line":"        if (d1 > 1) {"},
{"lineNum":" 5889","line":"            sh = (int32_t)bit_scan_reverse(uint32_t(d1-1));         // shift count = ceil(log2(d1))-1 = (bit_scan_reverse(d1-1)+1)-1"},
{"lineNum":" 5890","line":"            m = ((int32_t(1) << (16+sh)) / d1 - ((int32_t(1) << 16) - 1)); // calculate multiplier"},
{"lineNum":" 5891","line":"        }"},
{"lineNum":" 5892","line":"        else {"},
{"lineNum":" 5893","line":"            m  = 1;                                        // for d1 = 1"},
{"lineNum":" 5894","line":"            sh = 0;"},
{"lineNum":" 5895","line":"            if (d == 0) m /= d;                            // provoke error here if d = 0"},
{"lineNum":" 5896","line":"            if (uint16_t(d) == 0x8000u) {                  // fix overflow for this special case"},
{"lineNum":" 5897","line":"                m  = 0x8001;"},
{"lineNum":" 5898","line":"                sh = 14;"},
{"lineNum":" 5899","line":"            }"},
{"lineNum":" 5900","line":"        }"},
{"lineNum":" 5901","line":"        multiplier = _mm_set1_epi16(int16_t(m));           // broadcast multiplier"},
{"lineNum":" 5902","line":"        shift1     = _mm_setr_epi32(sh, 0, 0, 0);          // shift count"},
{"lineNum":" 5903","line":"        sign       = _mm_set1_epi32(d < 0 ? -1 : 0);       // sign of divisor"},
{"lineNum":" 5904","line":"    }"},
{"lineNum":" 5905","line":"    __m128i getm() const {                                 // get multiplier"},
{"lineNum":" 5906","line":"        return multiplier;"},
{"lineNum":" 5907","line":"    }"},
{"lineNum":" 5908","line":"    __m128i gets1() const {                                // get shift count"},
{"lineNum":" 5909","line":"        return shift1;"},
{"lineNum":" 5910","line":"    }"},
{"lineNum":" 5911","line":"    __m128i getsign() const {                              // get sign of divisor"},
{"lineNum":" 5912","line":"        return sign;"},
{"lineNum":" 5913","line":"    }"},
{"lineNum":" 5914","line":"};"},
{"lineNum":" 5915","line":""},
{"lineNum":" 5916","line":""},
{"lineNum":" 5917","line":"// encapsulate parameters for fast division on vector of 8 16-bit unsigned integers"},
{"lineNum":" 5918","line":"class Divisor_us {"},
{"lineNum":" 5919","line":"protected:"},
{"lineNum":" 5920","line":"    __m128i multiplier;                                    // multiplier used in fast division"},
{"lineNum":" 5921","line":"    __m128i shift1;                                        // shift count 1 used in fast division"},
{"lineNum":" 5922","line":"    __m128i shift2;                                        // shift count 2 used in fast division"},
{"lineNum":" 5923","line":"public:"},
{"lineNum":" 5924","line":"    Divisor_us() {};                                       // Default constructor"},
{"lineNum":" 5925","line":"    Divisor_us(uint16_t d) {                               // Constructor with divisor"},
{"lineNum":" 5926","line":"        set(d);"},
{"lineNum":" 5927","line":"    }"},
{"lineNum":" 5928","line":"    Divisor_us(uint16_t m, int s1, int s2) {               // Constructor with precalculated multiplier and shifts"},
{"lineNum":" 5929","line":"        multiplier = _mm_set1_epi16((int16_t)m);"},
{"lineNum":" 5930","line":"        shift1     = _mm_setr_epi32(s1, 0, 0, 0);"},
{"lineNum":" 5931","line":"        shift2     = _mm_setr_epi32(s2, 0, 0, 0);"},
{"lineNum":" 5932","line":"    }"},
{"lineNum":" 5933","line":"    void set(uint16_t d) {                                 // Set or change divisor, calculate parameters"},
{"lineNum":" 5934","line":"        uint16_t L, L2, sh1, sh2, m;"},
{"lineNum":" 5935","line":"        switch (d) {"},
{"lineNum":" 5936","line":"        case 0:"},
{"lineNum":" 5937","line":"            m = sh1 = sh2 = 1u / d;                        // provoke error for d = 0"},
{"lineNum":" 5938","line":"            break;"},
{"lineNum":" 5939","line":"        case 1:"},
{"lineNum":" 5940","line":"            m = 1; sh1 = sh2 = 0;                          // parameters for d = 1"},
{"lineNum":" 5941","line":"            break;"},
{"lineNum":" 5942","line":"        case 2:"},
{"lineNum":" 5943","line":"            m = 1; sh1 = 1; sh2 = 0;                       // parameters for d = 2"},
{"lineNum":" 5944","line":"            break;"},
{"lineNum":" 5945","line":"        default:                                           // general case for d > 2"},
{"lineNum":" 5946","line":"            L  = (uint16_t)bit_scan_reverse(d-1u)+1u;      // ceil(log2(d))"},
{"lineNum":" 5947","line":"            L2 = uint16_t(1 << L);                         // 2^L, overflow to 0 if L = 16"},
{"lineNum":" 5948","line":"            m  = 1u + uint16_t((uint32_t(L2 - d) << 16) / d); // multiplier"},
{"lineNum":" 5949","line":"            sh1 = 1;  sh2 = L - 1u;                        // shift counts"},
{"lineNum":" 5950","line":"        }"},
{"lineNum":" 5951","line":"        multiplier = _mm_set1_epi16((int16_t)m);"},
{"lineNum":" 5952","line":"        shift1     = _mm_setr_epi32((int32_t)sh1, 0, 0, 0);"},
{"lineNum":" 5953","line":"        shift2     = _mm_setr_epi32((int32_t)sh2, 0, 0, 0);"},
{"lineNum":" 5954","line":"    }"},
{"lineNum":" 5955","line":"    __m128i getm() const {                                 // get multiplier"},
{"lineNum":" 5956","line":"        return multiplier;"},
{"lineNum":" 5957","line":"    }"},
{"lineNum":" 5958","line":"    __m128i gets1() const {                                // get shift count 1"},
{"lineNum":" 5959","line":"        return shift1;"},
{"lineNum":" 5960","line":"    }"},
{"lineNum":" 5961","line":"    __m128i gets2() const {                                // get shift count 2"},
{"lineNum":" 5962","line":"        return shift2;"},
{"lineNum":" 5963","line":"    }"},
{"lineNum":" 5964","line":"};"},
{"lineNum":" 5965","line":""},
{"lineNum":" 5966","line":""},
{"lineNum":" 5967","line":"// vector operator / : divide each element by divisor"},
{"lineNum":" 5968","line":""},
{"lineNum":" 5969","line":"// vector of 4 32-bit signed integers"},
{"lineNum":" 5970","line":"static inline Vec4i operator / (Vec4i const & a, Divisor_i const & d) {"},
{"lineNum":" 5971","line":"#if defined (__XOP__) && defined (GCC_VERSION) && GCC_VERSION <= 40702/*?*/ && !defined(__INTEL_COMPILER) && !defined(__clang__)"},
{"lineNum":" 5972","line":"#define XOP_MUL_BUG                                       // GCC has bug in XOP multiply"},
{"lineNum":" 5973","line":"// Bug found in GCC version 4.7.0 and 4.7.1"},
{"lineNum":" 5974","line":"#endif"},
{"lineNum":" 5975","line":"// to do: test this when GCC bug is fixed"},
{"lineNum":" 5976","line":"#if defined (__XOP__) && !defined (XOP_MUL_BUG)"},
{"lineNum":" 5977","line":"    __m128i t1  = _mm_mul_epi32(a,d.getm());               // 32x32->64 bit signed multiplication of a[0] and a[2]"},
{"lineNum":" 5978","line":"    __m128i t2  = _mm_srli_epi64(t1,32);                   // high dword of result 0 and 2"},
{"lineNum":" 5979","line":"    __m128i t3  = _mm_macchi_epi32(a,d.getm(),_mm_setzero_si128());// 32x32->64 bit signed multiplication of a[1] and a[3]"},
{"lineNum":" 5980","line":"    __m128i t5  = _mm_set_epi32(-1,0,-1,0);                // mask of dword 1 and 3"},
{"lineNum":" 5981","line":"    __m128i t7  = _mm_blendv_epi8(t2,t3,t5);               // blend two results"},
{"lineNum":" 5982","line":"    __m128i t8  = _mm_add_epi32(t7,a);                     // add"},
{"lineNum":" 5983","line":"    __m128i t9  = _mm_sra_epi32(t8,d.gets1());             // shift right arithmetic"},
{"lineNum":" 5984","line":"    __m128i t10 = _mm_srai_epi32(a,31);                    // sign of a"},
{"lineNum":" 5985","line":"    __m128i t11 = _mm_sub_epi32(t10,d.getsign());          // sign of a - sign of d"},
{"lineNum":" 5986","line":"    __m128i t12 = _mm_sub_epi32(t9,t11);                   // + 1 if a < 0, -1 if d < 0"},
{"lineNum":" 5987","line":"    return        _mm_xor_si128(t12,d.getsign());          // change sign if divisor negative"},
{"lineNum":" 5988","line":""},
{"lineNum":" 5989","line":"#elif INSTRSET >= 5 && !defined (XOP_MUL_BUG)  // SSE4.1 supported"},
{"lineNum":" 5990","line":"    __m128i t1  = _mm_mul_epi32(a,d.getm());               // 32x32->64 bit signed multiplication of a[0] and a[2]"},
{"lineNum":" 5991","line":"    __m128i t2  = _mm_srli_epi64(t1,32);                   // high dword of result 0 and 2"},
{"lineNum":" 5992","line":"    __m128i t3  = _mm_srli_epi64(a,32);                    // get a[1] and a[3] into position for multiplication"},
{"lineNum":" 5993","line":"    __m128i t4  = _mm_mul_epi32(t3,d.getm());              // 32x32->64 bit signed multiplication of a[1] and a[3]"},
{"lineNum":" 5994","line":"    __m128i t5  = _mm_set_epi32(-1,0,-1,0);                // mask of dword 1 and 3"},
{"lineNum":" 5995","line":"    __m128i t7  = _mm_blendv_epi8(t2,t4,t5);               // blend two results"},
{"lineNum":" 5996","line":"    __m128i t8  = _mm_add_epi32(t7,a);                     // add"},
{"lineNum":" 5997","line":"    __m128i t9  = _mm_sra_epi32(t8,d.gets1());             // shift right arithmetic"},
{"lineNum":" 5998","line":"    __m128i t10 = _mm_srai_epi32(a,31);                    // sign of a"},
{"lineNum":" 5999","line":"    __m128i t11 = _mm_sub_epi32(t10,d.getsign());          // sign of a - sign of d"},
{"lineNum":" 6000","line":"    __m128i t12 = _mm_sub_epi32(t9,t11);                   // + 1 if a < 0, -1 if d < 0"},
{"lineNum":" 6001","line":"    return        _mm_xor_si128(t12,d.getsign());          // change sign if divisor negative"},
{"lineNum":" 6002","line":"#else  // not SSE4.1"},
{"lineNum":" 6003","line":"    __m128i t1  = _mm_mul_epu32(a,d.getm());               // 32x32->64 bit unsigned multiplication of a[0] and a[2]"},
{"lineNum":" 6004","line":"    __m128i t2  = _mm_srli_epi64(t1,32);                   // high dword of result 0 and 2"},
{"lineNum":" 6005","line":"    __m128i t3  = _mm_srli_epi64(a,32);                    // get a[1] and a[3] into position for multiplication"},
{"lineNum":" 6006","line":"    __m128i t4  = _mm_mul_epu32(t3,d.getm());              // 32x32->64 bit unsigned multiplication of a[1] and a[3]"},
{"lineNum":" 6007","line":"    __m128i t5  = _mm_set_epi32(-1,0,-1,0);                // mask of dword 1 and 3"},
{"lineNum":" 6008","line":"    __m128i t6  = _mm_and_si128(t4,t5);                    // high dword of result 1 and 3"},
{"lineNum":" 6009","line":"    __m128i t7  = _mm_or_si128(t2,t6);                     // combine all four results of unsigned high mul into one vector"},
{"lineNum":" 6010","line":"    // convert unsigned to signed high multiplication (from: H S Warren: Hacker\'s delight, 2003, p. 132)"},
{"lineNum":" 6011","line":"    __m128i u1  = _mm_srai_epi32(a,31);                    // sign of a"},
{"lineNum":" 6012","line":"    __m128i u2  = _mm_srai_epi32(d.getm(),31);             // sign of m [ m is always negative, except for abs(d) = 1 ]"},
{"lineNum":" 6013","line":"    __m128i u3  = _mm_and_si128 (d.getm(),u1);             // m * sign of a"},
{"lineNum":" 6014","line":"    __m128i u4  = _mm_and_si128 (a,u2);                    // a * sign of m"},
{"lineNum":" 6015","line":"    __m128i u5  = _mm_add_epi32 (u3,u4);                   // sum of sign corrections"},
{"lineNum":" 6016","line":"    __m128i u6  = _mm_sub_epi32 (t7,u5);                   // high multiplication result converted to signed"},
{"lineNum":" 6017","line":"    __m128i t8  = _mm_add_epi32(u6,a);                     // add a"},
{"lineNum":" 6018","line":"    __m128i t9  = _mm_sra_epi32(t8,d.gets1());             // shift right arithmetic"},
{"lineNum":" 6019","line":"    __m128i t10 = _mm_sub_epi32(u1,d.getsign());           // sign of a - sign of d"},
{"lineNum":" 6020","line":"    __m128i t11 = _mm_sub_epi32(t9,t10);                   // + 1 if a < 0, -1 if d < 0"},
{"lineNum":" 6021","line":"    return        _mm_xor_si128(t11,d.getsign());          // change sign if divisor negative"},
{"lineNum":" 6022","line":"#endif"},
{"lineNum":" 6023","line":"}"},
{"lineNum":" 6024","line":""},
{"lineNum":" 6025","line":"// vector of 4 32-bit unsigned integers"},
{"lineNum":" 6026","line":"static inline Vec4ui operator / (Vec4ui const & a, Divisor_ui const & d) {"},
{"lineNum":" 6027","line":"    __m128i t1  = _mm_mul_epu32(a,d.getm());               // 32x32->64 bit unsigned multiplication of a[0] and a[2]"},
{"lineNum":" 6028","line":"    __m128i t2  = _mm_srli_epi64(t1,32);                   // high dword of result 0 and 2"},
{"lineNum":" 6029","line":"    __m128i t3  = _mm_srli_epi64(a,32);                    // get a[1] and a[3] into position for multiplication"},
{"lineNum":" 6030","line":"    __m128i t4  = _mm_mul_epu32(t3,d.getm());              // 32x32->64 bit unsigned multiplication of a[1] and a[3]"},
{"lineNum":" 6031","line":"    __m128i t5  = _mm_set_epi32(-1,0,-1,0);                // mask of dword 1 and 3"},
{"lineNum":" 6032","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 6033","line":"    __m128i t7  = _mm_blendv_epi8(t2,t4,t5);               // blend two results"},
{"lineNum":" 6034","line":"#else"},
{"lineNum":" 6035","line":"    __m128i t6  = _mm_and_si128(t4,t5);                    // high dword of result 1 and 3"},
{"lineNum":" 6036","line":"    __m128i t7  = _mm_or_si128(t2,t6);                     // combine all four results into one vector"},
{"lineNum":" 6037","line":"#endif"},
{"lineNum":" 6038","line":"    __m128i t8  = _mm_sub_epi32(a,t7);                     // subtract"},
{"lineNum":" 6039","line":"    __m128i t9  = _mm_srl_epi32(t8,d.gets1());             // shift right logical"},
{"lineNum":" 6040","line":"    __m128i t10 = _mm_add_epi32(t7,t9);                    // add"},
{"lineNum":" 6041","line":"    return        _mm_srl_epi32(t10,d.gets2());            // shift right logical"},
{"lineNum":" 6042","line":"}"},
{"lineNum":" 6043","line":""},
{"lineNum":" 6044","line":"// vector of 8 16-bit signed integers"},
{"lineNum":" 6045","line":"static inline Vec8s operator / (Vec8s const & a, Divisor_s const & d) {"},
{"lineNum":" 6046","line":"    __m128i t1  = _mm_mulhi_epi16(a, d.getm());            // multiply high signed words"},
{"lineNum":" 6047","line":"    __m128i t2  = _mm_add_epi16(t1,a);                     // + a"},
{"lineNum":" 6048","line":"    __m128i t3  = _mm_sra_epi16(t2,d.gets1());             // shift right arithmetic"},
{"lineNum":" 6049","line":"    __m128i t4  = _mm_srai_epi16(a,15);                    // sign of a"},
{"lineNum":" 6050","line":"    __m128i t5  = _mm_sub_epi16(t4,d.getsign());           // sign of a - sign of d"},
{"lineNum":" 6051","line":"    __m128i t6  = _mm_sub_epi16(t3,t5);                    // + 1 if a < 0, -1 if d < 0"},
{"lineNum":" 6052","line":"    return        _mm_xor_si128(t6,d.getsign());           // change sign if divisor negative"},
{"lineNum":" 6053","line":"}"},
{"lineNum":" 6054","line":""},
{"lineNum":" 6055","line":"// vector of 8 16-bit unsigned integers"},
{"lineNum":" 6056","line":"static inline Vec8us operator / (Vec8us const & a, Divisor_us const & d) {"},
{"lineNum":" 6057","line":"    __m128i t1  = _mm_mulhi_epu16(a, d.getm());            // multiply high unsigned words"},
{"lineNum":" 6058","line":"    __m128i t2  = _mm_sub_epi16(a,t1);                     // subtract"},
{"lineNum":" 6059","line":"    __m128i t3  = _mm_srl_epi16(t2,d.gets1());             // shift right logical"},
{"lineNum":" 6060","line":"    __m128i t4  = _mm_add_epi16(t1,t3);                    // add"},
{"lineNum":" 6061","line":"    return        _mm_srl_epi16(t4,d.gets2());             // shift right logical"},
{"lineNum":" 6062","line":"}"},
{"lineNum":" 6063","line":""},
{"lineNum":" 6064","line":""},
{"lineNum":" 6065","line":"// vector of 16 8-bit signed integers"},
{"lineNum":" 6066","line":"static inline Vec16c operator / (Vec16c const & a, Divisor_s const & d) {"},
{"lineNum":" 6067","line":"    // expand into two Vec8s"},
{"lineNum":" 6068","line":"    Vec8s low  = extend_low(a)  / d;"},
{"lineNum":" 6069","line":"    Vec8s high = extend_high(a) / d;"},
{"lineNum":" 6070","line":"    return compress(low,high);"},
{"lineNum":" 6071","line":"}"},
{"lineNum":" 6072","line":""},
{"lineNum":" 6073","line":"// vector of 16 8-bit unsigned integers"},
{"lineNum":" 6074","line":"static inline Vec16uc operator / (Vec16uc const & a, Divisor_us const & d) {"},
{"lineNum":" 6075","line":"    // expand into two Vec8s"},
{"lineNum":" 6076","line":"    Vec8us low  = extend_low(a)  / d;"},
{"lineNum":" 6077","line":"    Vec8us high = extend_high(a) / d;"},
{"lineNum":" 6078","line":"    return compress(low,high);"},
{"lineNum":" 6079","line":"}"},
{"lineNum":" 6080","line":""},
{"lineNum":" 6081","line":"// vector operator /= : divide"},
{"lineNum":" 6082","line":"static inline Vec8s & operator /= (Vec8s & a, Divisor_s const & d) {"},
{"lineNum":" 6083","line":"    a = a / d;"},
{"lineNum":" 6084","line":"    return a;"},
{"lineNum":" 6085","line":"}"},
{"lineNum":" 6086","line":""},
{"lineNum":" 6087","line":"// vector operator /= : divide"},
{"lineNum":" 6088","line":"static inline Vec8us & operator /= (Vec8us & a, Divisor_us const & d) {"},
{"lineNum":" 6089","line":"    a = a / d;"},
{"lineNum":" 6090","line":"    return a;"},
{"lineNum":" 6091","line":"}"},
{"lineNum":" 6092","line":""},
{"lineNum":" 6093","line":"// vector operator /= : divide"},
{"lineNum":" 6094","line":"static inline Vec4i & operator /= (Vec4i & a, Divisor_i const & d) {"},
{"lineNum":" 6095","line":"    a = a / d;"},
{"lineNum":" 6096","line":"    return a;"},
{"lineNum":" 6097","line":"}"},
{"lineNum":" 6098","line":""},
{"lineNum":" 6099","line":"// vector operator /= : divide"},
{"lineNum":" 6100","line":"static inline Vec4ui & operator /= (Vec4ui & a, Divisor_ui const & d) {"},
{"lineNum":" 6101","line":"    a = a / d;"},
{"lineNum":" 6102","line":"    return a;"},
{"lineNum":" 6103","line":"}"},
{"lineNum":" 6104","line":""},
{"lineNum":" 6105","line":"// vector operator /= : divide"},
{"lineNum":" 6106","line":"static inline Vec16c & operator /= (Vec16c & a, Divisor_s const & d) {"},
{"lineNum":" 6107","line":"    a = a / d;"},
{"lineNum":" 6108","line":"    return a;"},
{"lineNum":" 6109","line":"}"},
{"lineNum":" 6110","line":""},
{"lineNum":" 6111","line":"// vector operator /= : divide"},
{"lineNum":" 6112","line":"static inline Vec16uc & operator /= (Vec16uc & a, Divisor_us const & d) {"},
{"lineNum":" 6113","line":"    a = a / d;"},
{"lineNum":" 6114","line":"    return a;"},
{"lineNum":" 6115","line":"}"},
{"lineNum":" 6116","line":""},
{"lineNum":" 6117","line":"/*****************************************************************************"},
{"lineNum":" 6118","line":"*"},
{"lineNum":" 6119","line":"*          Integer division 2: divisor is a compile-time constant"},
{"lineNum":" 6120","line":"*"},
{"lineNum":" 6121","line":"*****************************************************************************/"},
{"lineNum":" 6122","line":""},
{"lineNum":" 6123","line":"// Divide Vec4i by compile-time constant"},
{"lineNum":" 6124","line":"template <int32_t d>"},
{"lineNum":" 6125","line":"static inline Vec4i divide_by_i(Vec4i const & x) {"},
{"lineNum":" 6126","line":"    Static_error_check<(d!=0)> Dividing_by_zero;                     // Error message if dividing by zero"},
{"lineNum":" 6127","line":"    if (d ==  1) return  x;"},
{"lineNum":" 6128","line":"    if (d == -1) return -x;"},
{"lineNum":" 6129","line":"    if (uint32_t(d) == 0x80000000u) return Vec4i(x == Vec4i(0x80000000)) & 1; // prevent overflow when changing sign"},
{"lineNum":" 6130","line":"    const uint32_t d1 = d > 0 ? uint32_t(d) : uint32_t(-d);          // compile-time abs(d). (force GCC compiler to treat d as 32 bits, not 64 bits)"},
{"lineNum":" 6131","line":"    if ((d1 & (d1-1)) == 0) {"},
{"lineNum":" 6132","line":"        // d1 is a power of 2. use shift"},
{"lineNum":" 6133","line":"        const int k = bit_scan_reverse_const(d1);"},
{"lineNum":" 6134","line":"        __m128i sign;"},
{"lineNum":" 6135","line":"        if (k > 1) sign = _mm_srai_epi32(x, k-1); else sign = x;     // k copies of sign bit"},
{"lineNum":" 6136","line":"        __m128i bias    = _mm_srli_epi32(sign, 32-k);                // bias = x >= 0 ? 0 : k-1"},
{"lineNum":" 6137","line":"        __m128i xpbias  = _mm_add_epi32 (x, bias);                   // x + bias"},
{"lineNum":" 6138","line":"        __m128i q       = _mm_srai_epi32(xpbias, k);                 // (x + bias) >> k"},
{"lineNum":" 6139","line":"        if (d > 0)      return q;                                    // d > 0: return  q"},
{"lineNum":" 6140","line":"        return _mm_sub_epi32(_mm_setzero_si128(), q);                // d < 0: return -q"},
{"lineNum":" 6141","line":"    }"},
{"lineNum":" 6142","line":"    // general case"},
{"lineNum":" 6143","line":"    const int32_t sh = bit_scan_reverse_const(uint32_t(d1)-1);            // ceil(log2(d1)) - 1. (d1 < 2 handled by power of 2 case)"},
{"lineNum":" 6144","line":"    const int32_t mult = int(1 + (uint64_t(1) << (32+sh)) / uint32_t(d1) - (int64_t(1) << 32));   // multiplier"},
{"lineNum":" 6145","line":"    const Divisor_i div(mult, sh, d < 0 ? -1 : 0);"},
{"lineNum":" 6146","line":"    return x / div;"},
{"lineNum":" 6147","line":"}"},
{"lineNum":" 6148","line":""},
{"lineNum":" 6149","line":"// define Vec4i a / const_int(d)"},
{"lineNum":" 6150","line":"template <int32_t d>"},
{"lineNum":" 6151","line":"static inline Vec4i operator / (Vec4i const & a, Const_int_t<d>) {"},
{"lineNum":" 6152","line":"    return divide_by_i<d>(a);"},
{"lineNum":" 6153","line":"}"},
{"lineNum":" 6154","line":""},
{"lineNum":" 6155","line":"// define Vec4i a / const_uint(d)"},
{"lineNum":" 6156","line":"template <uint32_t d>"},
{"lineNum":" 6157","line":"static inline Vec4i operator / (Vec4i const & a, Const_uint_t<d>) {"},
{"lineNum":" 6158","line":"    Static_error_check< (d<0x80000000u) > Error_overflow_dividing_signed_by_unsigned; // Error: dividing signed by overflowing unsigned"},
{"lineNum":" 6159","line":"    return divide_by_i<int32_t(d)>(a);                               // signed divide"},
{"lineNum":" 6160","line":"}"},
{"lineNum":" 6161","line":""},
{"lineNum":" 6162","line":"// vector operator /= : divide"},
{"lineNum":" 6163","line":"template <int32_t d>"},
{"lineNum":" 6164","line":"static inline Vec4i & operator /= (Vec4i & a, Const_int_t<d> b) {"},
{"lineNum":" 6165","line":"    a = a / b;"},
{"lineNum":" 6166","line":"    return a;"},
{"lineNum":" 6167","line":"}"},
{"lineNum":" 6168","line":""},
{"lineNum":" 6169","line":"// vector operator /= : divide"},
{"lineNum":" 6170","line":"template <uint32_t d>"},
{"lineNum":" 6171","line":"static inline Vec4i & operator /= (Vec4i & a, Const_uint_t<d> b) {"},
{"lineNum":" 6172","line":"    a = a / b;"},
{"lineNum":" 6173","line":"    return a;"},
{"lineNum":" 6174","line":"}"},
{"lineNum":" 6175","line":""},
{"lineNum":" 6176","line":""},
{"lineNum":" 6177","line":"// Divide Vec4ui by compile-time constant"},
{"lineNum":" 6178","line":"template <uint32_t d>"},
{"lineNum":" 6179","line":"static inline Vec4ui divide_by_ui(Vec4ui const & x) {"},
{"lineNum":" 6180","line":"    Static_error_check<(d!=0)> Dividing_by_zero;                     // Error message if dividing by zero"},
{"lineNum":" 6181","line":"    if (d == 1) return x;                                            // divide by 1"},
{"lineNum":" 6182","line":"    const int b = bit_scan_reverse_const(d);                         // floor(log2(d))"},
{"lineNum":" 6183","line":"    if ((uint32_t(d) & (uint32_t(d)-1)) == 0) {"},
{"lineNum":" 6184","line":"        // d is a power of 2. use shift"},
{"lineNum":" 6185","line":"        return    _mm_srli_epi32(x, b);                              // x >> b"},
{"lineNum":" 6186","line":"    }"},
{"lineNum":" 6187","line":"    // general case (d > 2)"},
{"lineNum":" 6188","line":"    uint32_t mult = uint32_t((uint64_t(1) << (b+32)) / d);           // multiplier = 2^(32+b) / d"},
{"lineNum":" 6189","line":"    const uint64_t rem = (uint64_t(1) << (b+32)) - uint64_t(d)*mult; // remainder 2^(32+b) % d"},
{"lineNum":" 6190","line":"    const bool round_down = (2*rem < d);                             // check if fraction is less than 0.5"},
{"lineNum":" 6191","line":"    if (!round_down) {"},
{"lineNum":" 6192","line":"        mult = mult + 1;                                             // round up mult"},
{"lineNum":" 6193","line":"    }"},
{"lineNum":" 6194","line":"    // do 32*32->64 bit unsigned multiplication and get high part of result"},
{"lineNum":" 6195","line":"    const __m128i multv = _mm_set_epi32(0,mult,0,mult);              // zero-extend mult and broadcast"},
{"lineNum":" 6196","line":"    __m128i t1  = _mm_mul_epu32(x,multv);                            // 32x32->64 bit unsigned multiplication of x[0] and x[2]"},
{"lineNum":" 6197","line":"    if (round_down) {"},
{"lineNum":" 6198","line":"        t1      = _mm_add_epi64(t1,multv);                           // compensate for rounding error. (x+1)*m replaced by x*m+m to avoid overflow"},
{"lineNum":" 6199","line":"    }"},
{"lineNum":" 6200","line":"    __m128i t2  = _mm_srli_epi64(t1,32);                             // high dword of result 0 and 2"},
{"lineNum":" 6201","line":"    __m128i t3  = _mm_srli_epi64(x,32);                              // get x[1] and x[3] into position for multiplication"},
{"lineNum":" 6202","line":"    __m128i t4  = _mm_mul_epu32(t3,multv);                           // 32x32->64 bit unsigned multiplication of x[1] and x[3]"},
{"lineNum":" 6203","line":"    if (round_down) {"},
{"lineNum":" 6204","line":"        t4      = _mm_add_epi64(t4,multv);                           // compensate for rounding error. (x+1)*m replaced by x*m+m to avoid overflow"},
{"lineNum":" 6205","line":"    }"},
{"lineNum":" 6206","line":"    __m128i t5  = _mm_set_epi32(-1,0,-1,0);                          // mask of dword 1 and 3"},
{"lineNum":" 6207","line":"#if INSTRSET >= 5   // SSE4.1 supported"},
{"lineNum":" 6208","line":"    __m128i t7  = _mm_blendv_epi8(t2,t4,t5);                         // blend two results"},
{"lineNum":" 6209","line":"#else"},
{"lineNum":" 6210","line":"    __m128i t6  = _mm_and_si128(t4,t5);                              // high dword of result 1 and 3"},
{"lineNum":" 6211","line":"    __m128i t7  = _mm_or_si128(t2,t6);                               // combine all four results into one vector"},
{"lineNum":" 6212","line":"#endif"},
{"lineNum":" 6213","line":"    Vec4ui q    = _mm_srli_epi32(t7, b);                             // shift right by b"},
{"lineNum":" 6214","line":"    return q;                                                    // no overflow possible"},
{"lineNum":" 6215","line":"}"},
{"lineNum":" 6216","line":""},
{"lineNum":" 6217","line":"// define Vec4ui a / const_uint(d)"},
{"lineNum":" 6218","line":"template <uint32_t d>"},
{"lineNum":" 6219","line":"static inline Vec4ui operator / (Vec4ui const & a, Const_uint_t<d>) {"},
{"lineNum":" 6220","line":"    return divide_by_ui<d>(a);"},
{"lineNum":" 6221","line":"}"},
{"lineNum":" 6222","line":""},
{"lineNum":" 6223","line":"// define Vec4ui a / const_int(d)"},
{"lineNum":" 6224","line":"template <int32_t d>"},
{"lineNum":" 6225","line":"static inline Vec4ui operator / (Vec4ui const & a, Const_int_t<d>) {"},
{"lineNum":" 6226","line":"    Static_error_check< (d>=0) > Error_dividing_unsigned_by_negative;// Error: dividing unsigned by negative is ambiguous"},
{"lineNum":" 6227","line":"    return divide_by_ui<d>(a);                                       // unsigned divide"},
{"lineNum":" 6228","line":"}"},
{"lineNum":" 6229","line":""},
{"lineNum":" 6230","line":"// vector operator /= : divide"},
{"lineNum":" 6231","line":"template <uint32_t d>"},
{"lineNum":" 6232","line":"static inline Vec4ui & operator /= (Vec4ui & a, Const_uint_t<d> b) {"},
{"lineNum":" 6233","line":"    a = a / b;"},
{"lineNum":" 6234","line":"    return a;"},
{"lineNum":" 6235","line":"}"},
{"lineNum":" 6236","line":""},
{"lineNum":" 6237","line":"// vector operator /= : divide"},
{"lineNum":" 6238","line":"template <int32_t d>"},
{"lineNum":" 6239","line":"static inline Vec4ui & operator /= (Vec4ui & a, Const_int_t<d> b) {"},
{"lineNum":" 6240","line":"    a = a / b;"},
{"lineNum":" 6241","line":"    return a;"},
{"lineNum":" 6242","line":"}"},
{"lineNum":" 6243","line":""},
{"lineNum":" 6244","line":""},
{"lineNum":" 6245","line":"// Divide Vec8s by compile-time constant"},
{"lineNum":" 6246","line":"template <int d>"},
{"lineNum":" 6247","line":"static inline Vec8s divide_by_i(Vec8s const & x) {"},
{"lineNum":" 6248","line":"    const int16_t d0 = int16_t(d);                                   // truncate d to 16 bits"},
{"lineNum":" 6249","line":"    Static_error_check<(d0 != 0)> Dividing_by_zero;                  // Error message if dividing by zero"},
{"lineNum":" 6250","line":"    if (d0 ==  1) return  x;                                         // divide by  1"},
{"lineNum":" 6251","line":"    if (d0 == -1) return -x;                                         // divide by -1"},
{"lineNum":" 6252","line":"    if (uint16_t(d0) == 0x8000u) return Vec8s(x == Vec8s(0x8000)) & 1;// prevent overflow when changing sign"},
{"lineNum":" 6253","line":"    // if (d > 0x7FFF || d < -0x8000) return 0;                      // not relevant when d truncated to 16 bits"},
{"lineNum":" 6254","line":"    const uint16_t d1 = d0 > 0 ? d0 : -d0;                           // compile-time abs(d0)"},
{"lineNum":" 6255","line":"    if ((d1 & (d1-1)) == 0) {"},
{"lineNum":" 6256","line":"        // d is a power of 2. use shift"},
{"lineNum":" 6257","line":"        const int k = bit_scan_reverse_const(uint32_t(d1));"},
{"lineNum":" 6258","line":"        __m128i sign;"},
{"lineNum":" 6259","line":"        if (k > 1) sign = _mm_srai_epi16(x, k-1); else sign = x;     // k copies of sign bit"},
{"lineNum":" 6260","line":"        __m128i bias    = _mm_srli_epi16(sign, 16-k);                // bias = x >= 0 ? 0 : k-1"},
{"lineNum":" 6261","line":"        __m128i xpbias  = _mm_add_epi16 (x, bias);                   // x + bias"},
{"lineNum":" 6262","line":"        __m128i q       = _mm_srai_epi16(xpbias, k);                 // (x + bias) >> k"},
{"lineNum":" 6263","line":"        if (d0 > 0)  return q;                                       // d0 > 0: return  q"},
{"lineNum":" 6264","line":"        return _mm_sub_epi16(_mm_setzero_si128(), q);                // d0 < 0: return -q"},
{"lineNum":" 6265","line":"    }"},
{"lineNum":" 6266","line":"    // general case"},
{"lineNum":" 6267","line":"    const int L = bit_scan_reverse_const(uint16_t(d1-1)) + 1;        // ceil(log2(d)). (d < 2 handled above)"},
{"lineNum":" 6268","line":"    const int16_t mult = int16_t(1 + (1u << (15+L)) / uint32_t(d1) - 0x10000);// multiplier"},
{"lineNum":" 6269","line":"    const int shift1 = L - 1;"},
{"lineNum":" 6270","line":"    const Divisor_s div(mult, shift1, d0 > 0 ? 0 : -1);"},
{"lineNum":" 6271","line":"    return x / div;"},
{"lineNum":" 6272","line":"}"},
{"lineNum":" 6273","line":""},
{"lineNum":" 6274","line":"// define Vec8s a / const_int(d)"},
{"lineNum":" 6275","line":"template <int d>"},
{"lineNum":" 6276","line":"static inline Vec8s operator / (Vec8s const & a, Const_int_t<d>) {"},
{"lineNum":" 6277","line":"    return divide_by_i<d>(a);"},
{"lineNum":" 6278","line":"}"},
{"lineNum":" 6279","line":""},
{"lineNum":" 6280","line":"// define Vec8s a / const_uint(d)"},
{"lineNum":" 6281","line":"template <uint32_t d>"},
{"lineNum":" 6282","line":"static inline Vec8s operator / (Vec8s const & a, Const_uint_t<d>) {"},
{"lineNum":" 6283","line":"    Static_error_check< (d<0x8000u) > Error_overflow_dividing_signed_by_unsigned; // Error: dividing signed by overflowing unsigned"},
{"lineNum":" 6284","line":"    return divide_by_i<int(d)>(a);                                   // signed divide"},
{"lineNum":" 6285","line":"}"},
{"lineNum":" 6286","line":""},
{"lineNum":" 6287","line":"// vector operator /= : divide"},
{"lineNum":" 6288","line":"template <int32_t d>"},
{"lineNum":" 6289","line":"static inline Vec8s & operator /= (Vec8s & a, Const_int_t<d> b) {"},
{"lineNum":" 6290","line":"    a = a / b;"},
{"lineNum":" 6291","line":"    return a;"},
{"lineNum":" 6292","line":"}"},
{"lineNum":" 6293","line":""},
{"lineNum":" 6294","line":"// vector operator /= : divide"},
{"lineNum":" 6295","line":"template <uint32_t d>"},
{"lineNum":" 6296","line":"static inline Vec8s & operator /= (Vec8s & a, Const_uint_t<d> b) {"},
{"lineNum":" 6297","line":"    a = a / b;"},
{"lineNum":" 6298","line":"    return a;"},
{"lineNum":" 6299","line":"}"},
{"lineNum":" 6300","line":""},
{"lineNum":" 6301","line":""},
{"lineNum":" 6302","line":"// Divide Vec8us by compile-time constant"},
{"lineNum":" 6303","line":"template <uint32_t d>"},
{"lineNum":" 6304","line":"static inline Vec8us divide_by_ui(Vec8us const & x) {"},
{"lineNum":" 6305","line":"    const uint16_t d0 = uint16_t(d);                                 // truncate d to 16 bits"},
{"lineNum":" 6306","line":"    Static_error_check<(d0 != 0)> Dividing_by_zero;                  // Error message if dividing by zero"},
{"lineNum":" 6307","line":"    if (d0 == 1) return x;                                           // divide by 1"},
{"lineNum":" 6308","line":"    const int b = bit_scan_reverse_const(d0);                        // floor(log2(d))"},
{"lineNum":" 6309","line":"    if ((d0 & (d0-1u)) == 0) {"},
{"lineNum":" 6310","line":"        // d is a power of 2. use shift"},
{"lineNum":" 6311","line":"        return  _mm_srli_epi16(x, b);                                // x >> b"},
{"lineNum":" 6312","line":"    }"},
{"lineNum":" 6313","line":"    // general case (d > 2)"},
{"lineNum":" 6314","line":"    uint16_t mult = uint16_t((1u << uint32_t(b+16)) / d0);                   // multiplier = 2^(32+b) / d"},
{"lineNum":" 6315","line":"    const uint32_t rem = (uint32_t(1) << uint32_t(b+16)) - uint32_t(d0)*mult;// remainder 2^(32+b) % d"},
{"lineNum":" 6316","line":"    const bool round_down = (2u*rem < d0);                            // check if fraction is less than 0.5"},
{"lineNum":" 6317","line":"    Vec8us x1 = x;"},
{"lineNum":" 6318","line":"    if (round_down) {"},
{"lineNum":" 6319","line":"        x1 = x1 + 1u;                                                // round down mult and compensate by adding 1 to x"},
{"lineNum":" 6320","line":"    }"},
{"lineNum":" 6321","line":"    else {"},
{"lineNum":" 6322","line":"        mult = mult + 1u;                                             // round up mult. no compensation needed"},
{"lineNum":" 6323","line":"    }"},
{"lineNum":" 6324","line":"    const __m128i multv = _mm_set1_epi16((int16_t)mult);                      // broadcast mult"},
{"lineNum":" 6325","line":"    __m128i xm = _mm_mulhi_epu16(x1, multv);                         // high part of 16x16->32 bit unsigned multiplication"},
{"lineNum":" 6326","line":"    Vec8us q    = _mm_srli_epi16(xm, (int)b);                             // shift right by b"},
{"lineNum":" 6327","line":"    if (round_down) {"},
{"lineNum":" 6328","line":"        Vec8sb overfl = (x1 == (Vec8us)_mm_setzero_si128());         // check for overflow of x+1"},
{"lineNum":" 6329","line":"        return select(overfl, Vec8us(uint16_t(mult >> (uint16_t)b)), q); // deal with overflow (rarely needed)"},
{"lineNum":" 6330","line":"    }"},
{"lineNum":" 6331","line":"    else {"},
{"lineNum":" 6332","line":"        return q;                                                    // no overflow possible"},
{"lineNum":" 6333","line":"    }"},
{"lineNum":" 6334","line":"}"},
{"lineNum":" 6335","line":""},
{"lineNum":" 6336","line":"// define Vec8us a / const_uint(d)"},
{"lineNum":" 6337","line":"template <uint32_t d>"},
{"lineNum":" 6338","line":"static inline Vec8us operator / (Vec8us const & a, Const_uint_t<d>) {"},
{"lineNum":" 6339","line":"    return divide_by_ui<d>(a);"},
{"lineNum":" 6340","line":"}"},
{"lineNum":" 6341","line":""},
{"lineNum":" 6342","line":"// define Vec8us a / const_int(d)"},
{"lineNum":" 6343","line":"template <int d>"},
{"lineNum":" 6344","line":"static inline Vec8us operator / (Vec8us const & a, Const_int_t<d>) {"},
{"lineNum":" 6345","line":"    Static_error_check< (d>=0) > Error_dividing_unsigned_by_negative;// Error: dividing unsigned by negative is ambiguous"},
{"lineNum":" 6346","line":"    return divide_by_ui<d>(a);                                       // unsigned divide"},
{"lineNum":" 6347","line":"}"},
{"lineNum":" 6348","line":""},
{"lineNum":" 6349","line":"// vector operator /= : divide"},
{"lineNum":" 6350","line":"template <uint32_t d>"},
{"lineNum":" 6351","line":"static inline Vec8us & operator /= (Vec8us & a, Const_uint_t<d> b) {"},
{"lineNum":" 6352","line":"    a = a / b;"},
{"lineNum":" 6353","line":"    return a;"},
{"lineNum":" 6354","line":"}"},
{"lineNum":" 6355","line":""},
{"lineNum":" 6356","line":"// vector operator /= : divide"},
{"lineNum":" 6357","line":"template <int32_t d>"},
{"lineNum":" 6358","line":"static inline Vec8us & operator /= (Vec8us & a, Const_int_t<d> b) {"},
{"lineNum":" 6359","line":"    a = a / b;"},
{"lineNum":" 6360","line":"    return a;"},
{"lineNum":" 6361","line":"}"},
{"lineNum":" 6362","line":""},
{"lineNum":" 6363","line":""},
{"lineNum":" 6364","line":"// define Vec16c a / const_int(d)"},
{"lineNum":" 6365","line":"template <int d>"},
{"lineNum":" 6366","line":"static inline Vec16c operator / (Vec16c const & a, Const_int_t<d>) {"},
{"lineNum":" 6367","line":"    // expand into two Vec8s"},
{"lineNum":" 6368","line":"    Vec8s low  = extend_low(a)  / Const_int_t<d>();"},
{"lineNum":" 6369","line":"    Vec8s high = extend_high(a) / Const_int_t<d>();"},
{"lineNum":" 6370","line":"    return compress(low,high);"},
{"lineNum":" 6371","line":"}"},
{"lineNum":" 6372","line":""},
{"lineNum":" 6373","line":"// define Vec16c a / const_uint(d)"},
{"lineNum":" 6374","line":"template <uint32_t d>"},
{"lineNum":" 6375","line":"static inline Vec16c operator / (Vec16c const & a, Const_uint_t<d>) {"},
{"lineNum":" 6376","line":"    Static_error_check< (uint8_t(d)<0x80u) > Error_overflow_dividing_signed_by_unsigned; // Error: dividing signed by overflowing unsigned"},
{"lineNum":" 6377","line":"    return a / Const_int_t<d>();                              // signed divide"},
{"lineNum":" 6378","line":"}"},
{"lineNum":" 6379","line":""},
{"lineNum":" 6380","line":"// vector operator /= : divide"},
{"lineNum":" 6381","line":"template <int32_t d>"},
{"lineNum":" 6382","line":"static inline Vec16c & operator /= (Vec16c & a, Const_int_t<d> b) {"},
{"lineNum":" 6383","line":"    a = a / b;"},
{"lineNum":" 6384","line":"    return a;"},
{"lineNum":" 6385","line":"}"},
{"lineNum":" 6386","line":"// vector operator /= : divide"},
{"lineNum":" 6387","line":"template <uint32_t d>"},
{"lineNum":" 6388","line":"static inline Vec16c & operator /= (Vec16c & a, Const_uint_t<d> b) {"},
{"lineNum":" 6389","line":"    a = a / b;"},
{"lineNum":" 6390","line":"    return a;"},
{"lineNum":" 6391","line":"}"},
{"lineNum":" 6392","line":""},
{"lineNum":" 6393","line":"// define Vec16uc a / const_uint(d)"},
{"lineNum":" 6394","line":"template <uint32_t d>"},
{"lineNum":" 6395","line":"static inline Vec16uc operator / (Vec16uc const & a, Const_uint_t<d>) {"},
{"lineNum":" 6396","line":"    // expand into two Vec8usc"},
{"lineNum":" 6397","line":"    Vec8us low  = extend_low(a)  / Const_uint_t<d>();"},
{"lineNum":" 6398","line":"    Vec8us high = extend_high(a) / Const_uint_t<d>();"},
{"lineNum":" 6399","line":"    return compress(low,high);"},
{"lineNum":" 6400","line":"}"},
{"lineNum":" 6401","line":""},
{"lineNum":" 6402","line":"// define Vec16uc a / const_int(d)"},
{"lineNum":" 6403","line":"template <int d>"},
{"lineNum":" 6404","line":"static inline Vec16uc operator / (Vec16uc const & a, Const_int_t<d>) {"},
{"lineNum":" 6405","line":"    Static_error_check< (int8_t(d)>=0) > Error_dividing_unsigned_by_negative;// Error: dividing unsigned by negative is ambiguous"},
{"lineNum":" 6406","line":"    return a / Const_uint_t<d>();                         // unsigned divide"},
{"lineNum":" 6407","line":"}"},
{"lineNum":" 6408","line":""},
{"lineNum":" 6409","line":"// vector operator /= : divide"},
{"lineNum":" 6410","line":"template <uint32_t d>"},
{"lineNum":" 6411","line":"static inline Vec16uc & operator /= (Vec16uc & a, Const_uint_t<d> b) {"},
{"lineNum":" 6412","line":"    a = a / b;"},
{"lineNum":" 6413","line":"    return a;"},
{"lineNum":" 6414","line":"}"},
{"lineNum":" 6415","line":""},
{"lineNum":" 6416","line":"// vector operator /= : divide"},
{"lineNum":" 6417","line":"template <int32_t d>"},
{"lineNum":" 6418","line":"static inline Vec16uc & operator /= (Vec16uc & a, Const_int_t<d> b) {"},
{"lineNum":" 6419","line":"    a = a / b;"},
{"lineNum":" 6420","line":"    return a;"},
{"lineNum":" 6421","line":"}"},
{"lineNum":" 6422","line":""},
{"lineNum":" 6423","line":"/*****************************************************************************"},
{"lineNum":" 6424","line":"*"},
{"lineNum":" 6425","line":"*          Horizontal scan functions"},
{"lineNum":" 6426","line":"*"},
{"lineNum":" 6427","line":"*****************************************************************************/"},
{"lineNum":" 6428","line":""},
{"lineNum":" 6429","line":"// Get index to the first element that is true. Return -1 if all are false"},
{"lineNum":" 6430","line":"static inline int horizontal_find_first(Vec16cb const & x) {"},
{"lineNum":" 6431","line":"    uint32_t a = (uint32_t)_mm_movemask_epi8(x);"},
{"lineNum":" 6432","line":"    if (a == 0) return -1;"},
{"lineNum":" 6433","line":"    int32_t b = (int32_t)bit_scan_forward(a);"},
{"lineNum":" 6434","line":"    return b;"},
{"lineNum":" 6435","line":"}"},
{"lineNum":" 6436","line":""},
{"lineNum":" 6437","line":"static inline int horizontal_find_first(Vec8sb const & x) {"},
{"lineNum":" 6438","line":"    return horizontal_find_first(Vec16cb(x)) >> 1;   // must use signed shift"},
{"lineNum":" 6439","line":"}"},
{"lineNum":" 6440","line":""},
{"lineNum":" 6441","line":"static inline int horizontal_find_first(Vec4ib const & x) {"},
{"lineNum":" 6442","line":"    return horizontal_find_first(Vec16cb(x)) >> 2;   // must use signed shift"},
{"lineNum":" 6443","line":"}"},
{"lineNum":" 6444","line":""},
{"lineNum":" 6445","line":"static inline int horizontal_find_first(Vec2qb const & x) {"},
{"lineNum":" 6446","line":"    return horizontal_find_first(Vec16cb(x)) >> 3;   // must use signed shift"},
{"lineNum":" 6447","line":"}"},
{"lineNum":" 6448","line":""},
{"lineNum":" 6449","line":"// Count the number of elements that are true"},
{"lineNum":" 6450","line":"static inline uint32_t horizontal_count(Vec16cb const & x) {"},
{"lineNum":" 6451","line":"    uint32_t a = (uint32_t)_mm_movemask_epi8(x);"},
{"lineNum":" 6452","line":"    return vml_popcnt(a);"},
{"lineNum":" 6453","line":"}"},
{"lineNum":" 6454","line":""},
{"lineNum":" 6455","line":"static inline uint32_t horizontal_count(Vec8sb const & x) {"},
{"lineNum":" 6456","line":"    return horizontal_count(Vec16cb(x)) >> 1;"},
{"lineNum":" 6457","line":"}"},
{"lineNum":" 6458","line":""},
{"lineNum":" 6459","line":"static inline uint32_t horizontal_count(Vec4ib const & x) {"},
{"lineNum":" 6460","line":"    return horizontal_count(Vec16cb(x)) >> 2;"},
{"lineNum":" 6461","line":"}"},
{"lineNum":" 6462","line":""},
{"lineNum":" 6463","line":"static inline uint32_t horizontal_count(Vec2qb const & x) {"},
{"lineNum":" 6464","line":"    return horizontal_count(Vec16cb(x)) >> 3;"},
{"lineNum":" 6465","line":"}"},
{"lineNum":" 6466","line":""},
{"lineNum":" 6467","line":""},
{"lineNum":" 6468","line":"/*****************************************************************************"},
{"lineNum":" 6469","line":"*"},
{"lineNum":" 6470","line":"*          Boolean <-> bitfield conversion functions"},
{"lineNum":" 6471","line":"*"},
{"lineNum":" 6472","line":"*****************************************************************************/"},
{"lineNum":" 6473","line":""},
{"lineNum":" 6474","line":"// to_bits: convert boolean vector to integer bitfield"},
{"lineNum":" 6475","line":"static inline uint16_t to_bits(Vec16cb const & x) {"},
{"lineNum":" 6476","line":"    return (uint16_t)_mm_movemask_epi8(x);"},
{"lineNum":" 6477","line":"}"},
{"lineNum":" 6478","line":""},
{"lineNum":" 6479","line":"// to_Vec16bc: convert integer bitfield to boolean vector"},
{"lineNum":" 6480","line":"// DEPRECATED. REPLACED BY load_bits"},
{"lineNum":" 6481","line":"static inline Vec16cb to_Vec16cb(uint16_t x) {"},
{"lineNum":" 6482","line":"    return Vec16cb().load_bits(x);"},
{"lineNum":" 6483","line":"}"},
{"lineNum":" 6484","line":""},
{"lineNum":" 6485","line":"// to_bits: convert boolean vector to integer bitfield"},
{"lineNum":" 6486","line":"static inline uint8_t to_bits(Vec8sb const & x) {"},
{"lineNum":" 6487","line":"    __m128i a = _mm_packs_epi16(x, x);  // 16-bit words to bytes"},
{"lineNum":" 6488","line":"    return (uint8_t)_mm_movemask_epi8(a);"},
{"lineNum":" 6489","line":"}"},
{"lineNum":" 6490","line":""},
{"lineNum":" 6491","line":"// to_Vec8sb: convert integer bitfield to boolean vector"},
{"lineNum":" 6492","line":"// DEPRECATED. REPLACED BY load_bits"},
{"lineNum":" 6493","line":"static inline Vec8sb to_Vec8sb(uint8_t x) {"},
{"lineNum":" 6494","line":"    return Vec8sb().load_bits(x);"},
{"lineNum":" 6495","line":"}"},
{"lineNum":" 6496","line":""},
{"lineNum":" 6497","line":"#if INSTRSET < 9 || MAX_VECTOR_SIZE < 512"},
{"lineNum":" 6498","line":"// These functions are defined in Vectori512.h if AVX512 instruction set is used"},
{"lineNum":" 6499","line":""},
{"lineNum":" 6500","line":"// to_bits: convert boolean vector to integer bitfield"},
{"lineNum":" 6501","line":"static inline uint8_t to_bits(Vec4ib const & x) {"},
{"lineNum":" 6502","line":"    __m128i a = _mm_packs_epi32(x, x);  // 32-bit dwords to 16-bit words"},
{"lineNum":" 6503","line":"    __m128i b = _mm_packs_epi16(a, a);  // 16-bit words to bytes"},
{"lineNum":" 6504","line":"    return uint8_t(_mm_movemask_epi8(b) & 0xF);"},
{"lineNum":" 6505","line":"}"},
{"lineNum":" 6506","line":""},
{"lineNum":" 6507","line":"// to_Vec4ib: convert integer bitfield to boolean vector"},
{"lineNum":" 6508","line":"// DEPRECATED. REPLACED BY load_bits"},
{"lineNum":" 6509","line":"static inline Vec4ib to_Vec4ib(uint8_t x) {"},
{"lineNum":" 6510","line":"    return Vec4ib().load_bits(x);"},
{"lineNum":" 6511","line":"}"},
{"lineNum":" 6512","line":""},
{"lineNum":" 6513","line":"// to_bits: convert boolean vector to integer bitfield"},
{"lineNum":" 6514","line":"static inline uint8_t to_bits(Vec2qb const & x) {"},
{"lineNum":" 6515","line":"    uint32_t a = (uint32_t)_mm_movemask_epi8(x);"},
{"lineNum":" 6516","line":"    return (a & 1) | ((a >> 7) & 2);"},
{"lineNum":" 6517","line":"}"},
{"lineNum":" 6518","line":""},
{"lineNum":" 6519","line":"// to_Vec2qb: convert integer bitfield to boolean vector"},
{"lineNum":" 6520","line":"// DEPRECATED. REPLACED BY load_bits"},
{"lineNum":" 6521","line":"static inline Vec2qb to_Vec2qb(uint8_t x) {"},
{"lineNum":" 6522","line":"    return Vec2qb().load_bits(x);"},
{"lineNum":" 6523","line":"}"},
{"lineNum":" 6524","line":""},
{"lineNum":" 6525","line":"#else  // function prototypes here only"},
{"lineNum":" 6526","line":""},
{"lineNum":" 6527","line":"// to_bits: convert boolean vector to integer bitfield"},
{"lineNum":" 6528","line":"static inline uint8_t to_bits(Vec4ib x);"},
{"lineNum":" 6529","line":""},
{"lineNum":" 6530","line":"// to_Vec4ib: convert integer bitfield to boolean vector"},
{"lineNum":" 6531","line":"// DEPRECATED. REPLACED BY load_bits"},
{"lineNum":" 6532","line":"static inline Vec4ib to_Vec4ib(uint8_t x);"},
{"lineNum":" 6533","line":""},
{"lineNum":" 6534","line":"// to_bits: convert boolean vector to integer bitfield"},
{"lineNum":" 6535","line":"static inline uint8_t to_bits(Vec2qb x);"},
{"lineNum":" 6536","line":""},
{"lineNum":" 6537","line":"// to_Vec2qb: convert integer bitfield to boolean vector"},
{"lineNum":" 6538","line":"// DEPRECATED. REPLACED BY load_bits"},
{"lineNum":" 6539","line":"static inline Vec2qb to_Vec2qb(uint8_t x);"},
{"lineNum":" 6540","line":""},
{"lineNum":" 6541","line":"#endif  // INSTRSET < 9 || MAX_VECTOR_SIZE < 512"},
{"lineNum":" 6542","line":""},
{"lineNum":" 6543","line":"#ifdef VCL_NAMESPACE"},
{"lineNum":" 6544","line":"}"},
{"lineNum":" 6545","line":"#endif"},
{"lineNum":" 6546","line":""},
{"lineNum":" 6547","line":"#endif // VECTORI128_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 18, "covered" : 0,};
var merged_data = [];
