var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_COMMAINITIALIZER_H"},
{"lineNum":"   12","line":"#define EIGEN_COMMAINITIALIZER_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"/** \\class CommaInitializer"},
{"lineNum":"   19","line":"  * \\ingroup Core_Module"},
{"lineNum":"   20","line":"  *"},
{"lineNum":"   21","line":"  * \\brief Helper class used by the comma initializer operator"},
{"lineNum":"   22","line":"  *"},
{"lineNum":"   23","line":"  * This class is internally used to implement the comma initializer feature. It is"},
{"lineNum":"   24","line":"  * the return type of MatrixBase::operator<<, and most of the time this is the only"},
{"lineNum":"   25","line":"  * way it is used."},
{"lineNum":"   26","line":"  *"},
{"lineNum":"   27","line":"  * \\sa \\blank \\ref MatrixBaseCommaInitRef \"MatrixBase::operator<<\", CommaInitializer::finished()"},
{"lineNum":"   28","line":"  */"},
{"lineNum":"   29","line":"template<typename XprType>"},
{"lineNum":"   30","line":"struct CommaInitializer"},
{"lineNum":"   31","line":"{"},
{"lineNum":"   32","line":"  typedef typename XprType::Scalar Scalar;"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   35","line":"  inline CommaInitializer(XprType& xpr, const Scalar& s)"},
{"lineNum":"   36","line":"    : m_xpr(xpr), m_row(0), m_col(1), m_currentBlockRows(1)"},
{"lineNum":"   37","line":"  {"},
{"lineNum":"   38","line":"    eigen_assert(m_xpr.rows() > 0 && m_xpr.cols() > 0"},
{"lineNum":"   39","line":"      && \"Cannot comma-initialize a 0x0 matrix (operator<<)\");"},
{"lineNum":"   40","line":"    m_xpr.coeffRef(0,0) = s;","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"   41","line":"  }"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"  template<typename OtherDerived>"},
{"lineNum":"   44","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   45","line":"  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)"},
{"lineNum":"   46","line":"    : m_xpr(xpr), m_row(0), m_col(other.cols()), m_currentBlockRows(other.rows())"},
{"lineNum":"   47","line":"  {"},
{"lineNum":"   48","line":"    eigen_assert(m_xpr.rows() >= other.rows() && m_xpr.cols() >= other.cols()"},
{"lineNum":"   49","line":"      && \"Cannot comma-initialize a 0x0 matrix (operator<<)\");"},
{"lineNum":"   50","line":"    m_xpr.block(0, 0, other.rows(), other.cols()) = other;"},
{"lineNum":"   51","line":"  }"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"  /* Copy/Move constructor which transfers ownership. This is crucial in"},
{"lineNum":"   54","line":"   * absence of return value optimization to avoid assertions during destruction. */"},
{"lineNum":"   55","line":"  // FIXME in C++11 mode this could be replaced by a proper RValue constructor"},
{"lineNum":"   56","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   57","line":"  inline CommaInitializer(const CommaInitializer& o)"},
{"lineNum":"   58","line":"  : m_xpr(o.m_xpr), m_row(o.m_row), m_col(o.m_col), m_currentBlockRows(o.m_currentBlockRows) {"},
{"lineNum":"   59","line":"    // Mark original object as finished. In absence of R-value references we need to const_cast:"},
{"lineNum":"   60","line":"    const_cast<CommaInitializer&>(o).m_row = m_xpr.rows();"},
{"lineNum":"   61","line":"    const_cast<CommaInitializer&>(o).m_col = m_xpr.cols();"},
{"lineNum":"   62","line":"    const_cast<CommaInitializer&>(o).m_currentBlockRows = 0;"},
{"lineNum":"   63","line":"  }"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"  /* inserts a scalar value in the target matrix */"},
{"lineNum":"   66","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   67","line":"  CommaInitializer& operator,(const Scalar& s)"},
{"lineNum":"   68","line":"  {"},
{"lineNum":"   69","line":"    if (m_col==m_xpr.cols())","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"   70","line":"    {"},
{"lineNum":"   71","line":"      m_row+=m_currentBlockRows;"},
{"lineNum":"   72","line":"      m_col = 0;"},
{"lineNum":"   73","line":"      m_currentBlockRows = 1;"},
{"lineNum":"   74","line":"      eigen_assert(m_row<m_xpr.rows()"},
{"lineNum":"   75","line":"        && \"Too many rows passed to comma initializer (operator<<)\");"},
{"lineNum":"   76","line":"    }"},
{"lineNum":"   77","line":"    eigen_assert(m_col<m_xpr.cols()"},
{"lineNum":"   78","line":"      && \"Too many coefficients passed to comma initializer (operator<<)\");"},
{"lineNum":"   79","line":"    eigen_assert(m_currentBlockRows==1);"},
{"lineNum":"   80","line":"    m_xpr.coeffRef(m_row, m_col++) = s;","class":"lineNoCov","hits":"0","possible_hits":"36",},
{"lineNum":"   81","line":"    return *this;"},
{"lineNum":"   82","line":"  }"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"  /* inserts a matrix expression in the target matrix */"},
{"lineNum":"   85","line":"  template<typename OtherDerived>"},
{"lineNum":"   86","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   87","line":"  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)"},
{"lineNum":"   88","line":"  {"},
{"lineNum":"   89","line":"    if (m_col==m_xpr.cols() && (other.cols()!=0 || other.rows()!=m_currentBlockRows))"},
{"lineNum":"   90","line":"    {"},
{"lineNum":"   91","line":"      m_row+=m_currentBlockRows;"},
{"lineNum":"   92","line":"      m_col = 0;"},
{"lineNum":"   93","line":"      m_currentBlockRows = other.rows();"},
{"lineNum":"   94","line":"      eigen_assert(m_row+m_currentBlockRows<=m_xpr.rows()"},
{"lineNum":"   95","line":"        && \"Too many rows passed to comma initializer (operator<<)\");"},
{"lineNum":"   96","line":"    }"},
{"lineNum":"   97","line":"    eigen_assert((m_col + other.cols() <= m_xpr.cols())"},
{"lineNum":"   98","line":"      && \"Too many coefficients passed to comma initializer (operator<<)\");"},
{"lineNum":"   99","line":"    eigen_assert(m_currentBlockRows==other.rows());"},
{"lineNum":"  100","line":"    m_xpr.template block<OtherDerived::RowsAtCompileTime, OtherDerived::ColsAtCompileTime>"},
{"lineNum":"  101","line":"                    (m_row, m_col, other.rows(), other.cols()) = other;"},
{"lineNum":"  102","line":"    m_col += other.cols();"},
{"lineNum":"  103","line":"    return *this;"},
{"lineNum":"  104","line":"  }"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  107","line":"  inline ~CommaInitializer()"},
{"lineNum":"  108","line":"#if defined VERIFY_RAISES_ASSERT && (!defined EIGEN_NO_ASSERTION_CHECKING) && defined EIGEN_EXCEPTIONS"},
{"lineNum":"  109","line":"  EIGEN_EXCEPTION_SPEC(Eigen::eigen_assert_exception)"},
{"lineNum":"  110","line":"#endif"},
{"lineNum":"  111","line":"  {"},
{"lineNum":"  112","line":"    finished();"},
{"lineNum":"  113","line":"  }"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"  /** \\returns the built matrix once all its coefficients have been set."},
{"lineNum":"  116","line":"    * Calling finished is 100% optional. Its purpose is to write expressions"},
{"lineNum":"  117","line":"    * like this:"},
{"lineNum":"  118","line":"    * \\code"},
{"lineNum":"  119","line":"    * quaternion.fromRotationMatrix((Matrix3f() << axis0, axis1, axis2).finished());"},
{"lineNum":"  120","line":"    * \\endcode"},
{"lineNum":"  121","line":"    */"},
{"lineNum":"  122","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  123","line":"  inline XprType& finished() {"},
{"lineNum":"  124","line":"      eigen_assert(((m_row+m_currentBlockRows) == m_xpr.rows() || m_xpr.cols() == 0)"},
{"lineNum":"  125","line":"           && m_col == m_xpr.cols()"},
{"lineNum":"  126","line":"           && \"Too few coefficients passed to comma initializer (operator<<)\");"},
{"lineNum":"  127","line":"      return m_xpr;"},
{"lineNum":"  128","line":"  }"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"  XprType& m_xpr;           // target expression"},
{"lineNum":"  131","line":"  Index m_row;              // current row id"},
{"lineNum":"  132","line":"  Index m_col;              // current col id"},
{"lineNum":"  133","line":"  Index m_currentBlockRows; // current block height"},
{"lineNum":"  134","line":"};"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"/** \\anchor MatrixBaseCommaInitRef"},
{"lineNum":"  137","line":"  * Convenient operator to set the coefficients of a matrix."},
{"lineNum":"  138","line":"  *"},
{"lineNum":"  139","line":"  * The coefficients must be provided in a row major order and exactly match"},
{"lineNum":"  140","line":"  * the size of the matrix. Otherwise an assertion is raised."},
{"lineNum":"  141","line":"  *"},
{"lineNum":"  142","line":"  * Example: \\include MatrixBase_set.cpp"},
{"lineNum":"  143","line":"  * Output: \\verbinclude MatrixBase_set.out"},
{"lineNum":"  144","line":"  *"},
{"lineNum":"  145","line":"  * \\note According the c++ standard, the argument expressions of this comma initializer are evaluated in arbitrary order."},
{"lineNum":"  146","line":"  *"},
{"lineNum":"  147","line":"  * \\sa CommaInitializer::finished(), class CommaInitializer"},
{"lineNum":"  148","line":"  */"},
{"lineNum":"  149","line":"template<typename Derived>"},
{"lineNum":"  150","line":"EIGEN_DEVICE_FUNC inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)"},
{"lineNum":"  151","line":"{"},
{"lineNum":"  152","line":"  return CommaInitializer<Derived>(*static_cast<Derived*>(this), s);"},
{"lineNum":"  153","line":"}"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"/** \\sa operator<<(const Scalar&) */"},
{"lineNum":"  156","line":"template<typename Derived>"},
{"lineNum":"  157","line":"template<typename OtherDerived>"},
{"lineNum":"  158","line":"EIGEN_DEVICE_FUNC inline CommaInitializer<Derived>"},
{"lineNum":"  159","line":"DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)"},
{"lineNum":"  160","line":"{"},
{"lineNum":"  161","line":"  return CommaInitializer<Derived>(*static_cast<Derived *>(this), other);"},
{"lineNum":"  162","line":"}"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"} // end namespace Eigen"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"#endif // EIGEN_COMMAINITIALIZER_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 3, "covered" : 0,};
var merged_data = [];
