var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2007-2010 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_MAP_H"},
{"lineNum":"   12","line":"#define EIGEN_MAP_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":"template<typename PlainObjectType, int MapOptions, typename StrideType>"},
{"lineNum":"   20","line":"struct traits<Map<PlainObjectType, MapOptions, StrideType> >"},
{"lineNum":"   21","line":"  : public traits<PlainObjectType>"},
{"lineNum":"   22","line":"{"},
{"lineNum":"   23","line":"  typedef traits<PlainObjectType> TraitsBase;"},
{"lineNum":"   24","line":"  enum {"},
{"lineNum":"   25","line":"    PlainObjectTypeInnerSize = ((traits<PlainObjectType>::Flags&RowMajorBit)==RowMajorBit)"},
{"lineNum":"   26","line":"                             ? PlainObjectType::ColsAtCompileTime"},
{"lineNum":"   27","line":"                             : PlainObjectType::RowsAtCompileTime,"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0"},
{"lineNum":"   30","line":"                             ? int(PlainObjectType::InnerStrideAtCompileTime)"},
{"lineNum":"   31","line":"                             : int(StrideType::InnerStrideAtCompileTime),"},
{"lineNum":"   32","line":"    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0"},
{"lineNum":"   33","line":"                             ? (InnerStrideAtCompileTime==Dynamic || PlainObjectTypeInnerSize==Dynamic"},
{"lineNum":"   34","line":"                                ? Dynamic"},
{"lineNum":"   35","line":"                                : int(InnerStrideAtCompileTime) * int(PlainObjectTypeInnerSize))"},
{"lineNum":"   36","line":"                             : int(StrideType::OuterStrideAtCompileTime),"},
{"lineNum":"   37","line":"    Alignment = int(MapOptions)&int(AlignedMask),"},
{"lineNum":"   38","line":"    Flags0 = TraitsBase::Flags & (~NestByRefBit),"},
{"lineNum":"   39","line":"    Flags = is_lvalue<PlainObjectType>::value ? int(Flags0) : (int(Flags0) & ~LvalueBit)"},
{"lineNum":"   40","line":"  };"},
{"lineNum":"   41","line":"private:"},
{"lineNum":"   42","line":"  enum { Options }; // Expressions don\'t have Options"},
{"lineNum":"   43","line":"};"},
{"lineNum":"   44","line":"}"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"/** \\class Map"},
{"lineNum":"   47","line":"  * \\ingroup Core_Module"},
{"lineNum":"   48","line":"  *"},
{"lineNum":"   49","line":"  * \\brief A matrix or vector expression mapping an existing array of data."},
{"lineNum":"   50","line":"  *"},
{"lineNum":"   51","line":"  * \\tparam PlainObjectType the equivalent matrix type of the mapped data"},
{"lineNum":"   52","line":"  * \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned."},
{"lineNum":"   53","line":"  *                The default is \\c #Unaligned."},
{"lineNum":"   54","line":"  * \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout"},
{"lineNum":"   55","line":"  *                   of an ordinary, contiguous array. This can be overridden by specifying strides."},
{"lineNum":"   56","line":"  *                   The type passed here must be a specialization of the Stride template, see examples below."},
{"lineNum":"   57","line":"  *"},
{"lineNum":"   58","line":"  * This class represents a matrix or vector expression mapping an existing array of data."},
{"lineNum":"   59","line":"  * It can be used to let Eigen interface without any overhead with non-Eigen data structures,"},
{"lineNum":"   60","line":"  * such as plain C arrays or structures from other libraries. By default, it assumes that the"},
{"lineNum":"   61","line":"  * data is laid out contiguously in memory. You can however override this by explicitly specifying"},
{"lineNum":"   62","line":"  * inner and outer strides."},
{"lineNum":"   63","line":"  *"},
{"lineNum":"   64","line":"  * Here\'s an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:"},
{"lineNum":"   65","line":"  * \\include Map_simple.cpp"},
{"lineNum":"   66","line":"  * Output: \\verbinclude Map_simple.out"},
{"lineNum":"   67","line":"  *"},
{"lineNum":"   68","line":"  * If you need to map non-contiguous arrays, you can do so by specifying strides:"},
{"lineNum":"   69","line":"  *"},
{"lineNum":"   70","line":"  * Here\'s an example of mapping an array as a vector, specifying an inner stride, that is, the pointer"},
{"lineNum":"   71","line":"  * increment between two consecutive coefficients. Here, we\'re specifying the inner stride as a compile-time"},
{"lineNum":"   72","line":"  * fixed value."},
{"lineNum":"   73","line":"  * \\include Map_inner_stride.cpp"},
{"lineNum":"   74","line":"  * Output: \\verbinclude Map_inner_stride.out"},
{"lineNum":"   75","line":"  *"},
{"lineNum":"   76","line":"  * Here\'s an example of mapping an array while specifying an outer stride. Here, since we\'re mapping"},
{"lineNum":"   77","line":"  * as a column-major matrix, \'outer stride\' means the pointer increment between two consecutive columns."},
{"lineNum":"   78","line":"  * Here, we\'re specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is"},
{"lineNum":"   79","line":"  * a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride"},
{"lineNum":"   80","line":"  * is  \\c Dynamic"},
{"lineNum":"   81","line":"  * \\include Map_outer_stride.cpp"},
{"lineNum":"   82","line":"  * Output: \\verbinclude Map_outer_stride.out"},
{"lineNum":"   83","line":"  *"},
{"lineNum":"   84","line":"  * For more details and for an example of specifying both an inner and an outer stride, see class Stride."},
{"lineNum":"   85","line":"  *"},
{"lineNum":"   86","line":"  * \\b Tip: to change the array of data mapped by a Map object, you can use the C++"},
{"lineNum":"   87","line":"  * placement new syntax:"},
{"lineNum":"   88","line":"  *"},
{"lineNum":"   89","line":"  * Example: \\include Map_placement_new.cpp"},
{"lineNum":"   90","line":"  * Output: \\verbinclude Map_placement_new.out"},
{"lineNum":"   91","line":"  *"},
{"lineNum":"   92","line":"  * This class is the return type of PlainObjectBase::Map() but can also be used directly."},
{"lineNum":"   93","line":"  *"},
{"lineNum":"   94","line":"  * \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"},
{"lineNum":"   95","line":"  */"},
{"lineNum":"   96","line":"template<typename PlainObjectType, int MapOptions, typename StrideType> class Map"},
{"lineNum":"   97","line":"  : public MapBase<Map<PlainObjectType, MapOptions, StrideType> >"},
{"lineNum":"   98","line":"{"},
{"lineNum":"   99","line":"  public:"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"    typedef MapBase<Map> Base;"},
{"lineNum":"  102","line":"    EIGEN_DENSE_PUBLIC_INTERFACE(Map)"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"    typedef typename Base::PointerType PointerType;"},
{"lineNum":"  105","line":"    typedef PointerType PointerArgType;"},
{"lineNum":"  106","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  107","line":"    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  110","line":"    inline Index innerStride() const"},
{"lineNum":"  111","line":"    {"},
{"lineNum":"  112","line":"      return StrideType::InnerStrideAtCompileTime != 0 ? m_stride.inner() : 1;"},
{"lineNum":"  113","line":"    }"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    EIGEN_DEVICE_FUNC EIGEN_CONSTEXPR"},
{"lineNum":"  116","line":"    inline Index outerStride() const"},
{"lineNum":"  117","line":"    {"},
{"lineNum":"  118","line":"      return StrideType::OuterStrideAtCompileTime != 0 ? m_stride.outer()"},
{"lineNum":"  119","line":"           : internal::traits<Map>::OuterStrideAtCompileTime != Dynamic ? Index(internal::traits<Map>::OuterStrideAtCompileTime)"},
{"lineNum":"  120","line":"           : IsVectorAtCompileTime ? (this->size() * innerStride())"},
{"lineNum":"  121","line":"           : int(Flags)&RowMajorBit ? (this->cols() * innerStride())"},
{"lineNum":"  122","line":"           : (this->rows() * innerStride());"},
{"lineNum":"  123","line":"    }"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"    /** Constructor in the fixed-size case."},
{"lineNum":"  126","line":"      *"},
{"lineNum":"  127","line":"      * \\param dataPtr pointer to the array to map"},
{"lineNum":"  128","line":"      * \\param stride optional Stride object, passing the strides."},
{"lineNum":"  129","line":"      */"},
{"lineNum":"  130","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  131","line":"    explicit inline Map(PointerArgType dataPtr, const StrideType& stride = StrideType())"},
{"lineNum":"  132","line":"      : Base(cast_to_pointer_type(dataPtr)), m_stride(stride)"},
{"lineNum":"  133","line":"    {"},
{"lineNum":"  134","line":"    }"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"    /** Constructor in the dynamic-size vector case."},
{"lineNum":"  137","line":"      *"},
{"lineNum":"  138","line":"      * \\param dataPtr pointer to the array to map"},
{"lineNum":"  139","line":"      * \\param size the size of the vector expression"},
{"lineNum":"  140","line":"      * \\param stride optional Stride object, passing the strides."},
{"lineNum":"  141","line":"      */"},
{"lineNum":"  142","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  143","line":"    inline Map(PointerArgType dataPtr, Index size, const StrideType& stride = StrideType())"},
{"lineNum":"  144","line":"      : Base(cast_to_pointer_type(dataPtr), size), m_stride(stride)"},
{"lineNum":"  145","line":"    {"},
{"lineNum":"  146","line":"    }"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"    /** Constructor in the dynamic-size matrix case."},
{"lineNum":"  149","line":"      *"},
{"lineNum":"  150","line":"      * \\param dataPtr pointer to the array to map"},
{"lineNum":"  151","line":"      * \\param rows the number of rows of the matrix expression"},
{"lineNum":"  152","line":"      * \\param cols the number of columns of the matrix expression"},
{"lineNum":"  153","line":"      * \\param stride optional Stride object, passing the strides."},
{"lineNum":"  154","line":"      */"},
{"lineNum":"  155","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  156","line":"    inline Map(PointerArgType dataPtr, Index rows, Index cols, const StrideType& stride = StrideType())"},
{"lineNum":"  157","line":"      : Base(cast_to_pointer_type(dataPtr), rows, cols), m_stride(stride)"},
{"lineNum":"  158","line":"    {"},
{"lineNum":"  159","line":"    }"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Map)","class":"lineNoCov","hits":"0","possible_hits":"29",},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"  protected:"},
{"lineNum":"  164","line":"    StrideType m_stride;"},
{"lineNum":"  165","line":"};"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"} // end namespace Eigen"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"#endif // EIGEN_MAP_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
