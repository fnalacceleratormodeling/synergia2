var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":"#ifndef KOKKOS_COMPLEX_HPP"},
{"lineNum":"   45","line":"#define KOKKOS_COMPLEX_HPP"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"#include <Kokkos_Atomic.hpp>"},
{"lineNum":"   48","line":"#include <Kokkos_MathematicalFunctions.hpp>"},
{"lineNum":"   49","line":"#include <Kokkos_NumericTraits.hpp>"},
{"lineNum":"   50","line":"#include <impl/Kokkos_Error.hpp>"},
{"lineNum":"   51","line":"#include <complex>"},
{"lineNum":"   52","line":"#include <type_traits>"},
{"lineNum":"   53","line":"#include <iosfwd>"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"namespace Kokkos {"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"/// \\class complex"},
{"lineNum":"   58","line":"/// \\brief Partial reimplementation of std::complex that works as the"},
{"lineNum":"   59","line":"///   result of a Kokkos::parallel_reduce."},
{"lineNum":"   60","line":"/// \\tparam RealType The type of the real and imaginary parts of the"},
{"lineNum":"   61","line":"///   complex number.  As with std::complex, this is only defined for"},
{"lineNum":"   62","line":"///   \\c float, \\c double, and <tt>long double</tt>.  The latter is"},
{"lineNum":"   63","line":"///   currently forbidden in CUDA device kernels."},
{"lineNum":"   64","line":"template <class RealType>"},
{"lineNum":"   65","line":"class"},
{"lineNum":"   66","line":"#ifdef KOKKOS_ENABLE_COMPLEX_ALIGN"},
{"lineNum":"   67","line":"    alignas(2 * sizeof(RealType))"},
{"lineNum":"   68","line":"#endif"},
{"lineNum":"   69","line":"        complex {"},
{"lineNum":"   70","line":" private:"},
{"lineNum":"   71","line":"  RealType re_{};"},
{"lineNum":"   72","line":"  RealType im_{};"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":" public:"},
{"lineNum":"   75","line":"  //! The type of the real or imaginary parts of this complex number."},
{"lineNum":"   76","line":"  using value_type = RealType;"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"  //! Default constructor (initializes both real and imaginary parts to zero)."},
{"lineNum":"   79","line":"  KOKKOS_DEFAULTED_FUNCTION"},
{"lineNum":"   80","line":"  complex() noexcept = default;"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"  //! Copy constructor."},
{"lineNum":"   83","line":"  KOKKOS_DEFAULTED_FUNCTION"},
{"lineNum":"   84","line":"  complex(const complex&) noexcept = default;"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"  KOKKOS_DEFAULTED_FUNCTION"},
{"lineNum":"   87","line":"  complex& operator=(const complex&) noexcept = default;"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"  /// \\brief Conversion constructor from compatible RType"},
{"lineNum":"   90","line":"  template <class RType,"},
{"lineNum":"   91","line":"            typename std::enable_if<std::is_convertible<RType, RealType>::value,"},
{"lineNum":"   92","line":"                                    int>::type = 0>"},
{"lineNum":"   93","line":"  KOKKOS_INLINE_FUNCTION complex(const complex<RType>& other) noexcept"},
{"lineNum":"   94","line":"      // Intentionally do the conversions implicitly here so that users don\'t"},
{"lineNum":"   95","line":"      // get any warnings about narrowing, etc., that they would expect to get"},
{"lineNum":"   96","line":"      // otherwise."},
{"lineNum":"   97","line":"      : re_(other.real()), im_(other.imag()) {}"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"  /// \\brief Conversion constructor from std::complex."},
{"lineNum":"  100","line":"  ///"},
{"lineNum":"  101","line":"  /// This constructor cannot be called in a CUDA device function,"},
{"lineNum":"  102","line":"  /// because std::complex\'s methods and nonmember functions are not"},
{"lineNum":"  103","line":"  /// marked as CUDA device functions."},
{"lineNum":"  104","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  105","line":"  complex(const std::complex<RealType>& src) noexcept"},
{"lineNum":"  106","line":"      // We can use this aspect of the standard to avoid calling"},
{"lineNum":"  107","line":"      // non-device-marked functions `std::real` and `std::imag`: \"For any"},
{"lineNum":"  108","line":"      // object z of type complex<T>, reinterpret_cast<T(&)[2]>(z)[0] is the"},
{"lineNum":"  109","line":"      // real part of z and reinterpret_cast<T(&)[2]>(z)[1] is the imaginary"},
{"lineNum":"  110","line":"      // part of z.\" Now we don\'t have to provide a whole bunch of the overloads"},
{"lineNum":"  111","line":"      // of things taking either Kokkos::complex or std::complex"},
{"lineNum":"  112","line":"      : re_(reinterpret_cast<const RealType (&)[2]>(src)[0]),","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  113","line":"        im_(reinterpret_cast<const RealType (&)[2]>(src)[1]) {}","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"  /// \\brief Conversion operator to std::complex."},
{"lineNum":"  116","line":"  ///"},
{"lineNum":"  117","line":"  /// This operator cannot be called in a CUDA device function,"},
{"lineNum":"  118","line":"  /// because std::complex\'s methods and nonmember functions are not"},
{"lineNum":"  119","line":"  /// marked as CUDA device functions."},
{"lineNum":"  120","line":"  // TODO: make explicit.  DJS 2019-08-28"},
{"lineNum":"  121","line":"  operator std::complex<RealType>() const noexcept {"},
{"lineNum":"  122","line":"    return std::complex<RealType>(re_, im_);"},
{"lineNum":"  123","line":"  }"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"  /// \\brief Constructor that takes just the real part, and sets the"},
{"lineNum":"  126","line":"  ///   imaginary part to zero."},
{"lineNum":"  127","line":"  KOKKOS_INLINE_FUNCTION complex(const RealType& val) noexcept"},
{"lineNum":"  128","line":"      : re_(val), im_(static_cast<RealType>(0)) {}"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"  //! Constructor that takes the real and imaginary parts."},
{"lineNum":"  131","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  132","line":"  complex(const RealType& re, const RealType& im) noexcept : re_(re), im_(im) {}"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"  //! Assignment operator (from a real number)."},
{"lineNum":"  135","line":"  KOKKOS_INLINE_FUNCTION complex& operator=(const RealType& val) noexcept {"},
{"lineNum":"  136","line":"    re_ = val;"},
{"lineNum":"  137","line":"    im_ = RealType(0);"},
{"lineNum":"  138","line":"    return *this;"},
{"lineNum":"  139","line":"  }"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"  /// \\brief Assignment operator from std::complex."},
{"lineNum":"  142","line":"  ///"},
{"lineNum":"  143","line":"  /// This constructor cannot be called in a CUDA device function,"},
{"lineNum":"  144","line":"  /// because std::complex\'s methods and nonmember functions are not"},
{"lineNum":"  145","line":"  /// marked as CUDA device functions."},
{"lineNum":"  146","line":"  complex& operator=(const std::complex<RealType>& src) noexcept {"},
{"lineNum":"  147","line":"    *this = complex(src);"},
{"lineNum":"  148","line":"    return *this;"},
{"lineNum":"  149","line":"  }"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"  //! The imaginary part of this complex number."},
{"lineNum":"  152","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  153","line":"  KOKKOS_CONSTEXPR_14 RealType& imag() noexcept { return im_; }"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"  //! The real part of this complex number."},
{"lineNum":"  156","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  157","line":"  KOKKOS_CONSTEXPR_14 RealType& real() noexcept { return re_; }"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"  //! The imaginary part of this complex number."},
{"lineNum":"  160","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  161","line":"  constexpr RealType imag() const noexcept { return im_; }"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"  //! The real part of this complex number."},
{"lineNum":"  164","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  165","line":"  constexpr RealType real() const noexcept { return re_; }"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"  //! Set the imaginary part of this complex number."},
{"lineNum":"  168","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  169","line":"  KOKKOS_CONSTEXPR_14"},
{"lineNum":"  170","line":"  void imag(RealType v) noexcept { im_ = v; }"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"  //! Set the real part of this complex number."},
{"lineNum":"  173","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  174","line":"  KOKKOS_CONSTEXPR_14"},
{"lineNum":"  175","line":"  void real(RealType v) noexcept { re_ = v; }"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"  KOKKOS_CONSTEXPR_14 KOKKOS_INLINE_FUNCTION complex& operator+=("},
{"lineNum":"  178","line":"      const complex<RealType>& src) noexcept {"},
{"lineNum":"  179","line":"    re_ += src.re_;"},
{"lineNum":"  180","line":"    im_ += src.im_;"},
{"lineNum":"  181","line":"    return *this;"},
{"lineNum":"  182","line":"  }"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"  KOKKOS_CONSTEXPR_14 KOKKOS_INLINE_FUNCTION complex& operator+=("},
{"lineNum":"  185","line":"      const RealType& src) noexcept {"},
{"lineNum":"  186","line":"    re_ += src;"},
{"lineNum":"  187","line":"    return *this;"},
{"lineNum":"  188","line":"  }"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"  KOKKOS_CONSTEXPR_14 KOKKOS_INLINE_FUNCTION complex& operator-=("},
{"lineNum":"  191","line":"      const complex<RealType>& src) noexcept {"},
{"lineNum":"  192","line":"    re_ -= src.re_;"},
{"lineNum":"  193","line":"    im_ -= src.im_;"},
{"lineNum":"  194","line":"    return *this;"},
{"lineNum":"  195","line":"  }"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"  KOKKOS_CONSTEXPR_14 KOKKOS_INLINE_FUNCTION complex& operator-=("},
{"lineNum":"  198","line":"      const RealType& src) noexcept {"},
{"lineNum":"  199","line":"    re_ -= src;"},
{"lineNum":"  200","line":"    return *this;"},
{"lineNum":"  201","line":"  }"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"  KOKKOS_CONSTEXPR_14 KOKKOS_INLINE_FUNCTION complex& operator*=("},
{"lineNum":"  204","line":"      const complex<RealType>& src) noexcept {"},
{"lineNum":"  205","line":"    const RealType realPart = re_ * src.re_ - im_ * src.im_;"},
{"lineNum":"  206","line":"    const RealType imagPart = re_ * src.im_ + im_ * src.re_;"},
{"lineNum":"  207","line":"    re_                     = realPart;"},
{"lineNum":"  208","line":"    im_                     = imagPart;"},
{"lineNum":"  209","line":"    return *this;"},
{"lineNum":"  210","line":"  }"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"  KOKKOS_CONSTEXPR_14 KOKKOS_INLINE_FUNCTION complex& operator*=("},
{"lineNum":"  213","line":"      const RealType& src) noexcept {"},
{"lineNum":"  214","line":"    re_ *= src;"},
{"lineNum":"  215","line":"    im_ *= src;"},
{"lineNum":"  216","line":"    return *this;"},
{"lineNum":"  217","line":"  }"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"  // Conditional noexcept, just in case RType throws on divide-by-zero"},
{"lineNum":"  220","line":"  KOKKOS_CONSTEXPR_14 KOKKOS_INLINE_FUNCTION complex& operator/=("},
{"lineNum":"  221","line":"      const complex<RealType>& y) noexcept(noexcept(RealType{} / RealType{})) {"},
{"lineNum":"  222","line":"    using Kokkos::Experimental::fabs;"},
{"lineNum":"  223","line":"    // Scale (by the \"1-norm\" of y) to avoid unwarranted overflow."},
{"lineNum":"  224","line":"    // If the real part is +/-Inf and the imaginary part is -/+Inf,"},
{"lineNum":"  225","line":"    // this won\'t change the result."},
{"lineNum":"  226","line":"    const RealType s = fabs(y.real()) + fabs(y.imag());"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"    // If s is 0, then y is zero, so x/y == real(x)/0 + i*imag(x)/0."},
{"lineNum":"  229","line":"    // In that case, the relation x/y == (x/s) / (y/s) doesn\'t hold,"},
{"lineNum":"  230","line":"    // because y/s is NaN."},
{"lineNum":"  231","line":"    // TODO mark this branch unlikely"},
{"lineNum":"  232","line":"    if (s == RealType(0)) {"},
{"lineNum":"  233","line":"      this->re_ /= s;"},
{"lineNum":"  234","line":"      this->im_ /= s;"},
{"lineNum":"  235","line":"    } else {"},
{"lineNum":"  236","line":"      const complex x_scaled(this->re_ / s, this->im_ / s);"},
{"lineNum":"  237","line":"      const complex y_conj_scaled(y.re_ / s, -(y.im_) / s);"},
{"lineNum":"  238","line":"      const RealType y_scaled_abs ="},
{"lineNum":"  239","line":"          y_conj_scaled.re_ * y_conj_scaled.re_ +"},
{"lineNum":"  240","line":"          y_conj_scaled.im_ * y_conj_scaled.im_;  // abs(y) == abs(conj(y))"},
{"lineNum":"  241","line":"      *this = x_scaled * y_conj_scaled;"},
{"lineNum":"  242","line":"      *this /= y_scaled_abs;"},
{"lineNum":"  243","line":"    }"},
{"lineNum":"  244","line":"    return *this;"},
{"lineNum":"  245","line":"  }"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"  KOKKOS_CONSTEXPR_14"},
{"lineNum":"  248","line":"  KOKKOS_INLINE_FUNCTION complex& operator/=("},
{"lineNum":"  249","line":"      const std::complex<RealType>& y) noexcept(noexcept(RealType{} /"},
{"lineNum":"  250","line":"                                                         RealType{})) {"},
{"lineNum":"  251","line":"    using Kokkos::Experimental::fabs;"},
{"lineNum":"  252","line":"    // Scale (by the \"1-norm\" of y) to avoid unwarranted overflow."},
{"lineNum":"  253","line":"    // If the real part is +/-Inf and the imaginary part is -/+Inf,"},
{"lineNum":"  254","line":"    // this won\'t change the result."},
{"lineNum":"  255","line":"    const RealType s = fabs(y.real()) + fabs(y.imag());"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"    // If s is 0, then y is zero, so x/y == real(x)/0 + i*imag(x)/0."},
{"lineNum":"  258","line":"    // In that case, the relation x/y == (x/s) / (y/s) doesn\'t hold,"},
{"lineNum":"  259","line":"    // because y/s is NaN."},
{"lineNum":"  260","line":"    if (s == RealType(0)) {"},
{"lineNum":"  261","line":"      this->re_ /= s;"},
{"lineNum":"  262","line":"      this->im_ /= s;"},
{"lineNum":"  263","line":"    } else {"},
{"lineNum":"  264","line":"      const complex x_scaled(this->re_ / s, this->im_ / s);"},
{"lineNum":"  265","line":"      const complex y_conj_scaled(y.re_ / s, -(y.im_) / s);"},
{"lineNum":"  266","line":"      const RealType y_scaled_abs ="},
{"lineNum":"  267","line":"          y_conj_scaled.re_ * y_conj_scaled.re_ +"},
{"lineNum":"  268","line":"          y_conj_scaled.im_ * y_conj_scaled.im_;  // abs(y) == abs(conj(y))"},
{"lineNum":"  269","line":"      *this = x_scaled * y_conj_scaled;"},
{"lineNum":"  270","line":"      *this /= y_scaled_abs;"},
{"lineNum":"  271","line":"    }"},
{"lineNum":"  272","line":"    return *this;"},
{"lineNum":"  273","line":"  }"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"  KOKKOS_CONSTEXPR_14 KOKKOS_INLINE_FUNCTION complex& operator/=("},
{"lineNum":"  276","line":"      const RealType& src) noexcept(noexcept(RealType{} / RealType{})) {"},
{"lineNum":"  277","line":"    re_ /= src;"},
{"lineNum":"  278","line":"    im_ /= src;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  279","line":"    return *this;"},
{"lineNum":"  280","line":"  }"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"  //---------------------------------------------------------------------------"},
{"lineNum":"  283","line":"  // TODO: refactor Kokkos reductions to remove dependency on"},
{"lineNum":"  284","line":"  // volatile member overloads since they are being deprecated in c++20"},
{"lineNum":"  285","line":"  //---------------------------------------------------------------------------"},
{"lineNum":"  286","line":""},
{"lineNum":"  287","line":"  //! Copy constructor from volatile."},
{"lineNum":"  288","line":"  template <class RType,"},
{"lineNum":"  289","line":"            typename std::enable_if<std::is_convertible<RType, RealType>::value,"},
{"lineNum":"  290","line":"                                    int>::type = 0>"},
{"lineNum":"  291","line":"  KOKKOS_INLINE_FUNCTION complex(const volatile complex<RType>& src) noexcept"},
{"lineNum":"  292","line":"      // Intentionally do the conversions implicitly here so that users don\'t"},
{"lineNum":"  293","line":"      // get any warnings about narrowing, etc., that they would expect to get"},
{"lineNum":"  294","line":"      // otherwise."},
{"lineNum":"  295","line":"      : re_(src.re_), im_(src.im_) {}"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"  /// \\brief Assignment operator, for volatile <tt>*this</tt> and"},
{"lineNum":"  298","line":"  ///   nonvolatile input."},
{"lineNum":"  299","line":"  ///"},
{"lineNum":"  300","line":"  /// \\param src [in] Input; right-hand side of the assignment."},
{"lineNum":"  301","line":"  ///"},
{"lineNum":"  302","line":"  /// This operator returns \\c void instead of <tt>volatile"},
{"lineNum":"  303","line":"  /// complex& </tt>.  See Kokkos Issue #177 for the"},
{"lineNum":"  304","line":"  /// explanation.  In practice, this means that you should not chain"},
{"lineNum":"  305","line":"  /// assignments with volatile lvalues."},
{"lineNum":"  306","line":"  //"},
{"lineNum":"  307","line":"  // Templated, so as not to be a copy assignment operator (Kokkos issue #2577)"},
{"lineNum":"  308","line":"  // Intended to behave as"},
{"lineNum":"  309","line":"  //    void operator=(const complex&) volatile noexcept"},
{"lineNum":"  310","line":"  //"},
{"lineNum":"  311","line":"  // Use cases:"},
{"lineNum":"  312","line":"  //    complex r;"},
{"lineNum":"  313","line":"  //    const complex cr;"},
{"lineNum":"  314","line":"  //    volatile complex vl;"},
{"lineNum":"  315","line":"  //    vl = r;"},
{"lineNum":"  316","line":"  //    vl = cr;"},
{"lineNum":"  317","line":"  template <class Complex,"},
{"lineNum":"  318","line":"            typename std::enable_if<std::is_same<Complex, complex>::value,"},
{"lineNum":"  319","line":"                                    int>::type = 0>"},
{"lineNum":"  320","line":"  KOKKOS_INLINE_FUNCTION void operator=(const Complex& src) volatile noexcept {"},
{"lineNum":"  321","line":"    re_ = src.re_;"},
{"lineNum":"  322","line":"    im_ = src.im_;"},
{"lineNum":"  323","line":"    // We deliberately do not return anything here.  See explanation"},
{"lineNum":"  324","line":"    // in public documentation above."},
{"lineNum":"  325","line":"  }"},
{"lineNum":"  326","line":""},
{"lineNum":"  327","line":"  //! Assignment operator, volatile LHS and volatile RHS"},
{"lineNum":"  328","line":"  // TODO Should this return void like the other volatile assignment operators?"},
{"lineNum":"  329","line":"  //"},
{"lineNum":"  330","line":"  // Templated, so as not to be a copy assignment operator (Kokkos issue #2577)"},
{"lineNum":"  331","line":"  // Intended to behave as"},
{"lineNum":"  332","line":"  //    volatile complex& operator=(const volatile complex&) volatile noexcept"},
{"lineNum":"  333","line":"  //"},
{"lineNum":"  334","line":"  // Use cases:"},
{"lineNum":"  335","line":"  //    volatile complex vr;"},
{"lineNum":"  336","line":"  //    const volatile complex cvr;"},
{"lineNum":"  337","line":"  //    volatile complex vl;"},
{"lineNum":"  338","line":"  //    vl = vr;"},
{"lineNum":"  339","line":"  //    vl = cvr;"},
{"lineNum":"  340","line":"  template <class Complex,"},
{"lineNum":"  341","line":"            typename std::enable_if<std::is_same<Complex, complex>::value,"},
{"lineNum":"  342","line":"                                    int>::type = 0>"},
{"lineNum":"  343","line":"  KOKKOS_INLINE_FUNCTION volatile complex& operator=("},
{"lineNum":"  344","line":"      const volatile Complex& src) volatile noexcept {"},
{"lineNum":"  345","line":"    re_ = src.re_;"},
{"lineNum":"  346","line":"    im_ = src.im_;"},
{"lineNum":"  347","line":"    return *this;"},
{"lineNum":"  348","line":"  }"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"  //! Assignment operator, volatile RHS and non-volatile LHS"},
{"lineNum":"  351","line":"  //"},
{"lineNum":"  352","line":"  // Templated, so as not to be a copy assignment operator (Kokkos issue #2577)"},
{"lineNum":"  353","line":"  // Intended to behave as"},
{"lineNum":"  354","line":"  //    complex& operator=(const volatile complex&) noexcept"},
{"lineNum":"  355","line":"  //"},
{"lineNum":"  356","line":"  // Use cases:"},
{"lineNum":"  357","line":"  //    volatile complex vr;"},
{"lineNum":"  358","line":"  //    const volatile complex cvr;"},
{"lineNum":"  359","line":"  //    complex l;"},
{"lineNum":"  360","line":"  //    l = vr;"},
{"lineNum":"  361","line":"  //    l = cvr;"},
{"lineNum":"  362","line":"  //"},
{"lineNum":"  363","line":"  template <class Complex,"},
{"lineNum":"  364","line":"            typename std::enable_if<std::is_same<Complex, complex>::value,"},
{"lineNum":"  365","line":"                                    int>::type = 0>"},
{"lineNum":"  366","line":"  KOKKOS_INLINE_FUNCTION complex& operator=("},
{"lineNum":"  367","line":"      const volatile Complex& src) noexcept {"},
{"lineNum":"  368","line":"    re_ = src.re_;"},
{"lineNum":"  369","line":"    im_ = src.im_;"},
{"lineNum":"  370","line":"    return *this;"},
{"lineNum":"  371","line":"  }"},
{"lineNum":"  372","line":""},
{"lineNum":"  373","line":"  // Mirroring the behavior of the assignment operators from complex RHS in the"},
{"lineNum":"  374","line":"  // RealType RHS versions."},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"  //! Assignment operator (from a volatile real number)."},
{"lineNum":"  377","line":"  KOKKOS_INLINE_FUNCTION void operator=(const volatile RealType& val) noexcept {"},
{"lineNum":"  378","line":"    re_ = val;"},
{"lineNum":"  379","line":"    im_ = RealType(0);"},
{"lineNum":"  380","line":"    // We deliberately do not return anything here.  See explanation"},
{"lineNum":"  381","line":"    // in public documentation above."},
{"lineNum":"  382","line":"  }"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"  //! Assignment operator volatile LHS and non-volatile RHS"},
{"lineNum":"  385","line":"  KOKKOS_INLINE_FUNCTION complex& operator=("},
{"lineNum":"  386","line":"      const RealType& val) volatile noexcept {"},
{"lineNum":"  387","line":"    re_ = val;"},
{"lineNum":"  388","line":"    im_ = RealType(0);"},
{"lineNum":"  389","line":"    return *this;"},
{"lineNum":"  390","line":"  }"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"  //! Assignment operator volatile LHS and volatile RHS"},
{"lineNum":"  393","line":"  // TODO Should this return void like the other volatile assignment operators?"},
{"lineNum":"  394","line":"  KOKKOS_INLINE_FUNCTION complex& operator=("},
{"lineNum":"  395","line":"      const volatile RealType& val) volatile noexcept {"},
{"lineNum":"  396","line":"    re_ = val;"},
{"lineNum":"  397","line":"    im_ = RealType(0);"},
{"lineNum":"  398","line":"    return *this;"},
{"lineNum":"  399","line":"  }"},
{"lineNum":"  400","line":""},
{"lineNum":"  401","line":"  //! The imaginary part of this complex number (volatile overload)."},
{"lineNum":"  402","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  403","line":"  volatile RealType& imag() volatile noexcept { return im_; }"},
{"lineNum":"  404","line":""},
{"lineNum":"  405","line":"  //! The real part of this complex number (volatile overload)."},
{"lineNum":"  406","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  407","line":"  volatile RealType& real() volatile noexcept { return re_; }"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"  //! The imaginary part of this complex number (volatile overload)."},
{"lineNum":"  410","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  411","line":"  RealType imag() const volatile noexcept { return im_; }"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"  //! The real part of this complex number (volatile overload)."},
{"lineNum":"  414","line":"  KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  415","line":"  RealType real() const volatile noexcept { return re_; }"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"  KOKKOS_INLINE_FUNCTION void operator+=("},
{"lineNum":"  418","line":"      const volatile complex<RealType>& src) volatile noexcept {"},
{"lineNum":"  419","line":"    re_ += src.re_;"},
{"lineNum":"  420","line":"    im_ += src.im_;"},
{"lineNum":"  421","line":"  }"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"  KOKKOS_INLINE_FUNCTION void operator+=("},
{"lineNum":"  424","line":"      const volatile RealType& src) volatile noexcept {"},
{"lineNum":"  425","line":"    re_ += src;"},
{"lineNum":"  426","line":"  }"},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"  KOKKOS_INLINE_FUNCTION void operator*=("},
{"lineNum":"  429","line":"      const volatile complex<RealType>& src) volatile noexcept {"},
{"lineNum":"  430","line":"    const RealType realPart = re_ * src.re_ - im_ * src.im_;"},
{"lineNum":"  431","line":"    const RealType imagPart = re_ * src.im_ + im_ * src.re_;"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"    re_ = realPart;"},
{"lineNum":"  434","line":"    im_ = imagPart;"},
{"lineNum":"  435","line":"  }"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"  KOKKOS_INLINE_FUNCTION void operator*=("},
{"lineNum":"  438","line":"      const volatile RealType& src) volatile noexcept {"},
{"lineNum":"  439","line":"    re_ *= src;"},
{"lineNum":"  440","line":"    im_ *= src;"},
{"lineNum":"  441","line":"  }"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"  // TODO DSH 2019-10-7 why are there no volatile /= and friends?"},
{"lineNum":"  444","line":"};"},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":"//=============================================================================="},
{"lineNum":"  447","line":"// <editor-fold desc=\"Equality and inequality\"> {{{1"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"// Note that this is not the same behavior as std::complex, which doesn\'t allow"},
{"lineNum":"  450","line":"// implicit conversions, but since this is the way we had it before, we have"},
{"lineNum":"  451","line":"// to do it this way now."},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"//! Binary == operator for complex complex."},
{"lineNum":"  454","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  455","line":"KOKKOS_INLINE_FUNCTION bool operator==(complex<RealType1> const& x,"},
{"lineNum":"  456","line":"                                       complex<RealType2> const& y) noexcept {"},
{"lineNum":"  457","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  458","line":"  return common_type(x.real()) == common_type(y.real()) &&"},
{"lineNum":"  459","line":"         common_type(x.imag()) == common_type(y.imag());"},
{"lineNum":"  460","line":"}"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"// TODO (here and elsewhere) decide if we should convert to a Kokkos::complex"},
{"lineNum":"  463","line":"//      and do the comparison in a device-marked function"},
{"lineNum":"  464","line":"//! Binary == operator for std::complex complex."},
{"lineNum":"  465","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  466","line":"inline bool operator==(std::complex<RealType1> const& x,"},
{"lineNum":"  467","line":"                       complex<RealType2> const& y) noexcept {"},
{"lineNum":"  468","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  469","line":"  return common_type(x.real()) == common_type(y.real()) &&"},
{"lineNum":"  470","line":"         common_type(x.imag()) == common_type(y.imag());"},
{"lineNum":"  471","line":"}"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"//! Binary == operator for complex std::complex."},
{"lineNum":"  474","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  475","line":"inline bool operator==(complex<RealType1> const& x,"},
{"lineNum":"  476","line":"                       std::complex<RealType2> const& y) noexcept {"},
{"lineNum":"  477","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  478","line":"  return common_type(x.real()) == common_type(y.real()) &&"},
{"lineNum":"  479","line":"         common_type(x.imag()) == common_type(y.imag());"},
{"lineNum":"  480","line":"}"},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"//! Binary == operator for complex real."},
{"lineNum":"  483","line":"template <"},
{"lineNum":"  484","line":"    class RealType1, class RealType2,"},
{"lineNum":"  485","line":"    // Constraints to avoid participation in oparator==() for every possible RHS"},
{"lineNum":"  486","line":"    typename std::enable_if<std::is_convertible<RealType2, RealType1>::value,"},
{"lineNum":"  487","line":"                            int>::type = 0>"},
{"lineNum":"  488","line":"KOKKOS_INLINE_FUNCTION bool operator==(complex<RealType1> const& x,"},
{"lineNum":"  489","line":"                                       RealType2 const& y) noexcept {"},
{"lineNum":"  490","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  491","line":"  return common_type(x.real()) == common_type(y) &&"},
{"lineNum":"  492","line":"         common_type(x.imag()) == common_type(0);"},
{"lineNum":"  493","line":"}"},
{"lineNum":"  494","line":""},
{"lineNum":"  495","line":"//! Binary == operator for real complex."},
{"lineNum":"  496","line":"template <"},
{"lineNum":"  497","line":"    class RealType1, class RealType2,"},
{"lineNum":"  498","line":"    // Constraints to avoid participation in oparator==() for every possible RHS"},
{"lineNum":"  499","line":"    typename std::enable_if<std::is_convertible<RealType1, RealType2>::value,"},
{"lineNum":"  500","line":"                            int>::type = 0>"},
{"lineNum":"  501","line":"KOKKOS_INLINE_FUNCTION bool operator==(RealType1 const& x,"},
{"lineNum":"  502","line":"                                       complex<RealType2> const& y) noexcept {"},
{"lineNum":"  503","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  504","line":"  return common_type(x) == common_type(y.real()) &&"},
{"lineNum":"  505","line":"         common_type(0) == common_type(y.imag());"},
{"lineNum":"  506","line":"}"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"//! Binary != operator for complex complex."},
{"lineNum":"  509","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  510","line":"KOKKOS_INLINE_FUNCTION bool operator!=(complex<RealType1> const& x,"},
{"lineNum":"  511","line":"                                       complex<RealType2> const& y) noexcept {"},
{"lineNum":"  512","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  513","line":"  return common_type(x.real()) != common_type(y.real()) ||"},
{"lineNum":"  514","line":"         common_type(x.imag()) != common_type(y.imag());"},
{"lineNum":"  515","line":"}"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"//! Binary != operator for std::complex complex."},
{"lineNum":"  518","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  519","line":"inline bool operator!=(std::complex<RealType1> const& x,"},
{"lineNum":"  520","line":"                       complex<RealType2> const& y) noexcept {"},
{"lineNum":"  521","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  522","line":"  return common_type(x.real()) != common_type(y.real()) ||"},
{"lineNum":"  523","line":"         common_type(x.imag()) != common_type(y.imag());"},
{"lineNum":"  524","line":"}"},
{"lineNum":"  525","line":""},
{"lineNum":"  526","line":"//! Binary != operator for complex std::complex."},
{"lineNum":"  527","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  528","line":"inline bool operator!=(complex<RealType1> const& x,"},
{"lineNum":"  529","line":"                       std::complex<RealType2> const& y) noexcept {"},
{"lineNum":"  530","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  531","line":"  return common_type(x.real()) != common_type(y.real()) ||"},
{"lineNum":"  532","line":"         common_type(x.imag()) != common_type(y.imag());"},
{"lineNum":"  533","line":"}"},
{"lineNum":"  534","line":""},
{"lineNum":"  535","line":"//! Binary != operator for complex real."},
{"lineNum":"  536","line":"template <"},
{"lineNum":"  537","line":"    class RealType1, class RealType2,"},
{"lineNum":"  538","line":"    // Constraints to avoid participation in oparator==() for every possible RHS"},
{"lineNum":"  539","line":"    typename std::enable_if<std::is_convertible<RealType2, RealType1>::value,"},
{"lineNum":"  540","line":"                            int>::type = 0>"},
{"lineNum":"  541","line":"KOKKOS_INLINE_FUNCTION bool operator!=(complex<RealType1> const& x,"},
{"lineNum":"  542","line":"                                       RealType2 const& y) noexcept {"},
{"lineNum":"  543","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  544","line":"  return common_type(x.real()) != common_type(y) ||"},
{"lineNum":"  545","line":"         common_type(x.imag()) != common_type(0);"},
{"lineNum":"  546","line":"}"},
{"lineNum":"  547","line":""},
{"lineNum":"  548","line":"//! Binary != operator for real complex."},
{"lineNum":"  549","line":"template <"},
{"lineNum":"  550","line":"    class RealType1, class RealType2,"},
{"lineNum":"  551","line":"    // Constraints to avoid participation in oparator==() for every possible RHS"},
{"lineNum":"  552","line":"    typename std::enable_if<std::is_convertible<RealType1, RealType2>::value,"},
{"lineNum":"  553","line":"                            int>::type = 0>"},
{"lineNum":"  554","line":"KOKKOS_INLINE_FUNCTION bool operator!=(RealType1 const& x,"},
{"lineNum":"  555","line":"                                       complex<RealType2> const& y) noexcept {"},
{"lineNum":"  556","line":"  using common_type = typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":"  557","line":"  return common_type(x) != common_type(y.real()) ||"},
{"lineNum":"  558","line":"         common_type(0) != common_type(y.imag());"},
{"lineNum":"  559","line":"}"},
{"lineNum":"  560","line":""},
{"lineNum":"  561","line":"// </editor-fold> end Equality and inequality }}}1"},
{"lineNum":"  562","line":"//=============================================================================="},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"//! Binary + operator for complex complex."},
{"lineNum":"  565","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  566","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  567","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  568","line":"    operator+(const complex<RealType1>& x,"},
{"lineNum":"  569","line":"              const complex<RealType2>& y) noexcept {"},
{"lineNum":"  570","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  571","line":"      x.real() + y.real(), x.imag() + y.imag());","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  572","line":"}"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"//! Binary + operator for complex scalar."},
{"lineNum":"  575","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  576","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  577","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  578","line":"    operator+(const complex<RealType1>& x, const RealType2& y) noexcept {"},
{"lineNum":"  579","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  580","line":"      x.real() + y, x.imag());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  581","line":"}"},
{"lineNum":"  582","line":""},
{"lineNum":"  583","line":"//! Binary + operator for scalar complex."},
{"lineNum":"  584","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  585","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  586","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  587","line":"    operator+(const RealType1& x, const complex<RealType2>& y) noexcept {"},
{"lineNum":"  588","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  589","line":"      x + y.real(), y.imag());"},
{"lineNum":"  590","line":"}"},
{"lineNum":"  591","line":""},
{"lineNum":"  592","line":"//! Unary + operator for complex."},
{"lineNum":"  593","line":"template <class RealType>"},
{"lineNum":"  594","line":"KOKKOS_INLINE_FUNCTION complex<RealType> operator+("},
{"lineNum":"  595","line":"    const complex<RealType>& x) noexcept {"},
{"lineNum":"  596","line":"  return complex<RealType>{+x.real(), +x.imag()};"},
{"lineNum":"  597","line":"}"},
{"lineNum":"  598","line":""},
{"lineNum":"  599","line":"//! Binary - operator for complex."},
{"lineNum":"  600","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  601","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  602","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  603","line":"    operator-(const complex<RealType1>& x,"},
{"lineNum":"  604","line":"              const complex<RealType2>& y) noexcept {"},
{"lineNum":"  605","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  606","line":"      x.real() - y.real(), x.imag() - y.imag());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  607","line":"}"},
{"lineNum":"  608","line":""},
{"lineNum":"  609","line":"//! Binary - operator for complex scalar."},
{"lineNum":"  610","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  611","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  612","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  613","line":"    operator-(const complex<RealType1>& x, const RealType2& y) noexcept {"},
{"lineNum":"  614","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  615","line":"      x.real() - y, x.imag());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  616","line":"}"},
{"lineNum":"  617","line":""},
{"lineNum":"  618","line":"//! Binary - operator for scalar complex."},
{"lineNum":"  619","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  620","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  621","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  622","line":"    operator-(const RealType1& x, const complex<RealType2>& y) noexcept {"},
{"lineNum":"  623","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  624","line":"      x - y.real(), -y.imag());"},
{"lineNum":"  625","line":"}"},
{"lineNum":"  626","line":""},
{"lineNum":"  627","line":"//! Unary - operator for complex."},
{"lineNum":"  628","line":"template <class RealType>"},
{"lineNum":"  629","line":"KOKKOS_INLINE_FUNCTION complex<RealType> operator-("},
{"lineNum":"  630","line":"    const complex<RealType>& x) noexcept {"},
{"lineNum":"  631","line":"  return complex<RealType>(-x.real(), -x.imag());"},
{"lineNum":"  632","line":"}"},
{"lineNum":"  633","line":""},
{"lineNum":"  634","line":"//! Binary * operator for complex."},
{"lineNum":"  635","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  636","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  637","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  638","line":"    operator*(const complex<RealType1>& x,"},
{"lineNum":"  639","line":"              const complex<RealType2>& y) noexcept {"},
{"lineNum":"  640","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  641","line":"      x.real() * y.real() - x.imag() * y.imag(),","class":"lineNoCov","hits":"0","possible_hits":"17",},
{"lineNum":"  642","line":"      x.real() * y.imag() + x.imag() * y.real());","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  643","line":"}"},
{"lineNum":"  644","line":""},
{"lineNum":"  645","line":"/// \\brief Binary * operator for std::complex and complex."},
{"lineNum":"  646","line":"///"},
{"lineNum":"  647","line":"/// This needs to exist because template parameters can\'t be deduced when"},
{"lineNum":"  648","line":"/// conversions occur.  We could probably fix this using hidden friends patterns"},
{"lineNum":"  649","line":"///"},
{"lineNum":"  650","line":"/// This function cannot be called in a CUDA device function, because"},
{"lineNum":"  651","line":"/// std::complex\'s methods and nonmember functions are not marked as"},
{"lineNum":"  652","line":"/// CUDA device functions."},
{"lineNum":"  653","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  654","line":"inline complex<typename std::common_type<RealType1, RealType2>::type> operator*("},
{"lineNum":"  655","line":"    const std::complex<RealType1>& x, const complex<RealType2>& y) {"},
{"lineNum":"  656","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  657","line":"      x.real() * y.real() - x.imag() * y.imag(),"},
{"lineNum":"  658","line":"      x.real() * y.imag() + x.imag() * y.real());"},
{"lineNum":"  659","line":"}"},
{"lineNum":"  660","line":""},
{"lineNum":"  661","line":"/// \\brief Binary * operator for RealType times complex."},
{"lineNum":"  662","line":"///"},
{"lineNum":"  663","line":"/// This function exists because the compiler doesn\'t know that"},
{"lineNum":"  664","line":"/// RealType and complex<RealType> commute with respect to operator*."},
{"lineNum":"  665","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  666","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  667","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  668","line":"    operator*(const RealType1& x, const complex<RealType2>& y) noexcept {"},
{"lineNum":"  669","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  670","line":"      x * y.real(), x * y.imag());"},
{"lineNum":"  671","line":"}"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"/// \\brief Binary * operator for RealType times complex."},
{"lineNum":"  674","line":"///"},
{"lineNum":"  675","line":"/// This function exists because the compiler doesn\'t know that"},
{"lineNum":"  676","line":"/// RealType and complex<RealType> commute with respect to operator*."},
{"lineNum":"  677","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  678","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  679","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  680","line":"    operator*(const complex<RealType1>& y, const RealType2& x) noexcept {"},
{"lineNum":"  681","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  682","line":"      x * y.real(), x * y.imag());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  683","line":"}"},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"//! Imaginary part of a complex number."},
{"lineNum":"  686","line":"template <class RealType>"},
{"lineNum":"  687","line":"KOKKOS_INLINE_FUNCTION RealType imag(const complex<RealType>& x) noexcept {"},
{"lineNum":"  688","line":"  return x.imag();"},
{"lineNum":"  689","line":"}"},
{"lineNum":"  690","line":""},
{"lineNum":"  691","line":"//! Real part of a complex number."},
{"lineNum":"  692","line":"template <class RealType>"},
{"lineNum":"  693","line":"KOKKOS_INLINE_FUNCTION RealType real(const complex<RealType>& x) noexcept {"},
{"lineNum":"  694","line":"  return x.real();"},
{"lineNum":"  695","line":"}"},
{"lineNum":"  696","line":""},
{"lineNum":"  697","line":"//! Constructs a complex number from magnitude and phase angle"},
{"lineNum":"  698","line":"template <class T>"},
{"lineNum":"  699","line":"KOKKOS_INLINE_FUNCTION complex<T> polar(const T& r, const T& theta = T()) {"},
{"lineNum":"  700","line":"  using Kokkos::Experimental::cos;"},
{"lineNum":"  701","line":"  using Kokkos::Experimental::sin;"},
{"lineNum":"  702","line":"  KOKKOS_EXPECTS(r >= 0);"},
{"lineNum":"  703","line":"  return complex<T>(r * cos(theta), r * sin(theta));"},
{"lineNum":"  704","line":"}"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":"//! Absolute value (magnitude) of a complex number."},
{"lineNum":"  707","line":"template <class RealType>"},
{"lineNum":"  708","line":"KOKKOS_INLINE_FUNCTION RealType abs(const complex<RealType>& x) {"},
{"lineNum":"  709","line":"  using Kokkos::Experimental::hypot;"},
{"lineNum":"  710","line":"  return hypot(x.real(), x.imag());"},
{"lineNum":"  711","line":"}"},
{"lineNum":"  712","line":""},
{"lineNum":"  713","line":"//! Power of a complex number"},
{"lineNum":"  714","line":"template <class T>"},
{"lineNum":"  715","line":"KOKKOS_INLINE_FUNCTION complex<T> pow(const complex<T>& x, const T& y) {"},
{"lineNum":"  716","line":"  using Kokkos::Experimental::atan2;"},
{"lineNum":"  717","line":"  using Kokkos::Experimental::pow;"},
{"lineNum":"  718","line":"  T r     = abs(x);"},
{"lineNum":"  719","line":"  T theta = atan2(x.imag(), x.real());"},
{"lineNum":"  720","line":"  return polar(pow(r, y), y * theta);"},
{"lineNum":"  721","line":"}"},
{"lineNum":"  722","line":""},
{"lineNum":"  723","line":"template <class T>"},
{"lineNum":"  724","line":"KOKKOS_INLINE_FUNCTION complex<T> pow(const T& x, const complex<T>& y) {"},
{"lineNum":"  725","line":"  return pow(complex<T>(x), y);"},
{"lineNum":"  726","line":"}"},
{"lineNum":"  727","line":""},
{"lineNum":"  728","line":"template <class T>"},
{"lineNum":"  729","line":"KOKKOS_INLINE_FUNCTION complex<T> pow(const complex<T>& x,"},
{"lineNum":"  730","line":"                                      const complex<T>& y) {"},
{"lineNum":"  731","line":"  using Kokkos::Experimental::log;"},
{"lineNum":"  732","line":""},
{"lineNum":"  733","line":"  return x == T() ? T() : exp(y * log(x));"},
{"lineNum":"  734","line":"}"},
{"lineNum":"  735","line":""},
{"lineNum":"  736","line":"namespace Impl {"},
{"lineNum":"  737","line":"// NOTE promote would also be useful for math functions"},
{"lineNum":"  738","line":"template <class T, bool = std::is_integral<T>::value>"},
{"lineNum":"  739","line":"struct promote {"},
{"lineNum":"  740","line":"  using type = double;"},
{"lineNum":"  741","line":"};"},
{"lineNum":"  742","line":"template <class T>"},
{"lineNum":"  743","line":"struct promote<T, false> {};"},
{"lineNum":"  744","line":"template <>"},
{"lineNum":"  745","line":"struct promote<long double> {"},
{"lineNum":"  746","line":"  using type = long double;"},
{"lineNum":"  747","line":"};"},
{"lineNum":"  748","line":"template <>"},
{"lineNum":"  749","line":"struct promote<double> {"},
{"lineNum":"  750","line":"  using type = double;"},
{"lineNum":"  751","line":"};"},
{"lineNum":"  752","line":"template <>"},
{"lineNum":"  753","line":"struct promote<float> {"},
{"lineNum":"  754","line":"  using type = float;"},
{"lineNum":"  755","line":"};"},
{"lineNum":"  756","line":"template <class T>"},
{"lineNum":"  757","line":"using promote_t = typename promote<T>::type;"},
{"lineNum":"  758","line":"template <class T, class U>"},
{"lineNum":"  759","line":"struct promote_2 {"},
{"lineNum":"  760","line":"  using type = decltype(promote_t<T>() + promote_t<U>());"},
{"lineNum":"  761","line":"};"},
{"lineNum":"  762","line":"template <class T, class U>"},
{"lineNum":"  763","line":"using promote_2_t = typename promote_2<T, U>::type;"},
{"lineNum":"  764","line":"}  // namespace Impl"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"template <class T, class U,"},
{"lineNum":"  767","line":"          class = std::enable_if_t<std::is_arithmetic<T>::value>>"},
{"lineNum":"  768","line":"KOKKOS_INLINE_FUNCTION complex<Impl::promote_2_t<T, U>> pow("},
{"lineNum":"  769","line":"    const T& x, const complex<U>& y) {"},
{"lineNum":"  770","line":"  using type = Impl::promote_2_t<T, U>;"},
{"lineNum":"  771","line":"  return pow(type(x), complex<type>(y));"},
{"lineNum":"  772","line":"}"},
{"lineNum":"  773","line":""},
{"lineNum":"  774","line":"template <class T, class U,"},
{"lineNum":"  775","line":"          class = std::enable_if_t<std::is_arithmetic<U>::value>>"},
{"lineNum":"  776","line":"KOKKOS_INLINE_FUNCTION complex<Impl::promote_2_t<T, U>> pow(const complex<T>& x,"},
{"lineNum":"  777","line":"                                                            const U& y) {"},
{"lineNum":"  778","line":"  using type = Impl::promote_2_t<T, U>;"},
{"lineNum":"  779","line":"  return pow(complex<type>(x), type(y));"},
{"lineNum":"  780","line":"}"},
{"lineNum":"  781","line":""},
{"lineNum":"  782","line":"template <class T, class U>"},
{"lineNum":"  783","line":"KOKKOS_INLINE_FUNCTION complex<Impl::promote_2_t<T, U>> pow("},
{"lineNum":"  784","line":"    const complex<T>& x, const complex<U>& y) {"},
{"lineNum":"  785","line":"  using type = Impl::promote_2_t<T, U>;"},
{"lineNum":"  786","line":"  return pow(complex<type>(x), complex<type>(y));"},
{"lineNum":"  787","line":"}"},
{"lineNum":"  788","line":""},
{"lineNum":"  789","line":"//! Square root of a complex number. This is intended to match the stdc++"},
{"lineNum":"  790","line":"//! implementation, which returns sqrt(z*z) = z; where z is complex number."},
{"lineNum":"  791","line":"template <class RealType>"},
{"lineNum":"  792","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> sqrt("},
{"lineNum":"  793","line":"    const complex<RealType>& x) {"},
{"lineNum":"  794","line":"  using Kokkos::Experimental::fabs;"},
{"lineNum":"  795","line":"  using Kokkos::Experimental::sqrt;"},
{"lineNum":"  796","line":""},
{"lineNum":"  797","line":"  RealType r = x.real();"},
{"lineNum":"  798","line":"  RealType i = x.imag();"},
{"lineNum":"  799","line":""},
{"lineNum":"  800","line":"  if (r == RealType()) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  801","line":"    RealType t = sqrt(fabs(i) / 2);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  802","line":"    return Kokkos::complex<RealType>(t, i < RealType() ? -t : t);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  803","line":"  } else {"},
{"lineNum":"  804","line":"    RealType t = sqrt(2 * (abs(x) + fabs(r)));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  805","line":"    RealType u = t / 2;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  806","line":"    return r > RealType() ? Kokkos::complex<RealType>(u, i / t)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  807","line":"                          : Kokkos::complex<RealType>(fabs(i) / t,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  808","line":"                                                      i < RealType() ? -u : u);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  809","line":"  }"},
{"lineNum":"  810","line":"}"},
{"lineNum":"  811","line":""},
{"lineNum":"  812","line":"//! Conjugate of a complex number."},
{"lineNum":"  813","line":"template <class RealType>"},
{"lineNum":"  814","line":"KOKKOS_INLINE_FUNCTION complex<RealType> conj("},
{"lineNum":"  815","line":"    const complex<RealType>& x) noexcept {"},
{"lineNum":"  816","line":"  return complex<RealType>(real(x), -imag(x));"},
{"lineNum":"  817","line":"}"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"//! Exponential of a complex number."},
{"lineNum":"  820","line":"template <class RealType>"},
{"lineNum":"  821","line":"KOKKOS_INLINE_FUNCTION complex<RealType> exp(const complex<RealType>& x) {"},
{"lineNum":"  822","line":"  using Kokkos::Experimental::cos;"},
{"lineNum":"  823","line":"  using Kokkos::Experimental::exp;"},
{"lineNum":"  824","line":"  using Kokkos::Experimental::sin;"},
{"lineNum":"  825","line":"  return exp(x.real()) * complex<RealType>(cos(x.imag()), sin(x.imag()));"},
{"lineNum":"  826","line":"}"},
{"lineNum":"  827","line":""},
{"lineNum":"  828","line":"//! natural log of a complex number."},
{"lineNum":"  829","line":"template <class RealType>"},
{"lineNum":"  830","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> log("},
{"lineNum":"  831","line":"    const complex<RealType>& x) {"},
{"lineNum":"  832","line":"  using Kokkos::Experimental::atan2;"},
{"lineNum":"  833","line":"  using Kokkos::Experimental::log;"},
{"lineNum":"  834","line":"  RealType phi = atan2(x.imag(), x.real());"},
{"lineNum":"  835","line":"  return Kokkos::complex<RealType>(log(abs(x)), phi);"},
{"lineNum":"  836","line":"}"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"//! sine of a complex number."},
{"lineNum":"  839","line":"template <class RealType>"},
{"lineNum":"  840","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> sin("},
{"lineNum":"  841","line":"    const complex<RealType>& x) {"},
{"lineNum":"  842","line":"  using Kokkos::Experimental::cos;"},
{"lineNum":"  843","line":"  using Kokkos::Experimental::cosh;"},
{"lineNum":"  844","line":"  using Kokkos::Experimental::sin;"},
{"lineNum":"  845","line":"  using Kokkos::Experimental::sinh;"},
{"lineNum":"  846","line":"  return Kokkos::complex<RealType>(sin(x.real()) * cosh(x.imag()),"},
{"lineNum":"  847","line":"                                   cos(x.real()) * sinh(x.imag()));"},
{"lineNum":"  848","line":"}"},
{"lineNum":"  849","line":""},
{"lineNum":"  850","line":"//! cosine of a complex number."},
{"lineNum":"  851","line":"template <class RealType>"},
{"lineNum":"  852","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> cos("},
{"lineNum":"  853","line":"    const complex<RealType>& x) {"},
{"lineNum":"  854","line":"  using Kokkos::Experimental::cos;"},
{"lineNum":"  855","line":"  using Kokkos::Experimental::cosh;"},
{"lineNum":"  856","line":"  using Kokkos::Experimental::sin;"},
{"lineNum":"  857","line":"  using Kokkos::Experimental::sinh;"},
{"lineNum":"  858","line":"  return Kokkos::complex<RealType>(cos(x.real()) * cosh(x.imag()),"},
{"lineNum":"  859","line":"                                   -sin(x.real()) * sinh(x.imag()));"},
{"lineNum":"  860","line":"}"},
{"lineNum":"  861","line":""},
{"lineNum":"  862","line":"//! tangent of a complex number."},
{"lineNum":"  863","line":"template <class RealType>"},
{"lineNum":"  864","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> tan("},
{"lineNum":"  865","line":"    const complex<RealType>& x) {"},
{"lineNum":"  866","line":"  return sin(x) / cos(x);"},
{"lineNum":"  867","line":"}"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"//! hyperbolic sine of a complex number."},
{"lineNum":"  870","line":"template <class RealType>"},
{"lineNum":"  871","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> sinh("},
{"lineNum":"  872","line":"    const complex<RealType>& x) {"},
{"lineNum":"  873","line":"  using Kokkos::Experimental::cos;"},
{"lineNum":"  874","line":"  using Kokkos::Experimental::cosh;"},
{"lineNum":"  875","line":"  using Kokkos::Experimental::sin;"},
{"lineNum":"  876","line":"  using Kokkos::Experimental::sinh;"},
{"lineNum":"  877","line":"  return Kokkos::complex<RealType>(sinh(x.real()) * cos(x.imag()),"},
{"lineNum":"  878","line":"                                   cosh(x.real()) * sin(x.imag()));"},
{"lineNum":"  879","line":"}"},
{"lineNum":"  880","line":""},
{"lineNum":"  881","line":"//! hyperbolic cosine of a complex number."},
{"lineNum":"  882","line":"template <class RealType>"},
{"lineNum":"  883","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> cosh("},
{"lineNum":"  884","line":"    const complex<RealType>& x) {"},
{"lineNum":"  885","line":"  using Kokkos::Experimental::cos;"},
{"lineNum":"  886","line":"  using Kokkos::Experimental::cosh;"},
{"lineNum":"  887","line":"  using Kokkos::Experimental::sin;"},
{"lineNum":"  888","line":"  using Kokkos::Experimental::sinh;"},
{"lineNum":"  889","line":"  return Kokkos::complex<RealType>(cosh(x.real()) * cos(x.imag()),"},
{"lineNum":"  890","line":"                                   sinh(x.real()) * sin(x.imag()));"},
{"lineNum":"  891","line":"}"},
{"lineNum":"  892","line":""},
{"lineNum":"  893","line":"//! hyperbolic tangent of a complex number."},
{"lineNum":"  894","line":"template <class RealType>"},
{"lineNum":"  895","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> tanh("},
{"lineNum":"  896","line":"    const complex<RealType>& x) {"},
{"lineNum":"  897","line":"  return sinh(x) / cosh(x);"},
{"lineNum":"  898","line":"}"},
{"lineNum":"  899","line":""},
{"lineNum":"  900","line":"//! inverse hyperbolic sine of a complex number."},
{"lineNum":"  901","line":"template <class RealType>"},
{"lineNum":"  902","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> asinh("},
{"lineNum":"  903","line":"    const complex<RealType>& x) {"},
{"lineNum":"  904","line":"  return log(x + sqrt(x * x + RealType(1.0)));"},
{"lineNum":"  905","line":"}"},
{"lineNum":"  906","line":""},
{"lineNum":"  907","line":"//! inverse hyperbolic cosine of a complex number."},
{"lineNum":"  908","line":"template <class RealType>"},
{"lineNum":"  909","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> acosh("},
{"lineNum":"  910","line":"    const complex<RealType>& x) {"},
{"lineNum":"  911","line":"  return RealType(2.0) * log(sqrt(RealType(0.5) * (x + RealType(1.0))) +"},
{"lineNum":"  912","line":"                             sqrt(RealType(0.5) * (x - RealType(1.0))));"},
{"lineNum":"  913","line":"}"},
{"lineNum":"  914","line":""},
{"lineNum":"  915","line":"//! inverse hyperbolic tangent of a complex number."},
{"lineNum":"  916","line":"template <class RealType>"},
{"lineNum":"  917","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> atanh("},
{"lineNum":"  918","line":"    const complex<RealType>& x) {"},
{"lineNum":"  919","line":"  using Kokkos::Experimental::atan2;"},
{"lineNum":"  920","line":"  using Kokkos::Experimental::log;"},
{"lineNum":"  921","line":""},
{"lineNum":"  922","line":"  const RealType i2 = x.imag() * x.imag();"},
{"lineNum":"  923","line":"  const RealType r  = RealType(1.0) - i2 - x.real() * x.real();"},
{"lineNum":"  924","line":""},
{"lineNum":"  925","line":"  RealType p = RealType(1.0) + x.real();"},
{"lineNum":"  926","line":"  RealType m = RealType(1.0) - x.real();"},
{"lineNum":"  927","line":""},
{"lineNum":"  928","line":"  p = i2 + p * p;"},
{"lineNum":"  929","line":"  m = i2 + m * m;"},
{"lineNum":"  930","line":""},
{"lineNum":"  931","line":"  RealType phi = atan2(RealType(2.0) * x.imag(), r);"},
{"lineNum":"  932","line":"  return Kokkos::complex<RealType>(RealType(0.25) * (log(p) - log(m)),"},
{"lineNum":"  933","line":"                                   RealType(0.5) * phi);"},
{"lineNum":"  934","line":"}"},
{"lineNum":"  935","line":""},
{"lineNum":"  936","line":"//! inverse sine of a complex number."},
{"lineNum":"  937","line":"template <class RealType>"},
{"lineNum":"  938","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> asin("},
{"lineNum":"  939","line":"    const complex<RealType>& x) {"},
{"lineNum":"  940","line":"  Kokkos::complex<RealType> t ="},
{"lineNum":"  941","line":"      asinh(Kokkos::complex<RealType>(-x.imag(), x.real()));"},
{"lineNum":"  942","line":"  return Kokkos::complex<RealType>(t.imag(), -t.real());"},
{"lineNum":"  943","line":"}"},
{"lineNum":"  944","line":""},
{"lineNum":"  945","line":"//! inverse cosine of a complex number."},
{"lineNum":"  946","line":"template <class RealType>"},
{"lineNum":"  947","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> acos("},
{"lineNum":"  948","line":"    const complex<RealType>& x) {"},
{"lineNum":"  949","line":"  using Kokkos::Experimental::acos;"},
{"lineNum":"  950","line":"  Kokkos::complex<RealType> t = asin(x);"},
{"lineNum":"  951","line":"  RealType pi_2               = acos(RealType(0.0));"},
{"lineNum":"  952","line":"  return Kokkos::complex<RealType>(pi_2 - t.real(), -t.imag());"},
{"lineNum":"  953","line":"}"},
{"lineNum":"  954","line":""},
{"lineNum":"  955","line":"//! inverse tangent of a complex number."},
{"lineNum":"  956","line":"template <class RealType>"},
{"lineNum":"  957","line":"KOKKOS_INLINE_FUNCTION Kokkos::complex<RealType> atan("},
{"lineNum":"  958","line":"    const complex<RealType>& x) {"},
{"lineNum":"  959","line":"  using Kokkos::Experimental::atan2;"},
{"lineNum":"  960","line":"  using Kokkos::Experimental::log;"},
{"lineNum":"  961","line":"  const RealType r2 = x.real() * x.real();"},
{"lineNum":"  962","line":"  const RealType i  = RealType(1.0) - r2 - x.imag() * x.imag();"},
{"lineNum":"  963","line":""},
{"lineNum":"  964","line":"  RealType p = x.imag() + RealType(1.0);"},
{"lineNum":"  965","line":"  RealType m = x.imag() - RealType(1.0);"},
{"lineNum":"  966","line":""},
{"lineNum":"  967","line":"  p = r2 + p * p;"},
{"lineNum":"  968","line":"  m = r2 + m * m;"},
{"lineNum":"  969","line":""},
{"lineNum":"  970","line":"  return Kokkos::complex<RealType>("},
{"lineNum":"  971","line":"      RealType(0.5) * atan2(RealType(2.0) * x.real(), i),"},
{"lineNum":"  972","line":"      RealType(0.25) * log(p / m));"},
{"lineNum":"  973","line":"}"},
{"lineNum":"  974","line":""},
{"lineNum":"  975","line":"/// This function cannot be called in a CUDA device function,"},
{"lineNum":"  976","line":"/// because std::complex\'s methods and nonmember functions are not"},
{"lineNum":"  977","line":"/// marked as CUDA device functions."},
{"lineNum":"  978","line":"template <class RealType>"},
{"lineNum":"  979","line":"inline complex<RealType> exp(const std::complex<RealType>& c) {"},
{"lineNum":"  980","line":"  return complex<RealType>(std::exp(c.real()) * std::cos(c.imag()),"},
{"lineNum":"  981","line":"                           std::exp(c.real()) * std::sin(c.imag()));"},
{"lineNum":"  982","line":"}"},
{"lineNum":"  983","line":""},
{"lineNum":"  984","line":"//! Binary operator / for complex and real numbers"},
{"lineNum":"  985","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  986","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  987","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  988","line":"    operator/(const complex<RealType1>& x,"},
{"lineNum":"  989","line":"              const RealType2& y) noexcept(noexcept(RealType1{} /"},
{"lineNum":"  990","line":"                                                    RealType2{})) {"},
{"lineNum":"  991","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>("},
{"lineNum":"  992","line":"      real(x) / y, imag(x) / y);"},
{"lineNum":"  993","line":"}"},
{"lineNum":"  994","line":""},
{"lineNum":"  995","line":"//! Binary operator / for complex."},
{"lineNum":"  996","line":"template <class RealType1, class RealType2>"},
{"lineNum":"  997","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":"  998","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":"  999","line":"    operator/(const complex<RealType1>& x,"},
{"lineNum":" 1000","line":"              const complex<RealType2>& y) noexcept(noexcept(RealType1{} /"},
{"lineNum":" 1001","line":"                                                             RealType2{})) {"},
{"lineNum":" 1002","line":"  using Kokkos::Experimental::fabs;"},
{"lineNum":" 1003","line":"  // Scale (by the \"1-norm\" of y) to avoid unwarranted overflow."},
{"lineNum":" 1004","line":"  // If the real part is +/-Inf and the imaginary part is -/+Inf,"},
{"lineNum":" 1005","line":"  // this won\'t change the result."},
{"lineNum":" 1006","line":"  using common_real_type ="},
{"lineNum":" 1007","line":"      typename std::common_type<RealType1, RealType2>::type;"},
{"lineNum":" 1008","line":"  const common_real_type s = fabs(real(y)) + fabs(imag(y));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1009","line":""},
{"lineNum":" 1010","line":"  // If s is 0, then y is zero, so x/y == real(x)/0 + i*imag(x)/0."},
{"lineNum":" 1011","line":"  // In that case, the relation x/y == (x/s) / (y/s) doesn\'t hold,"},
{"lineNum":" 1012","line":"  // because y/s is NaN."},
{"lineNum":" 1013","line":"  if (s == 0.0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1014","line":"    return complex<common_real_type>(real(x) / s, imag(x) / s);"},
{"lineNum":" 1015","line":"  } else {"},
{"lineNum":" 1016","line":"    const complex<common_real_type> x_scaled(real(x) / s, imag(x) / s);"},
{"lineNum":" 1017","line":"    const complex<common_real_type> y_conj_scaled(real(y) / s, -imag(y) / s);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1018","line":"    const RealType1 y_scaled_abs ="},
{"lineNum":" 1019","line":"        real(y_conj_scaled) * real(y_conj_scaled) +"},
{"lineNum":" 1020","line":"        imag(y_conj_scaled) * imag(y_conj_scaled);  // abs(y) == abs(conj(y))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1021","line":"    complex<common_real_type> result = x_scaled * y_conj_scaled;"},
{"lineNum":" 1022","line":"    result /= y_scaled_abs;"},
{"lineNum":" 1023","line":"    return result;"},
{"lineNum":" 1024","line":"  }"},
{"lineNum":" 1025","line":"}"},
{"lineNum":" 1026","line":""},
{"lineNum":" 1027","line":"//! Binary operator / for complex and real numbers"},
{"lineNum":" 1028","line":"template <class RealType1, class RealType2>"},
{"lineNum":" 1029","line":"KOKKOS_INLINE_FUNCTION"},
{"lineNum":" 1030","line":"    complex<typename std::common_type<RealType1, RealType2>::type>"},
{"lineNum":" 1031","line":"    operator/(const RealType1& x,"},
{"lineNum":" 1032","line":"              const complex<RealType2>& y) noexcept(noexcept(RealType1{} /"},
{"lineNum":" 1033","line":"                                                             RealType2{})) {"},
{"lineNum":" 1034","line":"  return complex<typename std::common_type<RealType1, RealType2>::type>(x) / y;"},
{"lineNum":" 1035","line":"}"},
{"lineNum":" 1036","line":""},
{"lineNum":" 1037","line":"template <class RealType>"},
{"lineNum":" 1038","line":"std::ostream& operator<<(std::ostream& os, const complex<RealType>& x) {"},
{"lineNum":" 1039","line":"  const std::complex<RealType> x_std(Kokkos::real(x), Kokkos::imag(x));"},
{"lineNum":" 1040","line":"  os << x_std;"},
{"lineNum":" 1041","line":"  return os;"},
{"lineNum":" 1042","line":"}"},
{"lineNum":" 1043","line":""},
{"lineNum":" 1044","line":"template <class RealType>"},
{"lineNum":" 1045","line":"std::istream& operator>>(std::istream& is, complex<RealType>& x) {"},
{"lineNum":" 1046","line":"  std::complex<RealType> x_std;"},
{"lineNum":" 1047","line":"  is >> x_std;"},
{"lineNum":" 1048","line":"  x = x_std;  // only assigns on success of above"},
{"lineNum":" 1049","line":"  return is;"},
{"lineNum":" 1050","line":"}"},
{"lineNum":" 1051","line":""},
{"lineNum":" 1052","line":"template <class T>"},
{"lineNum":" 1053","line":"struct reduction_identity<Kokkos::complex<T>> {"},
{"lineNum":" 1054","line":"  using t_red_ident = reduction_identity<T>;"},
{"lineNum":" 1055","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr static Kokkos::complex<T>"},
{"lineNum":" 1056","line":"  sum() noexcept {"},
{"lineNum":" 1057","line":"    return Kokkos::complex<T>(t_red_ident::sum(), t_red_ident::sum());"},
{"lineNum":" 1058","line":"  }"},
{"lineNum":" 1059","line":"  KOKKOS_FORCEINLINE_FUNCTION constexpr static Kokkos::complex<T>"},
{"lineNum":" 1060","line":"  prod() noexcept {"},
{"lineNum":" 1061","line":"    return Kokkos::complex<T>(t_red_ident::prod(), t_red_ident::sum());"},
{"lineNum":" 1062","line":"  }"},
{"lineNum":" 1063","line":"};"},
{"lineNum":" 1064","line":""},
{"lineNum":" 1065","line":"}  // namespace Kokkos"},
{"lineNum":" 1066","line":""},
{"lineNum":" 1067","line":"#endif  // KOKKOS_COMPLEX_HPP"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 22, "covered" : 0,};
var merged_data = [];
