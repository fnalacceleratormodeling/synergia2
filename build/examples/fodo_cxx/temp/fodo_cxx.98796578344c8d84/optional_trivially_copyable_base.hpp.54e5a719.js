var data = {lines:[
{"lineNum":"    1","line":"// trivilally-copyable version of the storage"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"template<class T>"},
{"lineNum":"    4","line":"class tc_optional_base : public optional_tag"},
{"lineNum":"    5","line":"{"},
{"lineNum":"    6","line":"  private :"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"    typedef tc_optional_base<T> this_type ;"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"  protected :"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"    typedef T value_type ;"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"  protected:"},
{"lineNum":"   15","line":"    typedef T &       reference_type ;"},
{"lineNum":"   16","line":"    typedef T const&  reference_const_type ;"},
{"lineNum":"   17","line":"#ifndef  BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES"},
{"lineNum":"   18","line":"    typedef T &&  rval_reference_type ;"},
{"lineNum":"   19","line":"    typedef T &&  reference_type_of_temporary_wrapper ;"},
{"lineNum":"   20","line":"#endif"},
{"lineNum":"   21","line":"    typedef T *         pointer_type ;"},
{"lineNum":"   22","line":"    typedef T const*    pointer_const_type ;"},
{"lineNum":"   23","line":"    typedef T const&    argument_type ;"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"    tc_optional_base()"},
{"lineNum":"   26","line":"      :"},
{"lineNum":"   27","line":"      m_initialized(false) {}","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"    tc_optional_base ( none_t )"},
{"lineNum":"   30","line":"      :"},
{"lineNum":"   31","line":"      m_initialized(false) {}"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"    tc_optional_base ( init_value_tag, argument_type val )"},
{"lineNum":"   34","line":"      :"},
{"lineNum":"   35","line":"      m_initialized(true), m_storage(val) {}"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"    tc_optional_base ( bool cond, argument_type val )"},
{"lineNum":"   38","line":"      :"},
{"lineNum":"   39","line":"      m_initialized(cond), m_storage(val) {}"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"    // tc_optional_base ( tc_optional_base const& ) = default;"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"#ifndef  BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"    template<class Expr, class PtrExpr>"},
{"lineNum":"   47","line":"    explicit tc_optional_base ( Expr&& expr, PtrExpr const* tag )"},
{"lineNum":"   48","line":"      :"},
{"lineNum":"   49","line":"      m_initialized(false)"},
{"lineNum":"   50","line":"    {"},
{"lineNum":"   51","line":"      construct(boost::forward<Expr>(expr),tag);"},
{"lineNum":"   52","line":"    }"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"#else"},
{"lineNum":"   55","line":"    // This is used for both converting and in-place constructions."},
{"lineNum":"   56","line":"    // Derived classes use the \'tag\' to select the appropriate"},
{"lineNum":"   57","line":"    // implementation (the correct \'construct()\' overload)"},
{"lineNum":"   58","line":"    template<class Expr>"},
{"lineNum":"   59","line":"    explicit tc_optional_base ( Expr const& expr, Expr const* tag )"},
{"lineNum":"   60","line":"      :"},
{"lineNum":"   61","line":"      m_initialized(false)"},
{"lineNum":"   62","line":"    {"},
{"lineNum":"   63","line":"      construct(expr,tag);"},
{"lineNum":"   64","line":"    }"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"#endif"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"    // tc_optional_base& operator= ( tc_optional_base const& ) = default;"},
{"lineNum":"   69","line":"    // ~tc_optional_base() = default;"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"    // Assigns from another optional<T> (deep-copies the rhs value)"},
{"lineNum":"   72","line":"    void assign ( tc_optional_base const& rhs )"},
{"lineNum":"   73","line":"    {"},
{"lineNum":"   74","line":"      *this = rhs;"},
{"lineNum":"   75","line":"    }"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"    // Assigns from another _convertible_ optional<U> (deep-copies the rhs value)"},
{"lineNum":"   78","line":"    template<class U>"},
{"lineNum":"   79","line":"    void assign ( optional<U> const& rhs )"},
{"lineNum":"   80","line":"    {"},
{"lineNum":"   81","line":"      if ( rhs.is_initialized() )"},
{"lineNum":"   82","line":"#ifndef BOOST_OPTIONAL_CONFIG_RESTORE_ASSIGNMENT_OF_NONCONVERTIBLE_TYPES"},
{"lineNum":"   83","line":"        m_storage = rhs.get();"},
{"lineNum":"   84","line":"#else"},
{"lineNum":"   85","line":"        m_storage = static_cast<value_type>(rhs.get());"},
{"lineNum":"   86","line":"#endif"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"      m_initialized = rhs.is_initialized();"},
{"lineNum":"   89","line":"    }"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"#ifndef BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES"},
{"lineNum":"   92","line":"    // move-assigns from another _convertible_ optional<U> (deep-moves from the rhs value)"},
{"lineNum":"   93","line":"    template<class U>"},
{"lineNum":"   94","line":"    void assign ( optional<U>&& rhs )"},
{"lineNum":"   95","line":"    {"},
{"lineNum":"   96","line":"      typedef BOOST_DEDUCED_TYPENAME optional<U>::rval_reference_type ref_type;"},
{"lineNum":"   97","line":"      if ( rhs.is_initialized() )"},
{"lineNum":"   98","line":"        m_storage = static_cast<ref_type>(rhs.get());"},
{"lineNum":"   99","line":"      m_initialized = rhs.is_initialized();"},
{"lineNum":"  100","line":"    }"},
{"lineNum":"  101","line":"#endif"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"    void assign ( argument_type val )"},
{"lineNum":"  104","line":"    {"},
{"lineNum":"  105","line":"      construct(val);"},
{"lineNum":"  106","line":"    }"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"    void assign ( none_t ) { destroy(); }"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"#ifndef BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"#ifndef BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES"},
{"lineNum":"  113","line":"    template<class Expr, class ExprPtr>"},
{"lineNum":"  114","line":"    void assign_expr ( Expr&& expr, ExprPtr const* tag )"},
{"lineNum":"  115","line":"    {"},
{"lineNum":"  116","line":"       construct(boost::forward<Expr>(expr),tag);"},
{"lineNum":"  117","line":"    }"},
{"lineNum":"  118","line":"#else"},
{"lineNum":"  119","line":"    template<class Expr>"},
{"lineNum":"  120","line":"    void assign_expr ( Expr const& expr, Expr const* tag )"},
{"lineNum":"  121","line":"    {"},
{"lineNum":"  122","line":"      construct(expr,tag);"},
{"lineNum":"  123","line":"    }"},
{"lineNum":"  124","line":"#endif"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"#endif"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"  public :"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"    // Destroys the current value, if any, leaving this UNINITIALIZED"},
{"lineNum":"  131","line":"    // No-throw (assuming T::~T() doesn\'t)"},
{"lineNum":"  132","line":"    void reset() BOOST_NOEXCEPT { destroy(); }"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"    // **DEPPRECATED** Replaces the current value -if any- with \'val\'"},
{"lineNum":"  135","line":"    void reset ( argument_type val ) BOOST_NOEXCEPT { assign(val); }"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"    // Returns a pointer to the value if this is initialized, otherwise,"},
{"lineNum":"  138","line":"    // returns NULL."},
{"lineNum":"  139","line":"    // No-throw"},
{"lineNum":"  140","line":"    pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }"},
{"lineNum":"  141","line":"    pointer_type       get_ptr()       { return m_initialized ? get_ptr_impl() : 0 ; }"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"    bool is_initialized() const { return m_initialized ; }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"  protected :"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"    void construct ( argument_type val )"},
{"lineNum":"  148","line":"     {"},
{"lineNum":"  149","line":"       m_storage = val ;"},
{"lineNum":"  150","line":"       m_initialized = true ;"},
{"lineNum":"  151","line":"     }"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"#if (!defined BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES) && (!defined BOOST_NO_CXX11_VARIADIC_TEMPLATES)"},
{"lineNum":"  155","line":"    // Constructs in-place"},
{"lineNum":"  156","line":"    // upon exception *this is always uninitialized"},
{"lineNum":"  157","line":"    template<class... Args>"},
{"lineNum":"  158","line":"    void construct ( in_place_init_t, Args&&... args )"},
{"lineNum":"  159","line":"    {"},
{"lineNum":"  160","line":"      m_storage = value_type( boost::forward<Args>(args)... ) ;"},
{"lineNum":"  161","line":"      m_initialized = true ;"},
{"lineNum":"  162","line":"    }"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"    template<class... Args>"},
{"lineNum":"  165","line":"    void emplace_assign ( Args&&... args )"},
{"lineNum":"  166","line":"    {"},
{"lineNum":"  167","line":"      construct(in_place_init, boost::forward<Args>(args)...);"},
{"lineNum":"  168","line":"    }"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"    template<class... Args>"},
{"lineNum":"  171","line":"    explicit tc_optional_base ( in_place_init_t, Args&&... args )"},
{"lineNum":"  172","line":"      :"},
{"lineNum":"  173","line":"      m_initialized(false)"},
{"lineNum":"  174","line":"    {"},
{"lineNum":"  175","line":"      construct(in_place_init, boost::forward<Args>(args)...);"},
{"lineNum":"  176","line":"    }"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"    template<class... Args>"},
{"lineNum":"  179","line":"    explicit tc_optional_base ( in_place_init_if_t, bool cond, Args&&... args )"},
{"lineNum":"  180","line":"      :"},
{"lineNum":"  181","line":"      m_initialized(false)"},
{"lineNum":"  182","line":"    {"},
{"lineNum":"  183","line":"      if ( cond )"},
{"lineNum":"  184","line":"        construct(in_place_init, boost::forward<Args>(args)...);"},
{"lineNum":"  185","line":"    }"},
{"lineNum":"  186","line":"#elif (!defined BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES)"},
{"lineNum":"  187","line":"    template<class Arg>"},
{"lineNum":"  188","line":"    void construct ( in_place_init_t, Arg&& arg )"},
{"lineNum":"  189","line":"     {"},
{"lineNum":"  190","line":"       m_storage = value_type( boost::forward<Arg>(arg) );"},
{"lineNum":"  191","line":"       m_initialized = true ;"},
{"lineNum":"  192","line":"     }"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"    void construct ( in_place_init_t )"},
{"lineNum":"  195","line":"     {"},
{"lineNum":"  196","line":"       m_storage = value_type();"},
{"lineNum":"  197","line":"       m_initialized = true ;"},
{"lineNum":"  198","line":"     }"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"    template<class Arg>"},
{"lineNum":"  201","line":"    void emplace_assign ( Arg&& arg )"},
{"lineNum":"  202","line":"     {"},
{"lineNum":"  203","line":"       construct(in_place_init, boost::forward<Arg>(arg)) ;"},
{"lineNum":"  204","line":"     }"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"    void emplace_assign ()"},
{"lineNum":"  207","line":"     {"},
{"lineNum":"  208","line":"       construct(in_place_init) ;"},
{"lineNum":"  209","line":"     }"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"    template<class Arg>"},
{"lineNum":"  212","line":"    explicit tc_optional_base ( in_place_init_t, Arg&& arg )"},
{"lineNum":"  213","line":"      :"},
{"lineNum":"  214","line":"      m_initialized(false)"},
{"lineNum":"  215","line":"    {"},
{"lineNum":"  216","line":"      construct(in_place_init, boost::forward<Arg>(arg));"},
{"lineNum":"  217","line":"    }"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"    explicit tc_optional_base ( in_place_init_t )"},
{"lineNum":"  220","line":"      :"},
{"lineNum":"  221","line":"      m_initialized(false), m_storage() {}"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"    template<class Arg>"},
{"lineNum":"  224","line":"    explicit tc_optional_base ( in_place_init_if_t, bool cond, Arg&& arg )"},
{"lineNum":"  225","line":"      :"},
{"lineNum":"  226","line":"      m_initialized(false)"},
{"lineNum":"  227","line":"    {"},
{"lineNum":"  228","line":"      if ( cond )"},
{"lineNum":"  229","line":"        construct(in_place_init, boost::forward<Arg>(arg));"},
{"lineNum":"  230","line":"    }"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"    explicit tc_optional_base ( in_place_init_if_t, bool cond )"},
{"lineNum":"  233","line":"      :"},
{"lineNum":"  234","line":"      m_initialized(false)"},
{"lineNum":"  235","line":"    {"},
{"lineNum":"  236","line":"      if ( cond )"},
{"lineNum":"  237","line":"        construct(in_place_init);"},
{"lineNum":"  238","line":"    }"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"#else"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"    template<class Arg>"},
{"lineNum":"  243","line":"    void construct ( in_place_init_t, const Arg& arg )"},
{"lineNum":"  244","line":"     {"},
{"lineNum":"  245","line":"       m_storage = value_type( arg );"},
{"lineNum":"  246","line":"       m_initialized = true ;"},
{"lineNum":"  247","line":"     }"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"    template<class Arg>"},
{"lineNum":"  250","line":"    void construct ( in_place_init_t, Arg& arg )"},
{"lineNum":"  251","line":"     {"},
{"lineNum":"  252","line":"       m_storage = value_type( arg );"},
{"lineNum":"  253","line":"       m_initialized = true ;"},
{"lineNum":"  254","line":"     }"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"    void construct ( in_place_init_t )"},
{"lineNum":"  257","line":"     {"},
{"lineNum":"  258","line":"       m_storage = value_type();"},
{"lineNum":"  259","line":"       m_initialized = true ;"},
{"lineNum":"  260","line":"     }"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"    template<class Arg>"},
{"lineNum":"  263","line":"    void emplace_assign ( const Arg& arg )"},
{"lineNum":"  264","line":"    {"},
{"lineNum":"  265","line":"      construct(in_place_init, arg);"},
{"lineNum":"  266","line":"    }"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"    template<class Arg>"},
{"lineNum":"  269","line":"    void emplace_assign ( Arg& arg )"},
{"lineNum":"  270","line":"    {"},
{"lineNum":"  271","line":"      construct(in_place_init, arg);"},
{"lineNum":"  272","line":"    }"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"    void emplace_assign ()"},
{"lineNum":"  275","line":"    {"},
{"lineNum":"  276","line":"      construct(in_place_init);"},
{"lineNum":"  277","line":"    }"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"    template<class Arg>"},
{"lineNum":"  280","line":"    explicit tc_optional_base ( in_place_init_t, const Arg& arg )"},
{"lineNum":"  281","line":"      : m_initialized(false)"},
{"lineNum":"  282","line":"    {"},
{"lineNum":"  283","line":"      construct(in_place_init, arg);"},
{"lineNum":"  284","line":"    }"},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"    template<class Arg>"},
{"lineNum":"  287","line":"    explicit tc_optional_base ( in_place_init_t, Arg& arg )"},
{"lineNum":"  288","line":"      : m_initialized(false)"},
{"lineNum":"  289","line":"    {"},
{"lineNum":"  290","line":"      construct(in_place_init, arg);"},
{"lineNum":"  291","line":"    }"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"    explicit tc_optional_base ( in_place_init_t )"},
{"lineNum":"  294","line":"      : m_initialized(false)"},
{"lineNum":"  295","line":"    {"},
{"lineNum":"  296","line":"      construct(in_place_init);"},
{"lineNum":"  297","line":"    }"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"    template<class Arg>"},
{"lineNum":"  300","line":"    explicit tc_optional_base ( in_place_init_if_t, bool cond, const Arg& arg )"},
{"lineNum":"  301","line":"      : m_initialized(false)"},
{"lineNum":"  302","line":"    {"},
{"lineNum":"  303","line":"      if ( cond )"},
{"lineNum":"  304","line":"        construct(in_place_init, arg);"},
{"lineNum":"  305","line":"    }"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"    template<class Arg>"},
{"lineNum":"  308","line":"    explicit tc_optional_base ( in_place_init_if_t, bool cond, Arg& arg )"},
{"lineNum":"  309","line":"      : m_initialized(false)"},
{"lineNum":"  310","line":"    {"},
{"lineNum":"  311","line":"      if ( cond )"},
{"lineNum":"  312","line":"        construct(in_place_init, arg);"},
{"lineNum":"  313","line":"    }"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"    explicit tc_optional_base ( in_place_init_if_t, bool cond )"},
{"lineNum":"  316","line":"      : m_initialized(false)"},
{"lineNum":"  317","line":"    {"},
{"lineNum":"  318","line":"      if ( cond )"},
{"lineNum":"  319","line":"        construct(in_place_init);"},
{"lineNum":"  320","line":"    }"},
{"lineNum":"  321","line":"#endif"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"#ifndef BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT"},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"#ifndef BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES"},
{"lineNum":"  326","line":"    // Constructs in-place using the given factory"},
{"lineNum":"  327","line":"    template<class Expr>"},
{"lineNum":"  328","line":"    void construct ( Expr&& factory, in_place_factory_base const* )"},
{"lineNum":"  329","line":"     {"},
{"lineNum":"  330","line":"       boost_optional_detail::construct<value_type>(factory, boost::addressof(m_storage));"},
{"lineNum":"  331","line":"       m_initialized = true ;"},
{"lineNum":"  332","line":"     }"},
{"lineNum":"  333","line":""},
{"lineNum":"  334","line":"    // Constructs in-place using the given typed factory"},
{"lineNum":"  335","line":"    template<class Expr>"},
{"lineNum":"  336","line":"    void construct ( Expr&& factory, typed_in_place_factory_base const* )"},
{"lineNum":"  337","line":"     {"},
{"lineNum":"  338","line":"       factory.apply(boost::addressof(m_storage)) ;"},
{"lineNum":"  339","line":"       m_initialized = true ;"},
{"lineNum":"  340","line":"     }"},
{"lineNum":"  341","line":""},
{"lineNum":"  342","line":"    template<class Expr>"},
{"lineNum":"  343","line":"    void assign_expr_to_initialized ( Expr&& factory, in_place_factory_base const* tag )"},
{"lineNum":"  344","line":"     {"},
{"lineNum":"  345","line":"       destroy();"},
{"lineNum":"  346","line":"       construct(factory,tag);"},
{"lineNum":"  347","line":"     }"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"    // Constructs in-place using the given typed factory"},
{"lineNum":"  350","line":"    template<class Expr>"},
{"lineNum":"  351","line":"    void assign_expr_to_initialized ( Expr&& factory, typed_in_place_factory_base const* tag )"},
{"lineNum":"  352","line":"     {"},
{"lineNum":"  353","line":"       destroy();"},
{"lineNum":"  354","line":"       construct(factory,tag);"},
{"lineNum":"  355","line":"     }"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"#else"},
{"lineNum":"  358","line":"    // Constructs in-place using the given factory"},
{"lineNum":"  359","line":"    template<class Expr>"},
{"lineNum":"  360","line":"    void construct ( Expr const& factory, in_place_factory_base const* )"},
{"lineNum":"  361","line":"     {"},
{"lineNum":"  362","line":"       boost_optional_detail::construct<value_type>(factory, m_storage.address());"},
{"lineNum":"  363","line":"       m_initialized = true ;"},
{"lineNum":"  364","line":"     }"},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"    // Constructs in-place using the given typed factory"},
{"lineNum":"  367","line":"    template<class Expr>"},
{"lineNum":"  368","line":"    void construct ( Expr const& factory, typed_in_place_factory_base const* )"},
{"lineNum":"  369","line":"     {"},
{"lineNum":"  370","line":"       factory.apply(boost::addressof(m_storage)) ;"},
{"lineNum":"  371","line":"       m_initialized = true ;"},
{"lineNum":"  372","line":"     }"},
{"lineNum":"  373","line":""},
{"lineNum":"  374","line":"    template<class Expr>"},
{"lineNum":"  375","line":"    void assign_expr_to_initialized ( Expr const& factory, in_place_factory_base const* tag )"},
{"lineNum":"  376","line":"     {"},
{"lineNum":"  377","line":"       destroy();"},
{"lineNum":"  378","line":"       construct(factory,tag);"},
{"lineNum":"  379","line":"     }"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"    // Constructs in-place using the given typed factory"},
{"lineNum":"  382","line":"    template<class Expr>"},
{"lineNum":"  383","line":"    void assign_expr_to_initialized ( Expr const& factory, typed_in_place_factory_base const* tag )"},
{"lineNum":"  384","line":"     {"},
{"lineNum":"  385","line":"       destroy();"},
{"lineNum":"  386","line":"       construct(factory,tag);"},
{"lineNum":"  387","line":"     }"},
{"lineNum":"  388","line":"#endif"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"#endif"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"#ifndef BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES"},
{"lineNum":"  393","line":"    // Constructs using any expression implicitly convertible to the single argument"},
{"lineNum":"  394","line":"    // of a one-argument T constructor."},
{"lineNum":"  395","line":"    // Converting constructions of optional<T> from optional<U> uses this function with"},
{"lineNum":"  396","line":"    // \'Expr\' being of type \'U\' and relying on a converting constructor of T from U."},
{"lineNum":"  397","line":"    template<class Expr>"},
{"lineNum":"  398","line":"    void construct ( Expr&& expr, void const* )"},
{"lineNum":"  399","line":"    {"},
{"lineNum":"  400","line":"      m_storage = value_type(boost::forward<Expr>(expr)) ;"},
{"lineNum":"  401","line":"      m_initialized = true ;"},
{"lineNum":"  402","line":"    }"},
{"lineNum":"  403","line":""},
{"lineNum":"  404","line":"    // Assigns using a form any expression implicitly convertible to the single argument"},
{"lineNum":"  405","line":"    // of a T\'s assignment operator."},
{"lineNum":"  406","line":"    // Converting assignments of optional<T> from optional<U> uses this function with"},
{"lineNum":"  407","line":"    // \'Expr\' being of type \'U\' and relying on a converting assignment of T from U."},
{"lineNum":"  408","line":"    template<class Expr>"},
{"lineNum":"  409","line":"    void assign_expr_to_initialized ( Expr&& expr, void const* )"},
{"lineNum":"  410","line":"    {"},
{"lineNum":"  411","line":"      assign_value( boost::forward<Expr>(expr) );"},
{"lineNum":"  412","line":"    }"},
{"lineNum":"  413","line":"#else"},
{"lineNum":"  414","line":"    // Constructs using any expression implicitly convertible to the single argument"},
{"lineNum":"  415","line":"    // of a one-argument T constructor."},
{"lineNum":"  416","line":"    // Converting constructions of optional<T> from optional<U> uses this function with"},
{"lineNum":"  417","line":"    // \'Expr\' being of type \'U\' and relying on a converting constructor of T from U."},
{"lineNum":"  418","line":"    template<class Expr>"},
{"lineNum":"  419","line":"    void construct ( Expr const& expr, void const* )"},
{"lineNum":"  420","line":"     {"},
{"lineNum":"  421","line":"       m_storage = value_type(expr) ;"},
{"lineNum":"  422","line":"       m_initialized = true ;"},
{"lineNum":"  423","line":"     }"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"    // Assigns using a form any expression implicitly convertible to the single argument"},
{"lineNum":"  426","line":"    // of a T\'s assignment operator."},
{"lineNum":"  427","line":"    // Converting assignments of optional<T> from optional<U> uses this function with"},
{"lineNum":"  428","line":"    // \'Expr\' being of type \'U\' and relying on a converting assignment of T from U."},
{"lineNum":"  429","line":"    template<class Expr>"},
{"lineNum":"  430","line":"    void assign_expr_to_initialized ( Expr const& expr, void const* )"},
{"lineNum":"  431","line":"     {"},
{"lineNum":"  432","line":"       assign_value(expr);"},
{"lineNum":"  433","line":"     }"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"#endif"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"#ifdef BOOST_OPTIONAL_WEAK_OVERLOAD_RESOLUTION"},
{"lineNum":"  438","line":"    // BCB5.64 (and probably lower versions) workaround."},
{"lineNum":"  439","line":"    //   The in-place factories are supported by means of catch-all constructors"},
{"lineNum":"  440","line":"    //   and assignment operators (the functions are parameterized in terms of"},
{"lineNum":"  441","line":"    //   an arbitrary \'Expr\' type)"},
{"lineNum":"  442","line":"    //   This compiler incorrectly resolves the overload set and sinks optional<T> and optional<U>"},
{"lineNum":"  443","line":"    //   to the \'Expr\'-taking functions even though explicit overloads are present for them."},
{"lineNum":"  444","line":"    //   Thus, the following overload is needed to properly handle the case when the \'lhs\'"},
{"lineNum":"  445","line":"    //   is another optional."},
{"lineNum":"  446","line":"    //"},
{"lineNum":"  447","line":"    // For VC<=70 compilers this workaround dosen\'t work becasue the comnpiler issues and error"},
{"lineNum":"  448","line":"    // instead of choosing the wrong overload"},
{"lineNum":"  449","line":"    //"},
{"lineNum":"  450","line":"#ifndef  BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES"},
{"lineNum":"  451","line":"    // Notice that \'Expr\' will be optional<T> or optional<U> (but not tc_optional_base<..>)"},
{"lineNum":"  452","line":"    template<class Expr>"},
{"lineNum":"  453","line":"    void construct ( Expr&& expr, optional_tag const* )"},
{"lineNum":"  454","line":"     {"},
{"lineNum":"  455","line":"       if ( expr.is_initialized() )"},
{"lineNum":"  456","line":"       {"},
{"lineNum":"  457","line":"         // An exception can be thrown here."},
{"lineNum":"  458","line":"         // It it happens, THIS will be left uninitialized."},
{"lineNum":"  459","line":"         m_storage = value_type(boost::move(expr.get())) ;"},
{"lineNum":"  460","line":"         m_initialized = true ;"},
{"lineNum":"  461","line":"       }"},
{"lineNum":"  462","line":"     }"},
{"lineNum":"  463","line":"#else"},
{"lineNum":"  464","line":"    // Notice that \'Expr\' will be optional<T> or optional<U> (but not tc_optional_base<..>)"},
{"lineNum":"  465","line":"    template<class Expr>"},
{"lineNum":"  466","line":"    void construct ( Expr const& expr, optional_tag const* )"},
{"lineNum":"  467","line":"     {"},
{"lineNum":"  468","line":"       if ( expr.is_initialized() )"},
{"lineNum":"  469","line":"       {"},
{"lineNum":"  470","line":"         // An exception can be thrown here."},
{"lineNum":"  471","line":"         // It it happens, THIS will be left uninitialized."},
{"lineNum":"  472","line":"         m_storage = value_type(expr.get()) ;"},
{"lineNum":"  473","line":"         m_initialized = true ;"},
{"lineNum":"  474","line":"       }"},
{"lineNum":"  475","line":"     }"},
{"lineNum":"  476","line":"#endif"},
{"lineNum":"  477","line":"#endif // defined BOOST_OPTIONAL_WEAK_OVERLOAD_RESOLUTION"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"    void assign_value ( argument_type val ) { m_storage = val; }"},
{"lineNum":"  480","line":"#ifndef  BOOST_OPTIONAL_DETAIL_NO_RVALUE_REFERENCES"},
{"lineNum":"  481","line":"    void assign_value ( rval_reference_type val ) { m_storage = static_cast<rval_reference_type>(val); }"},
{"lineNum":"  482","line":"#endif"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"    void destroy()"},
{"lineNum":"  485","line":"    {"},
{"lineNum":"  486","line":"      m_initialized = false;"},
{"lineNum":"  487","line":"    }"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"    reference_const_type get_impl() const { return m_storage ; }"},
{"lineNum":"  490","line":"    reference_type       get_impl()       { return m_storage ; }"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"    pointer_const_type get_ptr_impl() const { return boost::addressof(m_storage); }"},
{"lineNum":"  493","line":"    pointer_type       get_ptr_impl()       { return boost::addressof(m_storage); }"},
{"lineNum":"  494","line":""},
{"lineNum":"  495","line":"  private :"},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"    bool m_initialized ;"},
{"lineNum":"  498","line":"    T    m_storage ;"},
{"lineNum":"  499","line":"} ;"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
