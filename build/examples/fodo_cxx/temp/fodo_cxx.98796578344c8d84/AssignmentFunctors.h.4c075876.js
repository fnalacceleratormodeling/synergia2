var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_ASSIGNMENT_FUNCTORS_H"},
{"lineNum":"   11","line":"#define EIGEN_ASSIGNMENT_FUNCTORS_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"../InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"/** \\internal"},
{"lineNum":"   20","line":"  * \\brief Template functor for scalar/packet assignment"},
{"lineNum":"   21","line":"  *"},
{"lineNum":"   22","line":"  */"},
{"lineNum":"   23","line":"template<typename DstScalar,typename SrcScalar> struct assign_op {"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"  EIGEN_EMPTY_STRUCT_CTOR(assign_op)"},
{"lineNum":"   26","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a = b; }","class":"lineNoCov","hits":"0","possible_hits":"457",},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"  template<int Alignment, typename Packet>"},
{"lineNum":"   29","line":"  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const"},
{"lineNum":"   30","line":"  { internal::pstoret<DstScalar,Packet,Alignment>(a,b); }"},
{"lineNum":"   31","line":"};"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"// Empty overload for void type (used by PermutationMatrix)"},
{"lineNum":"   34","line":"template<typename DstScalar> struct assign_op<DstScalar,void> {};"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"template<typename DstScalar,typename SrcScalar>"},
{"lineNum":"   37","line":"struct functor_traits<assign_op<DstScalar,SrcScalar> > {"},
{"lineNum":"   38","line":"  enum {"},
{"lineNum":"   39","line":"    Cost = NumTraits<DstScalar>::ReadCost,"},
{"lineNum":"   40","line":"    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::Vectorizable && packet_traits<SrcScalar>::Vectorizable"},
{"lineNum":"   41","line":"  };"},
{"lineNum":"   42","line":"};"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"/** \\internal"},
{"lineNum":"   45","line":"  * \\brief Template functor for scalar/packet assignment with addition"},
{"lineNum":"   46","line":"  *"},
{"lineNum":"   47","line":"  */"},
{"lineNum":"   48","line":"template<typename DstScalar,typename SrcScalar> struct add_assign_op {"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"  EIGEN_EMPTY_STRUCT_CTOR(add_assign_op)"},
{"lineNum":"   51","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a += b; }","class":"lineNoCov","hits":"0","possible_hits":"167",},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"  template<int Alignment, typename Packet>"},
{"lineNum":"   54","line":"  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const"},
{"lineNum":"   55","line":"  { internal::pstoret<DstScalar,Packet,Alignment>(a,internal::padd(internal::ploadt<Packet,Alignment>(a),b)); }"},
{"lineNum":"   56","line":"};"},
{"lineNum":"   57","line":"template<typename DstScalar,typename SrcScalar>"},
{"lineNum":"   58","line":"struct functor_traits<add_assign_op<DstScalar,SrcScalar> > {"},
{"lineNum":"   59","line":"  enum {"},
{"lineNum":"   60","line":"    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::AddCost,"},
{"lineNum":"   61","line":"    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasAdd"},
{"lineNum":"   62","line":"  };"},
{"lineNum":"   63","line":"};"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"/** \\internal"},
{"lineNum":"   66","line":"  * \\brief Template functor for scalar/packet assignment with subtraction"},
{"lineNum":"   67","line":"  *"},
{"lineNum":"   68","line":"  */"},
{"lineNum":"   69","line":"template<typename DstScalar,typename SrcScalar> struct sub_assign_op {"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"  EIGEN_EMPTY_STRUCT_CTOR(sub_assign_op)"},
{"lineNum":"   72","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a -= b; }","class":"lineNoCov","hits":"0","possible_hits":"381",},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"  template<int Alignment, typename Packet>"},
{"lineNum":"   75","line":"  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const"},
{"lineNum":"   76","line":"  { internal::pstoret<DstScalar,Packet,Alignment>(a,internal::psub(internal::ploadt<Packet,Alignment>(a),b)); }"},
{"lineNum":"   77","line":"};"},
{"lineNum":"   78","line":"template<typename DstScalar,typename SrcScalar>"},
{"lineNum":"   79","line":"struct functor_traits<sub_assign_op<DstScalar,SrcScalar> > {"},
{"lineNum":"   80","line":"  enum {"},
{"lineNum":"   81","line":"    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::AddCost,"},
{"lineNum":"   82","line":"    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasSub"},
{"lineNum":"   83","line":"  };"},
{"lineNum":"   84","line":"};"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"/** \\internal"},
{"lineNum":"   87","line":"  * \\brief Template functor for scalar/packet assignment with multiplication"},
{"lineNum":"   88","line":"  *"},
{"lineNum":"   89","line":"  */"},
{"lineNum":"   90","line":"template<typename DstScalar, typename SrcScalar=DstScalar>"},
{"lineNum":"   91","line":"struct mul_assign_op {"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"  EIGEN_EMPTY_STRUCT_CTOR(mul_assign_op)"},
{"lineNum":"   94","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a *= b; }","class":"lineNoCov","hits":"0","possible_hits":"33",},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"  template<int Alignment, typename Packet>"},
{"lineNum":"   97","line":"  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const"},
{"lineNum":"   98","line":"  { internal::pstoret<DstScalar,Packet,Alignment>(a,internal::pmul(internal::ploadt<Packet,Alignment>(a),b)); }"},
{"lineNum":"   99","line":"};"},
{"lineNum":"  100","line":"template<typename DstScalar, typename SrcScalar>"},
{"lineNum":"  101","line":"struct functor_traits<mul_assign_op<DstScalar,SrcScalar> > {"},
{"lineNum":"  102","line":"  enum {"},
{"lineNum":"  103","line":"    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::MulCost,"},
{"lineNum":"  104","line":"    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasMul"},
{"lineNum":"  105","line":"  };"},
{"lineNum":"  106","line":"};"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"/** \\internal"},
{"lineNum":"  109","line":"  * \\brief Template functor for scalar/packet assignment with diviving"},
{"lineNum":"  110","line":"  *"},
{"lineNum":"  111","line":"  */"},
{"lineNum":"  112","line":"template<typename DstScalar, typename SrcScalar=DstScalar> struct div_assign_op {"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"  EIGEN_EMPTY_STRUCT_CTOR(div_assign_op)"},
{"lineNum":"  115","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(DstScalar& a, const SrcScalar& b) const { a /= b; }","class":"lineNoCov","hits":"0","possible_hits":"57",},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"  template<int Alignment, typename Packet>"},
{"lineNum":"  118","line":"  EIGEN_STRONG_INLINE void assignPacket(DstScalar* a, const Packet& b) const"},
{"lineNum":"  119","line":"  { internal::pstoret<DstScalar,Packet,Alignment>(a,internal::pdiv(internal::ploadt<Packet,Alignment>(a),b)); }"},
{"lineNum":"  120","line":"};"},
{"lineNum":"  121","line":"template<typename DstScalar, typename SrcScalar>"},
{"lineNum":"  122","line":"struct functor_traits<div_assign_op<DstScalar,SrcScalar> > {"},
{"lineNum":"  123","line":"  enum {"},
{"lineNum":"  124","line":"    Cost = NumTraits<DstScalar>::ReadCost + NumTraits<DstScalar>::MulCost,"},
{"lineNum":"  125","line":"    PacketAccess = is_same<DstScalar,SrcScalar>::value && packet_traits<DstScalar>::HasDiv"},
{"lineNum":"  126","line":"  };"},
{"lineNum":"  127","line":"};"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"/** \\internal"},
{"lineNum":"  130","line":"  * \\brief Template functor for scalar/packet assignment with swapping"},
{"lineNum":"  131","line":"  *"},
{"lineNum":"  132","line":"  * It works as follow. For a non-vectorized evaluation loop, we have:"},
{"lineNum":"  133","line":"  *   for(i) func(A.coeffRef(i), B.coeff(i));"},
{"lineNum":"  134","line":"  * where B is a SwapWrapper expression. The trick is to make SwapWrapper::coeff behaves like a non-const coeffRef."},
{"lineNum":"  135","line":"  * Actually, SwapWrapper might not even be needed since even if B is a plain expression, since it has to be writable"},
{"lineNum":"  136","line":"  * B.coeff already returns a const reference to the underlying scalar value."},
{"lineNum":"  137","line":"  *"},
{"lineNum":"  138","line":"  * The case of a vectorized loop is more tricky:"},
{"lineNum":"  139","line":"  *   for(i,j) func.assignPacket<A_Align>(&A.coeffRef(i,j), B.packet<B_Align>(i,j));"},
{"lineNum":"  140","line":"  * Here, B must be a SwapWrapper whose packet function actually returns a proxy object holding a Scalar*,"},
{"lineNum":"  141","line":"  * the actual alignment and Packet type."},
{"lineNum":"  142","line":"  *"},
{"lineNum":"  143","line":"  */"},
{"lineNum":"  144","line":"template<typename Scalar> struct swap_assign_op {"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"  EIGEN_EMPTY_STRUCT_CTOR(swap_assign_op)"},
{"lineNum":"  147","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void assignCoeff(Scalar& a, const Scalar& b) const"},
{"lineNum":"  148","line":"  {"},
{"lineNum":"  149","line":"#ifdef EIGEN_GPUCC"},
{"lineNum":"  150","line":"    // FIXME is there some kind of cuda::swap?"},
{"lineNum":"  151","line":"    Scalar t=b; const_cast<Scalar&>(b)=a; a=t;"},
{"lineNum":"  152","line":"#else"},
{"lineNum":"  153","line":"    using std::swap;"},
{"lineNum":"  154","line":"    swap(a,const_cast<Scalar&>(b));"},
{"lineNum":"  155","line":"#endif"},
{"lineNum":"  156","line":"  }"},
{"lineNum":"  157","line":"};"},
{"lineNum":"  158","line":"template<typename Scalar>"},
{"lineNum":"  159","line":"struct functor_traits<swap_assign_op<Scalar> > {"},
{"lineNum":"  160","line":"  enum {"},
{"lineNum":"  161","line":"    Cost = 3 * NumTraits<Scalar>::ReadCost,"},
{"lineNum":"  162","line":"    PacketAccess ="},
{"lineNum":"  163","line":"    #if defined(EIGEN_VECTORIZE_AVX) && EIGEN_COMP_CLANG && (EIGEN_COMP_CLANG<800 || defined(__apple_build_version__))"},
{"lineNum":"  164","line":"    // This is a partial workaround for a bug in clang generating bad code"},
{"lineNum":"  165","line":"    // when mixing 256/512 bits loads and 128 bits moves."},
{"lineNum":"  166","line":"    // See http://eigen.tuxfamily.org/bz/show_bug.cgi?id=1684"},
{"lineNum":"  167","line":"    //     https://bugs.llvm.org/show_bug.cgi?id=40815"},
{"lineNum":"  168","line":"    0"},
{"lineNum":"  169","line":"    #else"},
{"lineNum":"  170","line":"    packet_traits<Scalar>::Vectorizable"},
{"lineNum":"  171","line":"    #endif"},
{"lineNum":"  172","line":"  };"},
{"lineNum":"  173","line":"};"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"} // namespace internal"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"} // namespace Eigen"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"#endif // EIGEN_ASSIGNMENT_FUNCTORS_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 5, "covered" : 0,};
var merged_data = [];
