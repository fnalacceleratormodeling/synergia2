var data = {lines:[
{"lineNum":"    1","line":"/* Copyright (C) 1991-2020 Free Software Foundation, Inc."},
{"lineNum":"    2","line":"   This file is part of the GNU C Library."},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"   The GNU C Library is free software; you can redistribute it and/or"},
{"lineNum":"    5","line":"   modify it under the terms of the GNU Lesser General Public"},
{"lineNum":"    6","line":"   License as published by the Free Software Foundation; either"},
{"lineNum":"    7","line":"   version 2.1 of the License, or (at your option) any later version."},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"   The GNU C Library is distributed in the hope that it will be useful,"},
{"lineNum":"   10","line":"   but WITHOUT ANY WARRANTY; without even the implied warranty of"},
{"lineNum":"   11","line":"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU"},
{"lineNum":"   12","line":"   Lesser General Public License for more details."},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"   You should have received a copy of the GNU Lesser General Public"},
{"lineNum":"   15","line":"   License along with the GNU C Library; if not, see"},
{"lineNum":"   16","line":"   <https://www.gnu.org/licenses/>.  */"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"/*"},
{"lineNum":"   19","line":" *\tISO C99 Standard: 7.20 General utilities\t<stdlib.h>"},
{"lineNum":"   20","line":" */"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"#ifndef\t_STDLIB_H"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"#define __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION"},
{"lineNum":"   25","line":"#include <bits/libc-header-start.h>"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"/* Get size_t, wchar_t and NULL from <stddef.h>.  */"},
{"lineNum":"   28","line":"#define __need_size_t"},
{"lineNum":"   29","line":"#define __need_wchar_t"},
{"lineNum":"   30","line":"#define __need_NULL"},
{"lineNum":"   31","line":"#include <stddef.h>"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"__BEGIN_DECLS"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"#define\t_STDLIB_H\t1"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"#if (defined __USE_XOPEN || defined __USE_XOPEN2K8) && !defined _SYS_WAIT_H"},
{"lineNum":"   38","line":"/* XPG requires a few symbols from <sys/wait.h> being defined.  */"},
{"lineNum":"   39","line":"# include <bits/waitflags.h>"},
{"lineNum":"   40","line":"# include <bits/waitstatus.h>"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"/* Define the macros <sys/wait.h> also would define this way.  */"},
{"lineNum":"   43","line":"# define WEXITSTATUS(status)\t__WEXITSTATUS (status)"},
{"lineNum":"   44","line":"# define WTERMSIG(status)\t__WTERMSIG (status)"},
{"lineNum":"   45","line":"# define WSTOPSIG(status)\t__WSTOPSIG (status)"},
{"lineNum":"   46","line":"# define WIFEXITED(status)\t__WIFEXITED (status)"},
{"lineNum":"   47","line":"# define WIFSIGNALED(status)\t__WIFSIGNALED (status)"},
{"lineNum":"   48","line":"# define WIFSTOPPED(status)\t__WIFSTOPPED (status)"},
{"lineNum":"   49","line":"# ifdef __WIFCONTINUED"},
{"lineNum":"   50","line":"#  define WIFCONTINUED(status)\t__WIFCONTINUED (status)"},
{"lineNum":"   51","line":"# endif"},
{"lineNum":"   52","line":"#endif\t/* X/Open or XPG7 and <sys/wait.h> not included.  */"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"/* _FloatN API tests for enablement.  */"},
{"lineNum":"   55","line":"#include <bits/floatn.h>"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"/* Returned by `div\'.  */"},
{"lineNum":"   58","line":"typedef struct"},
{"lineNum":"   59","line":"  {"},
{"lineNum":"   60","line":"    int quot;\t\t\t/* Quotient.  */"},
{"lineNum":"   61","line":"    int rem;\t\t\t/* Remainder.  */"},
{"lineNum":"   62","line":"  } div_t;"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"/* Returned by `ldiv\'.  */"},
{"lineNum":"   65","line":"#ifndef __ldiv_t_defined"},
{"lineNum":"   66","line":"typedef struct"},
{"lineNum":"   67","line":"  {"},
{"lineNum":"   68","line":"    long int quot;\t\t/* Quotient.  */"},
{"lineNum":"   69","line":"    long int rem;\t\t/* Remainder.  */"},
{"lineNum":"   70","line":"  } ldiv_t;"},
{"lineNum":"   71","line":"# define __ldiv_t_defined\t1"},
{"lineNum":"   72","line":"#endif"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"#if defined __USE_ISOC99 && !defined __lldiv_t_defined"},
{"lineNum":"   75","line":"/* Returned by `lldiv\'.  */"},
{"lineNum":"   76","line":"__extension__ typedef struct"},
{"lineNum":"   77","line":"  {"},
{"lineNum":"   78","line":"    long long int quot;\t\t/* Quotient.  */"},
{"lineNum":"   79","line":"    long long int rem;\t\t/* Remainder.  */"},
{"lineNum":"   80","line":"  } lldiv_t;"},
{"lineNum":"   81","line":"# define __lldiv_t_defined\t1"},
{"lineNum":"   82","line":"#endif"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"/* The largest number rand will return (same as INT_MAX).  */"},
{"lineNum":"   86","line":"#define\tRAND_MAX\t2147483647"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"/* We define these the same for all machines."},
{"lineNum":"   90","line":"   Changes from this to the outside world should be done in `_exit\'.  */"},
{"lineNum":"   91","line":"#define\tEXIT_FAILURE\t1\t/* Failing exit status.  */"},
{"lineNum":"   92","line":"#define\tEXIT_SUCCESS\t0\t/* Successful exit status.  */"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"/* Maximum length of a multibyte character in the current locale.  */"},
{"lineNum":"   96","line":"#define\tMB_CUR_MAX\t(__ctype_get_mb_cur_max ())"},
{"lineNum":"   97","line":"extern size_t __ctype_get_mb_cur_max (void) __THROW __wur;"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"/* Convert a string to a floating-point number.  */"},
{"lineNum":"  101","line":"extern double atof (const char *__nptr)"},
{"lineNum":"  102","line":"     __THROW __attribute_pure__ __nonnull ((1)) __wur;"},
{"lineNum":"  103","line":"/* Convert a string to an integer.  */"},
{"lineNum":"  104","line":"extern int atoi (const char *__nptr)"},
{"lineNum":"  105","line":"     __THROW __attribute_pure__ __nonnull ((1)) __wur;"},
{"lineNum":"  106","line":"/* Convert a string to a long integer.  */"},
{"lineNum":"  107","line":"extern long int atol (const char *__nptr)"},
{"lineNum":"  108","line":"     __THROW __attribute_pure__ __nonnull ((1)) __wur;"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"#ifdef __USE_ISOC99"},
{"lineNum":"  111","line":"/* Convert a string to a long long integer.  */"},
{"lineNum":"  112","line":"__extension__ extern long long int atoll (const char *__nptr)"},
{"lineNum":"  113","line":"     __THROW __attribute_pure__ __nonnull ((1)) __wur;"},
{"lineNum":"  114","line":"#endif"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"/* Convert a string to a floating-point number.  */"},
{"lineNum":"  117","line":"extern double strtod (const char *__restrict __nptr,"},
{"lineNum":"  118","line":"\t\t      char **__restrict __endptr)"},
{"lineNum":"  119","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"#ifdef\t__USE_ISOC99"},
{"lineNum":"  122","line":"/* Likewise for `float\' and `long double\' sizes of floating-point numbers.  */"},
{"lineNum":"  123","line":"extern float strtof (const char *__restrict __nptr,"},
{"lineNum":"  124","line":"\t\t     char **__restrict __endptr) __THROW __nonnull ((1));"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"extern long double strtold (const char *__restrict __nptr,"},
{"lineNum":"  127","line":"\t\t\t    char **__restrict __endptr)"},
{"lineNum":"  128","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  129","line":"#endif"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"/* Likewise for \'_FloatN\' and \'_FloatNx\'.  */"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"#if __HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  134","line":"extern _Float16 strtof16 (const char *__restrict __nptr,"},
{"lineNum":"  135","line":"\t\t\t  char **__restrict __endptr)"},
{"lineNum":"  136","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  137","line":"#endif"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"#if __HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  140","line":"extern _Float32 strtof32 (const char *__restrict __nptr,"},
{"lineNum":"  141","line":"\t\t\t  char **__restrict __endptr)"},
{"lineNum":"  142","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  143","line":"#endif"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"#if __HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  146","line":"extern _Float64 strtof64 (const char *__restrict __nptr,"},
{"lineNum":"  147","line":"\t\t\t  char **__restrict __endptr)"},
{"lineNum":"  148","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  149","line":"#endif"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"#if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  152","line":"extern _Float128 strtof128 (const char *__restrict __nptr,"},
{"lineNum":"  153","line":"\t\t\t    char **__restrict __endptr)"},
{"lineNum":"  154","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  155","line":"#endif"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"#if __HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  158","line":"extern _Float32x strtof32x (const char *__restrict __nptr,"},
{"lineNum":"  159","line":"\t\t\t    char **__restrict __endptr)"},
{"lineNum":"  160","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  161","line":"#endif"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"#if __HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  164","line":"extern _Float64x strtof64x (const char *__restrict __nptr,"},
{"lineNum":"  165","line":"\t\t\t    char **__restrict __endptr)"},
{"lineNum":"  166","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  167","line":"#endif"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"#if __HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  170","line":"extern _Float128x strtof128x (const char *__restrict __nptr,"},
{"lineNum":"  171","line":"\t\t\t      char **__restrict __endptr)"},
{"lineNum":"  172","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  173","line":"#endif"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"/* Convert a string to a long integer.  */"},
{"lineNum":"  176","line":"extern long int strtol (const char *__restrict __nptr,"},
{"lineNum":"  177","line":"\t\t\tchar **__restrict __endptr, int __base)"},
{"lineNum":"  178","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  179","line":"/* Convert a string to an unsigned long integer.  */"},
{"lineNum":"  180","line":"extern unsigned long int strtoul (const char *__restrict __nptr,"},
{"lineNum":"  181","line":"\t\t\t\t  char **__restrict __endptr, int __base)"},
{"lineNum":"  182","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"#ifdef __USE_MISC"},
{"lineNum":"  185","line":"/* Convert a string to a quadword integer.  */"},
{"lineNum":"  186","line":"__extension__"},
{"lineNum":"  187","line":"extern long long int strtoq (const char *__restrict __nptr,"},
{"lineNum":"  188","line":"\t\t\t     char **__restrict __endptr, int __base)"},
{"lineNum":"  189","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  190","line":"/* Convert a string to an unsigned quadword integer.  */"},
{"lineNum":"  191","line":"__extension__"},
{"lineNum":"  192","line":"extern unsigned long long int strtouq (const char *__restrict __nptr,"},
{"lineNum":"  193","line":"\t\t\t\t       char **__restrict __endptr, int __base)"},
{"lineNum":"  194","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  195","line":"#endif /* Use misc.  */"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"#ifdef __USE_ISOC99"},
{"lineNum":"  198","line":"/* Convert a string to a quadword integer.  */"},
{"lineNum":"  199","line":"__extension__"},
{"lineNum":"  200","line":"extern long long int strtoll (const char *__restrict __nptr,"},
{"lineNum":"  201","line":"\t\t\t      char **__restrict __endptr, int __base)"},
{"lineNum":"  202","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  203","line":"/* Convert a string to an unsigned quadword integer.  */"},
{"lineNum":"  204","line":"__extension__"},
{"lineNum":"  205","line":"extern unsigned long long int strtoull (const char *__restrict __nptr,"},
{"lineNum":"  206","line":"\t\t\t\t\tchar **__restrict __endptr, int __base)"},
{"lineNum":"  207","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  208","line":"#endif /* ISO C99 or use MISC.  */"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"/* Convert a floating-point number to a string.  */"},
{"lineNum":"  211","line":"#if __GLIBC_USE (IEC_60559_BFP_EXT_C2X)"},
{"lineNum":"  212","line":"extern int strfromd (char *__dest, size_t __size, const char *__format,"},
{"lineNum":"  213","line":"\t\t     double __f)"},
{"lineNum":"  214","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"extern int strfromf (char *__dest, size_t __size, const char *__format,"},
{"lineNum":"  217","line":"\t\t     float __f)"},
{"lineNum":"  218","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"extern int strfroml (char *__dest, size_t __size, const char *__format,"},
{"lineNum":"  221","line":"\t\t     long double __f)"},
{"lineNum":"  222","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  223","line":"#endif"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"#if __HAVE_FLOAT16 && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  226","line":"extern int strfromf16 (char *__dest, size_t __size, const char * __format,"},
{"lineNum":"  227","line":"\t\t       _Float16 __f)"},
{"lineNum":"  228","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  229","line":"#endif"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"#if __HAVE_FLOAT32 && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  232","line":"extern int strfromf32 (char *__dest, size_t __size, const char * __format,"},
{"lineNum":"  233","line":"\t\t       _Float32 __f)"},
{"lineNum":"  234","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  235","line":"#endif"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"#if __HAVE_FLOAT64 && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  238","line":"extern int strfromf64 (char *__dest, size_t __size, const char * __format,"},
{"lineNum":"  239","line":"\t\t       _Float64 __f)"},
{"lineNum":"  240","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  241","line":"#endif"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"#if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  244","line":"extern int strfromf128 (char *__dest, size_t __size, const char * __format,"},
{"lineNum":"  245","line":"\t\t\t_Float128 __f)"},
{"lineNum":"  246","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  247","line":"#endif"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"#if __HAVE_FLOAT32X && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  250","line":"extern int strfromf32x (char *__dest, size_t __size, const char * __format,"},
{"lineNum":"  251","line":"\t\t\t_Float32x __f)"},
{"lineNum":"  252","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  253","line":"#endif"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"#if __HAVE_FLOAT64X && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  256","line":"extern int strfromf64x (char *__dest, size_t __size, const char * __format,"},
{"lineNum":"  257","line":"\t\t\t_Float64x __f)"},
{"lineNum":"  258","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  259","line":"#endif"},
{"lineNum":"  260","line":""},
{"lineNum":"  261","line":"#if __HAVE_FLOAT128X && __GLIBC_USE (IEC_60559_TYPES_EXT)"},
{"lineNum":"  262","line":"extern int strfromf128x (char *__dest, size_t __size, const char * __format,"},
{"lineNum":"  263","line":"\t\t\t _Float128x __f)"},
{"lineNum":"  264","line":"     __THROW __nonnull ((3));"},
{"lineNum":"  265","line":"#endif"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"#ifdef __USE_GNU"},
{"lineNum":"  269","line":"/* Parallel versions of the functions above which take the locale to"},
{"lineNum":"  270","line":"   use as an additional parameter.  These are GNU extensions inspired"},
{"lineNum":"  271","line":"   by the POSIX.1-2008 extended locale API.  */"},
{"lineNum":"  272","line":"# include <bits/types/locale_t.h>"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"extern long int strtol_l (const char *__restrict __nptr,"},
{"lineNum":"  275","line":"\t\t\t  char **__restrict __endptr, int __base,"},
{"lineNum":"  276","line":"\t\t\t  locale_t __loc) __THROW __nonnull ((1, 4));"},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"extern unsigned long int strtoul_l (const char *__restrict __nptr,"},
{"lineNum":"  279","line":"\t\t\t\t    char **__restrict __endptr,"},
{"lineNum":"  280","line":"\t\t\t\t    int __base, locale_t __loc)"},
{"lineNum":"  281","line":"     __THROW __nonnull ((1, 4));"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"__extension__"},
{"lineNum":"  284","line":"extern long long int strtoll_l (const char *__restrict __nptr,"},
{"lineNum":"  285","line":"\t\t\t\tchar **__restrict __endptr, int __base,"},
{"lineNum":"  286","line":"\t\t\t\tlocale_t __loc)"},
{"lineNum":"  287","line":"     __THROW __nonnull ((1, 4));"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"__extension__"},
{"lineNum":"  290","line":"extern unsigned long long int strtoull_l (const char *__restrict __nptr,"},
{"lineNum":"  291","line":"\t\t\t\t\t  char **__restrict __endptr,"},
{"lineNum":"  292","line":"\t\t\t\t\t  int __base, locale_t __loc)"},
{"lineNum":"  293","line":"     __THROW __nonnull ((1, 4));"},
{"lineNum":"  294","line":""},
{"lineNum":"  295","line":"extern double strtod_l (const char *__restrict __nptr,"},
{"lineNum":"  296","line":"\t\t\tchar **__restrict __endptr, locale_t __loc)"},
{"lineNum":"  297","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"extern float strtof_l (const char *__restrict __nptr,"},
{"lineNum":"  300","line":"\t\t       char **__restrict __endptr, locale_t __loc)"},
{"lineNum":"  301","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"extern long double strtold_l (const char *__restrict __nptr,"},
{"lineNum":"  304","line":"\t\t\t      char **__restrict __endptr,"},
{"lineNum":"  305","line":"\t\t\t      locale_t __loc)"},
{"lineNum":"  306","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"# if __HAVE_FLOAT16"},
{"lineNum":"  309","line":"extern _Float16 strtof16_l (const char *__restrict __nptr,"},
{"lineNum":"  310","line":"\t\t\t    char **__restrict __endptr,"},
{"lineNum":"  311","line":"\t\t\t    locale_t __loc)"},
{"lineNum":"  312","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  313","line":"# endif"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"# if __HAVE_FLOAT32"},
{"lineNum":"  316","line":"extern _Float32 strtof32_l (const char *__restrict __nptr,"},
{"lineNum":"  317","line":"\t\t\t    char **__restrict __endptr,"},
{"lineNum":"  318","line":"\t\t\t    locale_t __loc)"},
{"lineNum":"  319","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  320","line":"# endif"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"# if __HAVE_FLOAT64"},
{"lineNum":"  323","line":"extern _Float64 strtof64_l (const char *__restrict __nptr,"},
{"lineNum":"  324","line":"\t\t\t    char **__restrict __endptr,"},
{"lineNum":"  325","line":"\t\t\t    locale_t __loc)"},
{"lineNum":"  326","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  327","line":"# endif"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"# if __HAVE_FLOAT128"},
{"lineNum":"  330","line":"extern _Float128 strtof128_l (const char *__restrict __nptr,"},
{"lineNum":"  331","line":"\t\t\t      char **__restrict __endptr,"},
{"lineNum":"  332","line":"\t\t\t      locale_t __loc)"},
{"lineNum":"  333","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  334","line":"# endif"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"# if __HAVE_FLOAT32X"},
{"lineNum":"  337","line":"extern _Float32x strtof32x_l (const char *__restrict __nptr,"},
{"lineNum":"  338","line":"\t\t\t      char **__restrict __endptr,"},
{"lineNum":"  339","line":"\t\t\t      locale_t __loc)"},
{"lineNum":"  340","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  341","line":"# endif"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"# if __HAVE_FLOAT64X"},
{"lineNum":"  344","line":"extern _Float64x strtof64x_l (const char *__restrict __nptr,"},
{"lineNum":"  345","line":"\t\t\t      char **__restrict __endptr,"},
{"lineNum":"  346","line":"\t\t\t      locale_t __loc)"},
{"lineNum":"  347","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  348","line":"# endif"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"# if __HAVE_FLOAT128X"},
{"lineNum":"  351","line":"extern _Float128x strtof128x_l (const char *__restrict __nptr,"},
{"lineNum":"  352","line":"\t\t\t\tchar **__restrict __endptr,"},
{"lineNum":"  353","line":"\t\t\t\tlocale_t __loc)"},
{"lineNum":"  354","line":"     __THROW __nonnull ((1, 3));"},
{"lineNum":"  355","line":"# endif"},
{"lineNum":"  356","line":"#endif /* GNU */"},
{"lineNum":"  357","line":""},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"#ifdef __USE_EXTERN_INLINES"},
{"lineNum":"  360","line":"__extern_inline int"},
{"lineNum":"  361","line":"__NTH (atoi (const char *__nptr))"},
{"lineNum":"  362","line":"{"},
{"lineNum":"  363","line":"  return (int) strtol (__nptr, (char **) NULL, 10);","class":"linePartCov","hits":"5","order":"1453","possible_hits":"98",},
{"lineNum":"  364","line":"}"},
{"lineNum":"  365","line":"__extern_inline long int"},
{"lineNum":"  366","line":"__NTH (atol (const char *__nptr))"},
{"lineNum":"  367","line":"{"},
{"lineNum":"  368","line":"  return strtol (__nptr, (char **) NULL, 10);"},
{"lineNum":"  369","line":"}"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":"# ifdef __USE_ISOC99"},
{"lineNum":"  372","line":"__extension__ __extern_inline long long int"},
{"lineNum":"  373","line":"__NTH (atoll (const char *__nptr))"},
{"lineNum":"  374","line":"{"},
{"lineNum":"  375","line":"  return strtoll (__nptr, (char **) NULL, 10);"},
{"lineNum":"  376","line":"}"},
{"lineNum":"  377","line":"# endif"},
{"lineNum":"  378","line":"#endif /* Optimizing and Inlining.  */"},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED"},
{"lineNum":"  382","line":"/* Convert N to base 64 using the digits \"./0-9A-Za-z\", least-significant"},
{"lineNum":"  383","line":"   digit first.  Returns a pointer to static storage overwritten by the"},
{"lineNum":"  384","line":"   next call.  */"},
{"lineNum":"  385","line":"extern char *l64a (long int __n) __THROW __wur;"},
{"lineNum":"  386","line":""},
{"lineNum":"  387","line":"/* Read a number from a string S in base 64 as above.  */"},
{"lineNum":"  388","line":"extern long int a64l (const char *__s)"},
{"lineNum":"  389","line":"     __THROW __attribute_pure__ __nonnull ((1)) __wur;"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"#endif\t/* Use misc || extended X/Open.  */"},
{"lineNum":"  392","line":""},
{"lineNum":"  393","line":"#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED"},
{"lineNum":"  394","line":"# include <sys/types.h>\t/* we need int32_t... */"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"/* These are the functions that actually do things.  The `random\', `srandom\',"},
{"lineNum":"  397","line":"   `initstate\' and `setstate\' functions are those from BSD Unices."},
{"lineNum":"  398","line":"   The `rand\' and `srand\' functions are required by the ANSI standard."},
{"lineNum":"  399","line":"   We provide both interfaces to the same random number generator.  */"},
{"lineNum":"  400","line":"/* Return a random long integer between 0 and RAND_MAX inclusive.  */"},
{"lineNum":"  401","line":"extern long int random (void) __THROW;"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"/* Seed the random number generator with the given number.  */"},
{"lineNum":"  404","line":"extern void srandom (unsigned int __seed) __THROW;"},
{"lineNum":"  405","line":""},
{"lineNum":"  406","line":"/* Initialize the random number generator to use state buffer STATEBUF,"},
{"lineNum":"  407","line":"   of length STATELEN, and seed it with SEED.  Optimal lengths are 8, 16,"},
{"lineNum":"  408","line":"   32, 64, 128 and 256, the bigger the better; values less than 8 will"},
{"lineNum":"  409","line":"   cause an error and values greater than 256 will be rounded down.  */"},
{"lineNum":"  410","line":"extern char *initstate (unsigned int __seed, char *__statebuf,"},
{"lineNum":"  411","line":"\t\t\tsize_t __statelen) __THROW __nonnull ((2));"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"/* Switch the random number generator to state buffer STATEBUF,"},
{"lineNum":"  414","line":"   which should have been previously initialized by `initstate\'.  */"},
{"lineNum":"  415","line":"extern char *setstate (char *__statebuf) __THROW __nonnull ((1));"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"# ifdef __USE_MISC"},
{"lineNum":"  419","line":"/* Reentrant versions of the `random\' family of functions."},
{"lineNum":"  420","line":"   These functions all use the following data structure to contain"},
{"lineNum":"  421","line":"   state, rather than global state variables.  */"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"struct random_data"},
{"lineNum":"  424","line":"  {"},
{"lineNum":"  425","line":"    int32_t *fptr;\t\t/* Front pointer.  */"},
{"lineNum":"  426","line":"    int32_t *rptr;\t\t/* Rear pointer.  */"},
{"lineNum":"  427","line":"    int32_t *state;\t\t/* Array of state values.  */"},
{"lineNum":"  428","line":"    int rand_type;\t\t/* Type of random number generator.  */"},
{"lineNum":"  429","line":"    int rand_deg;\t\t/* Degree of random number generator.  */"},
{"lineNum":"  430","line":"    int rand_sep;\t\t/* Distance between front and rear.  */"},
{"lineNum":"  431","line":"    int32_t *end_ptr;\t\t/* Pointer behind state table.  */"},
{"lineNum":"  432","line":"  };"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"extern int random_r (struct random_data *__restrict __buf,"},
{"lineNum":"  435","line":"\t\t     int32_t *__restrict __result) __THROW __nonnull ((1, 2));"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"extern int srandom_r (unsigned int __seed, struct random_data *__buf)"},
{"lineNum":"  438","line":"     __THROW __nonnull ((2));"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,"},
{"lineNum":"  441","line":"\t\t\tsize_t __statelen,"},
{"lineNum":"  442","line":"\t\t\tstruct random_data *__restrict __buf)"},
{"lineNum":"  443","line":"     __THROW __nonnull ((2, 4));"},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"extern int setstate_r (char *__restrict __statebuf,"},
{"lineNum":"  446","line":"\t\t       struct random_data *__restrict __buf)"},
{"lineNum":"  447","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  448","line":"# endif\t/* Use misc.  */"},
{"lineNum":"  449","line":"#endif\t/* Use extended X/Open || misc. */"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"/* Return a random integer between 0 and RAND_MAX inclusive.  */"},
{"lineNum":"  453","line":"extern int rand (void) __THROW;"},
{"lineNum":"  454","line":"/* Seed the random number generator with the given number.  */"},
{"lineNum":"  455","line":"extern void srand (unsigned int __seed) __THROW;"},
{"lineNum":"  456","line":""},
{"lineNum":"  457","line":"#ifdef __USE_POSIX199506"},
{"lineNum":"  458","line":"/* Reentrant interface according to POSIX.1.  */"},
{"lineNum":"  459","line":"extern int rand_r (unsigned int *__seed) __THROW;"},
{"lineNum":"  460","line":"#endif"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"#if defined __USE_MISC || defined __USE_XOPEN"},
{"lineNum":"  464","line":"/* System V style 48-bit random number generator functions.  */"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */"},
{"lineNum":"  467","line":"extern double drand48 (void) __THROW;"},
{"lineNum":"  468","line":"extern double erand48 (unsigned short int __xsubi[3]) __THROW __nonnull ((1));"},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"/* Return non-negative, long integer in [0,2^31).  */"},
{"lineNum":"  471","line":"extern long int lrand48 (void) __THROW;"},
{"lineNum":"  472","line":"extern long int nrand48 (unsigned short int __xsubi[3])"},
{"lineNum":"  473","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"/* Return signed, long integers in [-2^31,2^31).  */"},
{"lineNum":"  476","line":"extern long int mrand48 (void) __THROW;"},
{"lineNum":"  477","line":"extern long int jrand48 (unsigned short int __xsubi[3])"},
{"lineNum":"  478","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"/* Seed random number generator.  */"},
{"lineNum":"  481","line":"extern void srand48 (long int __seedval) __THROW;"},
{"lineNum":"  482","line":"extern unsigned short int *seed48 (unsigned short int __seed16v[3])"},
{"lineNum":"  483","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  484","line":"extern void lcong48 (unsigned short int __param[7]) __THROW __nonnull ((1));"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"# ifdef __USE_MISC"},
{"lineNum":"  487","line":"/* Data structure for communication with thread safe versions.  This"},
{"lineNum":"  488","line":"   type is to be regarded as opaque.  It\'s only exported because users"},
{"lineNum":"  489","line":"   have to allocate objects of this type.  */"},
{"lineNum":"  490","line":"struct drand48_data"},
{"lineNum":"  491","line":"  {"},
{"lineNum":"  492","line":"    unsigned short int __x[3];\t/* Current state.  */"},
{"lineNum":"  493","line":"    unsigned short int __old_x[3]; /* Old state.  */"},
{"lineNum":"  494","line":"    unsigned short int __c;\t/* Additive const. in congruential formula.  */"},
{"lineNum":"  495","line":"    unsigned short int __init;\t/* Flag for initializing.  */"},
{"lineNum":"  496","line":"    __extension__ unsigned long long int __a;\t/* Factor in congruential"},
{"lineNum":"  497","line":"\t\t\t\t\t\t   formula.  */"},
{"lineNum":"  498","line":"  };"},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"/* Return non-negative, double-precision floating-point value in [0.0,1.0).  */"},
{"lineNum":"  501","line":"extern int drand48_r (struct drand48_data *__restrict __buffer,"},
{"lineNum":"  502","line":"\t\t      double *__restrict __result) __THROW __nonnull ((1, 2));"},
{"lineNum":"  503","line":"extern int erand48_r (unsigned short int __xsubi[3],"},
{"lineNum":"  504","line":"\t\t      struct drand48_data *__restrict __buffer,"},
{"lineNum":"  505","line":"\t\t      double *__restrict __result) __THROW __nonnull ((1, 2));"},
{"lineNum":"  506","line":""},
{"lineNum":"  507","line":"/* Return non-negative, long integer in [0,2^31).  */"},
{"lineNum":"  508","line":"extern int lrand48_r (struct drand48_data *__restrict __buffer,"},
{"lineNum":"  509","line":"\t\t      long int *__restrict __result)"},
{"lineNum":"  510","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  511","line":"extern int nrand48_r (unsigned short int __xsubi[3],"},
{"lineNum":"  512","line":"\t\t      struct drand48_data *__restrict __buffer,"},
{"lineNum":"  513","line":"\t\t      long int *__restrict __result)"},
{"lineNum":"  514","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  515","line":""},
{"lineNum":"  516","line":"/* Return signed, long integers in [-2^31,2^31).  */"},
{"lineNum":"  517","line":"extern int mrand48_r (struct drand48_data *__restrict __buffer,"},
{"lineNum":"  518","line":"\t\t      long int *__restrict __result)"},
{"lineNum":"  519","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  520","line":"extern int jrand48_r (unsigned short int __xsubi[3],"},
{"lineNum":"  521","line":"\t\t      struct drand48_data *__restrict __buffer,"},
{"lineNum":"  522","line":"\t\t      long int *__restrict __result)"},
{"lineNum":"  523","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":"/* Seed random number generator.  */"},
{"lineNum":"  526","line":"extern int srand48_r (long int __seedval, struct drand48_data *__buffer)"},
{"lineNum":"  527","line":"     __THROW __nonnull ((2));"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"extern int seed48_r (unsigned short int __seed16v[3],"},
{"lineNum":"  530","line":"\t\t     struct drand48_data *__buffer) __THROW __nonnull ((1, 2));"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"extern int lcong48_r (unsigned short int __param[7],"},
{"lineNum":"  533","line":"\t\t      struct drand48_data *__buffer)"},
{"lineNum":"  534","line":"     __THROW __nonnull ((1, 2));"},
{"lineNum":"  535","line":"# endif\t/* Use misc.  */"},
{"lineNum":"  536","line":"#endif\t/* Use misc or X/Open.  */"},
{"lineNum":"  537","line":""},
{"lineNum":"  538","line":"/* Allocate SIZE bytes of memory.  */"},
{"lineNum":"  539","line":"extern void *malloc (size_t __size) __THROW __attribute_malloc__"},
{"lineNum":"  540","line":"     __attribute_alloc_size__ ((1)) __wur;"},
{"lineNum":"  541","line":"/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */"},
{"lineNum":"  542","line":"extern void *calloc (size_t __nmemb, size_t __size)"},
{"lineNum":"  543","line":"     __THROW __attribute_malloc__ __attribute_alloc_size__ ((1, 2)) __wur;"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"/* Re-allocate the previously allocated block"},
{"lineNum":"  546","line":"   in PTR, making the new block SIZE bytes long.  */"},
{"lineNum":"  547","line":"/* __attribute_malloc__ is not used, because if realloc returns"},
{"lineNum":"  548","line":"   the same pointer that was passed to it, aliasing needs to be allowed"},
{"lineNum":"  549","line":"   between objects pointed by the old and new pointers.  */"},
{"lineNum":"  550","line":"extern void *realloc (void *__ptr, size_t __size)"},
{"lineNum":"  551","line":"     __THROW __attribute_warn_unused_result__ __attribute_alloc_size__ ((2));"},
{"lineNum":"  552","line":""},
{"lineNum":"  553","line":"#ifdef __USE_MISC"},
{"lineNum":"  554","line":"/* Re-allocate the previously allocated block in PTR, making the new"},
{"lineNum":"  555","line":"   block large enough for NMEMB elements of SIZE bytes each.  */"},
{"lineNum":"  556","line":"/* __attribute_malloc__ is not used, because if reallocarray returns"},
{"lineNum":"  557","line":"   the same pointer that was passed to it, aliasing needs to be allowed"},
{"lineNum":"  558","line":"   between objects pointed by the old and new pointers.  */"},
{"lineNum":"  559","line":"extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)"},
{"lineNum":"  560","line":"     __THROW __attribute_warn_unused_result__"},
{"lineNum":"  561","line":"     __attribute_alloc_size__ ((2, 3));"},
{"lineNum":"  562","line":"#endif"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"/* Free a block allocated by `malloc\', `realloc\' or `calloc\'.  */"},
{"lineNum":"  565","line":"extern void free (void *__ptr) __THROW;"},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"#ifdef __USE_MISC"},
{"lineNum":"  568","line":"# include <alloca.h>"},
{"lineNum":"  569","line":"#endif /* Use misc.  */"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K) \\"},
{"lineNum":"  572","line":"    || defined __USE_MISC"},
{"lineNum":"  573","line":"/* Allocate SIZE bytes on a page boundary.  The storage cannot be freed.  */"},
{"lineNum":"  574","line":"extern void *valloc (size_t __size) __THROW __attribute_malloc__"},
{"lineNum":"  575","line":"     __attribute_alloc_size__ ((1)) __wur;"},
{"lineNum":"  576","line":"#endif"},
{"lineNum":"  577","line":""},
{"lineNum":"  578","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":"  579","line":"/* Allocate memory of SIZE bytes with an alignment of ALIGNMENT.  */"},
{"lineNum":"  580","line":"extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)"},
{"lineNum":"  581","line":"     __THROW __nonnull ((1)) __wur;"},
{"lineNum":"  582","line":"#endif"},
{"lineNum":"  583","line":""},
{"lineNum":"  584","line":"#ifdef __USE_ISOC11"},
{"lineNum":"  585","line":"/* ISO C variant of aligned allocation.  */"},
{"lineNum":"  586","line":"extern void *aligned_alloc (size_t __alignment, size_t __size)"},
{"lineNum":"  587","line":"     __THROW __attribute_malloc__ __attribute_alloc_size__ ((2)) __wur;"},
{"lineNum":"  588","line":"#endif"},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":"/* Abort execution and generate a core-dump.  */"},
{"lineNum":"  591","line":"extern void abort (void) __THROW __attribute__ ((__noreturn__));"},
{"lineNum":"  592","line":""},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"/* Register a function to be called when `exit\' is called.  */"},
{"lineNum":"  595","line":"extern int atexit (void (*__func) (void)) __THROW __nonnull ((1));"},
{"lineNum":"  596","line":""},
{"lineNum":"  597","line":"#if defined __USE_ISOC11 || defined __USE_ISOCXX11"},
{"lineNum":"  598","line":"/* Register a function to be called when `quick_exit\' is called.  */"},
{"lineNum":"  599","line":"# ifdef __cplusplus"},
{"lineNum":"  600","line":"extern \"C++\" int at_quick_exit (void (*__func) (void))"},
{"lineNum":"  601","line":"     __THROW __asm (\"at_quick_exit\") __nonnull ((1));"},
{"lineNum":"  602","line":"# else"},
{"lineNum":"  603","line":"extern int at_quick_exit (void (*__func) (void)) __THROW __nonnull ((1));"},
{"lineNum":"  604","line":"# endif"},
{"lineNum":"  605","line":"#endif"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"#ifdef\t__USE_MISC"},
{"lineNum":"  608","line":"/* Register a function to be called with the status"},
{"lineNum":"  609","line":"   given to `exit\' and the given argument.  */"},
{"lineNum":"  610","line":"extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)"},
{"lineNum":"  611","line":"     __THROW __nonnull ((1));"},
{"lineNum":"  612","line":"#endif"},
{"lineNum":"  613","line":""},
{"lineNum":"  614","line":"/* Call all functions registered with `atexit\' and `on_exit\',"},
{"lineNum":"  615","line":"   in the reverse of the order in which they were registered,"},
{"lineNum":"  616","line":"   perform stdio cleanup, and terminate program execution with STATUS.  */"},
{"lineNum":"  617","line":"extern void exit (int __status) __THROW __attribute__ ((__noreturn__));"},
{"lineNum":"  618","line":""},
{"lineNum":"  619","line":"#if defined __USE_ISOC11 || defined __USE_ISOCXX11"},
{"lineNum":"  620","line":"/* Call all functions registered with `at_quick_exit\' in the reverse"},
{"lineNum":"  621","line":"   of the order in which they were registered and terminate program"},
{"lineNum":"  622","line":"   execution with STATUS.  */"},
{"lineNum":"  623","line":"extern void quick_exit (int __status) __THROW __attribute__ ((__noreturn__));"},
{"lineNum":"  624","line":"#endif"},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"#ifdef __USE_ISOC99"},
{"lineNum":"  627","line":"/* Terminate the program with STATUS without calling any of the"},
{"lineNum":"  628","line":"   functions registered with `atexit\' or `on_exit\'.  */"},
{"lineNum":"  629","line":"extern void _Exit (int __status) __THROW __attribute__ ((__noreturn__));"},
{"lineNum":"  630","line":"#endif"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":""},
{"lineNum":"  633","line":"/* Return the value of envariable NAME, or NULL if it doesn\'t exist.  */"},
{"lineNum":"  634","line":"extern char *getenv (const char *__name) __THROW __nonnull ((1)) __wur;"},
{"lineNum":"  635","line":""},
{"lineNum":"  636","line":"#ifdef __USE_GNU"},
{"lineNum":"  637","line":"/* This function is similar to the above but returns NULL if the"},
{"lineNum":"  638","line":"   programs is running with SUID or SGID enabled.  */"},
{"lineNum":"  639","line":"extern char *secure_getenv (const char *__name)"},
{"lineNum":"  640","line":"     __THROW __nonnull ((1)) __wur;"},
{"lineNum":"  641","line":"#endif"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"#if defined __USE_MISC || defined __USE_XOPEN"},
{"lineNum":"  644","line":"/* The SVID says this is in <stdio.h>, but this seems a better place.\t*/"},
{"lineNum":"  645","line":"/* Put STRING, which is of the form \"NAME=VALUE\", in the environment."},
{"lineNum":"  646","line":"   If there is no `=\', remove NAME from the environment.  */"},
{"lineNum":"  647","line":"extern int putenv (char *__string) __THROW __nonnull ((1));"},
{"lineNum":"  648","line":"#endif"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"#ifdef __USE_XOPEN2K"},
{"lineNum":"  651","line":"/* Set NAME to VALUE in the environment."},
{"lineNum":"  652","line":"   If REPLACE is nonzero, overwrite an existing value.  */"},
{"lineNum":"  653","line":"extern int setenv (const char *__name, const char *__value, int __replace)"},
{"lineNum":"  654","line":"     __THROW __nonnull ((2));"},
{"lineNum":"  655","line":""},
{"lineNum":"  656","line":"/* Remove the variable NAME from the environment.  */"},
{"lineNum":"  657","line":"extern int unsetenv (const char *__name) __THROW __nonnull ((1));"},
{"lineNum":"  658","line":"#endif"},
{"lineNum":"  659","line":""},
{"lineNum":"  660","line":"#ifdef\t__USE_MISC"},
{"lineNum":"  661","line":"/* The `clearenv\' was planned to be added to POSIX.1 but probably"},
{"lineNum":"  662","line":"   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings"},
{"lineNum":"  663","line":"   for Fortran 77) requires this function.  */"},
{"lineNum":"  664","line":"extern int clearenv (void) __THROW;"},
{"lineNum":"  665","line":"#endif"},
{"lineNum":"  666","line":""},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"#if defined __USE_MISC \\"},
{"lineNum":"  669","line":"    || (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8)"},
{"lineNum":"  670","line":"/* Generate a unique temporary file name from TEMPLATE."},
{"lineNum":"  671","line":"   The last six characters of TEMPLATE must be \"XXXXXX\";"},
{"lineNum":"  672","line":"   they are replaced with a string that makes the file name unique."},
{"lineNum":"  673","line":"   Always returns TEMPLATE, it\'s either a temporary file name or a null"},
{"lineNum":"  674","line":"   string if it cannot get a unique file name.  */"},
{"lineNum":"  675","line":"extern char *mktemp (char *__template) __THROW __nonnull ((1));"},
{"lineNum":"  676","line":"#endif"},
{"lineNum":"  677","line":""},
{"lineNum":"  678","line":"#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8"},
{"lineNum":"  679","line":"/* Generate a unique temporary file name from TEMPLATE."},
{"lineNum":"  680","line":"   The last six characters of TEMPLATE must be \"XXXXXX\";"},
{"lineNum":"  681","line":"   they are replaced with a string that makes the filename unique."},
{"lineNum":"  682","line":"   Returns a file descriptor open on the file for reading and writing,"},
{"lineNum":"  683","line":"   or -1 if it cannot create a uniquely-named file."},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"   This function is a possible cancellation point and therefore not"},
{"lineNum":"  686","line":"   marked with __THROW.  */"},
{"lineNum":"  687","line":"# ifndef __USE_FILE_OFFSET64"},
{"lineNum":"  688","line":"extern int mkstemp (char *__template) __nonnull ((1)) __wur;"},
{"lineNum":"  689","line":"# else"},
{"lineNum":"  690","line":"#  ifdef __REDIRECT"},
{"lineNum":"  691","line":"extern int __REDIRECT (mkstemp, (char *__template), mkstemp64)"},
{"lineNum":"  692","line":"     __nonnull ((1)) __wur;"},
{"lineNum":"  693","line":"#  else"},
{"lineNum":"  694","line":"#   define mkstemp mkstemp64"},
{"lineNum":"  695","line":"#  endif"},
{"lineNum":"  696","line":"# endif"},
{"lineNum":"  697","line":"# ifdef __USE_LARGEFILE64"},
{"lineNum":"  698","line":"extern int mkstemp64 (char *__template) __nonnull ((1)) __wur;"},
{"lineNum":"  699","line":"# endif"},
{"lineNum":"  700","line":"#endif"},
{"lineNum":"  701","line":""},
{"lineNum":"  702","line":"#ifdef __USE_MISC"},
{"lineNum":"  703","line":"/* Similar to mkstemp, but the template can have a suffix after the"},
{"lineNum":"  704","line":"   XXXXXX.  The length of the suffix is specified in the second"},
{"lineNum":"  705","line":"   parameter."},
{"lineNum":"  706","line":""},
{"lineNum":"  707","line":"   This function is a possible cancellation point and therefore not"},
{"lineNum":"  708","line":"   marked with __THROW.  */"},
{"lineNum":"  709","line":"# ifndef __USE_FILE_OFFSET64"},
{"lineNum":"  710","line":"extern int mkstemps (char *__template, int __suffixlen) __nonnull ((1)) __wur;"},
{"lineNum":"  711","line":"# else"},
{"lineNum":"  712","line":"#  ifdef __REDIRECT"},
{"lineNum":"  713","line":"extern int __REDIRECT (mkstemps, (char *__template, int __suffixlen),"},
{"lineNum":"  714","line":"\t\t       mkstemps64) __nonnull ((1)) __wur;"},
{"lineNum":"  715","line":"#  else"},
{"lineNum":"  716","line":"#   define mkstemps mkstemps64"},
{"lineNum":"  717","line":"#  endif"},
{"lineNum":"  718","line":"# endif"},
{"lineNum":"  719","line":"# ifdef __USE_LARGEFILE64"},
{"lineNum":"  720","line":"extern int mkstemps64 (char *__template, int __suffixlen)"},
{"lineNum":"  721","line":"     __nonnull ((1)) __wur;"},
{"lineNum":"  722","line":"# endif"},
{"lineNum":"  723","line":"#endif"},
{"lineNum":"  724","line":""},
{"lineNum":"  725","line":"#ifdef __USE_XOPEN2K8"},
{"lineNum":"  726","line":"/* Create a unique temporary directory from TEMPLATE."},
{"lineNum":"  727","line":"   The last six characters of TEMPLATE must be \"XXXXXX\";"},
{"lineNum":"  728","line":"   they are replaced with a string that makes the directory name unique."},
{"lineNum":"  729","line":"   Returns TEMPLATE, or a null pointer if it cannot get a unique name."},
{"lineNum":"  730","line":"   The directory is created mode 700.  */"},
{"lineNum":"  731","line":"extern char *mkdtemp (char *__template) __THROW __nonnull ((1)) __wur;"},
{"lineNum":"  732","line":"#endif"},
{"lineNum":"  733","line":""},
{"lineNum":"  734","line":"#ifdef __USE_GNU"},
{"lineNum":"  735","line":"/* Generate a unique temporary file name from TEMPLATE similar to"},
{"lineNum":"  736","line":"   mkstemp.  But allow the caller to pass additional flags which are"},
{"lineNum":"  737","line":"   used in the open call to create the file.."},
{"lineNum":"  738","line":""},
{"lineNum":"  739","line":"   This function is a possible cancellation point and therefore not"},
{"lineNum":"  740","line":"   marked with __THROW.  */"},
{"lineNum":"  741","line":"# ifndef __USE_FILE_OFFSET64"},
{"lineNum":"  742","line":"extern int mkostemp (char *__template, int __flags) __nonnull ((1)) __wur;"},
{"lineNum":"  743","line":"# else"},
{"lineNum":"  744","line":"#  ifdef __REDIRECT"},
{"lineNum":"  745","line":"extern int __REDIRECT (mkostemp, (char *__template, int __flags), mkostemp64)"},
{"lineNum":"  746","line":"     __nonnull ((1)) __wur;"},
{"lineNum":"  747","line":"#  else"},
{"lineNum":"  748","line":"#   define mkostemp mkostemp64"},
{"lineNum":"  749","line":"#  endif"},
{"lineNum":"  750","line":"# endif"},
{"lineNum":"  751","line":"# ifdef __USE_LARGEFILE64"},
{"lineNum":"  752","line":"extern int mkostemp64 (char *__template, int __flags) __nonnull ((1)) __wur;"},
{"lineNum":"  753","line":"# endif"},
{"lineNum":"  754","line":""},
{"lineNum":"  755","line":"/* Similar to mkostemp, but the template can have a suffix after the"},
{"lineNum":"  756","line":"   XXXXXX.  The length of the suffix is specified in the second"},
{"lineNum":"  757","line":"   parameter."},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":"   This function is a possible cancellation point and therefore not"},
{"lineNum":"  760","line":"   marked with __THROW.  */"},
{"lineNum":"  761","line":"# ifndef __USE_FILE_OFFSET64"},
{"lineNum":"  762","line":"extern int mkostemps (char *__template, int __suffixlen, int __flags)"},
{"lineNum":"  763","line":"     __nonnull ((1)) __wur;"},
{"lineNum":"  764","line":"# else"},
{"lineNum":"  765","line":"#  ifdef __REDIRECT"},
{"lineNum":"  766","line":"extern int __REDIRECT (mkostemps, (char *__template, int __suffixlen,"},
{"lineNum":"  767","line":"\t\t\t\t   int __flags), mkostemps64)"},
{"lineNum":"  768","line":"     __nonnull ((1)) __wur;"},
{"lineNum":"  769","line":"#  else"},
{"lineNum":"  770","line":"#   define mkostemps mkostemps64"},
{"lineNum":"  771","line":"#  endif"},
{"lineNum":"  772","line":"# endif"},
{"lineNum":"  773","line":"# ifdef __USE_LARGEFILE64"},
{"lineNum":"  774","line":"extern int mkostemps64 (char *__template, int __suffixlen, int __flags)"},
{"lineNum":"  775","line":"     __nonnull ((1)) __wur;"},
{"lineNum":"  776","line":"# endif"},
{"lineNum":"  777","line":"#endif"},
{"lineNum":"  778","line":""},
{"lineNum":"  779","line":""},
{"lineNum":"  780","line":"/* Execute the given line as a shell command."},
{"lineNum":"  781","line":""},
{"lineNum":"  782","line":"   This function is a cancellation point and therefore not marked with"},
{"lineNum":"  783","line":"   __THROW.  */"},
{"lineNum":"  784","line":"extern int system (const char *__command) __wur;"},
{"lineNum":"  785","line":""},
{"lineNum":"  786","line":""},
{"lineNum":"  787","line":"#ifdef\t__USE_GNU"},
{"lineNum":"  788","line":"/* Return a malloc\'d string containing the canonical absolute name of the"},
{"lineNum":"  789","line":"   existing named file.  */"},
{"lineNum":"  790","line":"extern char *canonicalize_file_name (const char *__name)"},
{"lineNum":"  791","line":"     __THROW __nonnull ((1)) __wur;"},
{"lineNum":"  792","line":"#endif"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"#if defined __USE_MISC || defined __USE_XOPEN_EXTENDED"},
{"lineNum":"  795","line":"/* Return the canonical absolute name of file NAME.  If RESOLVED is"},
{"lineNum":"  796","line":"   null, the result is malloc\'d; otherwise, if the canonical name is"},
{"lineNum":"  797","line":"   PATH_MAX chars or more, returns null with `errno\' set to"},
{"lineNum":"  798","line":"   ENAMETOOLONG; if the name fits in fewer than PATH_MAX chars,"},
{"lineNum":"  799","line":"   returns the name in RESOLVED.  */"},
{"lineNum":"  800","line":"extern char *realpath (const char *__restrict __name,"},
{"lineNum":"  801","line":"\t\t       char *__restrict __resolved) __THROW __wur;"},
{"lineNum":"  802","line":"#endif"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":""},
{"lineNum":"  805","line":"/* Shorthand for type of comparison functions.  */"},
{"lineNum":"  806","line":"#ifndef __COMPAR_FN_T"},
{"lineNum":"  807","line":"# define __COMPAR_FN_T"},
{"lineNum":"  808","line":"typedef int (*__compar_fn_t) (const void *, const void *);"},
{"lineNum":"  809","line":""},
{"lineNum":"  810","line":"# ifdef\t__USE_GNU"},
{"lineNum":"  811","line":"typedef __compar_fn_t comparison_fn_t;"},
{"lineNum":"  812","line":"# endif"},
{"lineNum":"  813","line":"#endif"},
{"lineNum":"  814","line":"#ifdef __USE_GNU"},
{"lineNum":"  815","line":"typedef int (*__compar_d_fn_t) (const void *, const void *, void *);"},
{"lineNum":"  816","line":"#endif"},
{"lineNum":"  817","line":""},
{"lineNum":"  818","line":"/* Do a binary search for KEY in BASE, which consists of NMEMB elements"},
{"lineNum":"  819","line":"   of SIZE bytes each, using COMPAR to perform the comparisons.  */"},
{"lineNum":"  820","line":"extern void *bsearch (const void *__key, const void *__base,"},
{"lineNum":"  821","line":"\t\t      size_t __nmemb, size_t __size, __compar_fn_t __compar)"},
{"lineNum":"  822","line":"     __nonnull ((1, 2, 5)) __wur;"},
{"lineNum":"  823","line":""},
{"lineNum":"  824","line":"#ifdef __USE_EXTERN_INLINES"},
{"lineNum":"  825","line":"# include <bits/stdlib-bsearch.h>"},
{"lineNum":"  826","line":"#endif"},
{"lineNum":"  827","line":""},
{"lineNum":"  828","line":"/* Sort NMEMB elements of BASE, of SIZE bytes each,"},
{"lineNum":"  829","line":"   using COMPAR to perform the comparisons.  */"},
{"lineNum":"  830","line":"extern void qsort (void *__base, size_t __nmemb, size_t __size,"},
{"lineNum":"  831","line":"\t\t   __compar_fn_t __compar) __nonnull ((1, 4));"},
{"lineNum":"  832","line":"#ifdef __USE_GNU"},
{"lineNum":"  833","line":"extern void qsort_r (void *__base, size_t __nmemb, size_t __size,"},
{"lineNum":"  834","line":"\t\t     __compar_d_fn_t __compar, void *__arg)"},
{"lineNum":"  835","line":"  __nonnull ((1, 4));"},
{"lineNum":"  836","line":"#endif"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":""},
{"lineNum":"  839","line":"/* Return the absolute value of X.  */"},
{"lineNum":"  840","line":"extern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;"},
{"lineNum":"  841","line":"extern long int labs (long int __x) __THROW __attribute__ ((__const__)) __wur;"},
{"lineNum":"  842","line":""},
{"lineNum":"  843","line":"#ifdef __USE_ISOC99"},
{"lineNum":"  844","line":"__extension__ extern long long int llabs (long long int __x)"},
{"lineNum":"  845","line":"     __THROW __attribute__ ((__const__)) __wur;"},
{"lineNum":"  846","line":"#endif"},
{"lineNum":"  847","line":""},
{"lineNum":"  848","line":""},
{"lineNum":"  849","line":"/* Return the `div_t\', `ldiv_t\' or `lldiv_t\' representation"},
{"lineNum":"  850","line":"   of the value of NUMER over DENOM. */"},
{"lineNum":"  851","line":"/* GCC may have built-ins for these someday.  */"},
{"lineNum":"  852","line":"extern div_t div (int __numer, int __denom)"},
{"lineNum":"  853","line":"     __THROW __attribute__ ((__const__)) __wur;"},
{"lineNum":"  854","line":"extern ldiv_t ldiv (long int __numer, long int __denom)"},
{"lineNum":"  855","line":"     __THROW __attribute__ ((__const__)) __wur;"},
{"lineNum":"  856","line":""},
{"lineNum":"  857","line":"#ifdef __USE_ISOC99"},
{"lineNum":"  858","line":"__extension__ extern lldiv_t lldiv (long long int __numer,"},
{"lineNum":"  859","line":"\t\t\t\t    long long int __denom)"},
{"lineNum":"  860","line":"     __THROW __attribute__ ((__const__)) __wur;"},
{"lineNum":"  861","line":"#endif"},
{"lineNum":"  862","line":""},
{"lineNum":"  863","line":""},
{"lineNum":"  864","line":"#if (defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K8) \\"},
{"lineNum":"  865","line":"    || defined __USE_MISC"},
{"lineNum":"  866","line":"/* Convert floating point numbers to strings.  The returned values are"},
{"lineNum":"  867","line":"   valid only until another call to the same function.  */"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"/* Convert VALUE to a string with NDIGIT digits and return a pointer to"},
{"lineNum":"  870","line":"   this.  Set *DECPT with the position of the decimal character and *SIGN"},
{"lineNum":"  871","line":"   with the sign of the number.  */"},
{"lineNum":"  872","line":"extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,"},
{"lineNum":"  873","line":"\t\t   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;"},
{"lineNum":"  874","line":""},
{"lineNum":"  875","line":"/* Convert VALUE to a string rounded to NDIGIT decimal digits.  Set *DECPT"},
{"lineNum":"  876","line":"   with the position of the decimal character and *SIGN with the sign of"},
{"lineNum":"  877","line":"   the number.  */"},
{"lineNum":"  878","line":"extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,"},
{"lineNum":"  879","line":"\t\t   int *__restrict __sign) __THROW __nonnull ((3, 4)) __wur;"},
{"lineNum":"  880","line":""},
{"lineNum":"  881","line":"/* If possible convert VALUE to a string with NDIGIT significant digits."},
{"lineNum":"  882","line":"   Otherwise use exponential representation.  The resulting string will"},
{"lineNum":"  883","line":"   be written to BUF.  */"},
{"lineNum":"  884","line":"extern char *gcvt (double __value, int __ndigit, char *__buf)"},
{"lineNum":"  885","line":"     __THROW __nonnull ((3)) __wur;"},
{"lineNum":"  886","line":"#endif"},
{"lineNum":"  887","line":""},
{"lineNum":"  888","line":"#ifdef __USE_MISC"},
{"lineNum":"  889","line":"/* Long double versions of above functions.  */"},
{"lineNum":"  890","line":"extern char *qecvt (long double __value, int __ndigit,"},
{"lineNum":"  891","line":"\t\t    int *__restrict __decpt, int *__restrict __sign)"},
{"lineNum":"  892","line":"     __THROW __nonnull ((3, 4)) __wur;"},
{"lineNum":"  893","line":"extern char *qfcvt (long double __value, int __ndigit,"},
{"lineNum":"  894","line":"\t\t    int *__restrict __decpt, int *__restrict __sign)"},
{"lineNum":"  895","line":"     __THROW __nonnull ((3, 4)) __wur;"},
{"lineNum":"  896","line":"extern char *qgcvt (long double __value, int __ndigit, char *__buf)"},
{"lineNum":"  897","line":"     __THROW __nonnull ((3)) __wur;"},
{"lineNum":"  898","line":""},
{"lineNum":"  899","line":""},
{"lineNum":"  900","line":"/* Reentrant version of the functions above which provide their own"},
{"lineNum":"  901","line":"   buffers.  */"},
{"lineNum":"  902","line":"extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,"},
{"lineNum":"  903","line":"\t\t   int *__restrict __sign, char *__restrict __buf,"},
{"lineNum":"  904","line":"\t\t   size_t __len) __THROW __nonnull ((3, 4, 5));"},
{"lineNum":"  905","line":"extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,"},
{"lineNum":"  906","line":"\t\t   int *__restrict __sign, char *__restrict __buf,"},
{"lineNum":"  907","line":"\t\t   size_t __len) __THROW __nonnull ((3, 4, 5));"},
{"lineNum":"  908","line":""},
{"lineNum":"  909","line":"extern int qecvt_r (long double __value, int __ndigit,"},
{"lineNum":"  910","line":"\t\t    int *__restrict __decpt, int *__restrict __sign,"},
{"lineNum":"  911","line":"\t\t    char *__restrict __buf, size_t __len)"},
{"lineNum":"  912","line":"     __THROW __nonnull ((3, 4, 5));"},
{"lineNum":"  913","line":"extern int qfcvt_r (long double __value, int __ndigit,"},
{"lineNum":"  914","line":"\t\t    int *__restrict __decpt, int *__restrict __sign,"},
{"lineNum":"  915","line":"\t\t    char *__restrict __buf, size_t __len)"},
{"lineNum":"  916","line":"     __THROW __nonnull ((3, 4, 5));"},
{"lineNum":"  917","line":"#endif\t/* misc */"},
{"lineNum":"  918","line":""},
{"lineNum":"  919","line":""},
{"lineNum":"  920","line":"/* Return the length of the multibyte character"},
{"lineNum":"  921","line":"   in S, which is no longer than N.  */"},
{"lineNum":"  922","line":"extern int mblen (const char *__s, size_t __n) __THROW;"},
{"lineNum":"  923","line":"/* Return the length of the given multibyte character,"},
{"lineNum":"  924","line":"   putting its `wchar_t\' representation in *PWC.  */"},
{"lineNum":"  925","line":"extern int mbtowc (wchar_t *__restrict __pwc,"},
{"lineNum":"  926","line":"\t\t   const char *__restrict __s, size_t __n) __THROW;"},
{"lineNum":"  927","line":"/* Put the multibyte character represented"},
{"lineNum":"  928","line":"   by WCHAR in S, returning its length.  */"},
{"lineNum":"  929","line":"extern int wctomb (char *__s, wchar_t __wchar) __THROW;"},
{"lineNum":"  930","line":""},
{"lineNum":"  931","line":""},
{"lineNum":"  932","line":"/* Convert a multibyte string to a wide char string.  */"},
{"lineNum":"  933","line":"extern size_t mbstowcs (wchar_t *__restrict  __pwcs,"},
{"lineNum":"  934","line":"\t\t\tconst char *__restrict __s, size_t __n) __THROW;"},
{"lineNum":"  935","line":"/* Convert a wide char string to multibyte string.  */"},
{"lineNum":"  936","line":"extern size_t wcstombs (char *__restrict __s,"},
{"lineNum":"  937","line":"\t\t\tconst wchar_t *__restrict __pwcs, size_t __n)"},
{"lineNum":"  938","line":"     __THROW;"},
{"lineNum":"  939","line":""},
{"lineNum":"  940","line":""},
{"lineNum":"  941","line":"#ifdef __USE_MISC"},
{"lineNum":"  942","line":"/* Determine whether the string value of RESPONSE matches the affirmation"},
{"lineNum":"  943","line":"   or negative response expression as specified by the LC_MESSAGES category"},
{"lineNum":"  944","line":"   in the program\'s current locale.  Returns 1 if affirmative, 0 if"},
{"lineNum":"  945","line":"   negative, and -1 if not matching.  */"},
{"lineNum":"  946","line":"extern int rpmatch (const char *__response) __THROW __nonnull ((1)) __wur;"},
{"lineNum":"  947","line":"#endif"},
{"lineNum":"  948","line":""},
{"lineNum":"  949","line":""},
{"lineNum":"  950","line":"#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8"},
{"lineNum":"  951","line":"/* Parse comma separated suboption from *OPTIONP and match against"},
{"lineNum":"  952","line":"   strings in TOKENS.  If found return index and set *VALUEP to"},
{"lineNum":"  953","line":"   optional value introduced by an equal sign.  If the suboption is"},
{"lineNum":"  954","line":"   not part of TOKENS return in *VALUEP beginning of unknown"},
{"lineNum":"  955","line":"   suboption.  On exit *OPTIONP is set to the beginning of the next"},
{"lineNum":"  956","line":"   token or at the terminating NUL character.  */"},
{"lineNum":"  957","line":"extern int getsubopt (char **__restrict __optionp,"},
{"lineNum":"  958","line":"\t\t      char *const *__restrict __tokens,"},
{"lineNum":"  959","line":"\t\t      char **__restrict __valuep)"},
{"lineNum":"  960","line":"     __THROW __nonnull ((1, 2, 3)) __wur;"},
{"lineNum":"  961","line":"#endif"},
{"lineNum":"  962","line":""},
{"lineNum":"  963","line":""},
{"lineNum":"  964","line":"/* X/Open pseudo terminal handling.  */"},
{"lineNum":"  965","line":""},
{"lineNum":"  966","line":"#ifdef __USE_XOPEN2KXSI"},
{"lineNum":"  967","line":"/* Return a master pseudo-terminal handle.  */"},
{"lineNum":"  968","line":"extern int posix_openpt (int __oflag) __wur;"},
{"lineNum":"  969","line":"#endif"},
{"lineNum":"  970","line":""},
{"lineNum":"  971","line":"#ifdef __USE_XOPEN_EXTENDED"},
{"lineNum":"  972","line":"/* The next four functions all take a master pseudo-tty fd and"},
{"lineNum":"  973","line":"   perform an operation on the associated slave:  */"},
{"lineNum":"  974","line":""},
{"lineNum":"  975","line":"/* Chown the slave to the calling user.  */"},
{"lineNum":"  976","line":"extern int grantpt (int __fd) __THROW;"},
{"lineNum":"  977","line":""},
{"lineNum":"  978","line":"/* Release an internal lock so the slave can be opened."},
{"lineNum":"  979","line":"   Call after grantpt().  */"},
{"lineNum":"  980","line":"extern int unlockpt (int __fd) __THROW;"},
{"lineNum":"  981","line":""},
{"lineNum":"  982","line":"/* Return the pathname of the pseudo terminal slave associated with"},
{"lineNum":"  983","line":"   the master FD is open on, or NULL on errors."},
{"lineNum":"  984","line":"   The returned storage is good until the next call to this function.  */"},
{"lineNum":"  985","line":"extern char *ptsname (int __fd) __THROW __wur;"},
{"lineNum":"  986","line":"#endif"},
{"lineNum":"  987","line":""},
{"lineNum":"  988","line":"#ifdef __USE_GNU"},
{"lineNum":"  989","line":"/* Store at most BUFLEN characters of the pathname of the slave pseudo"},
{"lineNum":"  990","line":"   terminal associated with the master FD is open on in BUF."},
{"lineNum":"  991","line":"   Return 0 on success, otherwise an error number.  */"},
{"lineNum":"  992","line":"extern int ptsname_r (int __fd, char *__buf, size_t __buflen)"},
{"lineNum":"  993","line":"     __THROW __nonnull ((2));"},
{"lineNum":"  994","line":""},
{"lineNum":"  995","line":"/* Open a master pseudo terminal and return its file descriptor.  */"},
{"lineNum":"  996","line":"extern int getpt (void);"},
{"lineNum":"  997","line":"#endif"},
{"lineNum":"  998","line":""},
{"lineNum":"  999","line":"#ifdef __USE_MISC"},
{"lineNum":" 1000","line":"/* Put the 1 minute, 5 minute and 15 minute load averages into the first"},
{"lineNum":" 1001","line":"   NELEM elements of LOADAVG.  Return the number written (never more than"},
{"lineNum":" 1002","line":"   three, but may be less than NELEM), or -1 if an error occurred.  */"},
{"lineNum":" 1003","line":"extern int getloadavg (double __loadavg[], int __nelem)"},
{"lineNum":" 1004","line":"     __THROW __nonnull ((1));"},
{"lineNum":" 1005","line":"#endif"},
{"lineNum":" 1006","line":""},
{"lineNum":" 1007","line":"#if defined __USE_XOPEN_EXTENDED && !defined __USE_XOPEN2K"},
{"lineNum":" 1008","line":"/* Return the index into the active-logins file (utmp) for"},
{"lineNum":" 1009","line":"   the controlling terminal.  */"},
{"lineNum":" 1010","line":"extern int ttyslot (void) __THROW;"},
{"lineNum":" 1011","line":"#endif"},
{"lineNum":" 1012","line":""},
{"lineNum":" 1013","line":"#include <bits/stdlib-float.h>"},
{"lineNum":" 1014","line":""},
{"lineNum":" 1015","line":"/* Define some macros helping to catch buffer overflows.  */"},
{"lineNum":" 1016","line":"#if __USE_FORTIFY_LEVEL > 0 && defined __fortify_function"},
{"lineNum":" 1017","line":"# include <bits/stdlib.h>"},
{"lineNum":" 1018","line":"#endif"},
{"lineNum":" 1019","line":"#ifdef __LDBL_COMPAT"},
{"lineNum":" 1020","line":"# include <bits/stdlib-ldbl.h>"},
{"lineNum":" 1021","line":"#endif"},
{"lineNum":" 1022","line":""},
{"lineNum":" 1023","line":"__END_DECLS"},
{"lineNum":" 1024","line":""},
{"lineNum":" 1025","line":"#endif /* stdlib.h  */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-14 19:20:37", "instrumented" : 1, "covered" : 1,};
var merged_data = [];
