var data = {lines:[
{"lineNum":"    1","line":""},
{"lineNum":"    2","line":"#include <cassert>"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"#pragma message \"HDF5 version checking in Hdf5_reader (changes of H5O interfaces in Hdf5 1.12)\""},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"#include \"synergia/utils/hdf5_misc.h\""},
{"lineNum":"    7","line":"#include \"synergia/utils/commxx.h\""},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"namespace"},
{"lineNum":"   10","line":"{"},
{"lineNum":"   11","line":"    bool same_nth_dim(std::vector<hsize_t> const& dims,"},
{"lineNum":"   12","line":"            size_t dim, size_t ndim, size_t mpi_size)"},
{"lineNum":"   13","line":"    {"},
{"lineNum":"   14","line":"        assert(mpi_size > 0);"},
{"lineNum":"   15","line":"        assert(dims.size() == ndim * mpi_size);"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"        auto val = dims[dim];"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"        for (int r=0; r<mpi_size; ++r)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   20","line":"            if (dims[r*ndim + dim] != val) return false;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"        return true;"},
{"lineNum":"   23","line":"    }"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"    bool same_data_ranks(std::vector<size_t> const& ranks)"},
{"lineNum":"   26","line":"    {"},
{"lineNum":"   27","line":"        auto it = std::adjacent_find(ranks.begin(), ranks.end(),"},
{"lineNum":"   28","line":"                std::not_equal_to<>());"},
{"lineNum":"   29","line":"        return it == ranks.end();"},
{"lineNum":"   30","line":"    }"},
{"lineNum":"   31","line":"}"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"std::vector<hsize_t>"},
{"lineNum":"   34","line":"syn::collect_dims("},
{"lineNum":"   35","line":"        std::vector<hsize_t> const& dims,"},
{"lineNum":"   36","line":"        bool collective,"},
{"lineNum":"   37","line":"        Commxx const& comm,"},
{"lineNum":"   38","line":"        int root_rank )"},
{"lineNum":"   39","line":"{","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   40","line":"    const int mpi_size = comm.size();"},
{"lineNum":"   41","line":"    const int mpi_rank = comm.rank();"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"    // parameter check"},
{"lineNum":"   44","line":"    if (collective && !dims.size())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   45","line":"    {"},
{"lineNum":"   46","line":"        throw std::runtime_error(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   47","line":"                \"Hdf5_writer: collective read/write on a scalar, \""},
{"lineNum":"   48","line":"                \"should have been promoted to 1d array\" );"},
{"lineNum":"   49","line":"    }"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"    // create a local copy of the dims, always do a promotion"},
{"lineNum":"   52","line":"    // on scalar so we don\'t have to branch the code"},
{"lineNum":"   53","line":"    const auto local_dims = dims.size() ? dims : std::vector<hsize_t>{1};","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   54","line":"    const auto data_rank = local_dims.size();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"    // collect all data_ranks"},
{"lineNum":"   57","line":"    std::vector<size_t> all_ranks(mpi_size);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   58","line":"    MPI_Allgather(&data_rank, 1, MPI_UINT64_T,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   59","line":"            all_ranks.data(), 1, MPI_UINT64_T, comm);"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"    // data rank check -- all data_ranks should be the same"},
{"lineNum":"   62","line":"    if (!same_data_ranks(all_ranks))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   63","line":"    {"},
{"lineNum":"   64","line":"        throw std::runtime_error(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   65","line":"                \"Hdf5_writer: inconsistent data ranks\");"},
{"lineNum":"   66","line":"    }"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"    std::vector<hsize_t> all_dims(mpi_size*data_rank);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   69","line":"    std::vector<hsize_t> all_dim0(mpi_size, 0);"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"    // dimension check on non-scalars"},
{"lineNum":"   72","line":"    MPI_Allgather(local_dims.data(), data_rank, MPI_UINT64_T,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   73","line":"            all_dims.data(), data_rank, MPI_UINT64_T, comm);"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"    // for collective write: higher (>0) order dimensions must be the"},
{"lineNum":"   76","line":"    //   same across all ranks"},
{"lineNum":"   77","line":"    // for single write: all dimensions must be the same"},
{"lineNum":"   78","line":"    size_t d0 = collective ? 1 : 0;"},
{"lineNum":"   79","line":"    for (int d=d0; d<data_rank; ++d)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   80","line":"    {"},
{"lineNum":"   81","line":"        if (!same_nth_dim(all_dims, d, data_rank, mpi_size))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   82","line":"            throw std::runtime_error(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   83","line":"                    \"Hdf5_writer: inconsistent data dimensions\");"},
{"lineNum":"   84","line":"    }"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"    if (collective)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   87","line":"    {"},
{"lineNum":"   88","line":"        // everyone has its own share"},
{"lineNum":"   89","line":"        for(int r=0; r<mpi_size; ++r) all_dim0[r] = all_dims[r*data_rank];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   90","line":"    }"},
{"lineNum":"   91","line":"    else"},
{"lineNum":"   92","line":"    {"},
{"lineNum":"   93","line":"        // only the root rank gets a non-zero share"},
{"lineNum":"   94","line":"        all_dim0[root_rank] = local_dims[0];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   95","line":"    }"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"    return all_dim0;"},
{"lineNum":"   98","line":"}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":""},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 20, "covered" : 0,};
var merged_data = [];
