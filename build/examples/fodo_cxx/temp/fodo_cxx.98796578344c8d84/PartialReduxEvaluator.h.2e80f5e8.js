var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2011-2018 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_PARTIALREDUX_H"},
{"lineNum":"   11","line":"#define EIGEN_PARTIALREDUX_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"/***************************************************************************"},
{"lineNum":"   21","line":"*"},
{"lineNum":"   22","line":"* This file provides evaluators for partial reductions."},
{"lineNum":"   23","line":"* There are two modes:"},
{"lineNum":"   24","line":"*"},
{"lineNum":"   25","line":"*  - scalar path: simply calls the respective function on the column or row."},
{"lineNum":"   26","line":"*    -> nothing special here, all the tricky part is handled by the return"},
{"lineNum":"   27","line":"*       types of VectorwiseOp\'s members. They embed the functor calling the"},
{"lineNum":"   28","line":"*       respective DenseBase\'s member function."},
{"lineNum":"   29","line":"*"},
{"lineNum":"   30","line":"*  - vectorized path: implements a packet-wise reductions followed by"},
{"lineNum":"   31","line":"*    some (optional) processing of the outcome, e.g., division by n for mean."},
{"lineNum":"   32","line":"*"},
{"lineNum":"   33","line":"* For the vectorized path let\'s observe that the packet-size and outer-unrolling"},
{"lineNum":"   34","line":"* are both decided by the assignment logic. So all we have to do is to decide"},
{"lineNum":"   35","line":"* on the inner unrolling."},
{"lineNum":"   36","line":"*"},
{"lineNum":"   37","line":"* For the unrolling, we can reuse \"internal::redux_vec_unroller\" from Redux.h,"},
{"lineNum":"   38","line":"* but be need to be careful to specify correct increment."},
{"lineNum":"   39","line":"*"},
{"lineNum":"   40","line":"***************************************************************************/"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"/* logic deciding a strategy for unrolling of vectorized paths */"},
{"lineNum":"   44","line":"template<typename Func, typename Evaluator>"},
{"lineNum":"   45","line":"struct packetwise_redux_traits"},
{"lineNum":"   46","line":"{"},
{"lineNum":"   47","line":"  enum {"},
{"lineNum":"   48","line":"    OuterSize = int(Evaluator::IsRowMajor) ? Evaluator::RowsAtCompileTime : Evaluator::ColsAtCompileTime,"},
{"lineNum":"   49","line":"    Cost = OuterSize == Dynamic ? HugeCost"},
{"lineNum":"   50","line":"         : OuterSize * Evaluator::CoeffReadCost + (OuterSize-1) * functor_traits<Func>::Cost,"},
{"lineNum":"   51","line":"    Unrolling = Cost <= EIGEN_UNROLLING_LIMIT ? CompleteUnrolling : NoUnrolling"},
{"lineNum":"   52","line":"  };"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"/* Value to be returned when size==0 , by default let\'s return 0 */"},
{"lineNum":"   57","line":"template<typename PacketType,typename Func>"},
{"lineNum":"   58","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"   59","line":"PacketType packetwise_redux_empty_value(const Func& ) { return pset1<PacketType>(0); }"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"/* For products the default is 1 */"},
{"lineNum":"   62","line":"template<typename PacketType,typename Scalar>"},
{"lineNum":"   63","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"   64","line":"PacketType packetwise_redux_empty_value(const scalar_product_op<Scalar,Scalar>& ) { return pset1<PacketType>(1); }"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"/* Perform the actual reduction */"},
{"lineNum":"   67","line":"template<typename Func, typename Evaluator,"},
{"lineNum":"   68","line":"         int Unrolling = packetwise_redux_traits<Func, Evaluator>::Unrolling"},
{"lineNum":"   69","line":">"},
{"lineNum":"   70","line":"struct packetwise_redux_impl;"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"/* Perform the actual reduction with unrolling */"},
{"lineNum":"   73","line":"template<typename Func, typename Evaluator>"},
{"lineNum":"   74","line":"struct packetwise_redux_impl<Func, Evaluator, CompleteUnrolling>"},
{"lineNum":"   75","line":"{"},
{"lineNum":"   76","line":"  typedef redux_novec_unroller<Func,Evaluator, 0, Evaluator::SizeAtCompileTime> Base;"},
{"lineNum":"   77","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"  template<typename PacketType>"},
{"lineNum":"   80","line":"  EIGEN_DEVICE_FUNC static EIGEN_STRONG_INLINE"},
{"lineNum":"   81","line":"  PacketType run(const Evaluator &eval, const Func& func, Index /*size*/)"},
{"lineNum":"   82","line":"  {"},
{"lineNum":"   83","line":"    return redux_vec_unroller<Func, Evaluator, 0, packetwise_redux_traits<Func, Evaluator>::OuterSize>::template run<PacketType>(eval,func);"},
{"lineNum":"   84","line":"  }"},
{"lineNum":"   85","line":"};"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"/* Add a specialization of redux_vec_unroller for size==0 at compiletime."},
{"lineNum":"   88","line":" * This specialization is not required for general reductions, which is"},
{"lineNum":"   89","line":" * why it is defined here."},
{"lineNum":"   90","line":" */"},
{"lineNum":"   91","line":"template<typename Func, typename Evaluator, int Start>"},
{"lineNum":"   92","line":"struct redux_vec_unroller<Func, Evaluator, Start, 0>"},
{"lineNum":"   93","line":"{"},
{"lineNum":"   94","line":"  template<typename PacketType>"},
{"lineNum":"   95","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   96","line":"  static EIGEN_STRONG_INLINE PacketType run(const Evaluator &, const Func& f)"},
{"lineNum":"   97","line":"  {"},
{"lineNum":"   98","line":"    return packetwise_redux_empty_value<PacketType>(f);"},
{"lineNum":"   99","line":"  }"},
{"lineNum":"  100","line":"};"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"/* Perform the actual reduction for dynamic sizes */"},
{"lineNum":"  103","line":"template<typename Func, typename Evaluator>"},
{"lineNum":"  104","line":"struct packetwise_redux_impl<Func, Evaluator, NoUnrolling>"},
{"lineNum":"  105","line":"{"},
{"lineNum":"  106","line":"  typedef typename Evaluator::Scalar Scalar;"},
{"lineNum":"  107","line":"  typedef typename redux_traits<Func, Evaluator>::PacketType PacketScalar;"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"  template<typename PacketType>"},
{"lineNum":"  110","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  111","line":"  static PacketType run(const Evaluator &eval, const Func& func, Index size)"},
{"lineNum":"  112","line":"  {"},
{"lineNum":"  113","line":"    if(size==0)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  114","line":"      return packetwise_redux_empty_value<PacketType>(func);"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"    const Index size4 = (size-1)&(~3);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  117","line":"    PacketType p = eval.template packetByOuterInner<Unaligned,PacketType>(0,0);"},
{"lineNum":"  118","line":"    Index i = 1;"},
{"lineNum":"  119","line":"    // This loop is optimized for instruction pipelining:"},
{"lineNum":"  120","line":"    // - each iteration generates two independent instructions"},
{"lineNum":"  121","line":"    // - thanks to branch prediction and out-of-order execution we have independent instructions across loops"},
{"lineNum":"  122","line":"    for(; i<size4; i+=4)","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  123","line":"      p = func.packetOp(p,"},
{"lineNum":"  124","line":"            func.packetOp("},
{"lineNum":"  125","line":"              func.packetOp(eval.template packetByOuterInner<Unaligned,PacketType>(i+0,0),eval.template packetByOuterInner<Unaligned,PacketType>(i+1,0)),"},
{"lineNum":"  126","line":"              func.packetOp(eval.template packetByOuterInner<Unaligned,PacketType>(i+2,0),eval.template packetByOuterInner<Unaligned,PacketType>(i+3,0))));"},
{"lineNum":"  127","line":"    for(; i<size; ++i)","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  128","line":"      p = func.packetOp(p, eval.template packetByOuterInner<Unaligned,PacketType>(i,0));"},
{"lineNum":"  129","line":"    return p;"},
{"lineNum":"  130","line":"  }"},
{"lineNum":"  131","line":"};"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"template< typename ArgType, typename MemberOp, int Direction>"},
{"lineNum":"  134","line":"struct evaluator<PartialReduxExpr<ArgType, MemberOp, Direction> >"},
{"lineNum":"  135","line":"  : evaluator_base<PartialReduxExpr<ArgType, MemberOp, Direction> >"},
{"lineNum":"  136","line":"{"},
{"lineNum":"  137","line":"  typedef PartialReduxExpr<ArgType, MemberOp, Direction> XprType;"},
{"lineNum":"  138","line":"  typedef typename internal::nested_eval<ArgType,1>::type ArgTypeNested;"},
{"lineNum":"  139","line":"  typedef typename internal::add_const_on_value_type<ArgTypeNested>::type ConstArgTypeNested;"},
{"lineNum":"  140","line":"  typedef typename internal::remove_all<ArgTypeNested>::type ArgTypeNestedCleaned;"},
{"lineNum":"  141","line":"  typedef typename ArgType::Scalar InputScalar;"},
{"lineNum":"  142","line":"  typedef typename XprType::Scalar Scalar;"},
{"lineNum":"  143","line":"  enum {"},
{"lineNum":"  144","line":"    TraversalSize = Direction==int(Vertical) ? int(ArgType::RowsAtCompileTime) :  int(ArgType::ColsAtCompileTime)"},
{"lineNum":"  145","line":"  };"},
{"lineNum":"  146","line":"  typedef typename MemberOp::template Cost<int(TraversalSize)> CostOpType;"},
{"lineNum":"  147","line":"  enum {"},
{"lineNum":"  148","line":"    CoeffReadCost = TraversalSize==Dynamic ? HugeCost"},
{"lineNum":"  149","line":"                  : TraversalSize==0 ? 1"},
{"lineNum":"  150","line":"                  : int(TraversalSize) * int(evaluator<ArgType>::CoeffReadCost) + int(CostOpType::value),"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"    _ArgFlags = evaluator<ArgType>::Flags,"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"    _Vectorizable =  bool(int(_ArgFlags)&PacketAccessBit)"},
{"lineNum":"  155","line":"                  && bool(MemberOp::Vectorizable)"},
{"lineNum":"  156","line":"                  && (Direction==int(Vertical) ? bool(_ArgFlags&RowMajorBit) : (_ArgFlags&RowMajorBit)==0)"},
{"lineNum":"  157","line":"                  && (TraversalSize!=0),"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    Flags = (traits<XprType>::Flags&RowMajorBit)"},
{"lineNum":"  160","line":"          | (evaluator<ArgType>::Flags&(HereditaryBits&(~RowMajorBit)))"},
{"lineNum":"  161","line":"          | (_Vectorizable ? PacketAccessBit : 0)"},
{"lineNum":"  162","line":"          | LinearAccessBit,"},
{"lineNum":"  163","line":""},
{"lineNum":"  164","line":"    Alignment = 0 // FIXME this will need to be improved once PartialReduxExpr is vectorized"},
{"lineNum":"  165","line":"  };"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"  EIGEN_DEVICE_FUNC explicit evaluator(const XprType xpr)"},
{"lineNum":"  168","line":"    : m_arg(xpr.nestedExpression()), m_functor(xpr.functor())"},
{"lineNum":"  169","line":"  {"},
{"lineNum":"  170","line":"    EIGEN_INTERNAL_CHECK_COST_VALUE(TraversalSize==Dynamic ? HugeCost : (TraversalSize==0 ? 1 : int(CostOpType::value)));"},
{"lineNum":"  171","line":"    EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);"},
{"lineNum":"  172","line":"  }"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"  typedef typename XprType::CoeffReturnType CoeffReturnType;"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  177","line":"  const Scalar coeff(Index i, Index j) const"},
{"lineNum":"  178","line":"  {"},
{"lineNum":"  179","line":"    return coeff(Direction==Vertical ? j : i);"},
{"lineNum":"  180","line":"  }"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  183","line":"  const Scalar coeff(Index index) const"},
{"lineNum":"  184","line":"  {"},
{"lineNum":"  185","line":"    return m_functor(m_arg.template subVector<DirectionType(Direction)>(index));"},
{"lineNum":"  186","line":"  }"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"  template<int LoadMode,typename PacketType>"},
{"lineNum":"  189","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  190","line":"  PacketType packet(Index i, Index j) const"},
{"lineNum":"  191","line":"  {"},
{"lineNum":"  192","line":"    return packet<LoadMode,PacketType>(Direction==Vertical ? j : i);"},
{"lineNum":"  193","line":"  }"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"  template<int LoadMode,typename PacketType>"},
{"lineNum":"  196","line":"  EIGEN_STRONG_INLINE EIGEN_DEVICE_FUNC"},
{"lineNum":"  197","line":"  PacketType packet(Index idx) const"},
{"lineNum":"  198","line":"  {"},
{"lineNum":"  199","line":"    enum { PacketSize = internal::unpacket_traits<PacketType>::size };"},
{"lineNum":"  200","line":"    typedef Block<const ArgTypeNestedCleaned,"},
{"lineNum":"  201","line":"                  Direction==Vertical ? int(ArgType::RowsAtCompileTime) : int(PacketSize),"},
{"lineNum":"  202","line":"                  Direction==Vertical ? int(PacketSize) : int(ArgType::ColsAtCompileTime),"},
{"lineNum":"  203","line":"                  true /* InnerPanel */> PanelType;"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"    PanelType panel(m_arg,"},
{"lineNum":"  206","line":"                    Direction==Vertical ? 0 : idx,"},
{"lineNum":"  207","line":"                    Direction==Vertical ? idx : 0,"},
{"lineNum":"  208","line":"                    Direction==Vertical ? m_arg.rows() : Index(PacketSize),"},
{"lineNum":"  209","line":"                    Direction==Vertical ? Index(PacketSize) : m_arg.cols());"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"    // FIXME"},
{"lineNum":"  212","line":"    // See bug 1612, currently if PacketSize==1 (i.e. complex<double> with 128bits registers) then the storage-order of panel get reversed"},
{"lineNum":"  213","line":"    // and methods like packetByOuterInner do not make sense anymore in this context."},
{"lineNum":"  214","line":"    // So let\'s just by pass \"vectorization\" in this case:"},
{"lineNum":"  215","line":"    if(PacketSize==1)"},
{"lineNum":"  216","line":"      return internal::pset1<PacketType>(coeff(idx));"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"    typedef typename internal::redux_evaluator<PanelType> PanelEvaluator;"},
{"lineNum":"  219","line":"    PanelEvaluator panel_eval(panel);"},
{"lineNum":"  220","line":"    typedef typename MemberOp::BinaryOp BinaryOp;"},
{"lineNum":"  221","line":"    PacketType p = internal::packetwise_redux_impl<BinaryOp,PanelEvaluator>::template run<PacketType>(panel_eval,m_functor.binaryFunc(),m_arg.outerSize());"},
{"lineNum":"  222","line":"    return p;"},
{"lineNum":"  223","line":"  }"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"protected:"},
{"lineNum":"  226","line":"  ConstArgTypeNested m_arg;"},
{"lineNum":"  227","line":"  const MemberOp m_functor;"},
{"lineNum":"  228","line":"};"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"} // end namespace internal"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"} // end namespace Eigen"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"#endif // EIGEN_PARTIALREDUX_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
