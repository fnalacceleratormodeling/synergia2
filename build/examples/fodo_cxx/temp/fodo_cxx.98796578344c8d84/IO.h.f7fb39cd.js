var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2008 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_IO_H"},
{"lineNum":"   12","line":"#define EIGEN_IO_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"enum { DontAlignCols = 1 };"},
{"lineNum":"   19","line":"enum { StreamPrecision = -1,"},
{"lineNum":"   20","line":"       FullPrecision = -2 };"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"namespace internal {"},
{"lineNum":"   23","line":"template<typename Derived>"},
{"lineNum":"   24","line":"std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt);"},
{"lineNum":"   25","line":"}"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"/** \\class IOFormat"},
{"lineNum":"   28","line":"  * \\ingroup Core_Module"},
{"lineNum":"   29","line":"  *"},
{"lineNum":"   30","line":"  * \\brief Stores a set of parameters controlling the way matrices are printed"},
{"lineNum":"   31","line":"  *"},
{"lineNum":"   32","line":"  * List of available parameters:"},
{"lineNum":"   33","line":"  *  - \\b precision number of digits for floating point values, or one of the special constants \\c StreamPrecision and \\c FullPrecision."},
{"lineNum":"   34","line":"  *                 The default is the special value \\c StreamPrecision which means to use the"},
{"lineNum":"   35","line":"  *                 stream\'s own precision setting, as set for instance using \\c cout.precision(3). The other special value"},
{"lineNum":"   36","line":"  *                 \\c FullPrecision means that the number of digits will be computed to match the full precision of each floating-point"},
{"lineNum":"   37","line":"  *                 type."},
{"lineNum":"   38","line":"  *  - \\b flags an OR-ed combination of flags, the default value is 0, the only currently available flag is \\c DontAlignCols which"},
{"lineNum":"   39","line":"  *             allows to disable the alignment of columns, resulting in faster code."},
{"lineNum":"   40","line":"  *  - \\b coeffSeparator string printed between two coefficients of the same row"},
{"lineNum":"   41","line":"  *  - \\b rowSeparator string printed between two rows"},
{"lineNum":"   42","line":"  *  - \\b rowPrefix string printed at the beginning of each row"},
{"lineNum":"   43","line":"  *  - \\b rowSuffix string printed at the end of each row"},
{"lineNum":"   44","line":"  *  - \\b matPrefix string printed at the beginning of the matrix"},
{"lineNum":"   45","line":"  *  - \\b matSuffix string printed at the end of the matrix"},
{"lineNum":"   46","line":"  *  - \\b fill character printed to fill the empty space in aligned columns"},
{"lineNum":"   47","line":"  *"},
{"lineNum":"   48","line":"  * Example: \\include IOFormat.cpp"},
{"lineNum":"   49","line":"  * Output: \\verbinclude IOFormat.out"},
{"lineNum":"   50","line":"  *"},
{"lineNum":"   51","line":"  * \\sa DenseBase::format(), class WithFormat"},
{"lineNum":"   52","line":"  */"},
{"lineNum":"   53","line":"struct IOFormat","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   54","line":"{"},
{"lineNum":"   55","line":"  /** Default constructor, see class IOFormat for the meaning of the parameters */"},
{"lineNum":"   56","line":"  IOFormat(int _precision = StreamPrecision, int _flags = 0,"},
{"lineNum":"   57","line":"    const std::string& _coeffSeparator = \" \","},
{"lineNum":"   58","line":"    const std::string& _rowSeparator = \"\\n\", const std::string& _rowPrefix=\"\", const std::string& _rowSuffix=\"\","},
{"lineNum":"   59","line":"    const std::string& _matPrefix=\"\", const std::string& _matSuffix=\"\", const char _fill=\' \')"},
{"lineNum":"   60","line":"  : matPrefix(_matPrefix), matSuffix(_matSuffix), rowPrefix(_rowPrefix), rowSuffix(_rowSuffix), rowSeparator(_rowSeparator),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   61","line":"    rowSpacer(\"\"), coeffSeparator(_coeffSeparator), fill(_fill), precision(_precision), flags(_flags)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   62","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   63","line":"    // TODO check if rowPrefix, rowSuffix or rowSeparator contains a newline"},
{"lineNum":"   64","line":"    // don\'t add rowSpacer if columns are not to be aligned"},
{"lineNum":"   65","line":"    if((flags & DontAlignCols))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   66","line":"      return;"},
{"lineNum":"   67","line":"    int i = int(matSuffix.length())-1;"},
{"lineNum":"   68","line":"    while (i>=0 && matSuffix[i]!=\'\\n\')","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   69","line":"    {"},
{"lineNum":"   70","line":"      rowSpacer += \' \';"},
{"lineNum":"   71","line":"      i--;"},
{"lineNum":"   72","line":"    }"},
{"lineNum":"   73","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   74","line":"  std::string matPrefix, matSuffix;"},
{"lineNum":"   75","line":"  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;"},
{"lineNum":"   76","line":"  std::string coeffSeparator;"},
{"lineNum":"   77","line":"  char fill;"},
{"lineNum":"   78","line":"  int precision;"},
{"lineNum":"   79","line":"  int flags;"},
{"lineNum":"   80","line":"};"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"/** \\class WithFormat"},
{"lineNum":"   83","line":"  * \\ingroup Core_Module"},
{"lineNum":"   84","line":"  *"},
{"lineNum":"   85","line":"  * \\brief Pseudo expression providing matrix output with given format"},
{"lineNum":"   86","line":"  *"},
{"lineNum":"   87","line":"  * \\tparam ExpressionType the type of the object on which IO stream operations are performed"},
{"lineNum":"   88","line":"  *"},
{"lineNum":"   89","line":"  * This class represents an expression with stream operators controlled by a given IOFormat."},
{"lineNum":"   90","line":"  * It is the return type of DenseBase::format()"},
{"lineNum":"   91","line":"  * and most of the time this is the only way it is used."},
{"lineNum":"   92","line":"  *"},
{"lineNum":"   93","line":"  * See class IOFormat for some examples."},
{"lineNum":"   94","line":"  *"},
{"lineNum":"   95","line":"  * \\sa DenseBase::format(), class IOFormat"},
{"lineNum":"   96","line":"  */"},
{"lineNum":"   97","line":"template<typename ExpressionType>"},
{"lineNum":"   98","line":"class WithFormat"},
{"lineNum":"   99","line":"{"},
{"lineNum":"  100","line":"  public:"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    WithFormat(const ExpressionType& matrix, const IOFormat& format)"},
{"lineNum":"  103","line":"      : m_matrix(matrix), m_format(format)"},
{"lineNum":"  104","line":"    {}"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)"},
{"lineNum":"  107","line":"    {"},
{"lineNum":"  108","line":"      return internal::print_matrix(s, wf.m_matrix.eval(), wf.m_format);"},
{"lineNum":"  109","line":"    }"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"  protected:"},
{"lineNum":"  112","line":"    typename ExpressionType::Nested m_matrix;"},
{"lineNum":"  113","line":"    IOFormat m_format;"},
{"lineNum":"  114","line":"};"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"namespace internal {"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"// NOTE: This helper is kept for backward compatibility with previous code specializing"},
{"lineNum":"  119","line":"//       this internal::significant_decimals_impl structure. In the future we should directly"},
{"lineNum":"  120","line":"//       call digits10() which has been introduced in July 2016 in 3.3."},
{"lineNum":"  121","line":"template<typename Scalar>"},
{"lineNum":"  122","line":"struct significant_decimals_impl"},
{"lineNum":"  123","line":"{"},
{"lineNum":"  124","line":"  static inline int run()"},
{"lineNum":"  125","line":"  {"},
{"lineNum":"  126","line":"    return NumTraits<Scalar>::digits10();"},
{"lineNum":"  127","line":"  }"},
{"lineNum":"  128","line":"};"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"/** \\internal"},
{"lineNum":"  131","line":"  * print the matrix \\a _m to the output stream \\a s using the output format \\a fmt */"},
{"lineNum":"  132","line":"template<typename Derived>"},
{"lineNum":"  133","line":"std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)"},
{"lineNum":"  134","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  135","line":"  using internal::is_same;"},
{"lineNum":"  136","line":"  using internal::conditional;"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"  if(_m.size() == 0)"},
{"lineNum":"  139","line":"  {"},
{"lineNum":"  140","line":"    s << fmt.matPrefix << fmt.matSuffix;"},
{"lineNum":"  141","line":"    return s;"},
{"lineNum":"  142","line":"  }"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"  typename Derived::Nested m = _m;"},
{"lineNum":"  145","line":"  typedef typename Derived::Scalar Scalar;"},
{"lineNum":"  146","line":"  typedef typename"},
{"lineNum":"  147","line":"      conditional<"},
{"lineNum":"  148","line":"          is_same<Scalar, char>::value ||"},
{"lineNum":"  149","line":"            is_same<Scalar, unsigned char>::value ||"},
{"lineNum":"  150","line":"            is_same<Scalar, numext::int8_t>::value ||"},
{"lineNum":"  151","line":"            is_same<Scalar, numext::uint8_t>::value,"},
{"lineNum":"  152","line":"          int,"},
{"lineNum":"  153","line":"          typename conditional<"},
{"lineNum":"  154","line":"              is_same<Scalar, std::complex<char> >::value ||"},
{"lineNum":"  155","line":"                is_same<Scalar, std::complex<unsigned char> >::value ||"},
{"lineNum":"  156","line":"                is_same<Scalar, std::complex<numext::int8_t> >::value ||"},
{"lineNum":"  157","line":"                is_same<Scalar, std::complex<numext::uint8_t> >::value,"},
{"lineNum":"  158","line":"              std::complex<int>,"},
{"lineNum":"  159","line":"              const Scalar&"},
{"lineNum":"  160","line":"            >::type"},
{"lineNum":"  161","line":"        >::type PrintType;"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"  Index width = 0;"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"  std::streamsize explicit_precision;"},
{"lineNum":"  166","line":"  if(fmt.precision == StreamPrecision)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  167","line":"  {"},
{"lineNum":"  168","line":"    explicit_precision = 0;"},
{"lineNum":"  169","line":"  }"},
{"lineNum":"  170","line":"  else if(fmt.precision == FullPrecision)"},
{"lineNum":"  171","line":"  {"},
{"lineNum":"  172","line":"    if (NumTraits<Scalar>::IsInteger)"},
{"lineNum":"  173","line":"    {"},
{"lineNum":"  174","line":"      explicit_precision = 0;"},
{"lineNum":"  175","line":"    }"},
{"lineNum":"  176","line":"    else"},
{"lineNum":"  177","line":"    {"},
{"lineNum":"  178","line":"      explicit_precision = significant_decimals_impl<Scalar>::run();"},
{"lineNum":"  179","line":"    }"},
{"lineNum":"  180","line":"  }"},
{"lineNum":"  181","line":"  else"},
{"lineNum":"  182","line":"  {"},
{"lineNum":"  183","line":"    explicit_precision = fmt.precision;"},
{"lineNum":"  184","line":"  }"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"  std::streamsize old_precision = 0;"},
{"lineNum":"  187","line":"  if(explicit_precision) old_precision = s.precision(explicit_precision);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"  bool align_cols = !(fmt.flags & DontAlignCols);"},
{"lineNum":"  190","line":"  if(align_cols)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  191","line":"  {"},
{"lineNum":"  192","line":"    // compute the largest width"},
{"lineNum":"  193","line":"    for(Index j = 0; j < m.cols(); ++j)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  194","line":"      for(Index i = 0; i < m.rows(); ++i)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  195","line":"      {"},
{"lineNum":"  196","line":"        std::stringstream sstr;"},
{"lineNum":"  197","line":"        sstr.copyfmt(s);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  198","line":"        sstr << static_cast<PrintType>(m.coeff(i,j));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  199","line":"        width = std::max<Index>(width, Index(sstr.str().length()));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  200","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  201","line":"  }"},
{"lineNum":"  202","line":"  std::streamsize old_width = s.width();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  203","line":"  char old_fill_character = s.fill();"},
{"lineNum":"  204","line":"  s << fmt.matPrefix;"},
{"lineNum":"  205","line":"  for(Index i = 0; i < m.rows(); ++i)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  206","line":"  {"},
{"lineNum":"  207","line":"    if (i)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  208","line":"      s << fmt.rowSpacer;"},
{"lineNum":"  209","line":"    s << fmt.rowPrefix;"},
{"lineNum":"  210","line":"    if(width) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  211","line":"      s.fill(fmt.fill);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  212","line":"      s.width(width);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  213","line":"    }"},
{"lineNum":"  214","line":"    s << static_cast<PrintType>(m.coeff(i, 0));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  215","line":"    for(Index j = 1; j < m.cols(); ++j)"},
{"lineNum":"  216","line":"    {"},
{"lineNum":"  217","line":"      s << fmt.coeffSeparator;"},
{"lineNum":"  218","line":"      if(width) {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  219","line":"        s.fill(fmt.fill);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  220","line":"        s.width(width);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  221","line":"      }"},
{"lineNum":"  222","line":"      s << static_cast<PrintType>(m.coeff(i, j));","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  223","line":"    }"},
{"lineNum":"  224","line":"    s << fmt.rowSuffix;"},
{"lineNum":"  225","line":"    if( i < m.rows() - 1)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  226","line":"      s << fmt.rowSeparator;"},
{"lineNum":"  227","line":"  }"},
{"lineNum":"  228","line":"  s << fmt.matSuffix;"},
{"lineNum":"  229","line":"  if(explicit_precision) s.precision(old_precision);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  230","line":"  if(width) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  231","line":"    s.fill(old_fill_character);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  232","line":"    s.width(old_width);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  233","line":"  }"},
{"lineNum":"  234","line":"  return s;"},
{"lineNum":"  235","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"} // end namespace internal"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"/** \\relates DenseBase"},
{"lineNum":"  240","line":"  *"},
{"lineNum":"  241","line":"  * Outputs the matrix, to the given stream."},
{"lineNum":"  242","line":"  *"},
{"lineNum":"  243","line":"  * If you wish to print the matrix with a format different than the default, use DenseBase::format()."},
{"lineNum":"  244","line":"  *"},
{"lineNum":"  245","line":"  * It is also possible to change the default format by defining EIGEN_DEFAULT_IO_FORMAT before including Eigen headers."},
{"lineNum":"  246","line":"  * If not defined, this will automatically be defined to Eigen::IOFormat(), that is the Eigen::IOFormat with default parameters."},
{"lineNum":"  247","line":"  *"},
{"lineNum":"  248","line":"  * \\sa DenseBase::format()"},
{"lineNum":"  249","line":"  */"},
{"lineNum":"  250","line":"template<typename Derived>"},
{"lineNum":"  251","line":"std::ostream & operator <<"},
{"lineNum":"  252","line":"(std::ostream & s,"},
{"lineNum":"  253","line":" const DenseBase<Derived> & m)"},
{"lineNum":"  254","line":"{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  255","line":"  return internal::print_matrix(s, m.eval(), EIGEN_DEFAULT_IO_FORMAT);","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  256","line":"}"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"} // end namespace Eigen"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"#endif // EIGEN_IO_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 36, "covered" : 0,};
var merged_data = [];
