var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2009-2014 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_TRANSPOSE_H"},
{"lineNum":"   12","line":"#define EIGEN_TRANSPOSE_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":"template<typename MatrixType>"},
{"lineNum":"   20","line":"struct traits<Transpose<MatrixType> > : public traits<MatrixType>"},
{"lineNum":"   21","line":"{"},
{"lineNum":"   22","line":"  typedef typename ref_selector<MatrixType>::type MatrixTypeNested;"},
{"lineNum":"   23","line":"  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;"},
{"lineNum":"   24","line":"  enum {"},
{"lineNum":"   25","line":"    RowsAtCompileTime = MatrixType::ColsAtCompileTime,"},
{"lineNum":"   26","line":"    ColsAtCompileTime = MatrixType::RowsAtCompileTime,"},
{"lineNum":"   27","line":"    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,"},
{"lineNum":"   28","line":"    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,"},
{"lineNum":"   29","line":"    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,"},
{"lineNum":"   30","line":"    Flags0 = traits<MatrixTypeNestedPlain>::Flags & ~(LvalueBit | NestByRefBit),"},
{"lineNum":"   31","line":"    Flags1 = Flags0 | FlagsLvalueBit,"},
{"lineNum":"   32","line":"    Flags = Flags1 ^ RowMajorBit,"},
{"lineNum":"   33","line":"    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,"},
{"lineNum":"   34","line":"    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret"},
{"lineNum":"   35","line":"  };"},
{"lineNum":"   36","line":"};"},
{"lineNum":"   37","line":"}"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"template<typename MatrixType, typename StorageKind> class TransposeImpl;"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"/** \\class Transpose"},
{"lineNum":"   42","line":"  * \\ingroup Core_Module"},
{"lineNum":"   43","line":"  *"},
{"lineNum":"   44","line":"  * \\brief Expression of the transpose of a matrix"},
{"lineNum":"   45","line":"  *"},
{"lineNum":"   46","line":"  * \\tparam MatrixType the type of the object of which we are taking the transpose"},
{"lineNum":"   47","line":"  *"},
{"lineNum":"   48","line":"  * This class represents an expression of the transpose of a matrix."},
{"lineNum":"   49","line":"  * It is the return type of MatrixBase::transpose() and MatrixBase::adjoint()"},
{"lineNum":"   50","line":"  * and most of the time this is the only way it is used."},
{"lineNum":"   51","line":"  *"},
{"lineNum":"   52","line":"  * \\sa MatrixBase::transpose(), MatrixBase::adjoint()"},
{"lineNum":"   53","line":"  */"},
{"lineNum":"   54","line":"template<typename MatrixType> class Transpose"},
{"lineNum":"   55","line":"  : public TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>"},
{"lineNum":"   56","line":"{"},
{"lineNum":"   57","line":"  public:"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"    typedef typename internal::ref_selector<MatrixType>::non_const_type MatrixTypeNested;"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;"},
{"lineNum":"   62","line":"    EIGEN_GENERIC_PUBLIC_INTERFACE(Transpose)"},
{"lineNum":"   63","line":"    typedef typename internal::remove_all<MatrixType>::type NestedExpression;"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   66","line":"    explicit EIGEN_STRONG_INLINE Transpose(MatrixType& matrix) : m_matrix(matrix) {}","class":"lineNoCov","hits":"0","possible_hits":"43",},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(Transpose)"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"   71","line":"    Index rows() const EIGEN_NOEXCEPT { return m_matrix.cols(); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   72","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE EIGEN_CONSTEXPR"},
{"lineNum":"   73","line":"    Index cols() const EIGEN_NOEXCEPT { return m_matrix.rows(); }","class":"lineNoCov","hits":"0","possible_hits":"25",},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"    /** \\returns the nested expression */"},
{"lineNum":"   76","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"   77","line":"    const typename internal::remove_all<MatrixTypeNested>::type&"},
{"lineNum":"   78","line":"    nestedExpression() const { return m_matrix; }","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"    /** \\returns the nested expression */"},
{"lineNum":"   81","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"   82","line":"    typename internal::remove_reference<MatrixTypeNested>::type&"},
{"lineNum":"   83","line":"    nestedExpression() { return m_matrix; }"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"    /** \\internal */"},
{"lineNum":"   86","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"   87","line":"    void resize(Index nrows, Index ncols) {"},
{"lineNum":"   88","line":"      m_matrix.resize(ncols,nrows);"},
{"lineNum":"   89","line":"    }"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"  protected:"},
{"lineNum":"   92","line":"    typename internal::ref_selector<MatrixType>::non_const_type m_matrix;"},
{"lineNum":"   93","line":"};"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"namespace internal {"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"template<typename MatrixType, bool HasDirectAccess = has_direct_access<MatrixType>::ret>"},
{"lineNum":"   98","line":"struct TransposeImpl_base"},
{"lineNum":"   99","line":"{"},
{"lineNum":"  100","line":"  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;"},
{"lineNum":"  101","line":"};"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"template<typename MatrixType>"},
{"lineNum":"  104","line":"struct TransposeImpl_base<MatrixType, false>"},
{"lineNum":"  105","line":"{"},
{"lineNum":"  106","line":"  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;"},
{"lineNum":"  107","line":"};"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"} // end namespace internal"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"// Generic API dispatcher"},
{"lineNum":"  112","line":"template<typename XprType, typename StorageKind>"},
{"lineNum":"  113","line":"class TransposeImpl"},
{"lineNum":"  114","line":"  : public internal::generic_xpr_base<Transpose<XprType> >::type"},
{"lineNum":"  115","line":"{"},
{"lineNum":"  116","line":"public:"},
{"lineNum":"  117","line":"  typedef typename internal::generic_xpr_base<Transpose<XprType> >::type Base;"},
{"lineNum":"  118","line":"};"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"template<typename MatrixType> class TransposeImpl<MatrixType,Dense>"},
{"lineNum":"  121","line":"  : public internal::TransposeImpl_base<MatrixType>::type"},
{"lineNum":"  122","line":"{"},
{"lineNum":"  123","line":"  public:"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;"},
{"lineNum":"  126","line":"    using Base::coeffRef;"},
{"lineNum":"  127","line":"    EIGEN_DENSE_PUBLIC_INTERFACE(Transpose<MatrixType>)"},
{"lineNum":"  128","line":"    EIGEN_INHERIT_ASSIGNMENT_OPERATORS(TransposeImpl)"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  131","line":"    Index innerStride() const { return derived().nestedExpression().innerStride(); }"},
{"lineNum":"  132","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  133","line":"    Index outerStride() const { return derived().nestedExpression().outerStride(); }"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"    typedef typename internal::conditional<"},
{"lineNum":"  136","line":"                       internal::is_lvalue<MatrixType>::value,"},
{"lineNum":"  137","line":"                       Scalar,"},
{"lineNum":"  138","line":"                       const Scalar"},
{"lineNum":"  139","line":"                     >::type ScalarWithConstIfNotLvalue;"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  142","line":"    ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }"},
{"lineNum":"  143","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  144","line":"    const Scalar* data() const { return derived().nestedExpression().data(); }"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"    // FIXME: shall we keep the const version of coeffRef?"},
{"lineNum":"  147","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  148","line":"    const Scalar& coeffRef(Index rowId, Index colId) const"},
{"lineNum":"  149","line":"    {"},
{"lineNum":"  150","line":"      return derived().nestedExpression().coeffRef(colId, rowId);"},
{"lineNum":"  151","line":"    }"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"    EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  154","line":"    const Scalar& coeffRef(Index index) const"},
{"lineNum":"  155","line":"    {"},
{"lineNum":"  156","line":"      return derived().nestedExpression().coeffRef(index);"},
{"lineNum":"  157","line":"    }"},
{"lineNum":"  158","line":"  protected:"},
{"lineNum":"  159","line":"    EIGEN_DEFAULT_EMPTY_CONSTRUCTOR_AND_DESTRUCTOR(TransposeImpl)"},
{"lineNum":"  160","line":"};"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"/** \\returns an expression of the transpose of *this."},
{"lineNum":"  163","line":"  *"},
{"lineNum":"  164","line":"  * Example: \\include MatrixBase_transpose.cpp"},
{"lineNum":"  165","line":"  * Output: \\verbinclude MatrixBase_transpose.out"},
{"lineNum":"  166","line":"  *"},
{"lineNum":"  167","line":"  * \\warning If you want to replace a matrix by its own transpose, do \\b NOT do this:"},
{"lineNum":"  168","line":"  * \\code"},
{"lineNum":"  169","line":"  * m = m.transpose(); // bug!!! caused by aliasing effect"},
{"lineNum":"  170","line":"  * \\endcode"},
{"lineNum":"  171","line":"  * Instead, use the transposeInPlace() method:"},
{"lineNum":"  172","line":"  * \\code"},
{"lineNum":"  173","line":"  * m.transposeInPlace();"},
{"lineNum":"  174","line":"  * \\endcode"},
{"lineNum":"  175","line":"  * which gives Eigen good opportunities for optimization, or alternatively you can also do:"},
{"lineNum":"  176","line":"  * \\code"},
{"lineNum":"  177","line":"  * m = m.transpose().eval();"},
{"lineNum":"  178","line":"  * \\endcode"},
{"lineNum":"  179","line":"  *"},
{"lineNum":"  180","line":"  * \\sa transposeInPlace(), adjoint() */"},
{"lineNum":"  181","line":"template<typename Derived>"},
{"lineNum":"  182","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  183","line":"Transpose<Derived>"},
{"lineNum":"  184","line":"DenseBase<Derived>::transpose()"},
{"lineNum":"  185","line":"{"},
{"lineNum":"  186","line":"  return TransposeReturnType(derived());"},
{"lineNum":"  187","line":"}"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"/** This is the const version of transpose()."},
{"lineNum":"  190","line":"  *"},
{"lineNum":"  191","line":"  * Make sure you read the warning for transpose() !"},
{"lineNum":"  192","line":"  *"},
{"lineNum":"  193","line":"  * \\sa transposeInPlace(), adjoint() */"},
{"lineNum":"  194","line":"template<typename Derived>"},
{"lineNum":"  195","line":"EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  196","line":"typename DenseBase<Derived>::ConstTransposeReturnType"},
{"lineNum":"  197","line":"DenseBase<Derived>::transpose() const"},
{"lineNum":"  198","line":"{"},
{"lineNum":"  199","line":"  return ConstTransposeReturnType(derived());"},
{"lineNum":"  200","line":"}"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"/** \\returns an expression of the adjoint (i.e. conjugate transpose) of *this."},
{"lineNum":"  203","line":"  *"},
{"lineNum":"  204","line":"  * Example: \\include MatrixBase_adjoint.cpp"},
{"lineNum":"  205","line":"  * Output: \\verbinclude MatrixBase_adjoint.out"},
{"lineNum":"  206","line":"  *"},
{"lineNum":"  207","line":"  * \\warning If you want to replace a matrix by its own adjoint, do \\b NOT do this:"},
{"lineNum":"  208","line":"  * \\code"},
{"lineNum":"  209","line":"  * m = m.adjoint(); // bug!!! caused by aliasing effect"},
{"lineNum":"  210","line":"  * \\endcode"},
{"lineNum":"  211","line":"  * Instead, use the adjointInPlace() method:"},
{"lineNum":"  212","line":"  * \\code"},
{"lineNum":"  213","line":"  * m.adjointInPlace();"},
{"lineNum":"  214","line":"  * \\endcode"},
{"lineNum":"  215","line":"  * which gives Eigen good opportunities for optimization, or alternatively you can also do:"},
{"lineNum":"  216","line":"  * \\code"},
{"lineNum":"  217","line":"  * m = m.adjoint().eval();"},
{"lineNum":"  218","line":"  * \\endcode"},
{"lineNum":"  219","line":"  *"},
{"lineNum":"  220","line":"  * \\sa adjointInPlace(), transpose(), conjugate(), class Transpose, class internal::scalar_conjugate_op */"},
{"lineNum":"  221","line":"template<typename Derived>"},
{"lineNum":"  222","line":"EIGEN_DEVICE_FUNC inline const typename MatrixBase<Derived>::AdjointReturnType"},
{"lineNum":"  223","line":"MatrixBase<Derived>::adjoint() const"},
{"lineNum":"  224","line":"{"},
{"lineNum":"  225","line":"  return AdjointReturnType(this->transpose());"},
{"lineNum":"  226","line":"}"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"/***************************************************************************"},
{"lineNum":"  229","line":"* \"in place\" transpose implementation"},
{"lineNum":"  230","line":"***************************************************************************/"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"namespace internal {"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"template<typename MatrixType,"},
{"lineNum":"  235","line":"  bool IsSquare = (MatrixType::RowsAtCompileTime == MatrixType::ColsAtCompileTime) && MatrixType::RowsAtCompileTime!=Dynamic,"},
{"lineNum":"  236","line":"  bool MatchPacketSize ="},
{"lineNum":"  237","line":"        (int(MatrixType::RowsAtCompileTime) == int(internal::packet_traits<typename MatrixType::Scalar>::size))"},
{"lineNum":"  238","line":"    &&  (internal::evaluator<MatrixType>::Flags&PacketAccessBit) >"},
{"lineNum":"  239","line":"struct inplace_transpose_selector;"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"template<typename MatrixType>"},
{"lineNum":"  242","line":"struct inplace_transpose_selector<MatrixType,true,false> { // square matrix"},
{"lineNum":"  243","line":"  static void run(MatrixType& m) {"},
{"lineNum":"  244","line":"    m.matrix().template triangularView<StrictlyUpper>().swap(m.matrix().transpose().template triangularView<StrictlyUpper>());"},
{"lineNum":"  245","line":"  }"},
{"lineNum":"  246","line":"};"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"template<typename MatrixType>"},
{"lineNum":"  249","line":"struct inplace_transpose_selector<MatrixType,true,true> { // PacketSize x PacketSize"},
{"lineNum":"  250","line":"  static void run(MatrixType& m) {"},
{"lineNum":"  251","line":"    typedef typename MatrixType::Scalar Scalar;"},
{"lineNum":"  252","line":"    typedef typename internal::packet_traits<typename MatrixType::Scalar>::type Packet;"},
{"lineNum":"  253","line":"    const Index PacketSize = internal::packet_traits<Scalar>::size;"},
{"lineNum":"  254","line":"    const Index Alignment = internal::evaluator<MatrixType>::Alignment;"},
{"lineNum":"  255","line":"    PacketBlock<Packet> A;"},
{"lineNum":"  256","line":"    for (Index i=0; i<PacketSize; ++i)"},
{"lineNum":"  257","line":"      A.packet[i] = m.template packetByOuterInner<Alignment>(i,0);"},
{"lineNum":"  258","line":"    internal::ptranspose(A);"},
{"lineNum":"  259","line":"    for (Index i=0; i<PacketSize; ++i)"},
{"lineNum":"  260","line":"      m.template writePacket<Alignment>(m.rowIndexByOuterInner(i,0), m.colIndexByOuterInner(i,0), A.packet[i]);"},
{"lineNum":"  261","line":"  }"},
{"lineNum":"  262","line":"};"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":""},
{"lineNum":"  265","line":"template <typename MatrixType, Index Alignment>"},
{"lineNum":"  266","line":"void BlockedInPlaceTranspose(MatrixType& m) {"},
{"lineNum":"  267","line":"  typedef typename MatrixType::Scalar Scalar;"},
{"lineNum":"  268","line":"  typedef typename internal::packet_traits<typename MatrixType::Scalar>::type Packet;"},
{"lineNum":"  269","line":"  const Index PacketSize = internal::packet_traits<Scalar>::size;"},
{"lineNum":"  270","line":"  eigen_assert(m.rows() == m.cols());"},
{"lineNum":"  271","line":"  int row_start = 0;"},
{"lineNum":"  272","line":"  for (; row_start + PacketSize <= m.rows(); row_start += PacketSize) {"},
{"lineNum":"  273","line":"    for (int col_start = row_start; col_start + PacketSize <= m.cols(); col_start += PacketSize) {"},
{"lineNum":"  274","line":"      PacketBlock<Packet> A;"},
{"lineNum":"  275","line":"      if (row_start == col_start) {"},
{"lineNum":"  276","line":"        for (Index i=0; i<PacketSize; ++i)"},
{"lineNum":"  277","line":"          A.packet[i] = m.template packetByOuterInner<Alignment>(row_start + i,col_start);"},
{"lineNum":"  278","line":"        internal::ptranspose(A);"},
{"lineNum":"  279","line":"        for (Index i=0; i<PacketSize; ++i)"},
{"lineNum":"  280","line":"          m.template writePacket<Alignment>(m.rowIndexByOuterInner(row_start + i, col_start), m.colIndexByOuterInner(row_start + i,col_start), A.packet[i]);"},
{"lineNum":"  281","line":"      } else {"},
{"lineNum":"  282","line":"        PacketBlock<Packet> B;"},
{"lineNum":"  283","line":"        for (Index i=0; i<PacketSize; ++i) {"},
{"lineNum":"  284","line":"          A.packet[i] = m.template packetByOuterInner<Alignment>(row_start + i,col_start);"},
{"lineNum":"  285","line":"          B.packet[i] = m.template packetByOuterInner<Alignment>(col_start + i, row_start);"},
{"lineNum":"  286","line":"        }"},
{"lineNum":"  287","line":"        internal::ptranspose(A);"},
{"lineNum":"  288","line":"        internal::ptranspose(B);"},
{"lineNum":"  289","line":"        for (Index i=0; i<PacketSize; ++i) {"},
{"lineNum":"  290","line":"          m.template writePacket<Alignment>(m.rowIndexByOuterInner(row_start + i, col_start), m.colIndexByOuterInner(row_start + i,col_start), B.packet[i]);"},
{"lineNum":"  291","line":"          m.template writePacket<Alignment>(m.rowIndexByOuterInner(col_start + i, row_start), m.colIndexByOuterInner(col_start + i,row_start), A.packet[i]);"},
{"lineNum":"  292","line":"        }"},
{"lineNum":"  293","line":"      }"},
{"lineNum":"  294","line":"    }"},
{"lineNum":"  295","line":"  }"},
{"lineNum":"  296","line":"  for (Index row = row_start; row < m.rows(); ++row) {"},
{"lineNum":"  297","line":"    m.matrix().row(row).head(row).swap("},
{"lineNum":"  298","line":"        m.matrix().col(row).head(row).transpose());"},
{"lineNum":"  299","line":"  }"},
{"lineNum":"  300","line":"}"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"template<typename MatrixType,bool MatchPacketSize>"},
{"lineNum":"  303","line":"struct inplace_transpose_selector<MatrixType,false,MatchPacketSize> { // non square or dynamic matrix"},
{"lineNum":"  304","line":"  static void run(MatrixType& m) {"},
{"lineNum":"  305","line":"    typedef typename MatrixType::Scalar Scalar;"},
{"lineNum":"  306","line":"    if (m.rows() == m.cols()) {"},
{"lineNum":"  307","line":"      const Index PacketSize = internal::packet_traits<Scalar>::size;"},
{"lineNum":"  308","line":"      if (!NumTraits<Scalar>::IsComplex && m.rows() >= PacketSize) {"},
{"lineNum":"  309","line":"        if ((m.rows() % PacketSize) == 0)"},
{"lineNum":"  310","line":"          BlockedInPlaceTranspose<MatrixType,internal::evaluator<MatrixType>::Alignment>(m);"},
{"lineNum":"  311","line":"        else"},
{"lineNum":"  312","line":"          BlockedInPlaceTranspose<MatrixType,Unaligned>(m);"},
{"lineNum":"  313","line":"      }"},
{"lineNum":"  314","line":"      else {"},
{"lineNum":"  315","line":"        m.matrix().template triangularView<StrictlyUpper>().swap(m.matrix().transpose().template triangularView<StrictlyUpper>());"},
{"lineNum":"  316","line":"      }"},
{"lineNum":"  317","line":"    } else {"},
{"lineNum":"  318","line":"      m = m.transpose().eval();"},
{"lineNum":"  319","line":"    }"},
{"lineNum":"  320","line":"  }"},
{"lineNum":"  321","line":"};"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"} // end namespace internal"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"/** This is the \"in place\" version of transpose(): it replaces \\c *this by its own transpose."},
{"lineNum":"  327","line":"  * Thus, doing"},
{"lineNum":"  328","line":"  * \\code"},
{"lineNum":"  329","line":"  * m.transposeInPlace();"},
{"lineNum":"  330","line":"  * \\endcode"},
{"lineNum":"  331","line":"  * has the same effect on m as doing"},
{"lineNum":"  332","line":"  * \\code"},
{"lineNum":"  333","line":"  * m = m.transpose().eval();"},
{"lineNum":"  334","line":"  * \\endcode"},
{"lineNum":"  335","line":"  * and is faster and also safer because in the latter line of code, forgetting the eval() results"},
{"lineNum":"  336","line":"  * in a bug caused by \\ref TopicAliasing \"aliasing\"."},
{"lineNum":"  337","line":"  *"},
{"lineNum":"  338","line":"  * Notice however that this method is only useful if you want to replace a matrix by its own transpose."},
{"lineNum":"  339","line":"  * If you just need the transpose of a matrix, use transpose()."},
{"lineNum":"  340","line":"  *"},
{"lineNum":"  341","line":"  * \\note if the matrix is not square, then \\c *this must be a resizable matrix."},
{"lineNum":"  342","line":"  * This excludes (non-square) fixed-size matrices, block-expressions and maps."},
{"lineNum":"  343","line":"  *"},
{"lineNum":"  344","line":"  * \\sa transpose(), adjoint(), adjointInPlace() */"},
{"lineNum":"  345","line":"template<typename Derived>"},
{"lineNum":"  346","line":"EIGEN_DEVICE_FUNC inline void DenseBase<Derived>::transposeInPlace()"},
{"lineNum":"  347","line":"{"},
{"lineNum":"  348","line":"  eigen_assert((rows() == cols() || (RowsAtCompileTime == Dynamic && ColsAtCompileTime == Dynamic))"},
{"lineNum":"  349","line":"               && \"transposeInPlace() called on a non-square non-resizable matrix\");"},
{"lineNum":"  350","line":"  internal::inplace_transpose_selector<Derived>::run(derived());"},
{"lineNum":"  351","line":"}"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"/***************************************************************************"},
{"lineNum":"  354","line":"* \"in place\" adjoint implementation"},
{"lineNum":"  355","line":"***************************************************************************/"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"/** This is the \"in place\" version of adjoint(): it replaces \\c *this by its own transpose."},
{"lineNum":"  358","line":"  * Thus, doing"},
{"lineNum":"  359","line":"  * \\code"},
{"lineNum":"  360","line":"  * m.adjointInPlace();"},
{"lineNum":"  361","line":"  * \\endcode"},
{"lineNum":"  362","line":"  * has the same effect on m as doing"},
{"lineNum":"  363","line":"  * \\code"},
{"lineNum":"  364","line":"  * m = m.adjoint().eval();"},
{"lineNum":"  365","line":"  * \\endcode"},
{"lineNum":"  366","line":"  * and is faster and also safer because in the latter line of code, forgetting the eval() results"},
{"lineNum":"  367","line":"  * in a bug caused by aliasing."},
{"lineNum":"  368","line":"  *"},
{"lineNum":"  369","line":"  * Notice however that this method is only useful if you want to replace a matrix by its own adjoint."},
{"lineNum":"  370","line":"  * If you just need the adjoint of a matrix, use adjoint()."},
{"lineNum":"  371","line":"  *"},
{"lineNum":"  372","line":"  * \\note if the matrix is not square, then \\c *this must be a resizable matrix."},
{"lineNum":"  373","line":"  * This excludes (non-square) fixed-size matrices, block-expressions and maps."},
{"lineNum":"  374","line":"  *"},
{"lineNum":"  375","line":"  * \\sa transpose(), adjoint(), transposeInPlace() */"},
{"lineNum":"  376","line":"template<typename Derived>"},
{"lineNum":"  377","line":"EIGEN_DEVICE_FUNC inline void MatrixBase<Derived>::adjointInPlace()"},
{"lineNum":"  378","line":"{"},
{"lineNum":"  379","line":"  derived() = adjoint().eval();"},
{"lineNum":"  380","line":"}"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"#ifndef EIGEN_NO_DEBUG"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"// The following is to detect aliasing problems in most common cases."},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"namespace internal {"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"template<bool DestIsTransposed, typename OtherDerived>"},
{"lineNum":"  389","line":"struct check_transpose_aliasing_compile_time_selector"},
{"lineNum":"  390","line":"{"},
{"lineNum":"  391","line":"  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };"},
{"lineNum":"  392","line":"};"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"template<bool DestIsTransposed, typename BinOp, typename DerivedA, typename DerivedB>"},
{"lineNum":"  395","line":"struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >"},
{"lineNum":"  396","line":"{"},
{"lineNum":"  397","line":"  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed"},
{"lineNum":"  398","line":"               || bool(blas_traits<DerivedB>::IsTransposed) != DestIsTransposed"},
{"lineNum":"  399","line":"  };"},
{"lineNum":"  400","line":"};"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"template<typename Scalar, bool DestIsTransposed, typename OtherDerived>"},
{"lineNum":"  403","line":"struct check_transpose_aliasing_run_time_selector"},
{"lineNum":"  404","line":"{"},
{"lineNum":"  405","line":"  static bool run(const Scalar* dest, const OtherDerived& src)"},
{"lineNum":"  406","line":"  {"},
{"lineNum":"  407","line":"    return (bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src));"},
{"lineNum":"  408","line":"  }"},
{"lineNum":"  409","line":"};"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"template<typename Scalar, bool DestIsTransposed, typename BinOp, typename DerivedA, typename DerivedB>"},
{"lineNum":"  412","line":"struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >"},
{"lineNum":"  413","line":"{"},
{"lineNum":"  414","line":"  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)"},
{"lineNum":"  415","line":"  {"},
{"lineNum":"  416","line":"    return ((blas_traits<DerivedA>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.lhs())))"},
{"lineNum":"  417","line":"        || ((blas_traits<DerivedB>::IsTransposed != DestIsTransposed) && (dest!=0 && dest==(const Scalar*)extract_data(src.rhs())));"},
{"lineNum":"  418","line":"  }"},
{"lineNum":"  419","line":"};"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"// the following selector, checkTransposeAliasing_impl, based on MightHaveTransposeAliasing,"},
{"lineNum":"  422","line":"// is because when the condition controlling the assert is known at compile time, ICC emits a warning."},
{"lineNum":"  423","line":"// This is actually a good warning: in expressions that don\'t have any transposing, the condition is"},
{"lineNum":"  424","line":"// known at compile time to be false, and using that, we can avoid generating the code of the assert again"},
{"lineNum":"  425","line":"// and again for all these expressions that don\'t need it."},
{"lineNum":"  426","line":""},
{"lineNum":"  427","line":"template<typename Derived, typename OtherDerived,"},
{"lineNum":"  428","line":"         bool MightHaveTransposeAliasing"},
{"lineNum":"  429","line":"                 = check_transpose_aliasing_compile_time_selector"},
{"lineNum":"  430","line":"                     <blas_traits<Derived>::IsTransposed,OtherDerived>::ret"},
{"lineNum":"  431","line":"        >"},
{"lineNum":"  432","line":"struct checkTransposeAliasing_impl"},
{"lineNum":"  433","line":"{"},
{"lineNum":"  434","line":"    static void run(const Derived& dst, const OtherDerived& other)"},
{"lineNum":"  435","line":"    {"},
{"lineNum":"  436","line":"        eigen_assert((!check_transpose_aliasing_run_time_selector"},
{"lineNum":"  437","line":"                      <typename Derived::Scalar,blas_traits<Derived>::IsTransposed,OtherDerived>"},
{"lineNum":"  438","line":"                      ::run(extract_data(dst), other))"},
{"lineNum":"  439","line":"          && \"aliasing detected during transposition, use transposeInPlace() \""},
{"lineNum":"  440","line":"             \"or evaluate the rhs into a temporary using .eval()\");"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"    }"},
{"lineNum":"  443","line":"};"},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"template<typename Derived, typename OtherDerived>"},
{"lineNum":"  446","line":"struct checkTransposeAliasing_impl<Derived, OtherDerived, false>"},
{"lineNum":"  447","line":"{"},
{"lineNum":"  448","line":"    static void run(const Derived&, const OtherDerived&)"},
{"lineNum":"  449","line":"    {"},
{"lineNum":"  450","line":"    }"},
{"lineNum":"  451","line":"};"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"template<typename Dst, typename Src>"},
{"lineNum":"  454","line":"void check_for_aliasing(const Dst &dst, const Src &src)"},
{"lineNum":"  455","line":"{"},
{"lineNum":"  456","line":"  if((!Dst::IsVectorAtCompileTime) && dst.rows()>1 && dst.cols()>1)"},
{"lineNum":"  457","line":"    internal::checkTransposeAliasing_impl<Dst, Src>::run(dst, src);"},
{"lineNum":"  458","line":"}"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"} // end namespace internal"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"#endif // EIGEN_NO_DEBUG"},
{"lineNum":"  463","line":""},
{"lineNum":"  464","line":"} // end namespace Eigen"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"#endif // EIGEN_TRANSPOSE_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
