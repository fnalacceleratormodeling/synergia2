var data = {lines:[
{"lineNum":"    1","line":"/*! \\file polymorphic_impl.hpp"},
{"lineNum":"    2","line":"    \\brief Internal polymorphism support"},
{"lineNum":"    3","line":"    \\ingroup Internal */"},
{"lineNum":"    4","line":"/*"},
{"lineNum":"    5","line":"  Copyright (c) 2014, Randolph Voorhies, Shane Grant"},
{"lineNum":"    6","line":"  All rights reserved."},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"  Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    9","line":"  modification, are permitted provided that the following conditions are met:"},
{"lineNum":"   10","line":"      * Redistributions of source code must retain the above copyright"},
{"lineNum":"   11","line":"        notice, this list of conditions and the following disclaimer."},
{"lineNum":"   12","line":"      * Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   13","line":"        notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   14","line":"        documentation and/or other materials provided with the distribution."},
{"lineNum":"   15","line":"      * Neither the name of cereal nor the"},
{"lineNum":"   16","line":"        names of its contributors may be used to endorse or promote products"},
{"lineNum":"   17","line":"        derived from this software without specific prior written permission."},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"},
{"lineNum":"   20","line":"  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"},
{"lineNum":"   21","line":"  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"},
{"lineNum":"   22","line":"  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES OR SHANE GRANT BE LIABLE FOR ANY"},
{"lineNum":"   23","line":"  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"},
{"lineNum":"   24","line":"  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"},
{"lineNum":"   25","line":"  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"},
{"lineNum":"   26","line":"  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   27","line":"  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   28","line":"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   29","line":"*/"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"/* This code is heavily inspired by the boost serialization implementation by the following authors"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"   (C) Copyright 2002 Robert Ramey - http://www.rrsd.com ."},
{"lineNum":"   34","line":"   Use, modification and distribution is subject to the Boost Software"},
{"lineNum":"   35","line":"   License, Version 1.0. (See http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"    See http://www.boost.org for updates, documentation, and revision history."},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"   (C) Copyright 2006 David Abrahams - http://www.boost.org."},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"   See /boost/serialization/export.hpp, /boost/archive/detail/register_archive.hpp,"},
{"lineNum":"   42","line":"   and /boost/serialization/void_cast.hpp for their implementation. Additional details"},
{"lineNum":"   43","line":"   found in other files split across serialization and archive."},
{"lineNum":"   44","line":"*/"},
{"lineNum":"   45","line":"#ifndef CEREAL_DETAILS_POLYMORPHIC_IMPL_HPP_"},
{"lineNum":"   46","line":"#define CEREAL_DETAILS_POLYMORPHIC_IMPL_HPP_"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include \"cereal/details/polymorphic_impl_fwd.hpp\""},
{"lineNum":"   49","line":"#include \"cereal/details/static_object.hpp\""},
{"lineNum":"   50","line":"#include \"cereal/types/memory.hpp\""},
{"lineNum":"   51","line":"#include \"cereal/types/string.hpp\""},
{"lineNum":"   52","line":"#include <functional>"},
{"lineNum":"   53","line":"#include <typeindex>"},
{"lineNum":"   54","line":"#include <map>"},
{"lineNum":"   55","line":"#include <limits>"},
{"lineNum":"   56","line":"#include <set>"},
{"lineNum":"   57","line":"#include <stack>"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"//! Helper macro to omit unused warning"},
{"lineNum":"   60","line":"#if defined(__GNUC__)"},
{"lineNum":"   61","line":"  // GCC / clang don\'t want the function"},
{"lineNum":"   62","line":"  #define CEREAL_BIND_TO_ARCHIVES_UNUSED_FUNCTION"},
{"lineNum":"   63","line":"#else"},
{"lineNum":"   64","line":"  #define CEREAL_BIND_TO_ARCHIVES_UNUSED_FUNCTION static void unused() { (void)b; }"},
{"lineNum":"   65","line":"#endif"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"//! Binds a polymorhic type to all registered archives"},
{"lineNum":"   68","line":"/*! This binds a polymorphic type to all compatible registered archives that"},
{"lineNum":"   69","line":"    have been registered with CEREAL_REGISTER_ARCHIVE.  This must be called"},
{"lineNum":"   70","line":"    after all archives are registered (usually after the archives themselves"},
{"lineNum":"   71","line":"    have been included). */"},
{"lineNum":"   72","line":"#ifdef CEREAL_HAS_CPP17"},
{"lineNum":"   73","line":"#define CEREAL_BIND_TO_ARCHIVES(...)                                     \\"},
{"lineNum":"   74","line":"    namespace cereal {                                                   \\"},
{"lineNum":"   75","line":"    namespace detail {                                                   \\"},
{"lineNum":"   76","line":"    template<>                                                           \\"},
{"lineNum":"   77","line":"    struct init_binding<__VA_ARGS__> {                                   \\"},
{"lineNum":"   78","line":"        static inline bind_to_archives<__VA_ARGS__> const & b=           \\"},
{"lineNum":"   79","line":"        ::cereal::detail::StaticObject<                                  \\"},
{"lineNum":"   80","line":"            bind_to_archives<__VA_ARGS__>                                \\"},
{"lineNum":"   81","line":"        >::getInstance().bind();                                         \\"},
{"lineNum":"   82","line":"        CEREAL_BIND_TO_ARCHIVES_UNUSED_FUNCTION                          \\"},
{"lineNum":"   83","line":"    };                                                                   \\"},
{"lineNum":"   84","line":"    }} /* end namespaces */"},
{"lineNum":"   85","line":"#else"},
{"lineNum":"   86","line":"#define CEREAL_BIND_TO_ARCHIVES(...)                                     \\"},
{"lineNum":"   87","line":"    namespace cereal {                                                   \\"},
{"lineNum":"   88","line":"    namespace detail {                                                   \\"},
{"lineNum":"   89","line":"    template<>                                                           \\"},
{"lineNum":"   90","line":"    struct init_binding<__VA_ARGS__> {                                   \\"},
{"lineNum":"   91","line":"        static bind_to_archives<__VA_ARGS__> const& b;                   \\"},
{"lineNum":"   92","line":"        CEREAL_BIND_TO_ARCHIVES_UNUSED_FUNCTION                          \\"},
{"lineNum":"   93","line":"    };                                                                   \\"},
{"lineNum":"   94","line":"    bind_to_archives<__VA_ARGS__> const & init_binding<__VA_ARGS__>::b = \\"},
{"lineNum":"   95","line":"        ::cereal::detail::StaticObject<                                  \\"},
{"lineNum":"   96","line":"            bind_to_archives<__VA_ARGS__>                                \\"},
{"lineNum":"   97","line":"        >::getInstance().bind();                                         \\"},
{"lineNum":"   98","line":"    }} /* end namespaces */"},
{"lineNum":"   99","line":"#endif"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"namespace cereal"},
{"lineNum":"  102","line":"{"},
{"lineNum":"  103","line":"  /* Polymorphic casting support */"},
{"lineNum":"  104","line":"  namespace detail"},
{"lineNum":"  105","line":"  {"},
{"lineNum":"  106","line":"    //! Base type for polymorphic void casting"},
{"lineNum":"  107","line":"    /*! Contains functions for casting between registered base and derived types."},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"        This is necessary so that cereal can properly cast between polymorphic types"},
{"lineNum":"  110","line":"        even though void pointers are used, which normally have no type information."},
{"lineNum":"  111","line":"        Runtime type information is used instead to index a compile-time made mapping"},
{"lineNum":"  112","line":"        that can perform the proper cast. In the case of multiple levels of inheritance,"},
{"lineNum":"  113","line":"        cereal will attempt to find the shortest path by using registered relationships to"},
{"lineNum":"  114","line":"        perform the cast."},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"        This class will be allocated as a StaticObject and only referenced by pointer,"},
{"lineNum":"  117","line":"        allowing a templated derived version of it to define strongly typed functions"},
{"lineNum":"  118","line":"        that cast between registered base and derived types. */"},
{"lineNum":"  119","line":"    struct PolymorphicCaster"},
{"lineNum":"  120","line":"    {"},
{"lineNum":"  121","line":"      PolymorphicCaster() = default;"},
{"lineNum":"  122","line":"      PolymorphicCaster( const PolymorphicCaster & ) = default;"},
{"lineNum":"  123","line":"      PolymorphicCaster & operator=( const PolymorphicCaster & ) = default;"},
{"lineNum":"  124","line":"      PolymorphicCaster( PolymorphicCaster && ) CEREAL_NOEXCEPT {}"},
{"lineNum":"  125","line":"      PolymorphicCaster & operator=( PolymorphicCaster && ) CEREAL_NOEXCEPT { return *this; }"},
{"lineNum":"  126","line":"      virtual ~PolymorphicCaster() CEREAL_NOEXCEPT = default;","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"      //! Downcasts to the proper derived type"},
{"lineNum":"  129","line":"      virtual void const * downcast( void const * const ptr ) const = 0;"},
{"lineNum":"  130","line":"      //! Upcast to proper base type"},
{"lineNum":"  131","line":"      virtual void * upcast( void * const ptr ) const = 0;"},
{"lineNum":"  132","line":"      //! Upcast to proper base type, shared_ptr version"},
{"lineNum":"  133","line":"      virtual std::shared_ptr<void> upcast( std::shared_ptr<void> const & ptr ) const = 0;"},
{"lineNum":"  134","line":"    };"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"    //! Holds registered mappings between base and derived types for casting"},
{"lineNum":"  137","line":"    /*! This will be allocated as a StaticObject and holds a map containing"},
{"lineNum":"  138","line":"        all registered mappings between base and derived types. */"},
{"lineNum":"  139","line":"    struct PolymorphicCasters","class":"lineNoCov","hits":"0","possible_hits":"13",},
{"lineNum":"  140","line":"    {"},
{"lineNum":"  141","line":"      //! Maps from a derived type index to a set of chainable casters"},
{"lineNum":"  142","line":"      using DerivedCasterMap = std::unordered_map<std::type_index, std::vector<PolymorphicCaster const *>>;"},
{"lineNum":"  143","line":"      //! Maps from base type index to a map from derived type index to caster"},
{"lineNum":"  144","line":"      std::unordered_map<std::type_index, DerivedCasterMap> map;"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"      std::multimap<std::type_index, std::type_index> reverseMap;"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"      //! Error message used for unregistered polymorphic casts"},
{"lineNum":"  149","line":"      #define UNREGISTERED_POLYMORPHIC_CAST_EXCEPTION(LoadSave)                                                                                                                \\"},
{"lineNum":"  150","line":"        throw cereal::Exception(\"Trying to \" #LoadSave \" a registered polymorphic type with an unregistered polymorphic cast.\\n\"                                               \\"},
{"lineNum":"  151","line":"                                \"Could not find a path to a base class (\" + util::demangle(baseInfo.name()) + \") for type: \" + ::cereal::util::demangledName<Derived>() + \"\\n\" \\"},
{"lineNum":"  152","line":"                                \"Make sure you either serialize the base class at some point via cereal::base_class or cereal::virtual_base_class.\\n\"                          \\"},
{"lineNum":"  153","line":"                                \"Alternatively, manually register the association with CEREAL_REGISTER_POLYMORPHIC_RELATION.\");"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"      //! Checks if the mapping object that can perform the upcast or downcast exists, and returns it if so"},
{"lineNum":"  156","line":"      /*! Uses the type index from the base and derived class to find the matching"},
{"lineNum":"  157","line":"          registered caster. If no matching caster exists, the bool in the pair will be false and the vector"},
{"lineNum":"  158","line":"          reference should not be used. */"},
{"lineNum":"  159","line":"      static std::pair<bool, std::vector<PolymorphicCaster const *> const &>"},
{"lineNum":"  160","line":"      lookup_if_exists( std::type_index const & baseIndex, std::type_index const & derivedIndex )"},
{"lineNum":"  161","line":"      {","class":"linePartCov","hits":"1","order":"532","possible_hits":"4",},
{"lineNum":"  162","line":"        // First phase of lookup - match base type index"},
{"lineNum":"  163","line":"        auto const & baseMap = StaticObject<PolymorphicCasters>::getInstance().map;"},
{"lineNum":"  164","line":"        auto baseIter = baseMap.find( baseIndex );"},
{"lineNum":"  165","line":"        if (baseIter == baseMap.end())","class":"lineCov","hits":"1","order":"534","possible_hits":"1",},
{"lineNum":"  166","line":"          return {false, {}};","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"        // Second phase - find a match from base to derived"},
{"lineNum":"  169","line":"        auto const & derivedMap = baseIter->second;","class":"lineCov","hits":"1","order":"535","possible_hits":"1",},
{"lineNum":"  170","line":"        auto derivedIter = derivedMap.find( derivedIndex );"},
{"lineNum":"  171","line":"        if (derivedIter == derivedMap.end())","class":"lineCov","hits":"1","order":"536","possible_hits":"1",},
{"lineNum":"  172","line":"          return {false, {}};","class":"lineCov","hits":"1","order":"545","possible_hits":"1",},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"        return {true, derivedIter->second};","class":"linePartCov","hits":"1","order":"537","possible_hits":"4",},
{"lineNum":"  175","line":"      }","class":"linePartCov","hits":"1","order":"538","possible_hits":"4",},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"      //! Gets the mapping object that can perform the upcast or downcast"},
{"lineNum":"  178","line":"      /*! Uses the type index from the base and derived class to find the matching"},
{"lineNum":"  179","line":"          registered caster. If no matching caster exists, calls the exception function."},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"          The returned PolymorphicCaster is capable of upcasting or downcasting between the two types. */"},
{"lineNum":"  182","line":"      template <class F> inline"},
{"lineNum":"  183","line":"      static std::vector<PolymorphicCaster const *> const & lookup( std::type_index const & baseIndex, std::type_index const & derivedIndex, F && exceptionFunc )"},
{"lineNum":"  184","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  185","line":"        // First phase of lookup - match base type index"},
{"lineNum":"  186","line":"        auto const & baseMap = StaticObject<PolymorphicCasters>::getInstance().map;"},
{"lineNum":"  187","line":"        auto baseIter = baseMap.find( baseIndex );"},
{"lineNum":"  188","line":"        if( baseIter == baseMap.end() )","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  189","line":"          exceptionFunc();","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"        // Second phase - find a match from base to derived"},
{"lineNum":"  192","line":"        auto const & derivedMap = baseIter->second;","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  193","line":"        auto derivedIter = derivedMap.find( derivedIndex );"},
{"lineNum":"  194","line":"        if( derivedIter == derivedMap.end() )","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  195","line":"          exceptionFunc();","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"        return derivedIter->second;","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  198","line":"      }"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"      //! Performs a downcast to the derived type using a registered mapping"},
{"lineNum":"  201","line":"      template <class Derived> inline"},
{"lineNum":"  202","line":"      static const Derived * downcast( const void * dptr, std::type_info const & baseInfo )"},
{"lineNum":"  203","line":"      {"},
{"lineNum":"  204","line":"        auto const & mapping = lookup( baseInfo, typeid(Derived), [&](){ UNREGISTERED_POLYMORPHIC_CAST_EXCEPTION(save) } );","class":"lineNoCov","hits":"0","possible_hits":"387",},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"        for( auto const * dmap : mapping )","class":"lineNoCov","hits":"0","possible_hits":"378",},
{"lineNum":"  207","line":"          dptr = dmap->downcast( dptr );","class":"lineNoCov","hits":"0","possible_hits":"216",},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"        return static_cast<Derived const *>( dptr );"},
{"lineNum":"  210","line":"      }"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"      //! Performs an upcast to the registered base type using the given a derived type"},
{"lineNum":"  213","line":"      /*! The return is untyped because the final casting to the base type must happen in the polymorphic"},
{"lineNum":"  214","line":"          serialization function, where the type is known at compile time */"},
{"lineNum":"  215","line":"      template <class Derived> inline"},
{"lineNum":"  216","line":"      static void * upcast( Derived * const dptr, std::type_info const & baseInfo )"},
{"lineNum":"  217","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  218","line":"        auto const & mapping = lookup( baseInfo, typeid(Derived), [&](){ UNREGISTERED_POLYMORPHIC_CAST_EXCEPTION(load) } );","class":"lineNoCov","hits":"0","possible_hits":"288",},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"        void * uptr = dptr;"},
{"lineNum":"  221","line":"        for( auto mIter = mapping.rbegin(), mEnd = mapping.rend(); mIter != mEnd; ++mIter )","class":"lineNoCov","hits":"0","possible_hits":"135",},
{"lineNum":"  222","line":"          uptr = (*mIter)->upcast( uptr );","class":"lineNoCov","hits":"0","possible_hits":"90",},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"        return uptr;","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  225","line":"      }"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"      //! Upcasts for shared pointers"},
{"lineNum":"  228","line":"      template <class Derived> inline"},
{"lineNum":"  229","line":"      static std::shared_ptr<void> upcast( std::shared_ptr<Derived> const & dptr, std::type_info const & baseInfo )"},
{"lineNum":"  230","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  231","line":"        auto const & mapping = lookup( baseInfo, typeid(Derived), [&](){ UNREGISTERED_POLYMORPHIC_CAST_EXCEPTION(load) } );","class":"lineNoCov","hits":"0","possible_hits":"252",},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"        std::shared_ptr<void> uptr = dptr;"},
{"lineNum":"  234","line":"        for( auto mIter = mapping.rbegin(), mEnd = mapping.rend(); mIter != mEnd; ++mIter )","class":"lineNoCov","hits":"0","possible_hits":"55",},
{"lineNum":"  235","line":"          uptr = (*mIter)->upcast( uptr );","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"        return uptr;"},
{"lineNum":"  238","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"      #undef UNREGISTERED_POLYMORPHIC_CAST_EXCEPTION"},
{"lineNum":"  241","line":"    };"},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"    #ifdef CEREAL_OLDER_GCC"},
{"lineNum":"  244","line":"      #define CEREAL_EMPLACE_MAP(map, key, value)                     \\"},
{"lineNum":"  245","line":"      map.insert( std::make_pair(std::move(key), std::move(value)) );"},
{"lineNum":"  246","line":"    #else // NOT CEREAL_OLDER_GCC"},
{"lineNum":"  247","line":"      #define CEREAL_EMPLACE_MAP(map, key, value)                     \\"},
{"lineNum":"  248","line":"      map.emplace( key, value );"},
{"lineNum":"  249","line":"    #endif // NOT_CEREAL_OLDER_GCC"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"    //! Strongly typed derivation of PolymorphicCaster"},
{"lineNum":"  252","line":"    template <class Base, class Derived>"},
{"lineNum":"  253","line":"    struct PolymorphicVirtualCaster : PolymorphicCaster","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  254","line":"    {"},
{"lineNum":"  255","line":"      //! Inserts an entry in the polymorphic casting map for this pairing"},
{"lineNum":"  256","line":"      /*! Creates an explicit mapping between Base and Derived in both upwards and"},
{"lineNum":"  257","line":"          downwards directions, allowing void pointers to either to be properly cast"},
{"lineNum":"  258","line":"          assuming dynamic type information is available */"},
{"lineNum":"  259","line":"      PolymorphicVirtualCaster()"},
{"lineNum":"  260","line":"      {","class":"linePartCov","hits":"22","order":"95","possible_hits":"70",},
{"lineNum":"  261","line":"        const auto baseKey = std::type_index(typeid(Base));"},
{"lineNum":"  262","line":"        const auto derivedKey = std::type_index(typeid(Derived));"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"        // First insert the relation Base->Derived"},
{"lineNum":"  265","line":"        const auto lock = StaticObject<PolymorphicCasters>::lock();"},
{"lineNum":"  266","line":"        auto & baseMap = StaticObject<PolymorphicCasters>::getInstance().map;","class":"lineCov","hits":"1","order":"96","possible_hits":"1",},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"        {"},
{"lineNum":"  269","line":"          auto & derivedMap = baseMap.insert( {baseKey, PolymorphicCasters::DerivedCasterMap{}} ).first->second;","class":"linePartCov","hits":"33","order":"97","possible_hits":"81",},
{"lineNum":"  270","line":"          auto & derivedVec = derivedMap.insert( {derivedKey, {}} ).first->second;","class":"linePartCov","hits":"22","order":"185","possible_hits":"68",},
{"lineNum":"  271","line":"          derivedVec.push_back( this );","class":"lineCov","hits":"11","order":"190","possible_hits":"11",},
{"lineNum":"  272","line":"        }"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"        // Insert reverse relation Derived->Base"},
{"lineNum":"  275","line":"        auto & reverseMap = StaticObject<PolymorphicCasters>::getInstance().reverseMap;"},
{"lineNum":"  276","line":"        CEREAL_EMPLACE_MAP(reverseMap, derivedKey, baseKey);"},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"        // Find all chainable unregistered relations"},
{"lineNum":"  279","line":"        /* The strategy here is to process only the nodes in the class hierarchy graph that have been"},
{"lineNum":"  280","line":"           affected by the new insertion. The aglorithm iteratively processes a node an ensures that it"},
{"lineNum":"  281","line":"           is updated with all new shortest length paths. It then rocesses the parents of the active node,"},
{"lineNum":"  282","line":"           with the knowledge that all children have already been processed."},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"           Note that for the following, we\'ll use the nomenclature of parent and child to not confuse with"},
{"lineNum":"  285","line":"           the inserted base derived relationship */"},
{"lineNum":"  286","line":"        {"},
{"lineNum":"  287","line":"          // Checks whether there is a path from parent->child and returns a <dist, path> pair"},
{"lineNum":"  288","line":"          // dist is set to MAX if the path does not exist"},
{"lineNum":"  289","line":"          auto checkRelation = [](std::type_index const & parentInfo, std::type_index const & childInfo) ->"},
{"lineNum":"  290","line":"            std::pair<size_t, std::vector<PolymorphicCaster const *> const &>"},
{"lineNum":"  291","line":"          {","class":"linePartCov","hits":"2","order":"530","possible_hits":"11",},
{"lineNum":"  292","line":"            auto result = PolymorphicCasters::lookup_if_exists( parentInfo, childInfo );","class":"linePartCov","hits":"2","order":"531","possible_hits":"83",},
{"lineNum":"  293","line":"            if( result.first )","class":"linePartCov","hits":"2","order":"539","possible_hits":"83",},
{"lineNum":"  294","line":"            {"},
{"lineNum":"  295","line":"              auto const & path = result.second;","class":"linePartCov","hits":"2","order":"540","possible_hits":"11",},
{"lineNum":"  296","line":"              return {path.size(), path};"},
{"lineNum":"  297","line":"            }"},
{"lineNum":"  298","line":"            else"},
{"lineNum":"  299","line":"              return {(std::numeric_limits<size_t>::max)(), {}};","class":"linePartCov","hits":"2","order":"546","possible_hits":"11",},
{"lineNum":"  300","line":"          };","class":"linePartCov","hits":"2","order":"541","possible_hits":"22",},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"          std::stack<std::type_index>         parentStack;      // Holds the parent nodes to be processed"},
{"lineNum":"  303","line":"          std::vector<std::type_index> dirtySet;                // Marks child nodes that have been changed"},
{"lineNum":"  304","line":"          std::unordered_set<std::type_index> processedParents; // Marks parent nodes that have been processed","class":"lineCov","hits":"11","order":"242","possible_hits":"11",},
{"lineNum":"  305","line":""},
{"lineNum":"  306","line":"          // Checks if a child has been marked dirty"},
{"lineNum":"  307","line":"          auto isDirty = [&](std::type_index const & c)"},
{"lineNum":"  308","line":"          {"},
{"lineNum":"  309","line":"            auto const dirtySetSize = dirtySet.size();"},
{"lineNum":"  310","line":"            for( size_t i = 0; i < dirtySetSize; ++i )","class":"linePartCov","hits":"23","order":"317","possible_hits":"140",},
{"lineNum":"  311","line":"              if( dirtySet[i] == c )","class":"linePartCov","hits":"11","order":"318","possible_hits":"70",},
{"lineNum":"  312","line":"                return true;"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"            return false;"},
{"lineNum":"  315","line":"          };"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"          // Begin processing the base key and mark derived as dirty"},
{"lineNum":"  318","line":"          parentStack.push( baseKey );"},
{"lineNum":"  319","line":"          dirtySet.emplace_back( derivedKey );","class":"lineCov","hits":"11","order":"277","possible_hits":"11",},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"          while( !parentStack.empty() )","class":"linePartCov","hits":"12","order":"286","possible_hits":"62",},
{"lineNum":"  322","line":"          {"},
{"lineNum":"  323","line":"            using Relations = std::unordered_multimap<std::type_index, std::pair<std::type_index, std::vector<PolymorphicCaster const *>>>;"},
{"lineNum":"  324","line":"            Relations unregisteredRelations; // Defer insertions until after main loop to prevent iterator invalidation","class":"lineCov","hits":"11","order":"288","possible_hits":"11",},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"            const auto parent = parentStack.top();","class":"linePartCov","hits":"11","order":"293","possible_hits":"35",},
{"lineNum":"  327","line":"            parentStack.pop();"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"            // Update paths to all children marked dirty"},
{"lineNum":"  330","line":"            for( auto const & childPair : baseMap[parent] )","class":"linePartCov","hits":"22","order":"315","possible_hits":"46",},
{"lineNum":"  331","line":"            {"},
{"lineNum":"  332","line":"              const auto child = childPair.first;","class":"linePartCov","hits":"11","order":"316","possible_hits":"35",},
{"lineNum":"  333","line":"              if( isDirty( child ) && baseMap.count( child ) )","class":"linePartCov","hits":"28","order":"334","possible_hits":"57",},
{"lineNum":"  334","line":"              {"},
{"lineNum":"  335","line":"                auto parentChildPath = checkRelation( parent, child );","class":"linePartCov","hits":"2","order":"529","possible_hits":"11",},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"                // Search all paths from the child to its own children (finalChild),"},
{"lineNum":"  338","line":"                // looking for a shorter parth from parent to finalChild"},
{"lineNum":"  339","line":"                for( auto const & finalChildPair : baseMap[child] )","class":"linePartCov","hits":"6","order":"542","possible_hits":"57",},
{"lineNum":"  340","line":"                {"},
{"lineNum":"  341","line":"                  const auto finalChild = finalChildPair.first;","class":"linePartCov","hits":"2","order":"543","possible_hits":"35",},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"                  auto parentFinalChildPath = checkRelation( parent, finalChild );","class":"linePartCov","hits":"2","order":"544","possible_hits":"11",},
{"lineNum":"  344","line":"                  auto childFinalChildPath  = checkRelation( child, finalChild );","class":"linePartCov","hits":"2","order":"547","possible_hits":"11",},
{"lineNum":"  345","line":""},
{"lineNum":"  346","line":"                  const size_t newLength = 1u + parentChildPath.first;"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"                  if( newLength < parentFinalChildPath.first )","class":"linePartCov","hits":"2","order":"548","possible_hits":"35",},
{"lineNum":"  349","line":"                  {"},
{"lineNum":"  350","line":"                    std::vector<PolymorphicCaster const *> path = parentChildPath.second;","class":"linePartCov","hits":"2","order":"549","possible_hits":"11",},
{"lineNum":"  351","line":"                    path.insert( path.end(), childFinalChildPath.second.begin(), childFinalChildPath.second.end() );","class":"linePartCov","hits":"2","order":"567","possible_hits":"35",},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"                    // Check to see if we have a previous uncommitted path in unregisteredRelations"},
{"lineNum":"  354","line":"                    // that is shorter. If so, ignore this path"},
{"lineNum":"  355","line":"                    auto hintRange = unregisteredRelations.equal_range( parent );"},
{"lineNum":"  356","line":"                    auto hint = hintRange.first;"},
{"lineNum":"  357","line":"                    for( ; hint != hintRange.second; ++hint )","class":"linePartCov","hits":"2","order":"600","possible_hits":"102",},
{"lineNum":"  358","line":"                      if( hint->second.first == finalChild )","class":"lineNoCov","hits":"0","possible_hits":"57",},
{"lineNum":"  359","line":"                        break;","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  360","line":""},
{"lineNum":"  361","line":"                    const bool uncommittedExists = hint != unregisteredRelations.end();"},
{"lineNum":"  362","line":"                    if( uncommittedExists && (hint->second.second.size() <= newLength) )","class":"linePartCov","hits":"2","order":"601","possible_hits":"70",},
{"lineNum":"  363","line":"                      continue;"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"                    auto newPath = std::pair<std::type_index, std::vector<PolymorphicCaster const *>>{finalChild, std::move(path)};"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"                    // Insert the new path if it doesn\'t exist, otherwise this will just lookup where to do the"},
{"lineNum":"  368","line":"                    // replacement"},
{"lineNum":"  369","line":"                    #ifdef CEREAL_OLDER_GCC"},
{"lineNum":"  370","line":"                    auto old = unregisteredRelations.insert( hint, std::make_pair(parent, newPath) );"},
{"lineNum":"  371","line":"                    #else // NOT CEREAL_OLDER_GCC"},
{"lineNum":"  372","line":"                    auto old = unregisteredRelations.emplace_hint( hint, parent, newPath );"},
{"lineNum":"  373","line":"                    #endif // NOT CEREAL_OLDER_GCC"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"                    // If there was an uncommitted path, we need to perform a replacement"},
{"lineNum":"  376","line":"                    if( uncommittedExists )","class":"linePartCov","hits":"2","order":"640","possible_hits":"35",},
{"lineNum":"  377","line":"                      old->second = newPath;","class":"lineNoCov","hits":"0","possible_hits":"46",},
{"lineNum":"  378","line":"                  }","class":"linePartCov","hits":"4","order":"641","possible_hits":"33",},
{"lineNum":"  379","line":"                } // end loop over child\'s children","class":"linePartCov","hits":"2","order":"642","possible_hits":"11",},
{"lineNum":"  380","line":"              } // end if dirty and child has children","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  381","line":"            } // end loop over children","class":"lineCov","hits":"11","order":"336","possible_hits":"11",},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"            // Insert chained relations"},
{"lineNum":"  384","line":"            for( auto const & it : unregisteredRelations )","class":"linePartCov","hits":"11","order":"338","possible_hits":"60",},
{"lineNum":"  385","line":"            {"},
{"lineNum":"  386","line":"              auto & derivedMap = baseMap.find( it.first )->second;","class":"linePartCov","hits":"2","order":"652","possible_hits":"35",},
{"lineNum":"  387","line":"              derivedMap[it.second.first] = it.second.second;","class":"linePartCov","hits":"4","order":"653","possible_hits":"70",},
{"lineNum":"  388","line":"              CEREAL_EMPLACE_MAP(reverseMap, it.second.first, it.first );","class":"linePartCov","hits":"4","order":"668","possible_hits":"22",},
{"lineNum":"  389","line":"            }"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"            // Mark current parent as modified"},
{"lineNum":"  392","line":"            dirtySet.emplace_back( parent );"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"            // Insert all parents of the current parent node that haven\'t yet been processed"},
{"lineNum":"  395","line":"            auto parentRange = reverseMap.equal_range( parent );"},
{"lineNum":"  396","line":"            for( auto pIter = parentRange.first; pIter != parentRange.second; ++pIter )","class":"linePartCov","hits":"11","order":"354","possible_hits":"70",},
{"lineNum":"  397","line":"            {"},
{"lineNum":"  398","line":"              const auto pParent = pIter->second;","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  399","line":"              if( !processedParents.count( pParent ) )","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  400","line":"              {"},
{"lineNum":"  401","line":"                parentStack.push( pParent );","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  402","line":"                processedParents.insert( pParent );","class":"lineNoCov","hits":"0","possible_hits":"22",},
{"lineNum":"  403","line":"              }"},
{"lineNum":"  404","line":"            }","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  405","line":"          } // end loop over parent stack","class":"lineCov","hits":"11","order":"355","possible_hits":"11",},
{"lineNum":"  406","line":"        } // end chainable relations"},
{"lineNum":"  407","line":"      } // end PolymorphicVirtualCaster()","class":"linePartCov","hits":"11","order":"380","possible_hits":"101",},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"      #undef CEREAL_EMPLACE_MAP"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"      //! Performs the proper downcast with the templated types"},
{"lineNum":"  412","line":"      void const * downcast( void const * const ptr ) const override"},
{"lineNum":"  413","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  414","line":"        return dynamic_cast<Derived const*>( static_cast<Base const*>( ptr ) );","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  415","line":"      }"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"      //! Performs the proper upcast with the templated types"},
{"lineNum":"  418","line":"      void * upcast( void * const ptr ) const override"},
{"lineNum":"  419","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  420","line":"        return dynamic_cast<Base*>( static_cast<Derived*>( ptr ) );","class":"lineNoCov","hits":"0","possible_hits":"70",},
{"lineNum":"  421","line":"      }"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"      //! Performs the proper upcast with the templated types (shared_ptr version)"},
{"lineNum":"  424","line":"      std::shared_ptr<void> upcast( std::shared_ptr<void> const & ptr ) const override"},
{"lineNum":"  425","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"35",},
{"lineNum":"  426","line":"        return std::dynamic_pointer_cast<Base>( std::static_pointer_cast<Derived>( ptr ) );","class":"lineNoCov","hits":"0","possible_hits":"70",},
{"lineNum":"  427","line":"      }"},
{"lineNum":"  428","line":"    };"},
{"lineNum":"  429","line":""},
{"lineNum":"  430","line":"    //! Registers a polymorphic casting relation between a Base and Derived type"},
{"lineNum":"  431","line":"    /*! Registering a relation allows cereal to properly cast between the two types"},
{"lineNum":"  432","line":"        given runtime type information and void pointers."},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"        Registration happens automatically via cereal::base_class and cereal::virtual_base_class"},
{"lineNum":"  435","line":"        instantiations. For cases where neither is called, see the CEREAL_REGISTER_POLYMORPHIC_RELATION"},
{"lineNum":"  436","line":"        macro */"},
{"lineNum":"  437","line":"    template <class Base, class Derived>"},
{"lineNum":"  438","line":"    struct RegisterPolymorphicCaster"},
{"lineNum":"  439","line":"    {"},
{"lineNum":"  440","line":"      static PolymorphicCaster const * bind( std::true_type /* is_polymorphic<Base> */)"},
{"lineNum":"  441","line":"      {"},
{"lineNum":"  442","line":"        return &StaticObject<PolymorphicVirtualCaster<Base, Derived>>::getInstance();"},
{"lineNum":"  443","line":"      }"},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"      static PolymorphicCaster const * bind( std::false_type /* is_polymorphic<Base> */ )"},
{"lineNum":"  446","line":"      { return nullptr; }"},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"      //! Performs registration (binding) between Base and Derived"},
{"lineNum":"  449","line":"      /*! If the type is not polymorphic, nothing will happen */"},
{"lineNum":"  450","line":"      static PolymorphicCaster const * bind()"},
{"lineNum":"  451","line":"      { return bind( typename std::is_polymorphic<Base>::type() ); }"},
{"lineNum":"  452","line":"    };"},
{"lineNum":"  453","line":"  }"},
{"lineNum":"  454","line":""},
{"lineNum":"  455","line":"  /* General polymorphism support */"},
{"lineNum":"  456","line":"  namespace detail"},
{"lineNum":"  457","line":"  {"},
{"lineNum":"  458","line":"    //! Binds a compile time type with a user defined string"},
{"lineNum":"  459","line":"    template <class T>"},
{"lineNum":"  460","line":"    struct binding_name {};"},
{"lineNum":"  461","line":""},
{"lineNum":"  462","line":"    //! A structure holding a map from type_indices to output serializer functions"},
{"lineNum":"  463","line":"    /*! A static object of this map should be created for each registered archive"},
{"lineNum":"  464","line":"        type, containing entries for every registered type that describe how to"},
{"lineNum":"  465","line":"        properly cast the type to its real type in polymorphic scenarios for"},
{"lineNum":"  466","line":"        shared_ptr, weak_ptr, and unique_ptr. */"},
{"lineNum":"  467","line":"    template <class Archive>"},
{"lineNum":"  468","line":"    struct OutputBindingMap","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  469","line":"    {"},
{"lineNum":"  470","line":"      //! A serializer function"},
{"lineNum":"  471","line":"      /*! Serializer functions return nothing and take an archive as"},
{"lineNum":"  472","line":"          their first parameter (will be cast properly inside the function,"},
{"lineNum":"  473","line":"          a pointer to actual data (contents of smart_ptr\'s get() function)"},
{"lineNum":"  474","line":"          as their second parameter, and the type info of the owning smart_ptr"},
{"lineNum":"  475","line":"          as their final parameter */"},
{"lineNum":"  476","line":"      typedef std::function<void(void*, void const *, std::type_info const &)> Serializer;"},
{"lineNum":"  477","line":""},
{"lineNum":"  478","line":"      //! Struct containing the serializer functions for all pointer types"},
{"lineNum":"  479","line":"      struct Serializers","class":"linePartCov","hits":"6","order":"56","possible_hits":"87",},
{"lineNum":"  480","line":"      {"},
{"lineNum":"  481","line":"        Serializer shared_ptr, //!< Serializer function for shared/weak pointers"},
{"lineNum":"  482","line":"                   unique_ptr; //!< Serializer function for unique pointers"},
{"lineNum":"  483","line":"      };"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"      //! A map of serializers for pointers of all registered types"},
{"lineNum":"  486","line":"      std::map<std::type_index, Serializers> map;"},
{"lineNum":"  487","line":"    };"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"    //! An empty noop deleter"},
{"lineNum":"  490","line":"    template<class T> struct EmptyDeleter { void operator()(T *) const {} };"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"    //! A structure holding a map from type name strings to input serializer functions"},
{"lineNum":"  493","line":"    /*! A static object of this map should be created for each registered archive"},
{"lineNum":"  494","line":"        type, containing entries for every registered type that describe how to"},
{"lineNum":"  495","line":"        properly cast the type to its real type in polymorphic scenarios for"},
{"lineNum":"  496","line":"        shared_ptr, weak_ptr, and unique_ptr. */"},
{"lineNum":"  497","line":"    template <class Archive>"},
{"lineNum":"  498","line":"    struct InputBindingMap","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  499","line":"    {"},
{"lineNum":"  500","line":"      //! Shared ptr serializer function"},
{"lineNum":"  501","line":"      /*! Serializer functions return nothing and take an archive as"},
{"lineNum":"  502","line":"          their first parameter (will be cast properly inside the function,"},
{"lineNum":"  503","line":"          a shared_ptr (or unique_ptr for the unique case) of any base"},
{"lineNum":"  504","line":"          type, and the type id of said base type as the third parameter."},
{"lineNum":"  505","line":"          Internally it will properly be loaded and cast to the correct type. */"},
{"lineNum":"  506","line":"      typedef std::function<void(void*, std::shared_ptr<void> &, std::type_info const &)> SharedSerializer;"},
{"lineNum":"  507","line":"      //! Unique ptr serializer function"},
{"lineNum":"  508","line":"      typedef std::function<void(void*, std::unique_ptr<void, EmptyDeleter<void>> &, std::type_info const &)> UniqueSerializer;"},
{"lineNum":"  509","line":""},
{"lineNum":"  510","line":"      //! Struct containing the serializer functions for all pointer types"},
{"lineNum":"  511","line":"      struct Serializers","class":"linePartCov","hits":"6","order":"392","possible_hits":"93",},
{"lineNum":"  512","line":"      {"},
{"lineNum":"  513","line":"        SharedSerializer shared_ptr; //!< Serializer function for shared/weak pointers"},
{"lineNum":"  514","line":"        UniqueSerializer unique_ptr; //!< Serializer function for unique pointers"},
{"lineNum":"  515","line":"      };"},
{"lineNum":"  516","line":""},
{"lineNum":"  517","line":"      //! A map of serializers for pointers of all registered types"},
{"lineNum":"  518","line":"      std::map<std::string, Serializers> map;"},
{"lineNum":"  519","line":"    };"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"    // forward decls for archives from cereal.hpp"},
{"lineNum":"  522","line":"    class InputArchiveBase;"},
{"lineNum":"  523","line":"    class OutputArchiveBase;"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":"    //! Creates a binding (map entry) between an input archive type and a polymorphic type"},
{"lineNum":"  526","line":"    /*! Bindings are made when types are registered, assuming that at least one"},
{"lineNum":"  527","line":"        archive has already been registered.  When this struct is created,"},
{"lineNum":"  528","line":"        it will insert (at run time) an entry into a map that properly handles"},
{"lineNum":"  529","line":"        casting for serializing polymorphic objects */"},
{"lineNum":"  530","line":"    template <class Archive, class T> struct InputBindingCreator"},
{"lineNum":"  531","line":"    {"},
{"lineNum":"  532","line":"      //! Initialize the binding"},
{"lineNum":"  533","line":"      InputBindingCreator()"},
{"lineNum":"  534","line":"      {","class":"linePartCov","hits":"27","order":"381","possible_hits":"81",},
{"lineNum":"  535","line":"        auto & map = StaticObject<InputBindingMap<Archive>>::getInstance().map;","class":"lineCov","hits":"54","order":"382","possible_hits":"54",},
{"lineNum":"  536","line":"        auto lock = StaticObject<InputBindingMap<Archive>>::lock();"},
{"lineNum":"  537","line":"        auto key = std::string(binding_name<T>::name());"},
{"lineNum":"  538","line":"        auto lb = map.lower_bound(key);"},
{"lineNum":"  539","line":""},
{"lineNum":"  540","line":"        if (lb != map.end() && lb->first == key)","class":"linePartCov","hits":"39","order":"386","possible_hits":"126",},
{"lineNum":"  541","line":"          return;"},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"        typename InputBindingMap<Archive>::Serializers serializers;"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"        serializers.shared_ptr =","class":"lineCov","hits":"27","order":"387","possible_hits":"27",},
{"lineNum":"  546","line":"          [](void * arptr, std::shared_ptr<void> & dptr, std::type_info const & baseInfo)"},
{"lineNum":"  547","line":"          {","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  548","line":"            Archive & ar = *static_cast<Archive*>(arptr);"},
{"lineNum":"  549","line":"            std::shared_ptr<T> ptr;"},
{"lineNum":"  550","line":""},
{"lineNum":"  551","line":"            ar( CEREAL_NVP_(\"ptr_wrapper\", ::cereal::memory_detail::make_ptr_wrapper(ptr)) );","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  552","line":""},
{"lineNum":"  553","line":"            dptr = PolymorphicCasters::template upcast<T>( ptr, baseInfo );","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  554","line":"          };","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"        serializers.unique_ptr =","class":"lineCov","hits":"27","order":"388","possible_hits":"27",},
{"lineNum":"  557","line":"          [](void * arptr, std::unique_ptr<void, EmptyDeleter<void>> & dptr, std::type_info const & baseInfo)"},
{"lineNum":"  558","line":"          {","class":"lineNoCov","hits":"0","possible_hits":"49",},
{"lineNum":"  559","line":"            Archive & ar = *static_cast<Archive*>(arptr);"},
{"lineNum":"  560","line":"            std::unique_ptr<T> ptr;"},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"            ar( CEREAL_NVP_(\"ptr_wrapper\", ::cereal::memory_detail::make_ptr_wrapper(ptr)) );","class":"lineNoCov","hits":"0","possible_hits":"72",},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"            dptr.reset( PolymorphicCasters::template upcast<T>( ptr.release(), baseInfo ));","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  565","line":"          };","class":"lineNoCov","hits":"0","possible_hits":"49",},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"        map.insert( lb, { std::move(key), std::move(serializers) } );","class":"linePartCov","hits":"27","order":"409","possible_hits":"108",},
{"lineNum":"  568","line":"      }","class":"linePartCov","hits":"27","order":"413","possible_hits":"162",},
{"lineNum":"  569","line":"    };"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"    //! Creates a binding (map entry) between an output archive type and a polymorphic type"},
{"lineNum":"  572","line":"    /*! Bindings are made when types are registered, assuming that at least one"},
{"lineNum":"  573","line":"        archive has already been registered.  When this struct is created,"},
{"lineNum":"  574","line":"        it will insert (at run time) an entry into a map that properly handles"},
{"lineNum":"  575","line":"        casting for serializing polymorphic objects */"},
{"lineNum":"  576","line":"    template <class Archive, class T> struct OutputBindingCreator"},
{"lineNum":"  577","line":"    {"},
{"lineNum":"  578","line":"      //! Writes appropriate metadata to the archive for this polymorphic type"},
{"lineNum":"  579","line":"      static void writeMetadata(Archive & ar)"},
{"lineNum":"  580","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  581","line":"        // Register the polymorphic type name with the archive, and get the id"},
{"lineNum":"  582","line":"        char const * name = binding_name<T>::name();"},
{"lineNum":"  583","line":"        std::uint32_t id = ar.registerPolymorphicType(name);","class":"lineNoCov","hits":"0","possible_hits":"72",},
{"lineNum":"  584","line":""},
{"lineNum":"  585","line":"        // Serialize the id"},
{"lineNum":"  586","line":"        ar( CEREAL_NVP_(\"polymorphic_id\", id) );","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  587","line":""},
{"lineNum":"  588","line":"        // If the msb of the id is 1, then the type name is new, and we should serialize it"},
{"lineNum":"  589","line":"        if( id & detail::msb_32bit )","class":"lineNoCov","hits":"0","possible_hits":"99",},
{"lineNum":"  590","line":"        {"},
{"lineNum":"  591","line":"          std::string namestring(name);"},
{"lineNum":"  592","line":"          ar( CEREAL_NVP_(\"polymorphic_name\", namestring) );","class":"lineNoCov","hits":"0","possible_hits":"28",},
{"lineNum":"  593","line":"        }","class":"lineNoCov","hits":"0","possible_hits":"36",},
{"lineNum":"  594","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"135",},
{"lineNum":"  595","line":""},
{"lineNum":"  596","line":"      //! Holds a properly typed shared_ptr to the polymorphic type"},
{"lineNum":"  597","line":"      class PolymorphicSharedPointerWrapper","class":"lineNoCov","hits":"0","possible_hits":"72",},
{"lineNum":"  598","line":"      {"},
{"lineNum":"  599","line":"        public:"},
{"lineNum":"  600","line":"          /*! Wrap a raw polymorphic pointer in a shared_ptr to its true type"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"              The wrapped pointer will not be responsible for ownership of the held pointer"},
{"lineNum":"  603","line":"              so it will not attempt to destroy it; instead the refcount of the wrapped"},
{"lineNum":"  604","line":"              pointer will be tied to a fake \'ownership pointer\' that will do nothing"},
{"lineNum":"  605","line":"              when it ultimately goes out of scope."},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"              The main reason for doing this, other than not to destroy the true object"},
{"lineNum":"  608","line":"              with our wrapper pointer, is to avoid meddling with the internal reference"},
{"lineNum":"  609","line":"              count in a polymorphic type that inherits from std::enable_shared_from_this."},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"              @param dptr A void pointer to the contents of the shared_ptr to serialize */"},
{"lineNum":"  612","line":"          PolymorphicSharedPointerWrapper( T const * dptr ) : refCount(), wrappedPtr( refCount, dptr )"},
{"lineNum":"  613","line":"          { }"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"          //! Get the wrapped shared_ptr */"},
{"lineNum":"  616","line":"          inline std::shared_ptr<T const> const & operator()() const { return wrappedPtr; }"},
{"lineNum":"  617","line":""},
{"lineNum":"  618","line":"        private:"},
{"lineNum":"  619","line":"          std::shared_ptr<void> refCount;      //!< The ownership pointer"},
{"lineNum":"  620","line":"          std::shared_ptr<T const> wrappedPtr; //!< The wrapped pointer"},
{"lineNum":"  621","line":"      };"},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"      //! Does the actual work of saving a polymorphic shared_ptr"},
{"lineNum":"  624","line":"      /*! This function will properly create a shared_ptr from the void * that is passed in"},
{"lineNum":"  625","line":"          before passing it to the archive for serialization."},
{"lineNum":"  626","line":""},
{"lineNum":"  627","line":"          In addition, this will also preserve the state of any internal enable_shared_from_this mechanisms"},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"          @param ar The archive to serialize to"},
{"lineNum":"  630","line":"          @param dptr Pointer to the actual data held by the shared_ptr */"},
{"lineNum":"  631","line":"      static inline void savePolymorphicSharedPtr( Archive & ar, T const * dptr, std::true_type /* has_shared_from_this */ )"},
{"lineNum":"  632","line":"      {"},
{"lineNum":"  633","line":"        ::cereal::memory_detail::EnableSharedStateHelper<T> state( const_cast<T *>(dptr) );"},
{"lineNum":"  634","line":"        PolymorphicSharedPointerWrapper psptr( dptr );"},
{"lineNum":"  635","line":"        ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper( psptr() ) ) );"},
{"lineNum":"  636","line":"      }"},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"      //! Does the actual work of saving a polymorphic shared_ptr"},
{"lineNum":"  639","line":"      /*! This function will properly create a shared_ptr from the void * that is passed in"},
{"lineNum":"  640","line":"          before passing it to the archive for serialization."},
{"lineNum":"  641","line":""},
{"lineNum":"  642","line":"          This version is for types that do not inherit from std::enable_shared_from_this."},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":"          @param ar The archive to serialize to"},
{"lineNum":"  645","line":"          @param dptr Pointer to the actual data held by the shared_ptr */"},
{"lineNum":"  646","line":"      static inline void savePolymorphicSharedPtr( Archive & ar, T const * dptr, std::false_type /* has_shared_from_this */ )"},
{"lineNum":"  647","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"45",},
{"lineNum":"  648","line":"        PolymorphicSharedPointerWrapper psptr( dptr );"},
{"lineNum":"  649","line":"        ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper( psptr() ) ) );","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  650","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"45",},
{"lineNum":"  651","line":""},
{"lineNum":"  652","line":"      //! Initialize the binding"},
{"lineNum":"  653","line":"      OutputBindingCreator()"},
{"lineNum":"  654","line":"      {","class":"linePartCov","hits":"27","order":"5","possible_hits":"81",},
{"lineNum":"  655","line":"        auto & map = StaticObject<OutputBindingMap<Archive>>::getInstance().map;","class":"lineCov","hits":"27","order":"6","possible_hits":"27",},
{"lineNum":"  656","line":"        auto key = std::type_index(typeid(T));"},
{"lineNum":"  657","line":"        auto lb = map.lower_bound(key);"},
{"lineNum":"  658","line":""},
{"lineNum":"  659","line":"        if (lb != map.end() && lb->first == key)","class":"linePartCov","hits":"39","order":"22","possible_hits":"162",},
{"lineNum":"  660","line":"          return;"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"        typename OutputBindingMap<Archive>::Serializers serializers;"},
{"lineNum":"  663","line":""},
{"lineNum":"  664","line":"        serializers.shared_ptr =","class":"lineCov","hits":"27","order":"24","possible_hits":"27",},
{"lineNum":"  665","line":"          [&](void * arptr, void const * dptr, std::type_info const & baseInfo)"},
{"lineNum":"  666","line":"          {","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  667","line":"            Archive & ar = *static_cast<Archive*>(arptr);"},
{"lineNum":"  668","line":"            writeMetadata(ar);","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  669","line":""},
{"lineNum":"  670","line":"            auto ptr = PolymorphicCasters::template downcast<T>( dptr, baseInfo );"},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":"            #if defined(_MSC_VER) && _MSC_VER < 1916 && !defined(__clang__)"},
{"lineNum":"  673","line":"            savePolymorphicSharedPtr( ar, ptr, ::cereal::traits::has_shared_from_this<T>::type() ); // MSVC doesn\'t like typename here"},
{"lineNum":"  674","line":"            #else // not _MSC_VER"},
{"lineNum":"  675","line":"            savePolymorphicSharedPtr( ar, ptr, typename ::cereal::traits::has_shared_from_this<T>::type() );","class":"lineNoCov","hits":"0","possible_hits":"45",},
{"lineNum":"  676","line":"            #endif // _MSC_VER"},
{"lineNum":"  677","line":"          };","class":"lineNoCov","hits":"0","possible_hits":"54",},
{"lineNum":"  678","line":""},
{"lineNum":"  679","line":"        serializers.unique_ptr =","class":"lineCov","hits":"27","order":"54","possible_hits":"27",},
{"lineNum":"  680","line":"          [&](void * arptr, void const * dptr, std::type_info const & baseInfo)"},
{"lineNum":"  681","line":"          {","class":"lineNoCov","hits":"0","possible_hits":"45",},
{"lineNum":"  682","line":"            Archive & ar = *static_cast<Archive*>(arptr);"},
{"lineNum":"  683","line":"            writeMetadata(ar);","class":"lineNoCov","hits":"0","possible_hits":"81",},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"            std::unique_ptr<T const, EmptyDeleter<T const>> const ptr( PolymorphicCasters::template downcast<T>( dptr, baseInfo ) );"},
{"lineNum":"  686","line":""},
{"lineNum":"  687","line":"            ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper(ptr)) );","class":"lineNoCov","hits":"0","possible_hits":"63",},
{"lineNum":"  688","line":"          };","class":"lineNoCov","hits":"0","possible_hits":"63",},
{"lineNum":"  689","line":""},
{"lineNum":"  690","line":"        map.insert( { std::move(key), std::move(serializers) } );","class":"linePartCov","hits":"27","order":"93","possible_hits":"108",},
{"lineNum":"  691","line":"      }","class":"linePartCov","hits":"27","order":"94","possible_hits":"162",},
{"lineNum":"  692","line":"    };"},
{"lineNum":"  693","line":""},
{"lineNum":"  694","line":"    //! Used to help out argument dependent lookup for finding potential overloads"},
{"lineNum":"  695","line":"    //! of instantiate_polymorphic_binding"},
{"lineNum":"  696","line":"    struct adl_tag {};"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"    //! Tag for init_binding, bind_to_archives and instantiate_polymorphic_binding."},
{"lineNum":"  699","line":"    //! For C++14 and below, we must instantiate a unique StaticObject per TU that is"},
{"lineNum":"  700","line":"    //! otherwise identical -- otherwise we get multiple definition problems (ODR violations)."},
{"lineNum":"  701","line":"    //! To achieve this, put a tag in an anonymous namespace and use it as a template argument."},
{"lineNum":"  702","line":"    //!"},
{"lineNum":"  703","line":"    //! For C++17, we can use static inline global variables to unify these definitions across"},
{"lineNum":"  704","line":"    //! all TUs in the same shared object (DLL).  The tag is therefore not necessary."},
{"lineNum":"  705","line":"    //! For convenience, keep it to not complicate other code, but don\'t put it in"},
{"lineNum":"  706","line":"    //! an anonymous namespace.  Now the template instantiations will correspond"},
{"lineNum":"  707","line":"    //! to the same type, and since they are marked inline with C++17, they will be merged"},
{"lineNum":"  708","line":"    //! across all TUs."},
{"lineNum":"  709","line":"#ifdef CEREAL_HAS_CPP17"},
{"lineNum":"  710","line":"    struct polymorphic_binding_tag {};"},
{"lineNum":"  711","line":"#else"},
{"lineNum":"  712","line":"    namespace { struct polymorphic_binding_tag {}; }"},
{"lineNum":"  713","line":"#endif"},
{"lineNum":"  714","line":""},
{"lineNum":"  715","line":""},
{"lineNum":"  716","line":"    //! Causes the static object bindings between an archive type and a serializable type T"},
{"lineNum":"  717","line":"    template <class Archive, class T>"},
{"lineNum":"  718","line":"    struct create_bindings"},
{"lineNum":"  719","line":"    {"},
{"lineNum":"  720","line":"      static const InputBindingCreator<Archive, T> &"},
{"lineNum":"  721","line":"      load(std::true_type)"},
{"lineNum":"  722","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  723","line":"        return cereal::detail::StaticObject<InputBindingCreator<Archive, T>>::getInstance();","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  724","line":"      }"},
{"lineNum":"  725","line":""},
{"lineNum":"  726","line":"      static const OutputBindingCreator<Archive, T> &"},
{"lineNum":"  727","line":"      save(std::true_type)"},
{"lineNum":"  728","line":"      {","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  729","line":"        return cereal::detail::StaticObject<OutputBindingCreator<Archive, T>>::getInstance();","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  730","line":"      }"},
{"lineNum":"  731","line":""},
{"lineNum":"  732","line":"      inline static void load(std::false_type) {}"},
{"lineNum":"  733","line":"      inline static void save(std::false_type) {}"},
{"lineNum":"  734","line":"    };"},
{"lineNum":"  735","line":""},
{"lineNum":"  736","line":"    //! When specialized, causes the compiler to instantiate its parameter"},
{"lineNum":"  737","line":"    template <void(*)()>"},
{"lineNum":"  738","line":"    struct instantiate_function {};"},
{"lineNum":"  739","line":""},
{"lineNum":"  740","line":"    /*! This struct is used as the return type of instantiate_polymorphic_binding"},
{"lineNum":"  741","line":"        for specific Archive types.  When the compiler looks for overloads of"},
{"lineNum":"  742","line":"        instantiate_polymorphic_binding, it will be forced to instantiate this"},
{"lineNum":"  743","line":"        struct during overload resolution, even though it will not be part of a valid"},
{"lineNum":"  744","line":"        overload */"},
{"lineNum":"  745","line":"    template <class Archive, class T>"},
{"lineNum":"  746","line":"    struct polymorphic_serialization_support"},
{"lineNum":"  747","line":"    {"},
{"lineNum":"  748","line":"      #if defined(_MSC_VER) && !defined(__INTEL_COMPILER)"},
{"lineNum":"  749","line":"      //! Creates the appropriate bindings depending on whether the archive supports"},
{"lineNum":"  750","line":"      //! saving or loading"},
{"lineNum":"  751","line":"      virtual CEREAL_DLL_EXPORT void instantiate() CEREAL_USED;"},
{"lineNum":"  752","line":"      #else // NOT _MSC_VER"},
{"lineNum":"  753","line":"      //! Creates the appropriate bindings depending on whether the archive supports"},
{"lineNum":"  754","line":"      //! saving or loading"},
{"lineNum":"  755","line":"      static CEREAL_DLL_EXPORT void instantiate() CEREAL_USED;"},
{"lineNum":"  756","line":"      //! This typedef causes the compiler to instantiate this static function"},
{"lineNum":"  757","line":"      typedef instantiate_function<instantiate> unused;"},
{"lineNum":"  758","line":"      #endif // _MSC_VER"},
{"lineNum":"  759","line":"    };"},
{"lineNum":"  760","line":""},
{"lineNum":"  761","line":"    // instantiate implementation"},
{"lineNum":"  762","line":"    template <class Archive, class T>"},
{"lineNum":"  763","line":"    CEREAL_DLL_EXPORT void polymorphic_serialization_support<Archive,T>::instantiate()"},
{"lineNum":"  764","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"162",},
{"lineNum":"  765","line":"      create_bindings<Archive,T>::save( std::integral_constant<bool,","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  766","line":"                                          std::is_base_of<detail::OutputArchiveBase, Archive>::value &&"},
{"lineNum":"  767","line":"                                          traits::is_output_serializable<T, Archive>::value>{} );"},
{"lineNum":"  768","line":""},
{"lineNum":"  769","line":"      create_bindings<Archive,T>::load( std::integral_constant<bool,","class":"lineNoCov","hits":"0","possible_hits":"54",},
{"lineNum":"  770","line":"                                          std::is_base_of<detail::InputArchiveBase, Archive>::value &&"},
{"lineNum":"  771","line":"                                          traits::is_input_serializable<T, Archive>::value>{} );"},
{"lineNum":"  772","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"162",},
{"lineNum":"  773","line":""},
{"lineNum":"  774","line":"    //! Begins the binding process of a type to all registered archives"},
{"lineNum":"  775","line":"    /*! Archives need to be registered prior to this struct being instantiated via"},
{"lineNum":"  776","line":"        the CEREAL_REGISTER_ARCHIVE macro.  Overload resolution will then force"},
{"lineNum":"  777","line":"        several static objects to be made that allow us to bind together all"},
{"lineNum":"  778","line":"        registered archive types with the parameter type T. */"},
{"lineNum":"  779","line":"    template <class T, class Tag = polymorphic_binding_tag>"},
{"lineNum":"  780","line":"    struct bind_to_archives"},
{"lineNum":"  781","line":"    {"},
{"lineNum":"  782","line":"      //! Binding for non abstract types"},
{"lineNum":"  783","line":"      void bind(std::false_type) const"},
{"lineNum":"  784","line":"      {"},
{"lineNum":"  785","line":"        instantiate_polymorphic_binding(static_cast<T*>(nullptr), 0, Tag{}, adl_tag{});"},
{"lineNum":"  786","line":"      }"},
{"lineNum":"  787","line":""},
{"lineNum":"  788","line":"      //! Binding for abstract types"},
{"lineNum":"  789","line":"      void bind(std::true_type) const"},
{"lineNum":"  790","line":"      { }"},
{"lineNum":"  791","line":""},
{"lineNum":"  792","line":"      //! Binds the type T to all registered archives"},
{"lineNum":"  793","line":"      /*! If T is abstract, we will not serialize it and thus"},
{"lineNum":"  794","line":"          do not need to make a binding */"},
{"lineNum":"  795","line":"      bind_to_archives const & bind() const"},
{"lineNum":"  796","line":"      {"},
{"lineNum":"  797","line":"        static_assert( std::is_polymorphic<T>::value,"},
{"lineNum":"  798","line":"                       \"Attempting to register non polymorphic type\" );"},
{"lineNum":"  799","line":"        bind( std::is_abstract<T>() );"},
{"lineNum":"  800","line":"        return *this;"},
{"lineNum":"  801","line":"      }"},
{"lineNum":"  802","line":"    };"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"    //! Used to hide the static object used to bind T to registered archives"},
{"lineNum":"  805","line":"    template <class T, class Tag = polymorphic_binding_tag>"},
{"lineNum":"  806","line":"    struct init_binding;"},
{"lineNum":"  807","line":""},
{"lineNum":"  808","line":"    //! Base case overload for instantiation"},
{"lineNum":"  809","line":"    /*! This will end up always being the best overload due to the second"},
{"lineNum":"  810","line":"        parameter always being passed as an int.  All other overloads will"},
{"lineNum":"  811","line":"        accept pointers to archive types and have lower precedence than int."},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"        Since the compiler needs to check all possible overloads, the"},
{"lineNum":"  814","line":"        other overloads created via CEREAL_REGISTER_ARCHIVE, which will have"},
{"lineNum":"  815","line":"        lower precedence due to requring a conversion from int to (Archive*),"},
{"lineNum":"  816","line":"        will cause their return types to be instantiated through the static object"},
{"lineNum":"  817","line":"        mechanisms even though they are never called."},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"        See the documentation for the other functions to try and understand this */"},
{"lineNum":"  820","line":"    template <class T, typename BindingTag>"},
{"lineNum":"  821","line":"    void instantiate_polymorphic_binding( T*, int, BindingTag, adl_tag ) {}"},
{"lineNum":"  822","line":"  } // namespace detail"},
{"lineNum":"  823","line":"} // namespace cereal"},
{"lineNum":"  824","line":""},
{"lineNum":"  825","line":"#endif // CEREAL_DETAILS_POLYMORPHIC_IMPL_HPP_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 141, "covered" : 65,};
var merged_data = [];
