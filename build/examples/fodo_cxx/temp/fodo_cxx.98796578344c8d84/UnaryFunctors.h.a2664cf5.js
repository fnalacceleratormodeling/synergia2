var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2016 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_UNARY_FUNCTORS_H"},
{"lineNum":"   11","line":"#define EIGEN_UNARY_FUNCTORS_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"../InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"/** \\internal"},
{"lineNum":"   20","line":"  * \\brief Template functor to compute the opposite of a scalar"},
{"lineNum":"   21","line":"  *"},
{"lineNum":"   22","line":"  * \\sa class CwiseUnaryOp, MatrixBase::operator-"},
{"lineNum":"   23","line":"  */"},
{"lineNum":"   24","line":"template<typename Scalar> struct scalar_opposite_op {"},
{"lineNum":"   25","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_opposite_op)"},
{"lineNum":"   26","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   27","line":"  template<typename Packet>"},
{"lineNum":"   28","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const"},
{"lineNum":"   29","line":"  { return internal::pnegate(a); }"},
{"lineNum":"   30","line":"};"},
{"lineNum":"   31","line":"template<typename Scalar>"},
{"lineNum":"   32","line":"struct functor_traits<scalar_opposite_op<Scalar> >"},
{"lineNum":"   33","line":"{ enum {"},
{"lineNum":"   34","line":"    Cost = NumTraits<Scalar>::AddCost,"},
{"lineNum":"   35","line":"    PacketAccess = packet_traits<Scalar>::HasNegate };"},
{"lineNum":"   36","line":"};"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"/** \\internal"},
{"lineNum":"   39","line":"  * \\brief Template functor to compute the absolute value of a scalar"},
{"lineNum":"   40","line":"  *"},
{"lineNum":"   41","line":"  * \\sa class CwiseUnaryOp, Cwise::abs"},
{"lineNum":"   42","line":"  */"},
{"lineNum":"   43","line":"template<typename Scalar> struct scalar_abs_op {"},
{"lineNum":"   44","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_abs_op)"},
{"lineNum":"   45","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"   46","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs(a); }"},
{"lineNum":"   47","line":"  template<typename Packet>"},
{"lineNum":"   48","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const"},
{"lineNum":"   49","line":"  { return internal::pabs(a); }"},
{"lineNum":"   50","line":"};"},
{"lineNum":"   51","line":"template<typename Scalar>"},
{"lineNum":"   52","line":"struct functor_traits<scalar_abs_op<Scalar> >"},
{"lineNum":"   53","line":"{"},
{"lineNum":"   54","line":"  enum {"},
{"lineNum":"   55","line":"    Cost = NumTraits<Scalar>::AddCost,"},
{"lineNum":"   56","line":"    PacketAccess = packet_traits<Scalar>::HasAbs"},
{"lineNum":"   57","line":"  };"},
{"lineNum":"   58","line":"};"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"/** \\internal"},
{"lineNum":"   61","line":"  * \\brief Template functor to compute the score of a scalar, to chose a pivot"},
{"lineNum":"   62","line":"  *"},
{"lineNum":"   63","line":"  * \\sa class CwiseUnaryOp"},
{"lineNum":"   64","line":"  */"},
{"lineNum":"   65","line":"template<typename Scalar> struct scalar_score_coeff_op : scalar_abs_op<Scalar>"},
{"lineNum":"   66","line":"{"},
{"lineNum":"   67","line":"  typedef void Score_is_abs;"},
{"lineNum":"   68","line":"};"},
{"lineNum":"   69","line":"template<typename Scalar>"},
{"lineNum":"   70","line":"struct functor_traits<scalar_score_coeff_op<Scalar> > : functor_traits<scalar_abs_op<Scalar> > {};"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"/* Avoid recomputing abs when we know the score and they are the same. Not a true Eigen functor.  */"},
{"lineNum":"   73","line":"template<typename Scalar, typename=void> struct abs_knowing_score"},
{"lineNum":"   74","line":"{"},
{"lineNum":"   75","line":"  EIGEN_EMPTY_STRUCT_CTOR(abs_knowing_score)"},
{"lineNum":"   76","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"   77","line":"  template<typename Score>"},
{"lineNum":"   78","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a, const Score&) const { return numext::abs(a); }"},
{"lineNum":"   79","line":"};"},
{"lineNum":"   80","line":"template<typename Scalar> struct abs_knowing_score<Scalar, typename scalar_score_coeff_op<Scalar>::Score_is_abs>"},
{"lineNum":"   81","line":"{"},
{"lineNum":"   82","line":"  EIGEN_EMPTY_STRUCT_CTOR(abs_knowing_score)"},
{"lineNum":"   83","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"   84","line":"  template<typename Scal>"},
{"lineNum":"   85","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scal&, const result_type& a) const { return a; }"},
{"lineNum":"   86","line":"};"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"/** \\internal"},
{"lineNum":"   89","line":"  * \\brief Template functor to compute the squared absolute value of a scalar"},
{"lineNum":"   90","line":"  *"},
{"lineNum":"   91","line":"  * \\sa class CwiseUnaryOp, Cwise::abs2"},
{"lineNum":"   92","line":"  */"},
{"lineNum":"   93","line":"template<typename Scalar> struct scalar_abs2_op {"},
{"lineNum":"   94","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_abs2_op)"},
{"lineNum":"   95","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"   96","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"   97","line":"  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs2(a); }"},
{"lineNum":"   98","line":"  template<typename Packet>"},
{"lineNum":"   99","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const"},
{"lineNum":"  100","line":"  { return internal::pmul(a,a); }"},
{"lineNum":"  101","line":"};"},
{"lineNum":"  102","line":"template<typename Scalar>"},
{"lineNum":"  103","line":"struct functor_traits<scalar_abs2_op<Scalar> >"},
{"lineNum":"  104","line":"{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"/** \\internal"},
{"lineNum":"  107","line":"  * \\brief Template functor to compute the conjugate of a complex value"},
{"lineNum":"  108","line":"  *"},
{"lineNum":"  109","line":"  * \\sa class CwiseUnaryOp, MatrixBase::conjugate()"},
{"lineNum":"  110","line":"  */"},
{"lineNum":"  111","line":"template<typename Scalar> struct scalar_conjugate_op {"},
{"lineNum":"  112","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_conjugate_op)"},
{"lineNum":"  113","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  114","line":"  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::conj(a); }"},
{"lineNum":"  115","line":"  template<typename Packet>"},
{"lineNum":"  116","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }"},
{"lineNum":"  117","line":"};"},
{"lineNum":"  118","line":"template<typename Scalar>"},
{"lineNum":"  119","line":"struct functor_traits<scalar_conjugate_op<Scalar> >"},
{"lineNum":"  120","line":"{"},
{"lineNum":"  121","line":"  enum {"},
{"lineNum":"  122","line":"    Cost = 0,"},
{"lineNum":"  123","line":"    // Yes the cost is zero even for complexes because in most cases for which"},
{"lineNum":"  124","line":"    // the cost is used, conjugation turns to be a no-op. Some examples:"},
{"lineNum":"  125","line":"    //   cost(a*conj(b)) == cost(a*b)"},
{"lineNum":"  126","line":"    //   cost(a+conj(b)) == cost(a+b)"},
{"lineNum":"  127","line":"    //   <etc."},
{"lineNum":"  128","line":"    // If we don\'t set it to zero, then:"},
{"lineNum":"  129","line":"    //   A.conjugate().lazyProduct(B.conjugate())"},
{"lineNum":"  130","line":"    // will bake its operands. We definitely don\'t want that!"},
{"lineNum":"  131","line":"    PacketAccess = packet_traits<Scalar>::HasConj"},
{"lineNum":"  132","line":"  };"},
{"lineNum":"  133","line":"};"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"/** \\internal"},
{"lineNum":"  136","line":"  * \\brief Template functor to compute the phase angle of a complex"},
{"lineNum":"  137","line":"  *"},
{"lineNum":"  138","line":"  * \\sa class CwiseUnaryOp, Cwise::arg"},
{"lineNum":"  139","line":"  */"},
{"lineNum":"  140","line":"template<typename Scalar> struct scalar_arg_op {"},
{"lineNum":"  141","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_arg_op)"},
{"lineNum":"  142","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"  143","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::arg(a); }"},
{"lineNum":"  144","line":"  template<typename Packet>"},
{"lineNum":"  145","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const"},
{"lineNum":"  146","line":"  { return internal::parg(a); }"},
{"lineNum":"  147","line":"};"},
{"lineNum":"  148","line":"template<typename Scalar>"},
{"lineNum":"  149","line":"struct functor_traits<scalar_arg_op<Scalar> >"},
{"lineNum":"  150","line":"{"},
{"lineNum":"  151","line":"  enum {"},
{"lineNum":"  152","line":"    Cost = NumTraits<Scalar>::IsComplex ? 5 * NumTraits<Scalar>::MulCost : NumTraits<Scalar>::AddCost,"},
{"lineNum":"  153","line":"    PacketAccess = packet_traits<Scalar>::HasArg"},
{"lineNum":"  154","line":"  };"},
{"lineNum":"  155","line":"};"},
{"lineNum":"  156","line":"/** \\internal"},
{"lineNum":"  157","line":"  * \\brief Template functor to cast a scalar to another type"},
{"lineNum":"  158","line":"  *"},
{"lineNum":"  159","line":"  * \\sa class CwiseUnaryOp, MatrixBase::cast()"},
{"lineNum":"  160","line":"  */"},
{"lineNum":"  161","line":"template<typename Scalar, typename NewType>"},
{"lineNum":"  162","line":"struct scalar_cast_op {"},
{"lineNum":"  163","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_cast_op)"},
{"lineNum":"  164","line":"  typedef NewType result_type;"},
{"lineNum":"  165","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }"},
{"lineNum":"  166","line":"};"},
{"lineNum":"  167","line":"template<typename Scalar, typename NewType>"},
{"lineNum":"  168","line":"struct functor_traits<scalar_cast_op<Scalar,NewType> >"},
{"lineNum":"  169","line":"{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"/** \\internal"},
{"lineNum":"  172","line":"  * \\brief Template functor to arithmetically shift a scalar right by a number of bits"},
{"lineNum":"  173","line":"  *"},
{"lineNum":"  174","line":"  * \\sa class CwiseUnaryOp, MatrixBase::shift_right()"},
{"lineNum":"  175","line":"  */"},
{"lineNum":"  176","line":"template<typename Scalar, int N>"},
{"lineNum":"  177","line":"struct scalar_shift_right_op {"},
{"lineNum":"  178","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_shift_right_op)"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const"},
{"lineNum":"  181","line":"  { return a >> N; }"},
{"lineNum":"  182","line":"  template<typename Packet>"},
{"lineNum":"  183","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const"},
{"lineNum":"  184","line":"  { return internal::parithmetic_shift_right<N>(a); }"},
{"lineNum":"  185","line":"};"},
{"lineNum":"  186","line":"template<typename Scalar, int N>"},
{"lineNum":"  187","line":"struct functor_traits<scalar_shift_right_op<Scalar,N> >"},
{"lineNum":"  188","line":"{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasShift }; };"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"/** \\internal"},
{"lineNum":"  191","line":"  * \\brief Template functor to logically shift a scalar left by a number of bits"},
{"lineNum":"  192","line":"  *"},
{"lineNum":"  193","line":"  * \\sa class CwiseUnaryOp, MatrixBase::shift_left()"},
{"lineNum":"  194","line":"  */"},
{"lineNum":"  195","line":"template<typename Scalar, int N>"},
{"lineNum":"  196","line":"struct scalar_shift_left_op {"},
{"lineNum":"  197","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_shift_left_op)"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const"},
{"lineNum":"  200","line":"  { return a << N; }"},
{"lineNum":"  201","line":"  template<typename Packet>"},
{"lineNum":"  202","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const"},
{"lineNum":"  203","line":"  { return internal::plogical_shift_left<N>(a); }"},
{"lineNum":"  204","line":"};"},
{"lineNum":"  205","line":"template<typename Scalar, int N>"},
{"lineNum":"  206","line":"struct functor_traits<scalar_shift_left_op<Scalar,N> >"},
{"lineNum":"  207","line":"{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasShift }; };"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"/** \\internal"},
{"lineNum":"  210","line":"  * \\brief Template functor to extract the real part of a complex"},
{"lineNum":"  211","line":"  *"},
{"lineNum":"  212","line":"  * \\sa class CwiseUnaryOp, MatrixBase::real()"},
{"lineNum":"  213","line":"  */"},
{"lineNum":"  214","line":"template<typename Scalar>"},
{"lineNum":"  215","line":"struct scalar_real_op {"},
{"lineNum":"  216","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_real_op)"},
{"lineNum":"  217","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"  218","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  219","line":"  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::real(a); }"},
{"lineNum":"  220","line":"};"},
{"lineNum":"  221","line":"template<typename Scalar>"},
{"lineNum":"  222","line":"struct functor_traits<scalar_real_op<Scalar> >"},
{"lineNum":"  223","line":"{ enum { Cost = 0, PacketAccess = false }; };"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"/** \\internal"},
{"lineNum":"  226","line":"  * \\brief Template functor to extract the imaginary part of a complex"},
{"lineNum":"  227","line":"  *"},
{"lineNum":"  228","line":"  * \\sa class CwiseUnaryOp, MatrixBase::imag()"},
{"lineNum":"  229","line":"  */"},
{"lineNum":"  230","line":"template<typename Scalar>"},
{"lineNum":"  231","line":"struct scalar_imag_op {"},
{"lineNum":"  232","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_imag_op)"},
{"lineNum":"  233","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"  234","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  235","line":"  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::imag(a); }"},
{"lineNum":"  236","line":"};"},
{"lineNum":"  237","line":"template<typename Scalar>"},
{"lineNum":"  238","line":"struct functor_traits<scalar_imag_op<Scalar> >"},
{"lineNum":"  239","line":"{ enum { Cost = 0, PacketAccess = false }; };"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"/** \\internal"},
{"lineNum":"  242","line":"  * \\brief Template functor to extract the real part of a complex as a reference"},
{"lineNum":"  243","line":"  *"},
{"lineNum":"  244","line":"  * \\sa class CwiseUnaryOp, MatrixBase::real()"},
{"lineNum":"  245","line":"  */"},
{"lineNum":"  246","line":"template<typename Scalar>"},
{"lineNum":"  247","line":"struct scalar_real_ref_op {"},
{"lineNum":"  248","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_real_ref_op)"},
{"lineNum":"  249","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"  250","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  251","line":"  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::real_ref(*const_cast<Scalar*>(&a)); }"},
{"lineNum":"  252","line":"};"},
{"lineNum":"  253","line":"template<typename Scalar>"},
{"lineNum":"  254","line":"struct functor_traits<scalar_real_ref_op<Scalar> >"},
{"lineNum":"  255","line":"{ enum { Cost = 0, PacketAccess = false }; };"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"/** \\internal"},
{"lineNum":"  258","line":"  * \\brief Template functor to extract the imaginary part of a complex as a reference"},
{"lineNum":"  259","line":"  *"},
{"lineNum":"  260","line":"  * \\sa class CwiseUnaryOp, MatrixBase::imag()"},
{"lineNum":"  261","line":"  */"},
{"lineNum":"  262","line":"template<typename Scalar>"},
{"lineNum":"  263","line":"struct scalar_imag_ref_op {"},
{"lineNum":"  264","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_imag_ref_op)"},
{"lineNum":"  265","line":"  typedef typename NumTraits<Scalar>::Real result_type;"},
{"lineNum":"  266","line":"  EIGEN_DEVICE_FUNC"},
{"lineNum":"  267","line":"  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::imag_ref(*const_cast<Scalar*>(&a)); }"},
{"lineNum":"  268","line":"};"},
{"lineNum":"  269","line":"template<typename Scalar>"},
{"lineNum":"  270","line":"struct functor_traits<scalar_imag_ref_op<Scalar> >"},
{"lineNum":"  271","line":"{ enum { Cost = 0, PacketAccess = false }; };"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"/** \\internal"},
{"lineNum":"  274","line":"  *"},
{"lineNum":"  275","line":"  * \\brief Template functor to compute the exponential of a scalar"},
{"lineNum":"  276","line":"  *"},
{"lineNum":"  277","line":"  * \\sa class CwiseUnaryOp, Cwise::exp()"},
{"lineNum":"  278","line":"  */"},
{"lineNum":"  279","line":"template<typename Scalar> struct scalar_exp_op {"},
{"lineNum":"  280","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_exp_op)"},
{"lineNum":"  281","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::exp(a); }"},
{"lineNum":"  282","line":"  template <typename Packet>"},
{"lineNum":"  283","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }"},
{"lineNum":"  284","line":"};"},
{"lineNum":"  285","line":"template <typename Scalar>"},
{"lineNum":"  286","line":"struct functor_traits<scalar_exp_op<Scalar> > {"},
{"lineNum":"  287","line":"  enum {"},
{"lineNum":"  288","line":"    PacketAccess = packet_traits<Scalar>::HasExp,"},
{"lineNum":"  289","line":"    // The following numbers are based on the AVX implementation."},
{"lineNum":"  290","line":"#ifdef EIGEN_VECTORIZE_FMA"},
{"lineNum":"  291","line":"    // Haswell can issue 2 add/mul/madd per cycle."},
{"lineNum":"  292","line":"    Cost ="},
{"lineNum":"  293","line":"    (sizeof(Scalar) == 4"},
{"lineNum":"  294","line":"     // float: 8 pmadd, 4 pmul, 2 padd/psub, 6 other"},
{"lineNum":"  295","line":"     ? (8 * NumTraits<Scalar>::AddCost + 6 * NumTraits<Scalar>::MulCost)"},
{"lineNum":"  296","line":"     // double: 7 pmadd, 5 pmul, 3 padd/psub, 1 div,  13 other"},
{"lineNum":"  297","line":"     : (14 * NumTraits<Scalar>::AddCost +"},
{"lineNum":"  298","line":"        6 * NumTraits<Scalar>::MulCost +"},
{"lineNum":"  299","line":"        scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value))"},
{"lineNum":"  300","line":"#else"},
{"lineNum":"  301","line":"    Cost ="},
{"lineNum":"  302","line":"    (sizeof(Scalar) == 4"},
{"lineNum":"  303","line":"     // float: 7 pmadd, 6 pmul, 4 padd/psub, 10 other"},
{"lineNum":"  304","line":"     ? (21 * NumTraits<Scalar>::AddCost + 13 * NumTraits<Scalar>::MulCost)"},
{"lineNum":"  305","line":"     // double: 7 pmadd, 5 pmul, 3 padd/psub, 1 div,  13 other"},
{"lineNum":"  306","line":"     : (23 * NumTraits<Scalar>::AddCost +"},
{"lineNum":"  307","line":"        12 * NumTraits<Scalar>::MulCost +"},
{"lineNum":"  308","line":"        scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value))"},
{"lineNum":"  309","line":"#endif"},
{"lineNum":"  310","line":"  };"},
{"lineNum":"  311","line":"};"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"/** \\internal"},
{"lineNum":"  314","line":"  *"},
{"lineNum":"  315","line":"  * \\brief Template functor to compute the exponential of a scalar - 1."},
{"lineNum":"  316","line":"  *"},
{"lineNum":"  317","line":"  * \\sa class CwiseUnaryOp, ArrayBase::expm1()"},
{"lineNum":"  318","line":"  */"},
{"lineNum":"  319","line":"template<typename Scalar> struct scalar_expm1_op {"},
{"lineNum":"  320","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_expm1_op)"},
{"lineNum":"  321","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::expm1(a); }"},
{"lineNum":"  322","line":"  template <typename Packet>"},
{"lineNum":"  323","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pexpm1(a); }"},
{"lineNum":"  324","line":"};"},
{"lineNum":"  325","line":"template <typename Scalar>"},
{"lineNum":"  326","line":"struct functor_traits<scalar_expm1_op<Scalar> > {"},
{"lineNum":"  327","line":"  enum {"},
{"lineNum":"  328","line":"    PacketAccess = packet_traits<Scalar>::HasExpm1,"},
{"lineNum":"  329","line":"    Cost = functor_traits<scalar_exp_op<Scalar> >::Cost // TODO measure cost of expm1"},
{"lineNum":"  330","line":"  };"},
{"lineNum":"  331","line":"};"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"/** \\internal"},
{"lineNum":"  334","line":"  *"},
{"lineNum":"  335","line":"  * \\brief Template functor to compute the logarithm of a scalar"},
{"lineNum":"  336","line":"  *"},
{"lineNum":"  337","line":"  * \\sa class CwiseUnaryOp, ArrayBase::log()"},
{"lineNum":"  338","line":"  */"},
{"lineNum":"  339","line":"template<typename Scalar> struct scalar_log_op {"},
{"lineNum":"  340","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_log_op)"},
{"lineNum":"  341","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log(a); }"},
{"lineNum":"  342","line":"  template <typename Packet>"},
{"lineNum":"  343","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog(a); }"},
{"lineNum":"  344","line":"};"},
{"lineNum":"  345","line":"template <typename Scalar>"},
{"lineNum":"  346","line":"struct functor_traits<scalar_log_op<Scalar> > {"},
{"lineNum":"  347","line":"  enum {"},
{"lineNum":"  348","line":"    PacketAccess = packet_traits<Scalar>::HasLog,"},
{"lineNum":"  349","line":"    Cost ="},
{"lineNum":"  350","line":"    (PacketAccess"},
{"lineNum":"  351","line":"     // The following numbers are based on the AVX implementation."},
{"lineNum":"  352","line":"#ifdef EIGEN_VECTORIZE_FMA"},
{"lineNum":"  353","line":"     // 8 pmadd, 6 pmul, 8 padd/psub, 16 other, can issue 2 add/mul/madd per cycle."},
{"lineNum":"  354","line":"     ? (20 * NumTraits<Scalar>::AddCost + 7 * NumTraits<Scalar>::MulCost)"},
{"lineNum":"  355","line":"#else"},
{"lineNum":"  356","line":"     // 8 pmadd, 6 pmul, 8 padd/psub, 20 other"},
{"lineNum":"  357","line":"     ? (36 * NumTraits<Scalar>::AddCost + 14 * NumTraits<Scalar>::MulCost)"},
{"lineNum":"  358","line":"#endif"},
{"lineNum":"  359","line":"     // Measured cost of std::log."},
{"lineNum":"  360","line":"     : sizeof(Scalar)==4 ? 40 : 85)"},
{"lineNum":"  361","line":"  };"},
{"lineNum":"  362","line":"};"},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"/** \\internal"},
{"lineNum":"  365","line":"  *"},
{"lineNum":"  366","line":"  * \\brief Template functor to compute the logarithm of 1 plus a scalar value"},
{"lineNum":"  367","line":"  *"},
{"lineNum":"  368","line":"  * \\sa class CwiseUnaryOp, ArrayBase::log1p()"},
{"lineNum":"  369","line":"  */"},
{"lineNum":"  370","line":"template<typename Scalar> struct scalar_log1p_op {"},
{"lineNum":"  371","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_log1p_op)"},
{"lineNum":"  372","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::log1p(a); }"},
{"lineNum":"  373","line":"  template <typename Packet>"},
{"lineNum":"  374","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog1p(a); }"},
{"lineNum":"  375","line":"};"},
{"lineNum":"  376","line":"template <typename Scalar>"},
{"lineNum":"  377","line":"struct functor_traits<scalar_log1p_op<Scalar> > {"},
{"lineNum":"  378","line":"  enum {"},
{"lineNum":"  379","line":"    PacketAccess = packet_traits<Scalar>::HasLog1p,"},
{"lineNum":"  380","line":"    Cost = functor_traits<scalar_log_op<Scalar> >::Cost // TODO measure cost of log1p"},
{"lineNum":"  381","line":"  };"},
{"lineNum":"  382","line":"};"},
{"lineNum":"  383","line":""},
{"lineNum":"  384","line":"/** \\internal"},
{"lineNum":"  385","line":"  *"},
{"lineNum":"  386","line":"  * \\brief Template functor to compute the base-10 logarithm of a scalar"},
{"lineNum":"  387","line":"  *"},
{"lineNum":"  388","line":"  * \\sa class CwiseUnaryOp, Cwise::log10()"},
{"lineNum":"  389","line":"  */"},
{"lineNum":"  390","line":"template<typename Scalar> struct scalar_log10_op {"},
{"lineNum":"  391","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_log10_op)"},
{"lineNum":"  392","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { EIGEN_USING_STD(log10) return log10(a); }"},
{"lineNum":"  393","line":"  template <typename Packet>"},
{"lineNum":"  394","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog10(a); }"},
{"lineNum":"  395","line":"};"},
{"lineNum":"  396","line":"template<typename Scalar>"},
{"lineNum":"  397","line":"struct functor_traits<scalar_log10_op<Scalar> >"},
{"lineNum":"  398","line":"{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog10 }; };"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"/** \\internal"},
{"lineNum":"  401","line":"  *"},
{"lineNum":"  402","line":"  * \\brief Template functor to compute the base-2 logarithm of a scalar"},
{"lineNum":"  403","line":"  *"},
{"lineNum":"  404","line":"  * \\sa class CwiseUnaryOp, Cwise::log2()"},
{"lineNum":"  405","line":"  */"},
{"lineNum":"  406","line":"template<typename Scalar> struct scalar_log2_op {"},
{"lineNum":"  407","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_log2_op)"},
{"lineNum":"  408","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return Scalar(EIGEN_LOG2E) * numext::log(a); }"},
{"lineNum":"  409","line":"  template <typename Packet>"},
{"lineNum":"  410","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::plog2(a); }"},
{"lineNum":"  411","line":"};"},
{"lineNum":"  412","line":"template<typename Scalar>"},
{"lineNum":"  413","line":"struct functor_traits<scalar_log2_op<Scalar> >"},
{"lineNum":"  414","line":"{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"/** \\internal"},
{"lineNum":"  417","line":"  * \\brief Template functor to compute the square root of a scalar"},
{"lineNum":"  418","line":"  * \\sa class CwiseUnaryOp, Cwise::sqrt()"},
{"lineNum":"  419","line":"  */"},
{"lineNum":"  420","line":"template<typename Scalar> struct scalar_sqrt_op {"},
{"lineNum":"  421","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_sqrt_op)"},
{"lineNum":"  422","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sqrt(a); }"},
{"lineNum":"  423","line":"  template <typename Packet>"},
{"lineNum":"  424","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }"},
{"lineNum":"  425","line":"};"},
{"lineNum":"  426","line":"template <typename Scalar>"},
{"lineNum":"  427","line":"struct functor_traits<scalar_sqrt_op<Scalar> > {"},
{"lineNum":"  428","line":"  enum {"},
{"lineNum":"  429","line":"#if EIGEN_FAST_MATH"},
{"lineNum":"  430","line":"    // The following numbers are based on the AVX implementation."},
{"lineNum":"  431","line":"    Cost = (sizeof(Scalar) == 8 ? 28"},
{"lineNum":"  432","line":"                                // 4 pmul, 1 pmadd, 3 other"},
{"lineNum":"  433","line":"                                : (3 * NumTraits<Scalar>::AddCost +"},
{"lineNum":"  434","line":"                                   5 * NumTraits<Scalar>::MulCost)),"},
{"lineNum":"  435","line":"#else"},
{"lineNum":"  436","line":"    // The following numbers are based on min VSQRT throughput on Haswell."},
{"lineNum":"  437","line":"    Cost = (sizeof(Scalar) == 8 ? 28 : 14),"},
{"lineNum":"  438","line":"#endif"},
{"lineNum":"  439","line":"    PacketAccess = packet_traits<Scalar>::HasSqrt"},
{"lineNum":"  440","line":"  };"},
{"lineNum":"  441","line":"};"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"// Boolean specialization to eliminate -Wimplicit-conversion-floating-point-to-bool warnings."},
{"lineNum":"  444","line":"template<> struct scalar_sqrt_op<bool> {"},
{"lineNum":"  445","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_sqrt_op)"},
{"lineNum":"  446","line":"  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a) const { return a; }"},
{"lineNum":"  447","line":"  template <typename Packet>"},
{"lineNum":"  448","line":"  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return a; }"},
{"lineNum":"  449","line":"};"},
{"lineNum":"  450","line":"template <>"},
{"lineNum":"  451","line":"struct functor_traits<scalar_sqrt_op<bool> > {"},
{"lineNum":"  452","line":"  enum { Cost = 1, PacketAccess = packet_traits<bool>::Vectorizable };"},
{"lineNum":"  453","line":"};"},
{"lineNum":"  454","line":""},
{"lineNum":"  455","line":"/** \\internal"},
{"lineNum":"  456","line":"  * \\brief Template functor to compute the reciprocal square root of a scalar"},
{"lineNum":"  457","line":"  * \\sa class CwiseUnaryOp, Cwise::rsqrt()"},
{"lineNum":"  458","line":"  */"},
{"lineNum":"  459","line":"template<typename Scalar> struct scalar_rsqrt_op {"},
{"lineNum":"  460","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_rsqrt_op)"},
{"lineNum":"  461","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::rsqrt(a); }"},
{"lineNum":"  462","line":"  template <typename Packet>"},
{"lineNum":"  463","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::prsqrt(a); }"},
{"lineNum":"  464","line":"};"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"template<typename Scalar>"},
{"lineNum":"  467","line":"struct functor_traits<scalar_rsqrt_op<Scalar> >"},
{"lineNum":"  468","line":"{ enum {"},
{"lineNum":"  469","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  470","line":"    PacketAccess = packet_traits<Scalar>::HasRsqrt"},
{"lineNum":"  471","line":"  };"},
{"lineNum":"  472","line":"};"},
{"lineNum":"  473","line":""},
{"lineNum":"  474","line":"/** \\internal"},
{"lineNum":"  475","line":"  * \\brief Template functor to compute the cosine of a scalar"},
{"lineNum":"  476","line":"  * \\sa class CwiseUnaryOp, ArrayBase::cos()"},
{"lineNum":"  477","line":"  */"},
{"lineNum":"  478","line":"template<typename Scalar> struct scalar_cos_op {"},
{"lineNum":"  479","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_cos_op)"},
{"lineNum":"  480","line":"  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return numext::cos(a); }"},
{"lineNum":"  481","line":"  template <typename Packet>"},
{"lineNum":"  482","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }"},
{"lineNum":"  483","line":"};"},
{"lineNum":"  484","line":"template<typename Scalar>"},
{"lineNum":"  485","line":"struct functor_traits<scalar_cos_op<Scalar> >"},
{"lineNum":"  486","line":"{"},
{"lineNum":"  487","line":"  enum {"},
{"lineNum":"  488","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  489","line":"    PacketAccess = packet_traits<Scalar>::HasCos"},
{"lineNum":"  490","line":"  };"},
{"lineNum":"  491","line":"};"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"/** \\internal"},
{"lineNum":"  494","line":"  * \\brief Template functor to compute the sine of a scalar"},
{"lineNum":"  495","line":"  * \\sa class CwiseUnaryOp, ArrayBase::sin()"},
{"lineNum":"  496","line":"  */"},
{"lineNum":"  497","line":"template<typename Scalar> struct scalar_sin_op {"},
{"lineNum":"  498","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_sin_op)"},
{"lineNum":"  499","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sin(a); }"},
{"lineNum":"  500","line":"  template <typename Packet>"},
{"lineNum":"  501","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psin(a); }"},
{"lineNum":"  502","line":"};"},
{"lineNum":"  503","line":"template<typename Scalar>"},
{"lineNum":"  504","line":"struct functor_traits<scalar_sin_op<Scalar> >"},
{"lineNum":"  505","line":"{"},
{"lineNum":"  506","line":"  enum {"},
{"lineNum":"  507","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  508","line":"    PacketAccess = packet_traits<Scalar>::HasSin"},
{"lineNum":"  509","line":"  };"},
{"lineNum":"  510","line":"};"},
{"lineNum":"  511","line":""},
{"lineNum":"  512","line":""},
{"lineNum":"  513","line":"/** \\internal"},
{"lineNum":"  514","line":"  * \\brief Template functor to compute the tan of a scalar"},
{"lineNum":"  515","line":"  * \\sa class CwiseUnaryOp, ArrayBase::tan()"},
{"lineNum":"  516","line":"  */"},
{"lineNum":"  517","line":"template<typename Scalar> struct scalar_tan_op {"},
{"lineNum":"  518","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_tan_op)"},
{"lineNum":"  519","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::tan(a); }"},
{"lineNum":"  520","line":"  template <typename Packet>"},
{"lineNum":"  521","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }"},
{"lineNum":"  522","line":"};"},
{"lineNum":"  523","line":"template<typename Scalar>"},
{"lineNum":"  524","line":"struct functor_traits<scalar_tan_op<Scalar> >"},
{"lineNum":"  525","line":"{"},
{"lineNum":"  526","line":"  enum {"},
{"lineNum":"  527","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  528","line":"    PacketAccess = packet_traits<Scalar>::HasTan"},
{"lineNum":"  529","line":"  };"},
{"lineNum":"  530","line":"};"},
{"lineNum":"  531","line":""},
{"lineNum":"  532","line":"/** \\internal"},
{"lineNum":"  533","line":"  * \\brief Template functor to compute the arc cosine of a scalar"},
{"lineNum":"  534","line":"  * \\sa class CwiseUnaryOp, ArrayBase::acos()"},
{"lineNum":"  535","line":"  */"},
{"lineNum":"  536","line":"template<typename Scalar> struct scalar_acos_op {"},
{"lineNum":"  537","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_acos_op)"},
{"lineNum":"  538","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::acos(a); }"},
{"lineNum":"  539","line":"  template <typename Packet>"},
{"lineNum":"  540","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }"},
{"lineNum":"  541","line":"};"},
{"lineNum":"  542","line":"template<typename Scalar>"},
{"lineNum":"  543","line":"struct functor_traits<scalar_acos_op<Scalar> >"},
{"lineNum":"  544","line":"{"},
{"lineNum":"  545","line":"  enum {"},
{"lineNum":"  546","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  547","line":"    PacketAccess = packet_traits<Scalar>::HasACos"},
{"lineNum":"  548","line":"  };"},
{"lineNum":"  549","line":"};"},
{"lineNum":"  550","line":""},
{"lineNum":"  551","line":"/** \\internal"},
{"lineNum":"  552","line":"  * \\brief Template functor to compute the arc sine of a scalar"},
{"lineNum":"  553","line":"  * \\sa class CwiseUnaryOp, ArrayBase::asin()"},
{"lineNum":"  554","line":"  */"},
{"lineNum":"  555","line":"template<typename Scalar> struct scalar_asin_op {"},
{"lineNum":"  556","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_asin_op)"},
{"lineNum":"  557","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::asin(a); }"},
{"lineNum":"  558","line":"  template <typename Packet>"},
{"lineNum":"  559","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }"},
{"lineNum":"  560","line":"};"},
{"lineNum":"  561","line":"template<typename Scalar>"},
{"lineNum":"  562","line":"struct functor_traits<scalar_asin_op<Scalar> >"},
{"lineNum":"  563","line":"{"},
{"lineNum":"  564","line":"  enum {"},
{"lineNum":"  565","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  566","line":"    PacketAccess = packet_traits<Scalar>::HasASin"},
{"lineNum":"  567","line":"  };"},
{"lineNum":"  568","line":"};"},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"/** \\internal"},
{"lineNum":"  572","line":"  * \\brief Template functor to compute the atan of a scalar"},
{"lineNum":"  573","line":"  * \\sa class CwiseUnaryOp, ArrayBase::atan()"},
{"lineNum":"  574","line":"  */"},
{"lineNum":"  575","line":"template<typename Scalar> struct scalar_atan_op {"},
{"lineNum":"  576","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_atan_op)"},
{"lineNum":"  577","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::atan(a); }"},
{"lineNum":"  578","line":"  template <typename Packet>"},
{"lineNum":"  579","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::patan(a); }"},
{"lineNum":"  580","line":"};"},
{"lineNum":"  581","line":"template<typename Scalar>"},
{"lineNum":"  582","line":"struct functor_traits<scalar_atan_op<Scalar> >"},
{"lineNum":"  583","line":"{"},
{"lineNum":"  584","line":"  enum {"},
{"lineNum":"  585","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  586","line":"    PacketAccess = packet_traits<Scalar>::HasATan"},
{"lineNum":"  587","line":"  };"},
{"lineNum":"  588","line":"};"},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":"/** \\internal"},
{"lineNum":"  591","line":"  * \\brief Template functor to compute the tanh of a scalar"},
{"lineNum":"  592","line":"  * \\sa class CwiseUnaryOp, ArrayBase::tanh()"},
{"lineNum":"  593","line":"  */"},
{"lineNum":"  594","line":"template <typename Scalar>"},
{"lineNum":"  595","line":"struct scalar_tanh_op {"},
{"lineNum":"  596","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_tanh_op)"},
{"lineNum":"  597","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::tanh(a); }"},
{"lineNum":"  598","line":"  template <typename Packet>"},
{"lineNum":"  599","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& x) const { return ptanh(x); }"},
{"lineNum":"  600","line":"};"},
{"lineNum":"  601","line":""},
{"lineNum":"  602","line":"template <typename Scalar>"},
{"lineNum":"  603","line":"struct functor_traits<scalar_tanh_op<Scalar> > {"},
{"lineNum":"  604","line":"  enum {"},
{"lineNum":"  605","line":"    PacketAccess = packet_traits<Scalar>::HasTanh,"},
{"lineNum":"  606","line":"    Cost = ( (EIGEN_FAST_MATH && is_same<Scalar,float>::value)"},
{"lineNum":"  607","line":"// The following numbers are based on the AVX implementation,"},
{"lineNum":"  608","line":"#ifdef EIGEN_VECTORIZE_FMA"},
{"lineNum":"  609","line":"                // Haswell can issue 2 add/mul/madd per cycle."},
{"lineNum":"  610","line":"                // 9 pmadd, 2 pmul, 1 div, 2 other"},
{"lineNum":"  611","line":"                ? (2 * NumTraits<Scalar>::AddCost +"},
{"lineNum":"  612","line":"                   6 * NumTraits<Scalar>::MulCost +"},
{"lineNum":"  613","line":"                   scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value)"},
{"lineNum":"  614","line":"#else"},
{"lineNum":"  615","line":"                ? (11 * NumTraits<Scalar>::AddCost +"},
{"lineNum":"  616","line":"                   11 * NumTraits<Scalar>::MulCost +"},
{"lineNum":"  617","line":"                   scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value)"},
{"lineNum":"  618","line":"#endif"},
{"lineNum":"  619","line":"                // This number assumes a naive implementation of tanh"},
{"lineNum":"  620","line":"                : (6 * NumTraits<Scalar>::AddCost +"},
{"lineNum":"  621","line":"                   3 * NumTraits<Scalar>::MulCost +"},
{"lineNum":"  622","line":"                   2 * scalar_div_cost<Scalar,packet_traits<Scalar>::HasDiv>::value +"},
{"lineNum":"  623","line":"                   functor_traits<scalar_exp_op<Scalar> >::Cost))"},
{"lineNum":"  624","line":"  };"},
{"lineNum":"  625","line":"};"},
{"lineNum":"  626","line":""},
{"lineNum":"  627","line":"#if EIGEN_HAS_CXX11_MATH"},
{"lineNum":"  628","line":"/** \\internal"},
{"lineNum":"  629","line":"  * \\brief Template functor to compute the atanh of a scalar"},
{"lineNum":"  630","line":"  * \\sa class CwiseUnaryOp, ArrayBase::atanh()"},
{"lineNum":"  631","line":"  */"},
{"lineNum":"  632","line":"template <typename Scalar>"},
{"lineNum":"  633","line":"struct scalar_atanh_op {"},
{"lineNum":"  634","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_atanh_op)"},
{"lineNum":"  635","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::atanh(a); }"},
{"lineNum":"  636","line":"};"},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"template <typename Scalar>"},
{"lineNum":"  639","line":"struct functor_traits<scalar_atanh_op<Scalar> > {"},
{"lineNum":"  640","line":"  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };"},
{"lineNum":"  641","line":"};"},
{"lineNum":"  642","line":"#endif"},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":"/** \\internal"},
{"lineNum":"  645","line":"  * \\brief Template functor to compute the sinh of a scalar"},
{"lineNum":"  646","line":"  * \\sa class CwiseUnaryOp, ArrayBase::sinh()"},
{"lineNum":"  647","line":"  */"},
{"lineNum":"  648","line":"template<typename Scalar> struct scalar_sinh_op {"},
{"lineNum":"  649","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_sinh_op)"},
{"lineNum":"  650","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::sinh(a); }"},
{"lineNum":"  651","line":"  template <typename Packet>"},
{"lineNum":"  652","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psinh(a); }"},
{"lineNum":"  653","line":"};"},
{"lineNum":"  654","line":"template<typename Scalar>"},
{"lineNum":"  655","line":"struct functor_traits<scalar_sinh_op<Scalar> >"},
{"lineNum":"  656","line":"{"},
{"lineNum":"  657","line":"  enum {"},
{"lineNum":"  658","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  659","line":"    PacketAccess = packet_traits<Scalar>::HasSinh"},
{"lineNum":"  660","line":"  };"},
{"lineNum":"  661","line":"};"},
{"lineNum":"  662","line":""},
{"lineNum":"  663","line":"#if EIGEN_HAS_CXX11_MATH"},
{"lineNum":"  664","line":"/** \\internal"},
{"lineNum":"  665","line":"  * \\brief Template functor to compute the asinh of a scalar"},
{"lineNum":"  666","line":"  * \\sa class CwiseUnaryOp, ArrayBase::asinh()"},
{"lineNum":"  667","line":"  */"},
{"lineNum":"  668","line":"template <typename Scalar>"},
{"lineNum":"  669","line":"struct scalar_asinh_op {"},
{"lineNum":"  670","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_asinh_op)"},
{"lineNum":"  671","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::asinh(a); }"},
{"lineNum":"  672","line":"};"},
{"lineNum":"  673","line":""},
{"lineNum":"  674","line":"template <typename Scalar>"},
{"lineNum":"  675","line":"struct functor_traits<scalar_asinh_op<Scalar> > {"},
{"lineNum":"  676","line":"  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };"},
{"lineNum":"  677","line":"};"},
{"lineNum":"  678","line":"#endif"},
{"lineNum":"  679","line":""},
{"lineNum":"  680","line":"/** \\internal"},
{"lineNum":"  681","line":"  * \\brief Template functor to compute the cosh of a scalar"},
{"lineNum":"  682","line":"  * \\sa class CwiseUnaryOp, ArrayBase::cosh()"},
{"lineNum":"  683","line":"  */"},
{"lineNum":"  684","line":"template<typename Scalar> struct scalar_cosh_op {"},
{"lineNum":"  685","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_cosh_op)"},
{"lineNum":"  686","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const { return numext::cosh(a); }"},
{"lineNum":"  687","line":"  template <typename Packet>"},
{"lineNum":"  688","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pcosh(a); }"},
{"lineNum":"  689","line":"};"},
{"lineNum":"  690","line":"template<typename Scalar>"},
{"lineNum":"  691","line":"struct functor_traits<scalar_cosh_op<Scalar> >"},
{"lineNum":"  692","line":"{"},
{"lineNum":"  693","line":"  enum {"},
{"lineNum":"  694","line":"    Cost = 5 * NumTraits<Scalar>::MulCost,"},
{"lineNum":"  695","line":"    PacketAccess = packet_traits<Scalar>::HasCosh"},
{"lineNum":"  696","line":"  };"},
{"lineNum":"  697","line":"};"},
{"lineNum":"  698","line":""},
{"lineNum":"  699","line":"#if EIGEN_HAS_CXX11_MATH"},
{"lineNum":"  700","line":"/** \\internal"},
{"lineNum":"  701","line":"  * \\brief Template functor to compute the acosh of a scalar"},
{"lineNum":"  702","line":"  * \\sa class CwiseUnaryOp, ArrayBase::acosh()"},
{"lineNum":"  703","line":"  */"},
{"lineNum":"  704","line":"template <typename Scalar>"},
{"lineNum":"  705","line":"struct scalar_acosh_op {"},
{"lineNum":"  706","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_acosh_op)"},
{"lineNum":"  707","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator()(const Scalar& a) const { return numext::acosh(a); }"},
{"lineNum":"  708","line":"};"},
{"lineNum":"  709","line":""},
{"lineNum":"  710","line":"template <typename Scalar>"},
{"lineNum":"  711","line":"struct functor_traits<scalar_acosh_op<Scalar> > {"},
{"lineNum":"  712","line":"  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };"},
{"lineNum":"  713","line":"};"},
{"lineNum":"  714","line":"#endif"},
{"lineNum":"  715","line":""},
{"lineNum":"  716","line":"/** \\internal"},
{"lineNum":"  717","line":"  * \\brief Template functor to compute the inverse of a scalar"},
{"lineNum":"  718","line":"  * \\sa class CwiseUnaryOp, Cwise::inverse()"},
{"lineNum":"  719","line":"  */"},
{"lineNum":"  720","line":"template<typename Scalar>"},
{"lineNum":"  721","line":"struct scalar_inverse_op {"},
{"lineNum":"  722","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_inverse_op)"},
{"lineNum":"  723","line":"  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return Scalar(1)/a; }"},
{"lineNum":"  724","line":"  template<typename Packet>"},
{"lineNum":"  725","line":"  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const"},
{"lineNum":"  726","line":"  { return internal::pdiv(pset1<Packet>(Scalar(1)),a); }"},
{"lineNum":"  727","line":"};"},
{"lineNum":"  728","line":"template <typename Scalar>"},
{"lineNum":"  729","line":"struct functor_traits<scalar_inverse_op<Scalar> > {"},
{"lineNum":"  730","line":"  enum {"},
{"lineNum":"  731","line":"    PacketAccess = packet_traits<Scalar>::HasDiv,"},
{"lineNum":"  732","line":"    Cost = scalar_div_cost<Scalar, PacketAccess>::value"},
{"lineNum":"  733","line":"  };"},
{"lineNum":"  734","line":"};"},
{"lineNum":"  735","line":""},
{"lineNum":"  736","line":"/** \\internal"},
{"lineNum":"  737","line":"  * \\brief Template functor to compute the square of a scalar"},
{"lineNum":"  738","line":"  * \\sa class CwiseUnaryOp, Cwise::square()"},
{"lineNum":"  739","line":"  */"},
{"lineNum":"  740","line":"template<typename Scalar>"},
{"lineNum":"  741","line":"struct scalar_square_op {"},
{"lineNum":"  742","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_square_op)"},
{"lineNum":"  743","line":"  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a*a; }"},
{"lineNum":"  744","line":"  template<typename Packet>"},
{"lineNum":"  745","line":"  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const"},
{"lineNum":"  746","line":"  { return internal::pmul(a,a); }"},
{"lineNum":"  747","line":"};"},
{"lineNum":"  748","line":"template<typename Scalar>"},
{"lineNum":"  749","line":"struct functor_traits<scalar_square_op<Scalar> >"},
{"lineNum":"  750","line":"{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };"},
{"lineNum":"  751","line":""},
{"lineNum":"  752","line":"// Boolean specialization to avoid -Wint-in-bool-context warnings on GCC."},
{"lineNum":"  753","line":"template<>"},
{"lineNum":"  754","line":"struct scalar_square_op<bool> {"},
{"lineNum":"  755","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_square_op)"},
{"lineNum":"  756","line":"  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a) const { return a; }"},
{"lineNum":"  757","line":"  template<typename Packet>"},
{"lineNum":"  758","line":"  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const"},
{"lineNum":"  759","line":"  { return a; }"},
{"lineNum":"  760","line":"};"},
{"lineNum":"  761","line":"template<>"},
{"lineNum":"  762","line":"struct functor_traits<scalar_square_op<bool> >"},
{"lineNum":"  763","line":"{ enum { Cost = 0, PacketAccess = packet_traits<bool>::Vectorizable }; };"},
{"lineNum":"  764","line":""},
{"lineNum":"  765","line":"/** \\internal"},
{"lineNum":"  766","line":"  * \\brief Template functor to compute the cube of a scalar"},
{"lineNum":"  767","line":"  * \\sa class CwiseUnaryOp, Cwise::cube()"},
{"lineNum":"  768","line":"  */"},
{"lineNum":"  769","line":"template<typename Scalar>"},
{"lineNum":"  770","line":"struct scalar_cube_op {"},
{"lineNum":"  771","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_cube_op)"},
{"lineNum":"  772","line":"  EIGEN_DEVICE_FUNC inline Scalar operator() (const Scalar& a) const { return a*a*a; }"},
{"lineNum":"  773","line":"  template<typename Packet>"},
{"lineNum":"  774","line":"  EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const"},
{"lineNum":"  775","line":"  { return internal::pmul(a,pmul(a,a)); }"},
{"lineNum":"  776","line":"};"},
{"lineNum":"  777","line":"template<typename Scalar>"},
{"lineNum":"  778","line":"struct functor_traits<scalar_cube_op<Scalar> >"},
{"lineNum":"  779","line":"{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };"},
{"lineNum":"  780","line":""},
{"lineNum":"  781","line":"// Boolean specialization to avoid -Wint-in-bool-context warnings on GCC."},
{"lineNum":"  782","line":"template<>"},
{"lineNum":"  783","line":"struct scalar_cube_op<bool> {"},
{"lineNum":"  784","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_cube_op)"},
{"lineNum":"  785","line":"  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline bool operator() (const bool& a) const { return a; }"},
{"lineNum":"  786","line":"  template<typename Packet>"},
{"lineNum":"  787","line":"  EIGEN_DEPRECATED EIGEN_DEVICE_FUNC inline const Packet packetOp(const Packet& a) const"},
{"lineNum":"  788","line":"  { return a; }"},
{"lineNum":"  789","line":"};"},
{"lineNum":"  790","line":"template<>"},
{"lineNum":"  791","line":"struct functor_traits<scalar_cube_op<bool> >"},
{"lineNum":"  792","line":"{ enum { Cost = 0, PacketAccess = packet_traits<bool>::Vectorizable }; };"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"/** \\internal"},
{"lineNum":"  795","line":"  * \\brief Template functor to compute the rounded value of a scalar"},
{"lineNum":"  796","line":"  * \\sa class CwiseUnaryOp, ArrayBase::round()"},
{"lineNum":"  797","line":"  */"},
{"lineNum":"  798","line":"template<typename Scalar> struct scalar_round_op {"},
{"lineNum":"  799","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_round_op)"},
{"lineNum":"  800","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::round(a); }"},
{"lineNum":"  801","line":"  template <typename Packet>"},
{"lineNum":"  802","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pround(a); }"},
{"lineNum":"  803","line":"};"},
{"lineNum":"  804","line":"template<typename Scalar>"},
{"lineNum":"  805","line":"struct functor_traits<scalar_round_op<Scalar> >"},
{"lineNum":"  806","line":"{"},
{"lineNum":"  807","line":"  enum {"},
{"lineNum":"  808","line":"    Cost = NumTraits<Scalar>::MulCost,"},
{"lineNum":"  809","line":"    PacketAccess = packet_traits<Scalar>::HasRound"},
{"lineNum":"  810","line":"  };"},
{"lineNum":"  811","line":"};"},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"/** \\internal"},
{"lineNum":"  814","line":"  * \\brief Template functor to compute the floor of a scalar"},
{"lineNum":"  815","line":"  * \\sa class CwiseUnaryOp, ArrayBase::floor()"},
{"lineNum":"  816","line":"  */"},
{"lineNum":"  817","line":"template<typename Scalar> struct scalar_floor_op {"},
{"lineNum":"  818","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_floor_op)"},
{"lineNum":"  819","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::floor(a); }"},
{"lineNum":"  820","line":"  template <typename Packet>"},
{"lineNum":"  821","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pfloor(a); }"},
{"lineNum":"  822","line":"};"},
{"lineNum":"  823","line":"template<typename Scalar>"},
{"lineNum":"  824","line":"struct functor_traits<scalar_floor_op<Scalar> >"},
{"lineNum":"  825","line":"{"},
{"lineNum":"  826","line":"  enum {"},
{"lineNum":"  827","line":"    Cost = NumTraits<Scalar>::MulCost,"},
{"lineNum":"  828","line":"    PacketAccess = packet_traits<Scalar>::HasFloor"},
{"lineNum":"  829","line":"  };"},
{"lineNum":"  830","line":"};"},
{"lineNum":"  831","line":""},
{"lineNum":"  832","line":"/** \\internal"},
{"lineNum":"  833","line":"  * \\brief Template functor to compute the rounded (with current rounding mode)  value of a scalar"},
{"lineNum":"  834","line":"  * \\sa class CwiseUnaryOp, ArrayBase::rint()"},
{"lineNum":"  835","line":"  */"},
{"lineNum":"  836","line":"template<typename Scalar> struct scalar_rint_op {"},
{"lineNum":"  837","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_rint_op)"},
{"lineNum":"  838","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::rint(a); }"},
{"lineNum":"  839","line":"  template <typename Packet>"},
{"lineNum":"  840","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::print(a); }"},
{"lineNum":"  841","line":"};"},
{"lineNum":"  842","line":"template<typename Scalar>"},
{"lineNum":"  843","line":"struct functor_traits<scalar_rint_op<Scalar> >"},
{"lineNum":"  844","line":"{"},
{"lineNum":"  845","line":"  enum {"},
{"lineNum":"  846","line":"    Cost = NumTraits<Scalar>::MulCost,"},
{"lineNum":"  847","line":"    PacketAccess = packet_traits<Scalar>::HasRint"},
{"lineNum":"  848","line":"  };"},
{"lineNum":"  849","line":"};"},
{"lineNum":"  850","line":""},
{"lineNum":"  851","line":"/** \\internal"},
{"lineNum":"  852","line":"  * \\brief Template functor to compute the ceil of a scalar"},
{"lineNum":"  853","line":"  * \\sa class CwiseUnaryOp, ArrayBase::ceil()"},
{"lineNum":"  854","line":"  */"},
{"lineNum":"  855","line":"template<typename Scalar> struct scalar_ceil_op {"},
{"lineNum":"  856","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_ceil_op)"},
{"lineNum":"  857","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return numext::ceil(a); }"},
{"lineNum":"  858","line":"  template <typename Packet>"},
{"lineNum":"  859","line":"  EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::pceil(a); }"},
{"lineNum":"  860","line":"};"},
{"lineNum":"  861","line":"template<typename Scalar>"},
{"lineNum":"  862","line":"struct functor_traits<scalar_ceil_op<Scalar> >"},
{"lineNum":"  863","line":"{"},
{"lineNum":"  864","line":"  enum {"},
{"lineNum":"  865","line":"    Cost = NumTraits<Scalar>::MulCost,"},
{"lineNum":"  866","line":"    PacketAccess = packet_traits<Scalar>::HasCeil"},
{"lineNum":"  867","line":"  };"},
{"lineNum":"  868","line":"};"},
{"lineNum":"  869","line":""},
{"lineNum":"  870","line":"/** \\internal"},
{"lineNum":"  871","line":"  * \\brief Template functor to compute whether a scalar is NaN"},
{"lineNum":"  872","line":"  * \\sa class CwiseUnaryOp, ArrayBase::isnan()"},
{"lineNum":"  873","line":"  */"},
{"lineNum":"  874","line":"template<typename Scalar> struct scalar_isnan_op {"},
{"lineNum":"  875","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_isnan_op)"},
{"lineNum":"  876","line":"  typedef bool result_type;"},
{"lineNum":"  877","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const {"},
{"lineNum":"  878","line":"#if defined(SYCL_DEVICE_ONLY)"},
{"lineNum":"  879","line":"    return numext::isnan(a);"},
{"lineNum":"  880","line":"#else"},
{"lineNum":"  881","line":"    return (numext::isnan)(a);"},
{"lineNum":"  882","line":"#endif"},
{"lineNum":"  883","line":"  }"},
{"lineNum":"  884","line":"};"},
{"lineNum":"  885","line":"template<typename Scalar>"},
{"lineNum":"  886","line":"struct functor_traits<scalar_isnan_op<Scalar> >"},
{"lineNum":"  887","line":"{"},
{"lineNum":"  888","line":"  enum {"},
{"lineNum":"  889","line":"    Cost = NumTraits<Scalar>::MulCost,"},
{"lineNum":"  890","line":"    PacketAccess = false"},
{"lineNum":"  891","line":"  };"},
{"lineNum":"  892","line":"};"},
{"lineNum":"  893","line":""},
{"lineNum":"  894","line":"/** \\internal"},
{"lineNum":"  895","line":"  * \\brief Template functor to check whether a scalar is +/-inf"},
{"lineNum":"  896","line":"  * \\sa class CwiseUnaryOp, ArrayBase::isinf()"},
{"lineNum":"  897","line":"  */"},
{"lineNum":"  898","line":"template<typename Scalar> struct scalar_isinf_op {"},
{"lineNum":"  899","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_isinf_op)"},
{"lineNum":"  900","line":"  typedef bool result_type;"},
{"lineNum":"  901","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const {"},
{"lineNum":"  902","line":"#if defined(SYCL_DEVICE_ONLY)"},
{"lineNum":"  903","line":"    return numext::isinf(a);"},
{"lineNum":"  904","line":"#else"},
{"lineNum":"  905","line":"    return (numext::isinf)(a);"},
{"lineNum":"  906","line":"#endif"},
{"lineNum":"  907","line":"  }"},
{"lineNum":"  908","line":"};"},
{"lineNum":"  909","line":"template<typename Scalar>"},
{"lineNum":"  910","line":"struct functor_traits<scalar_isinf_op<Scalar> >"},
{"lineNum":"  911","line":"{"},
{"lineNum":"  912","line":"  enum {"},
{"lineNum":"  913","line":"    Cost = NumTraits<Scalar>::MulCost,"},
{"lineNum":"  914","line":"    PacketAccess = false"},
{"lineNum":"  915","line":"  };"},
{"lineNum":"  916","line":"};"},
{"lineNum":"  917","line":""},
{"lineNum":"  918","line":"/** \\internal"},
{"lineNum":"  919","line":"  * \\brief Template functor to check whether a scalar has a finite value"},
{"lineNum":"  920","line":"  * \\sa class CwiseUnaryOp, ArrayBase::isfinite()"},
{"lineNum":"  921","line":"  */"},
{"lineNum":"  922","line":"template<typename Scalar> struct scalar_isfinite_op {"},
{"lineNum":"  923","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_isfinite_op)"},
{"lineNum":"  924","line":"  typedef bool result_type;"},
{"lineNum":"  925","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const {"},
{"lineNum":"  926","line":"#if defined(SYCL_DEVICE_ONLY)"},
{"lineNum":"  927","line":"    return numext::isfinite(a);"},
{"lineNum":"  928","line":"#else"},
{"lineNum":"  929","line":"    return (numext::isfinite)(a);"},
{"lineNum":"  930","line":"#endif"},
{"lineNum":"  931","line":"  }"},
{"lineNum":"  932","line":"};"},
{"lineNum":"  933","line":"template<typename Scalar>"},
{"lineNum":"  934","line":"struct functor_traits<scalar_isfinite_op<Scalar> >"},
{"lineNum":"  935","line":"{"},
{"lineNum":"  936","line":"  enum {"},
{"lineNum":"  937","line":"    Cost = NumTraits<Scalar>::MulCost,"},
{"lineNum":"  938","line":"    PacketAccess = false"},
{"lineNum":"  939","line":"  };"},
{"lineNum":"  940","line":"};"},
{"lineNum":"  941","line":""},
{"lineNum":"  942","line":"/** \\internal"},
{"lineNum":"  943","line":"  * \\brief Template functor to compute the logical not of a boolean"},
{"lineNum":"  944","line":"  *"},
{"lineNum":"  945","line":"  * \\sa class CwiseUnaryOp, ArrayBase::operator!"},
{"lineNum":"  946","line":"  */"},
{"lineNum":"  947","line":"template<typename Scalar> struct scalar_boolean_not_op {"},
{"lineNum":"  948","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_boolean_not_op)"},
{"lineNum":"  949","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool operator() (const bool& a) const { return !a; }"},
{"lineNum":"  950","line":"};"},
{"lineNum":"  951","line":"template<typename Scalar>"},
{"lineNum":"  952","line":"struct functor_traits<scalar_boolean_not_op<Scalar> > {"},
{"lineNum":"  953","line":"  enum {"},
{"lineNum":"  954","line":"    Cost = NumTraits<bool>::AddCost,"},
{"lineNum":"  955","line":"    PacketAccess = false"},
{"lineNum":"  956","line":"  };"},
{"lineNum":"  957","line":"};"},
{"lineNum":"  958","line":""},
{"lineNum":"  959","line":"/** \\internal"},
{"lineNum":"  960","line":"  * \\brief Template functor to compute the signum of a scalar"},
{"lineNum":"  961","line":"  * \\sa class CwiseUnaryOp, Cwise::sign()"},
{"lineNum":"  962","line":"  */"},
{"lineNum":"  963","line":"template<typename Scalar,bool is_complex=(NumTraits<Scalar>::IsComplex!=0), bool is_integer=(NumTraits<Scalar>::IsInteger!=0) > struct scalar_sign_op;"},
{"lineNum":"  964","line":"template<typename Scalar>"},
{"lineNum":"  965","line":"struct scalar_sign_op<Scalar, false, true> {"},
{"lineNum":"  966","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op)"},
{"lineNum":"  967","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const"},
{"lineNum":"  968","line":"  {"},
{"lineNum":"  969","line":"      return Scalar( (a>Scalar(0)) - (a<Scalar(0)) );"},
{"lineNum":"  970","line":"  }"},
{"lineNum":"  971","line":"  //TODO"},
{"lineNum":"  972","line":"  //template <typename Packet>"},
{"lineNum":"  973","line":"  //EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psign(a); }"},
{"lineNum":"  974","line":"};"},
{"lineNum":"  975","line":""},
{"lineNum":"  976","line":"template<typename Scalar>"},
{"lineNum":"  977","line":"struct scalar_sign_op<Scalar, false, false> {"},
{"lineNum":"  978","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op)"},
{"lineNum":"  979","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const"},
{"lineNum":"  980","line":"  {"},
{"lineNum":"  981","line":"    return (numext::isnan)(a) ? a : Scalar( (a>Scalar(0)) - (a<Scalar(0)) );"},
{"lineNum":"  982","line":"  }"},
{"lineNum":"  983","line":"  //TODO"},
{"lineNum":"  984","line":"  //template <typename Packet>"},
{"lineNum":"  985","line":"  //EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psign(a); }"},
{"lineNum":"  986","line":"};"},
{"lineNum":"  987","line":""},
{"lineNum":"  988","line":"template<typename Scalar, bool is_integer>"},
{"lineNum":"  989","line":"struct scalar_sign_op<Scalar,true, is_integer> {"},
{"lineNum":"  990","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_sign_op)"},
{"lineNum":"  991","line":"  EIGEN_DEVICE_FUNC inline const Scalar operator() (const Scalar& a) const"},
{"lineNum":"  992","line":"  {"},
{"lineNum":"  993","line":"    typedef typename NumTraits<Scalar>::Real real_type;"},
{"lineNum":"  994","line":"    real_type aa = numext::abs(a);"},
{"lineNum":"  995","line":"    if (aa==real_type(0))"},
{"lineNum":"  996","line":"      return Scalar(0);"},
{"lineNum":"  997","line":"    aa = real_type(1)/aa;"},
{"lineNum":"  998","line":"    return Scalar(a.real()*aa, a.imag()*aa );"},
{"lineNum":"  999","line":"  }"},
{"lineNum":" 1000","line":"  //TODO"},
{"lineNum":" 1001","line":"  //template <typename Packet>"},
{"lineNum":" 1002","line":"  //EIGEN_DEVICE_FUNC inline Packet packetOp(const Packet& a) const { return internal::psign(a); }"},
{"lineNum":" 1003","line":"};"},
{"lineNum":" 1004","line":"template<typename Scalar>"},
{"lineNum":" 1005","line":"struct functor_traits<scalar_sign_op<Scalar> >"},
{"lineNum":" 1006","line":"{ enum {"},
{"lineNum":" 1007","line":"    Cost ="},
{"lineNum":" 1008","line":"        NumTraits<Scalar>::IsComplex"},
{"lineNum":" 1009","line":"        ? ( 8*NumTraits<Scalar>::MulCost  ) // roughly"},
{"lineNum":" 1010","line":"        : ( 3*NumTraits<Scalar>::AddCost),"},
{"lineNum":" 1011","line":"    PacketAccess = packet_traits<Scalar>::HasSign"},
{"lineNum":" 1012","line":"  };"},
{"lineNum":" 1013","line":"};"},
{"lineNum":" 1014","line":""},
{"lineNum":" 1015","line":"/** \\internal"},
{"lineNum":" 1016","line":"  * \\brief Template functor to compute the logistic function of a scalar"},
{"lineNum":" 1017","line":"  * \\sa class CwiseUnaryOp, ArrayBase::logistic()"},
{"lineNum":" 1018","line":"  */"},
{"lineNum":" 1019","line":"template <typename T>"},
{"lineNum":" 1020","line":"struct scalar_logistic_op {"},
{"lineNum":" 1021","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_logistic_op)"},
{"lineNum":" 1022","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE T operator()(const T& x) const {"},
{"lineNum":" 1023","line":"    return packetOp(x);"},
{"lineNum":" 1024","line":"  }"},
{"lineNum":" 1025","line":""},
{"lineNum":" 1026","line":"  template <typename Packet> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":" 1027","line":"  Packet packetOp(const Packet& x) const {"},
{"lineNum":" 1028","line":"    const Packet one = pset1<Packet>(T(1));"},
{"lineNum":" 1029","line":"    return pdiv(one, padd(one, pexp(pnegate(x))));"},
{"lineNum":" 1030","line":"  }"},
{"lineNum":" 1031","line":"};"},
{"lineNum":" 1032","line":""},
{"lineNum":" 1033","line":"#ifndef EIGEN_GPU_COMPILE_PHASE"},
{"lineNum":" 1034","line":"/** \\internal"},
{"lineNum":" 1035","line":"  * \\brief Template specialization of the logistic function for float."},
{"lineNum":" 1036","line":"  *"},
{"lineNum":" 1037","line":"  *  Uses just a 9/10-degree rational interpolant which"},
{"lineNum":" 1038","line":"  *  interpolates 1/(1+exp(-x)) - 0.5 up to a couple of ulps in the range"},
{"lineNum":" 1039","line":"  *  [-9, 18]. Below -9 we use the more accurate approximation"},
{"lineNum":" 1040","line":"  *  1/(1+exp(-x)) ~= exp(x), and above 18 the logistic function is 1 within"},
{"lineNum":" 1041","line":"  *  one ulp. The shifted logistic is interpolated because it was easier to"},
{"lineNum":" 1042","line":"  *  make the fit converge."},
{"lineNum":" 1043","line":"  *"},
{"lineNum":" 1044","line":"  */"},
{"lineNum":" 1045","line":"template <>"},
{"lineNum":" 1046","line":"struct scalar_logistic_op<float> {"},
{"lineNum":" 1047","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_logistic_op)"},
{"lineNum":" 1048","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE float operator()(const float& x) const {"},
{"lineNum":" 1049","line":"    return packetOp(x);"},
{"lineNum":" 1050","line":"  }"},
{"lineNum":" 1051","line":""},
{"lineNum":" 1052","line":"  template <typename Packet> EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":" 1053","line":"  Packet packetOp(const Packet& _x) const {"},
{"lineNum":" 1054","line":"    const Packet cutoff_lower = pset1<Packet>(-9.f);"},
{"lineNum":" 1055","line":"    const Packet lt_mask = pcmp_lt<Packet>(_x, cutoff_lower);"},
{"lineNum":" 1056","line":"    const bool any_small = predux_any(lt_mask);"},
{"lineNum":" 1057","line":""},
{"lineNum":" 1058","line":"    // The upper cut-off is the smallest x for which the rational approximation evaluates to 1."},
{"lineNum":" 1059","line":"    // Choosing this value saves us a few instructions clamping the results at the end."},
{"lineNum":" 1060","line":"#ifdef EIGEN_VECTORIZE_FMA"},
{"lineNum":" 1061","line":"    const Packet cutoff_upper = pset1<Packet>(15.7243833541870117f);"},
{"lineNum":" 1062","line":"#else"},
{"lineNum":" 1063","line":"    const Packet cutoff_upper = pset1<Packet>(15.6437711715698242f);"},
{"lineNum":" 1064","line":"#endif"},
{"lineNum":" 1065","line":"    const Packet x = pmin(_x, cutoff_upper);"},
{"lineNum":" 1066","line":""},
{"lineNum":" 1067","line":"    // The monomial coefficients of the numerator polynomial (odd)."},
{"lineNum":" 1068","line":"    const Packet alpha_1 = pset1<Packet>(2.48287947061529e-01f);"},
{"lineNum":" 1069","line":"    const Packet alpha_3 = pset1<Packet>(8.51377133304701e-03f);"},
{"lineNum":" 1070","line":"    const Packet alpha_5 = pset1<Packet>(6.08574864600143e-05f);"},
{"lineNum":" 1071","line":"    const Packet alpha_7 = pset1<Packet>(1.15627324459942e-07f);"},
{"lineNum":" 1072","line":"    const Packet alpha_9 = pset1<Packet>(4.37031012579801e-11f);"},
{"lineNum":" 1073","line":""},
{"lineNum":" 1074","line":"    // The monomial coefficients of the denominator polynomial (even)."},
{"lineNum":" 1075","line":"    const Packet beta_0 = pset1<Packet>(9.93151921023180e-01f);"},
{"lineNum":" 1076","line":"    const Packet beta_2 = pset1<Packet>(1.16817656904453e-01f);"},
{"lineNum":" 1077","line":"    const Packet beta_4 = pset1<Packet>(1.70198817374094e-03f);"},
{"lineNum":" 1078","line":"    const Packet beta_6 = pset1<Packet>(6.29106785017040e-06f);"},
{"lineNum":" 1079","line":"    const Packet beta_8 = pset1<Packet>(5.76102136993427e-09f);"},
{"lineNum":" 1080","line":"    const Packet beta_10 = pset1<Packet>(6.10247389755681e-13f);"},
{"lineNum":" 1081","line":""},
{"lineNum":" 1082","line":"    // Since the polynomials are odd/even, we need x^2."},
{"lineNum":" 1083","line":"    const Packet x2 = pmul(x, x);"},
{"lineNum":" 1084","line":""},
{"lineNum":" 1085","line":"    // Evaluate the numerator polynomial p."},
{"lineNum":" 1086","line":"    Packet p = pmadd(x2, alpha_9, alpha_7);"},
{"lineNum":" 1087","line":"    p = pmadd(x2, p, alpha_5);"},
{"lineNum":" 1088","line":"    p = pmadd(x2, p, alpha_3);"},
{"lineNum":" 1089","line":"    p = pmadd(x2, p, alpha_1);"},
{"lineNum":" 1090","line":"    p = pmul(x, p);"},
{"lineNum":" 1091","line":""},
{"lineNum":" 1092","line":"    // Evaluate the denominator polynomial q."},
{"lineNum":" 1093","line":"    Packet q = pmadd(x2, beta_10, beta_8);"},
{"lineNum":" 1094","line":"    q = pmadd(x2, q, beta_6);"},
{"lineNum":" 1095","line":"    q = pmadd(x2, q, beta_4);"},
{"lineNum":" 1096","line":"    q = pmadd(x2, q, beta_2);"},
{"lineNum":" 1097","line":"    q = pmadd(x2, q, beta_0);"},
{"lineNum":" 1098","line":"    // Divide the numerator by the denominator and shift it up."},
{"lineNum":" 1099","line":"    const Packet logistic = padd(pdiv(p, q), pset1<Packet>(0.5f));"},
{"lineNum":" 1100","line":"    if (EIGEN_PREDICT_FALSE(any_small)) {"},
{"lineNum":" 1101","line":"      const Packet exponential = pexp(_x);"},
{"lineNum":" 1102","line":"      return pselect(lt_mask, exponential, logistic);"},
{"lineNum":" 1103","line":"    } else {"},
{"lineNum":" 1104","line":"      return logistic;"},
{"lineNum":" 1105","line":"    }"},
{"lineNum":" 1106","line":"  }"},
{"lineNum":" 1107","line":"};"},
{"lineNum":" 1108","line":"#endif  // #ifndef EIGEN_GPU_COMPILE_PHASE"},
{"lineNum":" 1109","line":""},
{"lineNum":" 1110","line":"template <typename T>"},
{"lineNum":" 1111","line":"struct functor_traits<scalar_logistic_op<T> > {"},
{"lineNum":" 1112","line":"  enum {"},
{"lineNum":" 1113","line":"    // The cost estimate for float here here is for the common(?) case where"},
{"lineNum":" 1114","line":"    // all arguments are greater than -9."},
{"lineNum":" 1115","line":"    Cost = scalar_div_cost<T, packet_traits<T>::HasDiv>::value +"},
{"lineNum":" 1116","line":"           (internal::is_same<T, float>::value"},
{"lineNum":" 1117","line":"                ? NumTraits<T>::AddCost * 15 + NumTraits<T>::MulCost * 11"},
{"lineNum":" 1118","line":"                : NumTraits<T>::AddCost * 2 +"},
{"lineNum":" 1119","line":"                      functor_traits<scalar_exp_op<T> >::Cost),"},
{"lineNum":" 1120","line":"    PacketAccess ="},
{"lineNum":" 1121","line":"        packet_traits<T>::HasAdd && packet_traits<T>::HasDiv &&"},
{"lineNum":" 1122","line":"        (internal::is_same<T, float>::value"},
{"lineNum":" 1123","line":"             ? packet_traits<T>::HasMul && packet_traits<T>::HasMax &&"},
{"lineNum":" 1124","line":"                   packet_traits<T>::HasMin"},
{"lineNum":" 1125","line":"             : packet_traits<T>::HasNegate && packet_traits<T>::HasExp)"},
{"lineNum":" 1126","line":"  };"},
{"lineNum":" 1127","line":"};"},
{"lineNum":" 1128","line":""},
{"lineNum":" 1129","line":"} // end namespace internal"},
{"lineNum":" 1130","line":""},
{"lineNum":" 1131","line":"} // end namespace Eigen"},
{"lineNum":" 1132","line":""},
{"lineNum":" 1133","line":"#endif // EIGEN_FUNCTORS_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 1, "covered" : 0,};
var merged_data = [];
