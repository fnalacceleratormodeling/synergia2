var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_CONCURRENTBITSET_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_CONCURRENTBITSET_HPP"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include <stdint.h>"},
{"lineNum":"   49","line":"#include <Kokkos_Atomic.hpp>"},
{"lineNum":"   50","line":"#include <impl/Kokkos_BitOps.hpp>"},
{"lineNum":"   51","line":"#include <impl/Kokkos_ClockTic.hpp>"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"namespace Kokkos {"},
{"lineNum":"   54","line":"namespace Impl {"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"struct concurrent_bitset {"},
{"lineNum":"   57","line":" public:"},
{"lineNum":"   58","line":"  // 32 bits per integer value"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"  enum : uint32_t { bits_per_int_lg2 = 5 };"},
{"lineNum":"   61","line":"  enum : uint32_t { bits_per_int_mask = (1 << bits_per_int_lg2) - 1 };"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"  // Buffer is uint32_t[ buffer_bound ]"},
{"lineNum":"   64","line":"  //   [ uint32_t { state_header | used_count } , uint32_t bits[*] ]"},
{"lineNum":"   65","line":"  //"},
{"lineNum":"   66","line":"  //  Maximum bit count is 33 million (1u<<25):"},
{"lineNum":"   67","line":"  //"},
{"lineNum":"   68","line":"  //  - Maximum bit set size occupies 1 Mbyte"},
{"lineNum":"   69","line":"  //"},
{"lineNum":"   70","line":"  //  - State header can occupy bits [30-26]"},
{"lineNum":"   71","line":"  //    which can be the bit_count_lg2"},
{"lineNum":"   72","line":"  //"},
{"lineNum":"   73","line":"  //  - Accept at least 33 million concurrent calls to \'acquire\'"},
{"lineNum":"   74","line":"  //    before risking an overflow race condition on a full bitset."},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"  enum : uint32_t { max_bit_count_lg2 = 25 };"},
{"lineNum":"   77","line":"  enum : uint32_t { max_bit_count = 1u << max_bit_count_lg2 };"},
{"lineNum":"   78","line":"  enum : uint32_t { state_shift = 26 };"},
{"lineNum":"   79","line":"  enum : uint32_t { state_used_mask = (1 << state_shift) - 1 };"},
{"lineNum":"   80","line":"  enum : uint32_t { state_header_mask = uint32_t(0x001f) << state_shift };"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"  KOKKOS_INLINE_FUNCTION static constexpr uint32_t buffer_bound_lg2("},
{"lineNum":"   83","line":"      uint32_t const bit_bound_lg2) noexcept {"},
{"lineNum":"   84","line":"    return bit_bound_lg2 <= max_bit_count_lg2"},
{"lineNum":"   85","line":"               ? 1 + (1u << (bit_bound_lg2 > bits_per_int_lg2"},
{"lineNum":"   86","line":"                                 ? bit_bound_lg2 - bits_per_int_lg2"},
{"lineNum":"   87","line":"                                 : 0))"},
{"lineNum":"   88","line":"               : 0;"},
{"lineNum":"   89","line":"  }"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"  /**\\brief  Initialize bitset buffer */"},
{"lineNum":"   92","line":"  KOKKOS_INLINE_FUNCTION static constexpr uint32_t buffer_bound("},
{"lineNum":"   93","line":"      uint32_t const bit_bound) noexcept {"},
{"lineNum":"   94","line":"    return bit_bound <= max_bit_count"},
{"lineNum":"   95","line":"               ? 1 + (bit_bound >> bits_per_int_lg2) +"},
{"lineNum":"   96","line":"                     (bit_bound & bits_per_int_mask ? 1 : 0)"},
{"lineNum":"   97","line":"               : 0;"},
{"lineNum":"   98","line":"  }"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"  /**\\brief  Claim any bit within the bitset bound."},
{"lineNum":"  101","line":"   *"},
{"lineNum":"  102","line":"   *  Return : ( which_bit , bit_count )"},
{"lineNum":"  103","line":"   *"},
{"lineNum":"  104","line":"   *  if success then"},
{"lineNum":"  105","line":"   *    bit_count is the atomic-count of claimed > 0"},
{"lineNum":"  106","line":"   *    which_bit is the claimed bit >= 0"},
{"lineNum":"  107","line":"   *  else if attempt failed due to filled buffer"},
{"lineNum":"  108","line":"   *    bit_count == which_bit == -1"},
{"lineNum":"  109","line":"   *  else if attempt failed due to non-matching state_header"},
{"lineNum":"  110","line":"   *    bit_count == which_bit == -2"},
{"lineNum":"  111","line":"   *  else if attempt failed due to max_bit_count_lg2 < bit_bound_lg2"},
{"lineNum":"  112","line":"   *                             or invalid state_header"},
{"lineNum":"  113","line":"   *                             or (1u << bit_bound_lg2) <= bit"},
{"lineNum":"  114","line":"   *    bit_count == which_bit == -3"},
{"lineNum":"  115","line":"   *  endif"},
{"lineNum":"  116","line":"   *"},
{"lineNum":"  117","line":"   *  Recommended to have hint"},
{"lineNum":"  118","line":"   *    bit = Kokkos::Impl::clock_tic() & ((1u<<bit_bound_lg2) - 1)"},
{"lineNum":"  119","line":"   */"},
{"lineNum":"  120","line":"  KOKKOS_INLINE_FUNCTION static Kokkos::pair<int, int> acquire_bounded_lg2("},
{"lineNum":"  121","line":"      uint32_t volatile *const buffer, uint32_t const bit_bound_lg2,"},
{"lineNum":"  122","line":"      uint32_t bit = 0 /* optional hint */"},
{"lineNum":"  123","line":"      ,"},
{"lineNum":"  124","line":"      uint32_t const state_header = 0 /* optional header */"},
{"lineNum":"  125","line":"      ) noexcept {"},
{"lineNum":"  126","line":"    using type = Kokkos::pair<int, int>;"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":"    const uint32_t bit_bound  = 1 << bit_bound_lg2;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  129","line":"    const uint32_t word_count = bit_bound >> bits_per_int_lg2;"},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"    if ((max_bit_count_lg2 < bit_bound_lg2) ||","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  132","line":"        (state_header & ~state_header_mask) || (bit_bound < bit)) {"},
{"lineNum":"  133","line":"      return type(-3, -3);"},
{"lineNum":"  134","line":"    }"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"    // Use potentially two fetch_add to avoid CAS loop."},
{"lineNum":"  137","line":"    // Could generate \"racing\" failure-to-acquire"},
{"lineNum":"  138","line":"    // when is full at the atomic_fetch_add(+1)"},
{"lineNum":"  139","line":"    // then a release occurs before the atomic_fetch_add(-1)."},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"    const uint32_t state ="},
{"lineNum":"  142","line":"        (uint32_t)Kokkos::atomic_fetch_add((volatile int *)buffer, 1);"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"    const uint32_t state_error = state_header != (state & state_header_mask);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"    const uint32_t state_bit_used = state & state_used_mask;"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"    if (state_error || (bit_bound <= state_bit_used)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  149","line":"      Kokkos::atomic_fetch_add((volatile int *)buffer, -1);"},
{"lineNum":"  150","line":"      return state_error ? type(-2, -2) : type(-1, -1);"},
{"lineNum":"  151","line":"    }"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"    // Do not update bit until count is visible:"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"    Kokkos::memory_fence();"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"    // There is a zero bit available somewhere,"},
{"lineNum":"  158","line":"    // now find the (first) available bit and set it."},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"    while (1) {"},
{"lineNum":"  161","line":"      const uint32_t word = bit >> bits_per_int_lg2;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  162","line":"      const uint32_t mask = 1u << (bit & bits_per_int_mask);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  163","line":"      const uint32_t prev = Kokkos::atomic_fetch_or(buffer + word + 1, mask);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"      if (!(prev & mask)) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  166","line":"        // Successfully claimed \'result.first\' by"},
{"lineNum":"  167","line":"        // atomically setting that bit."},
{"lineNum":"  168","line":"        return type(bit, state_bit_used + 1);"},
{"lineNum":"  169","line":"      }"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"      // Failed race to set the selected bit"},
{"lineNum":"  172","line":"      // Find a new bit to try."},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"      const int j = Kokkos::Impl::bit_first_zero(prev);"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"      if (0 <= j) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  177","line":"        bit = (word << bits_per_int_lg2) | uint32_t(j);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  178","line":"      } else {"},
{"lineNum":"  179","line":"        bit = ((word + 1) < word_count ? ((word + 1) << bits_per_int_lg2) : 0) |","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  180","line":"              (bit & bits_per_int_mask);"},
{"lineNum":"  181","line":"      }"},
{"lineNum":"  182","line":"    }"},
{"lineNum":"  183","line":"  }"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"  /**\\brief  Claim any bit within the bitset bound."},
{"lineNum":"  186","line":"   *"},
{"lineNum":"  187","line":"   *  Return : ( which_bit , bit_count )"},
{"lineNum":"  188","line":"   *"},
{"lineNum":"  189","line":"   *  if success then"},
{"lineNum":"  190","line":"   *    bit_count is the atomic-count of claimed > 0"},
{"lineNum":"  191","line":"   *    which_bit is the claimed bit >= 0"},
{"lineNum":"  192","line":"   *  else if attempt failed due to filled buffer"},
{"lineNum":"  193","line":"   *    bit_count == which_bit == -1"},
{"lineNum":"  194","line":"   *  else if attempt failed due to non-matching state_header"},
{"lineNum":"  195","line":"   *    bit_count == which_bit == -2"},
{"lineNum":"  196","line":"   *  else if attempt failed due to max_bit_count_lg2 < bit_bound_lg2"},
{"lineNum":"  197","line":"   *                             or invalid state_header"},
{"lineNum":"  198","line":"   *                             or bit_bound <= bit"},
{"lineNum":"  199","line":"   *    bit_count == which_bit == -3"},
{"lineNum":"  200","line":"   *  endif"},
{"lineNum":"  201","line":"   *"},
{"lineNum":"  202","line":"   *  Recommended to have hint"},
{"lineNum":"  203","line":"   *    bit = Kokkos::Impl::clock_tic() % bit_bound"},
{"lineNum":"  204","line":"   */"},
{"lineNum":"  205","line":"  KOKKOS_INLINE_FUNCTION static Kokkos::pair<int, int> acquire_bounded("},
{"lineNum":"  206","line":"      uint32_t volatile *const buffer, uint32_t const bit_bound,"},
{"lineNum":"  207","line":"      uint32_t bit = 0 /* optional hint */"},
{"lineNum":"  208","line":"      ,"},
{"lineNum":"  209","line":"      uint32_t const state_header = 0 /* optional header */"},
{"lineNum":"  210","line":"      ) noexcept {"},
{"lineNum":"  211","line":"    using type = Kokkos::pair<int, int>;"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    if ((max_bit_count < bit_bound) || (state_header & ~state_header_mask) ||"},
{"lineNum":"  214","line":"        (bit_bound <= bit)) {"},
{"lineNum":"  215","line":"      return type(-3, -3);"},
{"lineNum":"  216","line":"    }"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"    const uint32_t word_count = bit_bound >> bits_per_int_lg2;"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    // Use potentially two fetch_add to avoid CAS loop."},
{"lineNum":"  221","line":"    // Could generate \"racing\" failure-to-acquire"},
{"lineNum":"  222","line":"    // when is full at the atomic_fetch_add(+1)"},
{"lineNum":"  223","line":"    // then a release occurs before the atomic_fetch_add(-1)."},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"    const uint32_t state ="},
{"lineNum":"  226","line":"        (uint32_t)Kokkos::atomic_fetch_add((volatile int *)buffer, 1);"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"    const uint32_t state_error = state_header != (state & state_header_mask);"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    const uint32_t state_bit_used = state & state_used_mask;"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"    if (state_error || (bit_bound <= state_bit_used)) {"},
{"lineNum":"  233","line":"      Kokkos::atomic_fetch_add((volatile int *)buffer, -1);"},
{"lineNum":"  234","line":"      return state_error ? type(-2, -2) : type(-1, -1);"},
{"lineNum":"  235","line":"    }"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"    // Do not update bit until count is visible:"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"    Kokkos::memory_fence();"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"    // There is a zero bit available somewhere,"},
{"lineNum":"  242","line":"    // now find the (first) available bit and set it."},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"    while (1) {"},
{"lineNum":"  245","line":"      const uint32_t word = bit >> bits_per_int_lg2;"},
{"lineNum":"  246","line":"      const uint32_t mask = 1u << (bit & bits_per_int_mask);"},
{"lineNum":"  247","line":"      const uint32_t prev = Kokkos::atomic_fetch_or(buffer + word + 1, mask);"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"      if (!(prev & mask)) {"},
{"lineNum":"  250","line":"        // Successfully claimed \'result.first\' by"},
{"lineNum":"  251","line":"        // atomically setting that bit."},
{"lineNum":"  252","line":"        // Flush the set operation. Technically this only needs to be acquire/"},
{"lineNum":"  253","line":"        // release semantics and not sequentially consistent, but for now"},
{"lineNum":"  254","line":"        // we\'ll just do this."},
{"lineNum":"  255","line":"        Kokkos::memory_fence();"},
{"lineNum":"  256","line":"        return type(bit, state_bit_used + 1);"},
{"lineNum":"  257","line":"      }"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"      // Failed race to set the selected bit"},
{"lineNum":"  260","line":"      // Find a new bit to try."},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"      const int j = Kokkos::Impl::bit_first_zero(prev);"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"      if (0 <= j) {"},
{"lineNum":"  265","line":"        bit = (word << bits_per_int_lg2) | uint32_t(j);"},
{"lineNum":"  266","line":"      }"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"      if ((j < 0) || (bit_bound <= bit)) {"},
{"lineNum":"  269","line":"        bit = ((word + 1) < word_count ? ((word + 1) << bits_per_int_lg2) : 0) |"},
{"lineNum":"  270","line":"              (bit & bits_per_int_mask);"},
{"lineNum":"  271","line":"      }"},
{"lineNum":"  272","line":"    }"},
{"lineNum":"  273","line":"  }"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"  /**\\brief"},
{"lineNum":"  276","line":"   *"},
{"lineNum":"  277","line":"   *  Requires: \'bit\' previously acquired and has not yet been released."},
{"lineNum":"  278","line":"   *"},
{"lineNum":"  279","line":"   *  Returns:"},
{"lineNum":"  280","line":"   *    0 <= used count after successful release"},
{"lineNum":"  281","line":"   *    -1 bit was already released"},
{"lineNum":"  282","line":"   *    -2 state_header error"},
{"lineNum":"  283","line":"   */"},
{"lineNum":"  284","line":"  KOKKOS_INLINE_FUNCTION static int release("},
{"lineNum":"  285","line":"      uint32_t volatile *const buffer, uint32_t const bit,"},
{"lineNum":"  286","line":"      uint32_t const state_header = 0 /* optional header */"},
{"lineNum":"  287","line":"      ) noexcept {"},
{"lineNum":"  288","line":"    if (state_header != (state_header_mask & *buffer)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  289","line":"      return -2;"},
{"lineNum":"  290","line":"    }"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"    const uint32_t mask = 1u << (bit & bits_per_int_mask);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  293","line":"    const uint32_t prev ="},
{"lineNum":"  294","line":"        Kokkos::atomic_fetch_and(buffer + (bit >> bits_per_int_lg2) + 1, ~mask);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"    if (!(prev & mask)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  297","line":"      return -1;"},
{"lineNum":"  298","line":"    }"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"    // Do not update count until bit clear is visible"},
{"lineNum":"  301","line":"    Kokkos::memory_fence();"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"    const int count = Kokkos::atomic_fetch_add((volatile int *)buffer, -1);"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"    // Flush the store-release"},
{"lineNum":"  306","line":"    Kokkos::memory_fence();"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"    return (count & state_used_mask) - 1;"},
{"lineNum":"  309","line":"  }"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"  /**\\brief"},
{"lineNum":"  312","line":"   *"},
{"lineNum":"  313","line":"   *  Requires: Bit within bounds and not already set."},
{"lineNum":"  314","line":"   *"},
{"lineNum":"  315","line":"   *  Returns:"},
{"lineNum":"  316","line":"   *    0 <= used count after successful release"},
{"lineNum":"  317","line":"   *    -1 bit was already released"},
{"lineNum":"  318","line":"   *    -2 bit or state_header error"},
{"lineNum":"  319","line":"   */"},
{"lineNum":"  320","line":"  KOKKOS_INLINE_FUNCTION static int set("},
{"lineNum":"  321","line":"      uint32_t volatile *const buffer, uint32_t const bit,"},
{"lineNum":"  322","line":"      uint32_t const state_header = 0 /* optional header */"},
{"lineNum":"  323","line":"      ) noexcept {"},
{"lineNum":"  324","line":"    if (state_header != (state_header_mask & *buffer)) {"},
{"lineNum":"  325","line":"      return -2;"},
{"lineNum":"  326","line":"    }"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"    const uint32_t mask = 1u << (bit & bits_per_int_mask);"},
{"lineNum":"  329","line":"    const uint32_t prev ="},
{"lineNum":"  330","line":"        Kokkos::atomic_fetch_or(buffer + (bit >> bits_per_int_lg2) + 1, mask);"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"    if (!(prev & mask)) {"},
{"lineNum":"  333","line":"      return -1;"},
{"lineNum":"  334","line":"    }"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"    // Do not update count until bit clear is visible"},
{"lineNum":"  337","line":"    Kokkos::memory_fence();"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"    const int count = Kokkos::atomic_fetch_add((volatile int *)buffer, -1);"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"    return (count & state_used_mask) - 1;"},
{"lineNum":"  342","line":"  }"},
{"lineNum":"  343","line":"};"},
{"lineNum":"  344","line":""},
{"lineNum":"  345","line":"}  // namespace Impl"},
{"lineNum":"  346","line":"}  // namespace Kokkos"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"#endif /* #ifndef KOKKOS_CONCURRENTBITSET_HPP */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 15, "covered" : 0,};
var merged_data = [];
