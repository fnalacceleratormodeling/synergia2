var data = {lines:[
{"lineNum":"    1","line":"#ifndef HDF5_FILE_H_"},
{"lineNum":"    2","line":"#define HDF5_FILE_H_"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"#include <string>"},
{"lineNum":"    5","line":"#include <memory>"},
{"lineNum":"    6","line":""},
{"lineNum":"    7","line":"#include \"synergia/utils/hdf5_misc.h\""},
{"lineNum":"    8","line":"#include \"synergia/utils/hdf5_writer.h\""},
{"lineNum":"    9","line":"#include \"synergia/utils/hdf5_reader.h\""},
{"lineNum":"   10","line":"#include \"synergia/utils/hdf5_seq_writer.h\""},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"#include \"synergia/utils/cereal.h\""},
{"lineNum":"   13","line":"#include \"synergia/utils/commxx.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"class Hdf5_file"},
{"lineNum":"   17","line":"{"},
{"lineNum":"   18","line":"public:"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"    enum Flag { truncate, read_write, read_only };"},
{"lineNum":"   21","line":"    enum Atomic_type { double_type, int_type };"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"    // set the type based on cmake config"},
{"lineNum":"   24","line":"#ifdef USE_PARALLEL_HDF5"},
{"lineNum":"   25","line":"    using use_parallel = std::true_type;"},
{"lineNum":"   26","line":"#else"},
{"lineNum":"   27","line":"    using use_parallel = std::false_type;"},
{"lineNum":"   28","line":"#endif"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"private:"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"    std::shared_ptr<Commxx> comm;"},
{"lineNum":"   33","line":"    std::string file_name;"},
{"lineNum":"   34","line":"    Hdf5_handler h5file;"},
{"lineNum":"   35","line":"    int root_rank;"},
{"lineNum":"   36","line":"    bool is_open;"},
{"lineNum":"   37","line":"    Flag current_flag;"},
{"lineNum":"   38","line":"    bool has_file;"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"    std::map<std::string, Hdf5_seq_writer> seq_writers;"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"    static unsigned int flag_to_h5_flags(Flag flag)"},
{"lineNum":"   43","line":"    {"},
{"lineNum":"   44","line":"        if (flag == Hdf5_file::truncate)   return H5F_ACC_TRUNC;"},
{"lineNum":"   45","line":"        if (flag == Hdf5_file::read_write) return H5F_ACC_RDWR;"},
{"lineNum":"   46","line":"        if (flag == Hdf5_file::read_only)  return H5F_ACC_RDONLY;"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"        return 0;"},
{"lineNum":"   49","line":"    }"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"public:"},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"    // since C++17 the shared_from_this() called from an unmanaged"},
{"lineNum":"   54","line":"    // shared_ptr would throw the bad_weak_ptr exception, instead"},
{"lineNum":"   55","line":"    // of having an undefined behavior. So if we move to C++17 we"},
{"lineNum":"   56","line":"    // would be able to reduce the constructor to a single one by"},
{"lineNum":"   57","line":"    // testing if we are able to call the shared_from_this(),"},
{"lineNum":"   58","line":"    //    ..."},
{"lineNum":"   59","line":"    //    try { comm = c.shared_from_this();}"},
{"lineNum":"   60","line":"    //    catch(...) { comm = std::make_shared<const Commxx>(c); }"},
{"lineNum":"   61","line":"    //    ..."},
{"lineNum":"   62","line":"    //"},
{"lineNum":"   63","line":"    // for now two separate constructors are both provided"},
{"lineNum":"   64","line":"    //"},
{"lineNum":"   65","line":"    Hdf5_file( std::string const& file_name,"},
{"lineNum":"   66","line":"               Flag flag,"},
{"lineNum":"   67","line":"               std::shared_ptr<Commxx> const& comm );"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"    Hdf5_file( std::string const& file_name,"},
{"lineNum":"   70","line":"               Flag flag,"},
{"lineNum":"   71","line":"               Commxx const& comm = Commxx() );"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    ~Hdf5_file() { close(); }","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"    // this is a resource handler, so disable the copy and assignment"},
{"lineNum":"   76","line":"    Hdf5_file(Hdf5_file const&) = delete;"},
{"lineNum":"   77","line":"    Hdf5_file& operator=(Hdf5_file const&) = delete;"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"    // move is still allowed"},
{"lineNum":"   80","line":"    Hdf5_file(Hdf5_file &&) noexcept = default;"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"    void open(Flag flag);"},
{"lineNum":"   83","line":"    void close();"},
{"lineNum":"   84","line":"    void flush() const;"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"    std::string const& get_filename() const"},
{"lineNum":"   87","line":"    { return file_name; }"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"#if 0"},
{"lineNum":"   90","line":"    std::vector<std::string> get_member_names();"},
{"lineNum":"   91","line":"    Atomic_type get_atomic_type(std::string const& name);"},
{"lineNum":"   92","line":"    std::vector<int > get_dims(std::string const& name);"},
{"lineNum":"   93","line":"#endif"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"    hid_t get_h5file()"},
{"lineNum":"   96","line":"    { return h5file.hid; }"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"    int master_rank() const"},
{"lineNum":"   99","line":"    { return root_rank; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"    // gather on the first dimension. all other dimensions must be of the same extents"},
{"lineNum":"  102","line":"    // calling from 4 ranks:"},
{"lineNum":"  103","line":"    //   write_collective(\"ds\", pz) -> \"ds\" : [pz, pz, ...]"},
{"lineNum":"  104","line":"    //   write_collective(\"part\", part[0:1][0:6]) -> \"part\" : part[0:3][0:6]"},
{"lineNum":"  105","line":"    template<typename T>"},
{"lineNum":"  106","line":"    void write_collective(std::string const& name, T const& data) const"},
{"lineNum":"  107","line":"    { write(name, data, true); }"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    // no gather, only the root rank will execute the write"},
{"lineNum":"  110","line":"    // calling from 4 ranks:"},
{"lineNum":"  111","line":"    //   write_single(\"ds\", pz) -> \"ds\" : pz"},
{"lineNum":"  112","line":"    //   write_single(\"part\", part[0:1][0:6]) -> \"part\" : part[0:1][0:6]"},
{"lineNum":"  113","line":"    template<typename T>"},
{"lineNum":"  114","line":"    void write_single(std::string const& name, T const& data) const"},
{"lineNum":"  115","line":"    { write(name, data, false); }"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"    template<typename T>"},
{"lineNum":"  118","line":"    void write(std::string const& name, T const& data, bool collective = false) const"},
{"lineNum":"  119","line":"    { Hdf5_writer::write(h5file, name, data, collective, *comm, root_rank); }","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"    template<typename T>"},
{"lineNum":"  122","line":"    void write(std::string const & name, T const* data, size_t len, bool collective = false) const"},
{"lineNum":"  123","line":"    { Hdf5_writer::write(h5file, name, data, len, collective, *comm, root_rank); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"    // same as write_single(), except this will do append instead of overwrite"},
{"lineNum":"  127","line":"    template<typename T>"},
{"lineNum":"  128","line":"    void append_single(std::string const& name, T const& data)"},
{"lineNum":"  129","line":"    { append(name, data, false); }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  130","line":""},
{"lineNum":"  131","line":"    template<typename T>"},
{"lineNum":"  132","line":"    void append_collective(std::string const& name, T const& data)"},
{"lineNum":"  133","line":"    { append(name, data, true); }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"    // same as write(), except this will do append instead of overwrite"},
{"lineNum":"  136","line":"    template<typename T>"},
{"lineNum":"  137","line":"    void append(std::string const& name, T const& data, bool collective = false)"},
{"lineNum":"  138","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  139","line":"        auto w = seq_writers.find(name);"},
{"lineNum":"  140","line":"        if (w == seq_writers.end())","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  141","line":"        {"},
{"lineNum":"  142","line":"            w = seq_writers","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  143","line":"                .emplace(name, Hdf5_seq_writer(h5file, name, *comm, root_rank))","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  144","line":"                .first;"},
{"lineNum":"  145","line":"        }"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"        w->second.append(data, collective);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  148","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"    // read the dataset to all ranks"},
{"lineNum":"  151","line":"    template<typename T>"},
{"lineNum":"  152","line":"    T read(std::string const& name) const"},
{"lineNum":"  153","line":"    { return Hdf5_reader::read<T>(h5file, name, *comm, root_rank); }"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"    // does a collective read on the dataset"},
{"lineNum":"  156","line":"    // rank r will get a container that has the len extent in the first dim"},
{"lineNum":"  157","line":"    template<typename T>"},
{"lineNum":"  158","line":"    T read(std::string const& name, size_t len) const"},
{"lineNum":"  159","line":"    { return Hdf5_reader::read<T>(h5file, name, len, *comm, root_rank); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"#if 0"},
{"lineNum":"  162","line":"    // a single read from a 1d dataset into the memory"},
{"lineNum":"  163","line":"    // memory must be larger or the same as the dataset size"},
{"lineNum":"  164","line":"    template<typename T>"},
{"lineNum":"  165","line":"    void read(std::string const& name, T * const data) const"},
{"lineNum":"  166","line":"    { Hdf5_reader::read<T>(h5file, name, data, *comm, root_rank); }"},
{"lineNum":"  167","line":"#endif"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"    // does a collective read of the named dataset into the raw array"},
{"lineNum":"  170","line":"    template<typename T>"},
{"lineNum":"  171","line":"    void read(std::string const& name, T * const data, size_t len) const"},
{"lineNum":"  172","line":"    { Hdf5_reader::read<T>(h5file, name, data, len, *comm, root_rank); }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"    std::vector<hsize_t>"},
{"lineNum":"  175","line":"    get_dims(std::string const& name) const"},
{"lineNum":"  176","line":"    { return Hdf5_reader::get_dims(h5file, name, *comm, root_rank); }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"    std::vector<std::string>"},
{"lineNum":"  179","line":"    get_dataset_names() const"},
{"lineNum":"  180","line":"    { return Hdf5_reader::get_dataset_names(h5file, *comm, root_rank); }"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"    bool"},
{"lineNum":"  183","line":"    has_dataset(std::string const& name) const"},
{"lineNum":"  184","line":"    { return Hdf5_reader::has_dataset(h5file, name, *comm, root_rank); }"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"private:"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"    friend class cereal::access;"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"    Hdf5_file()"},
{"lineNum":"  191","line":"    : comm(), file_name(), h5file(), root_rank(0), is_open(false)"},
{"lineNum":"  192","line":"    , current_flag(Hdf5_file::read_only), has_file(false)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  193","line":"    { }"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"    template<class Archive>"},
{"lineNum":"  196","line":"    void save(Archive & ar) const"},
{"lineNum":"  197","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  198","line":"        ar(CEREAL_NVP(comm));"},
{"lineNum":"  199","line":"        ar(CEREAL_NVP(file_name));"},
{"lineNum":"  200","line":"        ar(CEREAL_NVP(root_rank));"},
{"lineNum":"  201","line":"        ar(CEREAL_NVP(is_open));"},
{"lineNum":"  202","line":"        ar(CEREAL_NVP(current_flag));"},
{"lineNum":"  203","line":"        ar(CEREAL_NVP(has_file));"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"        if (is_open)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  206","line":"        {"},
{"lineNum":"  207","line":"            flush();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  208","line":"            // TODO: copy_to_serialization_directory(file_name);"},
{"lineNum":"  209","line":"        }"},
{"lineNum":"  210","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"    template<class Archive>"},
{"lineNum":"  213","line":"    void load(Archive & ar)"},
{"lineNum":"  214","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  215","line":"        ar(CEREAL_NVP(comm));"},
{"lineNum":"  216","line":"        ar(CEREAL_NVP(file_name));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  217","line":"        ar(CEREAL_NVP(root_rank));"},
{"lineNum":"  218","line":"        ar(CEREAL_NVP(is_open));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  219","line":"        ar(CEREAL_NVP(current_flag));"},
{"lineNum":"  220","line":"        ar(CEREAL_NVP(has_file));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"        if (is_open)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  223","line":"        {"},
{"lineNum":"  224","line":"            // TODO: copy_from_serialization_directory(file_name)"},
{"lineNum":"  225","line":"            is_open = false;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  226","line":"            open(current_flag);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  227","line":"        }"},
{"lineNum":"  228","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  229","line":"};"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"#endif /* HDF5_FILE_H_ */"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 28, "covered" : 0,};
var merged_data = [];
