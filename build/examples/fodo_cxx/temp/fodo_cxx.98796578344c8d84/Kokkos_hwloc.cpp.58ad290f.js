var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#define DEBUG_PRINT 0"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"#include <iostream>"},
{"lineNum":"   48","line":"#include <sstream>"},
{"lineNum":"   49","line":"#include <algorithm>"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"#include <Kokkos_Macros.hpp>"},
{"lineNum":"   52","line":"#include <Kokkos_Core.hpp>"},
{"lineNum":"   53","line":"#include <Kokkos_hwloc.hpp>"},
{"lineNum":"   54","line":"#include <impl/Kokkos_Error.hpp>"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"/*--------------------------------------------------------------------------*/"},
{"lineNum":"   57","line":"/*--------------------------------------------------------------------------*/"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"namespace Kokkos {"},
{"lineNum":"   60","line":"namespace hwloc {"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"/* Return 0 if asynchronous, 1 if synchronous and include process. */"},
{"lineNum":"   63","line":"unsigned thread_mapping(const char* const label, const bool allow_async,"},
{"lineNum":"   64","line":"                        unsigned& thread_count, unsigned& use_numa_count,"},
{"lineNum":"   65","line":"                        unsigned& use_cores_per_numa,"},
{"lineNum":"   66","line":"                        std::pair<unsigned, unsigned> threads_coord[]) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   67","line":"  const bool hwloc_avail = Kokkos::hwloc::available();"},
{"lineNum":"   68","line":"  const unsigned avail_numa_count ="},
{"lineNum":"   69","line":"      hwloc_avail ? hwloc::get_available_numa_count() : 1;"},
{"lineNum":"   70","line":"  const unsigned avail_cores_per_numa ="},
{"lineNum":"   71","line":"      hwloc_avail ? hwloc::get_available_cores_per_numa() : thread_count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   72","line":"  const unsigned avail_threads_per_core ="},
{"lineNum":"   73","line":"      hwloc_avail ? hwloc::get_available_threads_per_core() : 1;"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"  // (numa,core) coordinate of the process:"},
{"lineNum":"   76","line":"  const std::pair<unsigned, unsigned> proc_coord ="},
{"lineNum":"   77","line":"      Kokkos::hwloc::get_this_thread_coordinate();"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"  //------------------------------------------------------------------------"},
{"lineNum":"   80","line":"  // Defaults for unspecified inputs:"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"  if (!use_numa_count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   83","line":"    // Default to use all NUMA regions"},
{"lineNum":"   84","line":"    use_numa_count = !thread_count","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   85","line":"                         ? avail_numa_count"},
{"lineNum":"   86","line":"                         : (thread_count < avail_numa_count ? thread_count"},
{"lineNum":"   87","line":"                                                            : avail_numa_count);"},
{"lineNum":"   88","line":"  }"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"  if (!use_cores_per_numa) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   91","line":"    // Default to use all but one core if asynchronous, all cores if"},
{"lineNum":"   92","line":"    // synchronous."},
{"lineNum":"   93","line":"    const unsigned threads_per_numa = thread_count / use_numa_count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"    use_cores_per_numa =","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   96","line":"        !threads_per_numa","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   97","line":"            ? avail_cores_per_numa - (allow_async ? 1 : 0)"},
{"lineNum":"   98","line":"            : (threads_per_numa < avail_cores_per_numa ? threads_per_numa"},
{"lineNum":"   99","line":"                                                       : avail_cores_per_numa);"},
{"lineNum":"  100","line":"  }"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"  if (!thread_count) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  103","line":"    thread_count = use_numa_count * use_cores_per_numa * avail_threads_per_core;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  104","line":"  }"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"  //------------------------------------------------------------------------"},
{"lineNum":"  107","line":"  // Input verification:"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"  const bool valid_numa = use_numa_count <= avail_numa_count;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  110","line":"  const bool valid_cores ="},
{"lineNum":"  111","line":"      use_cores_per_numa && use_cores_per_numa <= avail_cores_per_numa;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  112","line":"  const bool valid_threads ="},
{"lineNum":"  113","line":"      thread_count && thread_count <= use_numa_count * use_cores_per_numa *","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  114","line":"                                          avail_threads_per_core;"},
{"lineNum":"  115","line":"  const bool balanced_numa = !(thread_count % use_numa_count);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  116","line":"  const bool balanced_cores ="},
{"lineNum":"  117","line":"      !(thread_count % (use_numa_count * use_cores_per_numa));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"  const bool valid_input = valid_numa && valid_cores && valid_threads &&","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  120","line":"                           balanced_numa && balanced_cores;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"  if (!valid_input) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  123","line":"    std::ostringstream msg;"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"    msg << label << \" HWLOC ERROR(s)\";"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    if (!valid_threads) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  128","line":"      msg << \" : thread_count(\" << thread_count << \") exceeds capacity(\"","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  129","line":"          << use_numa_count * use_cores_per_numa * avail_threads_per_core","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  130","line":"          << \")\";"},
{"lineNum":"  131","line":"    }"},
{"lineNum":"  132","line":"    if (!valid_numa) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  133","line":"      msg << \" : use_numa_count(\" << use_numa_count << \") exceeds capacity(\"","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  134","line":"          << avail_numa_count << \")\";","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  135","line":"    }"},
{"lineNum":"  136","line":"    if (!valid_cores) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  137","line":"      msg << \" : use_cores_per_numa(\" << use_cores_per_numa","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  138","line":"          << \") exceeds capacity(\" << avail_cores_per_numa << \")\";","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  139","line":"    }"},
{"lineNum":"  140","line":"    if (!balanced_numa) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  141","line":"      msg << \" : thread_count(\" << thread_count << \") imbalanced among numa(\"","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  142","line":"          << use_numa_count << \")\";","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  143","line":"    }"},
{"lineNum":"  144","line":"    if (!balanced_cores) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  145","line":"      msg << \" : thread_count(\" << thread_count << \") imbalanced among cores(\"","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  146","line":"          << use_numa_count * use_cores_per_numa << \")\";","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  147","line":"    }"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"    Kokkos::Impl::throw_runtime_exception(msg.str());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  150","line":"  }"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"  const unsigned thread_spawn_synchronous ="},
{"lineNum":"  153","line":"      (allow_async && 1 < thread_count &&","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  154","line":"       (use_numa_count < avail_numa_count ||","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  155","line":"        use_cores_per_numa < avail_cores_per_numa))","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  156","line":"          ? 0 /* asyncronous */"},
{"lineNum":"  157","line":"          : 1 /* synchronous, threads_coord[0] is process core */;"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"  // Determine binding coordinates for to-be-spawned threads so that"},
{"lineNum":"  160","line":"  // threads may be bound to cores as they are spawned."},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"  const unsigned threads_per_core ="},
{"lineNum":"  163","line":"      thread_count / (use_numa_count * use_cores_per_numa);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"  if (thread_spawn_synchronous) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  166","line":"    // Working synchronously and include process core as threads_coord[0]."},
{"lineNum":"  167","line":"    // Swap the NUMA coordinate of the process core with 0"},
{"lineNum":"  168","line":"    // Swap the CORE coordinate of the process core with 0"},
{"lineNum":"  169","line":"    for (unsigned i = 0, inuma = avail_numa_count - use_numa_count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  170","line":"         inuma < avail_numa_count; ++inuma) {"},
{"lineNum":"  171","line":"      const unsigned numa_coord = 0 == inuma"},
{"lineNum":"  172","line":"                                      ? proc_coord.first"},
{"lineNum":"  173","line":"                                      : (proc_coord.first == inuma ? 0 : inuma);"},
{"lineNum":"  174","line":"      for (unsigned icore = avail_cores_per_numa - use_cores_per_numa;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  175","line":"           icore < avail_cores_per_numa; ++icore) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  176","line":"        const unsigned core_coord ="},
{"lineNum":"  177","line":"            0 == icore ? proc_coord.second"},
{"lineNum":"  178","line":"                       : (proc_coord.second == icore ? 0 : icore);"},
{"lineNum":"  179","line":"        for (unsigned ith = 0; ith < threads_per_core; ++ith, ++i) {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  180","line":"          threads_coord[i].first  = numa_coord;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  181","line":"          threads_coord[i].second = core_coord;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  182","line":"        }"},
{"lineNum":"  183","line":"      }"},
{"lineNum":"  184","line":"    }"},
{"lineNum":"  185","line":"  } else if (use_numa_count < avail_numa_count) {"},
{"lineNum":"  186","line":"    // Working asynchronously and omit the process\' NUMA region from the pool."},
{"lineNum":"  187","line":"    // Swap the NUMA coordinate of the process core with ( ( avail_numa_count -"},
{"lineNum":"  188","line":"    // use_numa_count ) - 1 )"},
{"lineNum":"  189","line":"    const unsigned numa_coord_swap = (avail_numa_count - use_numa_count) - 1;"},
{"lineNum":"  190","line":"    for (unsigned i = 0, inuma = avail_numa_count - use_numa_count;"},
{"lineNum":"  191","line":"         inuma < avail_numa_count; ++inuma) {"},
{"lineNum":"  192","line":"      const unsigned numa_coord ="},
{"lineNum":"  193","line":"          proc_coord.first == inuma ? numa_coord_swap : inuma;"},
{"lineNum":"  194","line":"      for (unsigned icore = avail_cores_per_numa - use_cores_per_numa;"},
{"lineNum":"  195","line":"           icore < avail_cores_per_numa; ++icore) {"},
{"lineNum":"  196","line":"        const unsigned core_coord = icore;"},
{"lineNum":"  197","line":"        for (unsigned ith = 0; ith < threads_per_core; ++ith, ++i) {"},
{"lineNum":"  198","line":"          threads_coord[i].first  = numa_coord;"},
{"lineNum":"  199","line":"          threads_coord[i].second = core_coord;"},
{"lineNum":"  200","line":"        }"},
{"lineNum":"  201","line":"      }"},
{"lineNum":"  202","line":"    }"},
{"lineNum":"  203","line":"  } else if (use_cores_per_numa < avail_cores_per_numa) {"},
{"lineNum":"  204","line":"    // Working asynchronously and omit the process\' core from the pool."},
{"lineNum":"  205","line":"    // Swap the CORE coordinate of the process core with ( ("},
{"lineNum":"  206","line":"    // avail_cores_per_numa - use_cores_per_numa ) - 1 )"},
{"lineNum":"  207","line":"    const unsigned core_coord_swap ="},
{"lineNum":"  208","line":"        (avail_cores_per_numa - use_cores_per_numa) - 1;"},
{"lineNum":"  209","line":"    for (unsigned i = 0, inuma = avail_numa_count - use_numa_count;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  210","line":"         inuma < avail_numa_count; ++inuma) {"},
{"lineNum":"  211","line":"      const unsigned numa_coord = inuma;"},
{"lineNum":"  212","line":"      for (unsigned icore = avail_cores_per_numa - use_cores_per_numa;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  213","line":"           icore < avail_cores_per_numa; ++icore) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  214","line":"        const unsigned core_coord ="},
{"lineNum":"  215","line":"            proc_coord.second == icore ? core_coord_swap : icore;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  216","line":"        for (unsigned ith = 0; ith < threads_per_core; ++ith, ++i) {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  217","line":"          threads_coord[i].first  = numa_coord;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  218","line":"          threads_coord[i].second = core_coord;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  219","line":"        }"},
{"lineNum":"  220","line":"      }"},
{"lineNum":"  221","line":"    }"},
{"lineNum":"  222","line":"  }"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"  return thread_spawn_synchronous;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  225","line":"}"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"} /* namespace hwloc */"},
{"lineNum":"  228","line":"} /* namespace Kokkos */"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"/*--------------------------------------------------------------------------*/"},
{"lineNum":"  231","line":"/*--------------------------------------------------------------------------*/"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"#if defined(KOKKOS_ENABLE_HWLOC)"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"#include <iostream>"},
{"lineNum":"  236","line":"#include <sstream>"},
{"lineNum":"  237","line":"#include <stdexcept>"},
{"lineNum":"  238","line":""},
{"lineNum":"  239","line":"/*--------------------------------------------------------------------------*/"},
{"lineNum":"  240","line":"/* Third Party Libraries */"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"/* Hardware locality library: http://www.open-mpi.org/projects/hwloc/ */"},
{"lineNum":"  243","line":"#include <hwloc.h>"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"#define REQUIRED_HWLOC_API_VERSION 0x000010300"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"#if HWLOC_API_VERSION < REQUIRED_HWLOC_API_VERSION"},
{"lineNum":"  248","line":"#error \\"},
{"lineNum":"  249","line":"    \"Requires  http://www.open-mpi.org/projects/hwloc/  Version 1.3 or greater\""},
{"lineNum":"  250","line":"#endif"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"/*--------------------------------------------------------------------------*/"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"namespace Kokkos {"},
{"lineNum":"  255","line":"namespace hwloc {"},
{"lineNum":"  256","line":"namespace {"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"#if DEBUG_PRINT"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"inline void print_bitmap(std::ostream& s, const hwloc_const_bitmap_t bitmap) {"},
{"lineNum":"  261","line":"  s << \"{\";"},
{"lineNum":"  262","line":"  for (int i = hwloc_bitmap_first(bitmap); - 1 != i;"},
{"lineNum":"  263","line":"       i     = hwloc_bitmap_next(bitmap, i)) {"},
{"lineNum":"  264","line":"    s << \" \" << i;"},
{"lineNum":"  265","line":"  }"},
{"lineNum":"  266","line":"  s << \" }\";"},
{"lineNum":"  267","line":"}"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"#endif"},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"enum { MAX_CORE = 1024 };"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"std::pair<unsigned, unsigned> s_core_topology(0, 0);"},
{"lineNum":"  274","line":"unsigned s_core_capacity(0);"},
{"lineNum":"  275","line":"hwloc_topology_t s_hwloc_topology(0);"},
{"lineNum":"  276","line":"hwloc_bitmap_t s_hwloc_location(0);"},
{"lineNum":"  277","line":"hwloc_bitmap_t s_process_binding(0);"},
{"lineNum":"  278","line":"hwloc_bitmap_t s_core[MAX_CORE];"},
{"lineNum":"  279","line":"bool s_can_bind_threads(true);"},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"struct Sentinel {"},
{"lineNum":"  282","line":"  ~Sentinel();"},
{"lineNum":"  283","line":"  Sentinel();"},
{"lineNum":"  284","line":"};"},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"bool sentinel() {"},
{"lineNum":"  287","line":"  static Sentinel self;"},
{"lineNum":"  288","line":""},
{"lineNum":"  289","line":"  if (0 == s_hwloc_topology) {"},
{"lineNum":"  290","line":"    std::cerr << \"Kokkos::hwloc ERROR : Called after return from main()\""},
{"lineNum":"  291","line":"              << std::endl;"},
{"lineNum":"  292","line":"    std::cerr.flush();"},
{"lineNum":"  293","line":"  }"},
{"lineNum":"  294","line":""},
{"lineNum":"  295","line":"  return 0 != s_hwloc_topology;"},
{"lineNum":"  296","line":"}"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"Sentinel::~Sentinel() {"},
{"lineNum":"  299","line":"  hwloc_topology_destroy(s_hwloc_topology);"},
{"lineNum":"  300","line":"  hwloc_bitmap_free(s_process_binding);"},
{"lineNum":"  301","line":"  hwloc_bitmap_free(s_hwloc_location);"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"  s_core_topology.first  = 0;"},
{"lineNum":"  304","line":"  s_core_topology.second = 0;"},
{"lineNum":"  305","line":"  s_core_capacity        = 0;"},
{"lineNum":"  306","line":"  s_hwloc_topology       = 0;"},
{"lineNum":"  307","line":"  s_hwloc_location       = 0;"},
{"lineNum":"  308","line":"  s_process_binding      = 0;"},
{"lineNum":"  309","line":"}"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"Sentinel::Sentinel() {"},
{"lineNum":"  312","line":"#if defined(__MIC__)"},
{"lineNum":"  313","line":"  static const bool remove_core_0 = true;"},
{"lineNum":"  314","line":"#else"},
{"lineNum":"  315","line":"  static const bool remove_core_0 = false;"},
{"lineNum":"  316","line":"#endif"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"  s_core_topology   = std::pair<unsigned, unsigned>(0, 0);"},
{"lineNum":"  319","line":"  s_core_capacity   = 0;"},
{"lineNum":"  320","line":"  s_hwloc_topology  = 0;"},
{"lineNum":"  321","line":"  s_hwloc_location  = 0;"},
{"lineNum":"  322","line":"  s_process_binding = 0;"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"  for (unsigned i = 0; i < MAX_CORE; ++i) s_core[i] = 0;"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"  hwloc_topology_init(&s_hwloc_topology);"},
{"lineNum":"  327","line":"  hwloc_topology_load(s_hwloc_topology);"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"  s_hwloc_location  = hwloc_bitmap_alloc();"},
{"lineNum":"  330","line":"  s_process_binding = hwloc_bitmap_alloc();"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"  hwloc_get_cpubind(s_hwloc_topology, s_process_binding, HWLOC_CPUBIND_PROCESS);"},
{"lineNum":"  333","line":""},
{"lineNum":"  334","line":"  if (hwloc_bitmap_iszero(s_process_binding)) {"},
{"lineNum":"  335","line":"    if (Kokkos::show_warnings()) {"},
{"lineNum":"  336","line":"      std::cerr << \"WARNING: Cannot detect process binding -- ASSUMING ALL \""},
{"lineNum":"  337","line":"                   \"processing units\""},
{"lineNum":"  338","line":"                << std::endl;"},
{"lineNum":"  339","line":"    }"},
{"lineNum":"  340","line":"    const int pu_depth = hwloc_get_type_depth(s_hwloc_topology, HWLOC_OBJ_PU);"},
{"lineNum":"  341","line":"    int num_pu         = 1;"},
{"lineNum":"  342","line":"    if (pu_depth != HWLOC_TYPE_DEPTH_UNKNOWN) {"},
{"lineNum":"  343","line":"      num_pu = hwloc_get_nbobjs_by_depth(s_hwloc_topology, pu_depth);"},
{"lineNum":"  344","line":"    } else {"},
{"lineNum":"  345","line":"      if (Kokkos::show_warnings()) {"},
{"lineNum":"  346","line":"        std::cerr << \"WARNING: Cannot detect number of processing units -- \""},
{"lineNum":"  347","line":"                     \"ASSUMING 1 (serial).\""},
{"lineNum":"  348","line":"                  << std::endl;"},
{"lineNum":"  349","line":"      }"},
{"lineNum":"  350","line":"      num_pu = 1;"},
{"lineNum":"  351","line":"    }"},
{"lineNum":"  352","line":"    hwloc_bitmap_set_range(s_process_binding, 0, num_pu - 1);"},
{"lineNum":"  353","line":"    s_can_bind_threads = false;"},
{"lineNum":"  354","line":"  }"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"  if (remove_core_0) {"},
{"lineNum":"  357","line":"    const hwloc_obj_t core ="},
{"lineNum":"  358","line":"        hwloc_get_obj_by_type(s_hwloc_topology, HWLOC_OBJ_CORE, 0);"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"    if (hwloc_bitmap_intersects(s_process_binding, core->cpuset)) {"},
{"lineNum":"  361","line":"      hwloc_bitmap_t s_process_no_core_zero = hwloc_bitmap_alloc();"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"      hwloc_bitmap_andnot(s_process_no_core_zero, s_process_binding,"},
{"lineNum":"  364","line":"                          core->cpuset);"},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"      bool ok ="},
{"lineNum":"  367","line":"          0 == hwloc_set_cpubind(s_hwloc_topology, s_process_no_core_zero,"},
{"lineNum":"  368","line":"                                 HWLOC_CPUBIND_PROCESS | HWLOC_CPUBIND_STRICT);"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"      if (ok) {"},
{"lineNum":"  371","line":"        hwloc_get_cpubind(s_hwloc_topology, s_process_binding,"},
{"lineNum":"  372","line":"                          HWLOC_CPUBIND_PROCESS);"},
{"lineNum":"  373","line":""},
{"lineNum":"  374","line":"        ok = 0 !="},
{"lineNum":"  375","line":"             hwloc_bitmap_isequal(s_process_binding, s_process_no_core_zero);"},
{"lineNum":"  376","line":"      }"},
{"lineNum":"  377","line":""},
{"lineNum":"  378","line":"      hwloc_bitmap_free(s_process_no_core_zero);"},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":"      if (Kokkos::show_warnings() && !ok) {"},
{"lineNum":"  381","line":"        std::cerr << \"WARNING: Kokkos::hwloc attempted and failed to move \""},
{"lineNum":"  382","line":"                     \"process off of core #0\""},
{"lineNum":"  383","line":"                  << std::endl;"},
{"lineNum":"  384","line":"      }"},
{"lineNum":"  385","line":"    }"},
{"lineNum":"  386","line":"  }"},
{"lineNum":"  387","line":""},
{"lineNum":"  388","line":"  // Choose a hwloc object type for the NUMA level, which may not exist."},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"  hwloc_obj_type_t root_type = HWLOC_OBJ_TYPE_MAX;"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"  {"},
{"lineNum":"  393","line":"    // Object types to search, in order."},
{"lineNum":"  394","line":"    static const hwloc_obj_type_t candidate_root_type[] = {"},
{"lineNum":"  395","line":"        HWLOC_OBJ_NODE /* NUMA region     */"},
{"lineNum":"  396","line":"        ,"},
{"lineNum":"  397","line":"        HWLOC_OBJ_SOCKET /* hardware socket */"},
{"lineNum":"  398","line":"        ,"},
{"lineNum":"  399","line":"        HWLOC_OBJ_MACHINE /* local machine   */"},
{"lineNum":"  400","line":"    };"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"    enum {"},
{"lineNum":"  403","line":"      CANDIDATE_ROOT_TYPE_COUNT ="},
{"lineNum":"  404","line":"          sizeof(candidate_root_type) / sizeof(hwloc_obj_type_t)"},
{"lineNum":"  405","line":"    };"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"    for (int k = 0;"},
{"lineNum":"  408","line":"         k < CANDIDATE_ROOT_TYPE_COUNT && HWLOC_OBJ_TYPE_MAX == root_type;"},
{"lineNum":"  409","line":"         ++k) {"},
{"lineNum":"  410","line":"      if (0 <"},
{"lineNum":"  411","line":"          hwloc_get_nbobjs_by_type(s_hwloc_topology, candidate_root_type[k])) {"},
{"lineNum":"  412","line":"        root_type = candidate_root_type[k];"},
{"lineNum":"  413","line":"      }"},
{"lineNum":"  414","line":"    }"},
{"lineNum":"  415","line":"  }"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"  // Determine which of these \'root\' types are available to this process."},
{"lineNum":"  418","line":"  // The process may have been bound (e.g., by MPI) to a subset of these root"},
{"lineNum":"  419","line":"  // types. Determine current location of the master (calling) process>"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"  hwloc_bitmap_t proc_cpuset_location = hwloc_bitmap_alloc();"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"  hwloc_get_last_cpu_location(s_hwloc_topology, proc_cpuset_location,"},
{"lineNum":"  424","line":"                              HWLOC_CPUBIND_THREAD);"},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"  const unsigned max_root ="},
{"lineNum":"  427","line":"      hwloc_get_nbobjs_by_type(s_hwloc_topology, root_type);"},
{"lineNum":"  428","line":""},
{"lineNum":"  429","line":"  unsigned root_base     = max_root;"},
{"lineNum":"  430","line":"  unsigned root_count    = 0;"},
{"lineNum":"  431","line":"  unsigned core_per_root = 0;"},
{"lineNum":"  432","line":"  unsigned pu_per_core   = 0;"},
{"lineNum":"  433","line":"  bool symmetric         = true;"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"  for (unsigned i = 0; i < max_root; ++i) {"},
{"lineNum":"  436","line":"    const hwloc_obj_t root ="},
{"lineNum":"  437","line":"        hwloc_get_obj_by_type(s_hwloc_topology, root_type, i);"},
{"lineNum":"  438","line":""},
{"lineNum":"  439","line":"    if (hwloc_bitmap_intersects(s_process_binding, root->cpuset)) {"},
{"lineNum":"  440","line":"      ++root_count;"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"      // Remember which root (NUMA) object the master thread is running on."},
{"lineNum":"  443","line":"      // This will be logical NUMA rank #0 for this process."},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"      if (hwloc_bitmap_intersects(proc_cpuset_location, root->cpuset)) {"},
{"lineNum":"  446","line":"        root_base = i;"},
{"lineNum":"  447","line":"      }"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"      // Count available cores:"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"      const unsigned max_core = hwloc_get_nbobjs_inside_cpuset_by_type("},
{"lineNum":"  452","line":"          s_hwloc_topology, root->cpuset, HWLOC_OBJ_CORE);"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"      unsigned core_count = 0;"},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"      for (unsigned j = 0; j < max_core; ++j) {"},
{"lineNum":"  457","line":"        const hwloc_obj_t core = hwloc_get_obj_inside_cpuset_by_type("},
{"lineNum":"  458","line":"            s_hwloc_topology, root->cpuset, HWLOC_OBJ_CORE, j);"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"        // If process\' cpuset intersects core\'s cpuset then process can access"},
{"lineNum":"  461","line":"        // this core. Must use intersection instead of inclusion because the"},
{"lineNum":"  462","line":"        // Intel-Phi MPI may bind the process to only one of the core\'s"},
{"lineNum":"  463","line":"        // hyperthreads."},
{"lineNum":"  464","line":"        //"},
{"lineNum":"  465","line":"        // Assumption: if the process can access any hyperthread of the core"},
{"lineNum":"  466","line":"        // then it has ownership of the entire core."},
{"lineNum":"  467","line":"        // This assumes that it would be performance-detrimental"},
{"lineNum":"  468","line":"        // to spawn more than one MPI process per core and use nested threading."},
{"lineNum":"  469","line":""},
{"lineNum":"  470","line":"        if (hwloc_bitmap_intersects(s_process_binding, core->cpuset)) {"},
{"lineNum":"  471","line":"          ++core_count;"},
{"lineNum":"  472","line":""},
{"lineNum":"  473","line":"          const unsigned pu_count = hwloc_get_nbobjs_inside_cpuset_by_type("},
{"lineNum":"  474","line":"              s_hwloc_topology, core->cpuset, HWLOC_OBJ_PU);"},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"          if (pu_per_core == 0) pu_per_core = pu_count;"},
{"lineNum":"  477","line":""},
{"lineNum":"  478","line":"          // Enforce symmetry by taking the minimum:"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"          pu_per_core = std::min(pu_per_core, pu_count);"},
{"lineNum":"  481","line":""},
{"lineNum":"  482","line":"          if (pu_count != pu_per_core) symmetric = false;"},
{"lineNum":"  483","line":"        }"},
{"lineNum":"  484","line":"      }"},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"      if (0 == core_per_root) core_per_root = core_count;"},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"      // Enforce symmetry by taking the minimum:"},
{"lineNum":"  489","line":""},
{"lineNum":"  490","line":"      core_per_root = std::min(core_per_root, core_count);"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"      if (core_count != core_per_root) symmetric = false;"},
{"lineNum":"  493","line":"    }"},
{"lineNum":"  494","line":"  }"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"  s_core_topology.first  = root_count;"},
{"lineNum":"  497","line":"  s_core_topology.second = core_per_root;"},
{"lineNum":"  498","line":"  s_core_capacity        = pu_per_core;"},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"  // Fill the \'s_core\' array for fast mapping from a core coordinate to the"},
{"lineNum":"  501","line":"  // hwloc cpuset object required for thread location querying and binding."},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"  for (unsigned i = 0; i < max_root; ++i) {"},
{"lineNum":"  504","line":"    const unsigned root_rank = (i + root_base) % max_root;"},
{"lineNum":"  505","line":""},
{"lineNum":"  506","line":"    const hwloc_obj_t root ="},
{"lineNum":"  507","line":"        hwloc_get_obj_by_type(s_hwloc_topology, root_type, root_rank);"},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"    if (hwloc_bitmap_intersects(s_process_binding, root->cpuset)) {"},
{"lineNum":"  510","line":"      const unsigned max_core = hwloc_get_nbobjs_inside_cpuset_by_type("},
{"lineNum":"  511","line":"          s_hwloc_topology, root->cpuset, HWLOC_OBJ_CORE);"},
{"lineNum":"  512","line":""},
{"lineNum":"  513","line":"      unsigned core_count = 0;"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"      for (unsigned j = 0; j < max_core && core_count < core_per_root; ++j) {"},
{"lineNum":"  516","line":"        const hwloc_obj_t core = hwloc_get_obj_inside_cpuset_by_type("},
{"lineNum":"  517","line":"            s_hwloc_topology, root->cpuset, HWLOC_OBJ_CORE, j);"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"        if (hwloc_bitmap_intersects(s_process_binding, core->cpuset)) {"},
{"lineNum":"  520","line":"          s_core[core_count + core_per_root * i] = core->cpuset;"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"          ++core_count;"},
{"lineNum":"  523","line":"        }"},
{"lineNum":"  524","line":"      }"},
{"lineNum":"  525","line":"    }"},
{"lineNum":"  526","line":"  }"},
{"lineNum":"  527","line":""},
{"lineNum":"  528","line":"  hwloc_bitmap_free(proc_cpuset_location);"},
{"lineNum":"  529","line":""},
{"lineNum":"  530","line":"  if (Kokkos::show_warnings() && !symmetric) {"},
{"lineNum":"  531","line":"    std::cerr << \"Kokkos::hwloc WARNING: Using a symmetric subset of a \""},
{"lineNum":"  532","line":"                 \"non-symmetric core topology.\""},
{"lineNum":"  533","line":"              << std::endl;"},
{"lineNum":"  534","line":"  }"},
{"lineNum":"  535","line":"}"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"}  // namespace"},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  540","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  541","line":""},
{"lineNum":"  542","line":"bool available() { return true; }"},
{"lineNum":"  543","line":""},
{"lineNum":"  544","line":"unsigned get_available_numa_count() {"},
{"lineNum":"  545","line":"  sentinel();"},
{"lineNum":"  546","line":"  return s_core_topology.first;"},
{"lineNum":"  547","line":"}"},
{"lineNum":"  548","line":""},
{"lineNum":"  549","line":"unsigned get_available_cores_per_numa() {"},
{"lineNum":"  550","line":"  sentinel();"},
{"lineNum":"  551","line":"  return s_core_topology.second;"},
{"lineNum":"  552","line":"}"},
{"lineNum":"  553","line":""},
{"lineNum":"  554","line":"unsigned get_available_threads_per_core() {"},
{"lineNum":"  555","line":"  sentinel();"},
{"lineNum":"  556","line":"  return s_core_capacity;"},
{"lineNum":"  557","line":"}"},
{"lineNum":"  558","line":""},
{"lineNum":"  559","line":"bool can_bind_threads() {"},
{"lineNum":"  560","line":"  sentinel();"},
{"lineNum":"  561","line":"  return s_can_bind_threads;"},
{"lineNum":"  562","line":"}"},
{"lineNum":"  563","line":""},
{"lineNum":"  564","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  565","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  566","line":""},
{"lineNum":"  567","line":"unsigned bind_this_thread(const unsigned coordinate_count,"},
{"lineNum":"  568","line":"                          std::pair<unsigned, unsigned> coordinate[]) {"},
{"lineNum":"  569","line":"  unsigned i = 0;"},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"  try {"},
{"lineNum":"  572","line":"    const std::pair<unsigned, unsigned> current = get_this_thread_coordinate();"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"    // Match one of the requests:"},
{"lineNum":"  575","line":"    for (i = 0; i < coordinate_count && current != coordinate[i]; ++i)"},
{"lineNum":"  576","line":"      ;"},
{"lineNum":"  577","line":""},
{"lineNum":"  578","line":"    if (coordinate_count == i) {"},
{"lineNum":"  579","line":"      // Match the first request (typically NUMA):"},
{"lineNum":"  580","line":"      for (i = 0; i < coordinate_count && current.first != coordinate[i].first;"},
{"lineNum":"  581","line":"           ++i)"},
{"lineNum":"  582","line":"        ;"},
{"lineNum":"  583","line":"    }"},
{"lineNum":"  584","line":""},
{"lineNum":"  585","line":"    if (coordinate_count == i) {"},
{"lineNum":"  586","line":"      // Match any unclaimed request:"},
{"lineNum":"  587","line":"      for (i = 0; i < coordinate_count && ~0u == coordinate[i].first; ++i)"},
{"lineNum":"  588","line":"        ;"},
{"lineNum":"  589","line":"    }"},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"    if (coordinate_count == i || !bind_this_thread(coordinate[i])) {"},
{"lineNum":"  592","line":"      // Failed to bind:"},
{"lineNum":"  593","line":"      i = ~0u;"},
{"lineNum":"  594","line":"    }"},
{"lineNum":"  595","line":""},
{"lineNum":"  596","line":"    if (i < coordinate_count) {"},
{"lineNum":"  597","line":"#if DEBUG_PRINT"},
{"lineNum":"  598","line":"      if (current != coordinate[i]) {"},
{"lineNum":"  599","line":"        std::cout << \"  bind_this_thread: rebinding from (\" << current.first"},
{"lineNum":"  600","line":"                  << \",\" << current.second << \") to (\" << coordinate[i].first"},
{"lineNum":"  601","line":"                  << \",\" << coordinate[i].second << \")\" << std::endl;"},
{"lineNum":"  602","line":"      }"},
{"lineNum":"  603","line":"#endif"},
{"lineNum":"  604","line":""},
{"lineNum":"  605","line":"      coordinate[i].first  = ~0u;"},
{"lineNum":"  606","line":"      coordinate[i].second = ~0u;"},
{"lineNum":"  607","line":"    }"},
{"lineNum":"  608","line":"  } catch (...) {"},
{"lineNum":"  609","line":"    i = ~0u;"},
{"lineNum":"  610","line":"  }"},
{"lineNum":"  611","line":""},
{"lineNum":"  612","line":"  return i;"},
{"lineNum":"  613","line":"}"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"bool bind_this_thread(const std::pair<unsigned, unsigned> coord) {"},
{"lineNum":"  616","line":"  if (!sentinel()) return false;"},
{"lineNum":"  617","line":""},
{"lineNum":"  618","line":"#if DEBUG_PRINT"},
{"lineNum":"  619","line":""},
{"lineNum":"  620","line":"  std::cout << \"Kokkos::bind_this_thread() at \";"},
{"lineNum":"  621","line":""},
{"lineNum":"  622","line":"  hwloc_get_last_cpu_location(s_hwloc_topology, s_hwloc_location,"},
{"lineNum":"  623","line":"                              HWLOC_CPUBIND_THREAD);"},
{"lineNum":"  624","line":""},
{"lineNum":"  625","line":"  print_bitmap(std::cout, s_hwloc_location);"},
{"lineNum":"  626","line":""},
{"lineNum":"  627","line":"  std::cout << \" to \";"},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"  print_bitmap(std::cout,"},
{"lineNum":"  630","line":"               s_core[coord.second + coord.first * s_core_topology.second]);"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":"  std::cout << std::endl;"},
{"lineNum":"  633","line":""},
{"lineNum":"  634","line":"#endif"},
{"lineNum":"  635","line":""},
{"lineNum":"  636","line":"  // As safe and fast as possible."},
{"lineNum":"  637","line":"  // Fast-lookup by caching the coordinate -> hwloc cpuset mapping in \'s_core\'."},
{"lineNum":"  638","line":"  return coord.first < s_core_topology.first &&"},
{"lineNum":"  639","line":"         coord.second < s_core_topology.second &&"},
{"lineNum":"  640","line":"         0 == hwloc_set_cpubind("},
{"lineNum":"  641","line":"                  s_hwloc_topology,"},
{"lineNum":"  642","line":"                  s_core[coord.second + coord.first * s_core_topology.second],"},
{"lineNum":"  643","line":"                  HWLOC_CPUBIND_THREAD | HWLOC_CPUBIND_STRICT);"},
{"lineNum":"  644","line":"}"},
{"lineNum":"  645","line":""},
{"lineNum":"  646","line":"bool unbind_this_thread() {"},
{"lineNum":"  647","line":"  if (!sentinel()) return false;"},
{"lineNum":"  648","line":""},
{"lineNum":"  649","line":"#define HWLOC_DEBUG_PRINT 0"},
{"lineNum":"  650","line":""},
{"lineNum":"  651","line":"#if HWLOC_DEBUG_PRINT"},
{"lineNum":"  652","line":""},
{"lineNum":"  653","line":"  std::cout << \"Kokkos::unbind_this_thread() from \";"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"  hwloc_get_cpubind(s_hwloc_topology, s_hwloc_location, HWLOC_CPUBIND_THREAD);"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"  print_bitmap(std::cout, s_hwloc_location);"},
{"lineNum":"  658","line":""},
{"lineNum":"  659","line":"#endif"},
{"lineNum":"  660","line":""},
{"lineNum":"  661","line":"  const bool result ="},
{"lineNum":"  662","line":"      s_hwloc_topology &&"},
{"lineNum":"  663","line":"      0 == hwloc_set_cpubind(s_hwloc_topology, s_process_binding,"},
{"lineNum":"  664","line":"                             HWLOC_CPUBIND_THREAD | HWLOC_CPUBIND_STRICT);"},
{"lineNum":"  665","line":""},
{"lineNum":"  666","line":"#if HWLOC_DEBUG_PRINT"},
{"lineNum":"  667","line":""},
{"lineNum":"  668","line":"  std::cout << \" to \";"},
{"lineNum":"  669","line":""},
{"lineNum":"  670","line":"  hwloc_get_cpubind(s_hwloc_topology, s_hwloc_location, HWLOC_CPUBIND_THREAD);"},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":"  print_bitmap(std::cout, s_hwloc_location);"},
{"lineNum":"  673","line":""},
{"lineNum":"  674","line":"  std::cout << std::endl;"},
{"lineNum":"  675","line":""},
{"lineNum":"  676","line":"#endif"},
{"lineNum":"  677","line":""},
{"lineNum":"  678","line":"  return result;"},
{"lineNum":"  679","line":""},
{"lineNum":"  680","line":"#undef HWLOC_DEBUG_PRINT"},
{"lineNum":"  681","line":"}"},
{"lineNum":"  682","line":""},
{"lineNum":"  683","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"std::pair<unsigned, unsigned> get_this_thread_coordinate() {"},
{"lineNum":"  686","line":"  std::pair<unsigned, unsigned> coord(0u, 0u);"},
{"lineNum":"  687","line":""},
{"lineNum":"  688","line":"  if (!sentinel()) return coord;"},
{"lineNum":"  689","line":""},
{"lineNum":"  690","line":"  const unsigned n = s_core_topology.first * s_core_topology.second;"},
{"lineNum":"  691","line":""},
{"lineNum":"  692","line":"  // Using the pre-allocated \'s_hwloc_location\' to avoid memory"},
{"lineNum":"  693","line":"  // allocation by this thread.  This call is NOT thread-safe."},
{"lineNum":"  694","line":"  hwloc_get_last_cpu_location(s_hwloc_topology, s_hwloc_location,"},
{"lineNum":"  695","line":"                              HWLOC_CPUBIND_THREAD);"},
{"lineNum":"  696","line":""},
{"lineNum":"  697","line":"  unsigned i = 0;"},
{"lineNum":"  698","line":""},
{"lineNum":"  699","line":"  while (i < n && !hwloc_bitmap_intersects(s_hwloc_location, s_core[i])) ++i;"},
{"lineNum":"  700","line":""},
{"lineNum":"  701","line":"  if (i < n) {"},
{"lineNum":"  702","line":"    coord.first  = i / s_core_topology.second;"},
{"lineNum":"  703","line":"    coord.second = i % s_core_topology.second;"},
{"lineNum":"  704","line":"  }"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":"  return coord;"},
{"lineNum":"  707","line":"}"},
{"lineNum":"  708","line":""},
{"lineNum":"  709","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  710","line":""},
{"lineNum":"  711","line":"} /* namespace hwloc */"},
{"lineNum":"  712","line":"} /* namespace Kokkos */"},
{"lineNum":"  713","line":""},
{"lineNum":"  714","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  715","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  716","line":""},
{"lineNum":"  717","line":"#else /* ! defined( KOKKOS_ENABLE_HWLOC ) */"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"namespace Kokkos {"},
{"lineNum":"  720","line":"namespace hwloc {"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"bool available() { return false; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  723","line":"bool can_bind_threads() { return false; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  724","line":""},
{"lineNum":"  725","line":"unsigned get_available_numa_count() { return 1; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  726","line":"unsigned get_available_cores_per_numa() { return 1; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  727","line":"unsigned get_available_threads_per_core() { return 1; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  728","line":""},
{"lineNum":"  729","line":"unsigned bind_this_thread(const unsigned, std::pair<unsigned, unsigned>[]) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  730","line":"  return ~0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  731","line":"}"},
{"lineNum":"  732","line":""},
{"lineNum":"  733","line":"bool bind_this_thread(const std::pair<unsigned, unsigned>) { return false; }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  734","line":""},
{"lineNum":"  735","line":"bool unbind_this_thread() { return true; }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  736","line":""},
{"lineNum":"  737","line":"std::pair<unsigned, unsigned> get_this_thread_coordinate() {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  738","line":"  return std::pair<unsigned, unsigned>(0, 0);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  739","line":"}"},
{"lineNum":"  740","line":""},
{"lineNum":"  741","line":"}  // namespace hwloc"},
{"lineNum":"  742","line":"}  // namespace Kokkos"},
{"lineNum":"  743","line":""},
{"lineNum":"  744","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  745","line":"//----------------------------------------------------------------------------"},
{"lineNum":"  746","line":""},
{"lineNum":"  747","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 64, "covered" : 0,};
var merged_data = [];
