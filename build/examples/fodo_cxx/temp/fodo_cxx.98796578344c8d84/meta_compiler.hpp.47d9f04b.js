var data = {lines:[
{"lineNum":"    1","line":"/*============================================================================="},
{"lineNum":"    2","line":"  Copyright (c) 2001-2011 Joel de Guzman"},
{"lineNum":"    3","line":"  http://spirit.sourceforge.net/"},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"  Distributed under the Boost Software License, Version 1.0. (See accompanying"},
{"lineNum":"    6","line":"  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"    7","line":"=============================================================================*/"},
{"lineNum":"    8","line":"#ifndef BOOST_SPIRIT_META_COMPILER_OCTOBER_16_2008_1258PM"},
{"lineNum":"    9","line":"#define BOOST_SPIRIT_META_COMPILER_OCTOBER_16_2008_1258PM"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#if defined(_MSC_VER)"},
{"lineNum":"   12","line":"#pragma once"},
{"lineNum":"   13","line":"#endif"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"#include <boost/config.hpp>"},
{"lineNum":"   16","line":"#include <boost/spirit/include/phoenix_limits.hpp>"},
{"lineNum":"   17","line":"#include <boost/detail/workaround.hpp>"},
{"lineNum":"   18","line":"#include <boost/spirit/include/phoenix_limits.hpp>      // needs to be included before proto"},
{"lineNum":"   19","line":"#include <boost/proto/proto.hpp>"},
{"lineNum":"   20","line":"#include <boost/spirit/home/support/make_component.hpp>"},
{"lineNum":"   21","line":"#include <boost/spirit/home/support/modify.hpp>"},
{"lineNum":"   22","line":"#include <boost/spirit/home/support/detail/make_cons.hpp>"},
{"lineNum":"   23","line":"#include <boost/spirit/home/support/unused.hpp>"},
{"lineNum":"   24","line":"#include <boost/spirit/home/support/assert_msg.hpp>"},
{"lineNum":"   25","line":"#include <boost/utility/enable_if.hpp>"},
{"lineNum":"   26","line":"#include <boost/type_traits/remove_reference.hpp>"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"namespace boost { namespace spirit"},
{"lineNum":"   29","line":"{"},
{"lineNum":"   30","line":"    // Some defaults..."},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"    template <typename Domain, typename Tag, typename Enable = void>"},
{"lineNum":"   33","line":"    struct use_operator : mpl::false_ {};"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"    template <typename Domain, typename T, typename Enable = void>"},
{"lineNum":"   36","line":"    struct use_function : mpl::false_ {};"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"    template <typename Domain, typename T, typename Enable = void>"},
{"lineNum":"   39","line":"    struct use_directive : mpl::false_ {};"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"    template <typename Domain, typename T, typename Enable /* = void */>"},
{"lineNum":"   42","line":"    struct is_modifier_directive : mpl::false_ {};"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"    template <typename Domain, typename T, typename Enable = void>"},
{"lineNum":"   45","line":"    struct use_terminal : mpl::false_ {};"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"    template <typename Domain, typename T, typename Enable /*= void*/>"},
{"lineNum":"   48","line":"    struct flatten_tree : mpl::false_ {};"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"    // Our meta-compiler. This is the main engine that hooks Spirit"},
{"lineNum":"   51","line":"    // to the proto expression template engine."},
{"lineNum":"   52","line":""},
{"lineNum":"   53","line":"    template <typename Domain>"},
{"lineNum":"   54","line":"    struct meta_compiler"},
{"lineNum":"   55","line":"    {"},
{"lineNum":"   56","line":"        struct meta_grammar;"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"        BOOST_SPIRIT_ASSERT_MSG(("},
{"lineNum":"   59","line":"            !use_operator<Domain, proto::tag::subscript>::value"},
{"lineNum":"   60","line":"        ), error_proto_tag_subscript_cannot_be_used, ());"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"#if !BOOST_WORKAROUND(BOOST_MSVC, < 1400)"},
{"lineNum":"   63","line":"        // this is the non-broken part for compilers properly supporting"},
{"lineNum":"   64","line":"        // partial template specialization (VC7.1 does not)"},
{"lineNum":"   65","line":"        struct cases"},
{"lineNum":"   66","line":"        {"},
{"lineNum":"   67","line":"            template <typename Tag, typename Enable = void>"},
{"lineNum":"   68","line":"            struct case_"},
{"lineNum":"   69","line":"              : proto::not_<proto::_>"},
{"lineNum":"   70","line":"            {};"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"   73","line":"            // terminals"},
{"lineNum":"   74","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"   75","line":"            template <typename Enable>"},
{"lineNum":"   76","line":"            struct case_<proto::tag::terminal, Enable>"},
{"lineNum":"   77","line":"              : proto::when<"},
{"lineNum":"   78","line":"                    proto::if_<use_terminal<Domain, proto::_value>()>,"},
{"lineNum":"   79","line":"                    detail::make_terminal<Domain>"},
{"lineNum":"   80","line":"                >"},
{"lineNum":"   81","line":"            {};"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"            template <typename Tag>"},
{"lineNum":"   84","line":"            struct case_<Tag, typename enable_if<use_operator<Domain, Tag> >::type>"},
{"lineNum":"   85","line":"              : proto::or_<"},
{"lineNum":"   86","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"   87","line":"            // binary operators"},
{"lineNum":"   88","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"   89","line":"                    proto::when<proto::binary_expr<Tag, meta_grammar, meta_grammar>,"},
{"lineNum":"   90","line":"                        detail::make_binary<Domain, Tag, meta_grammar>"},
{"lineNum":"   91","line":"                    >,"},
{"lineNum":"   92","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"   93","line":"            // unary operators"},
{"lineNum":"   94","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"   95","line":"                    proto::when<proto::unary_expr<Tag, meta_grammar>,"},
{"lineNum":"   96","line":"                        detail::make_unary<Domain, Tag, meta_grammar>"},
{"lineNum":"   97","line":"                    >"},
{"lineNum":"   98","line":"                >"},
{"lineNum":"   99","line":"            {};"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"            template <typename Enable>"},
{"lineNum":"  102","line":"            struct case_<proto::tag::subscript, Enable>"},
{"lineNum":"  103","line":"              : proto::or_<"},
{"lineNum":"  104","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  105","line":"            // directives"},
{"lineNum":"  106","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  107","line":"                    proto::when<proto::binary_expr<proto::tag::subscript"},
{"lineNum":"  108","line":"                      , proto::and_<"},
{"lineNum":"  109","line":"                            proto::terminal<proto::_>"},
{"lineNum":"  110","line":"                          , proto::if_<use_directive<Domain, proto::_value >()> >"},
{"lineNum":"  111","line":"                      , meta_grammar>,"},
{"lineNum":"  112","line":"                        detail::make_directive<Domain, meta_grammar>"},
{"lineNum":"  113","line":"                    >,"},
{"lineNum":"  114","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  115","line":"            // semantic actions"},
{"lineNum":"  116","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  117","line":"                    proto::when<proto::binary_expr<proto::tag::subscript"},
{"lineNum":"  118","line":"                      , meta_grammar, proto::_>,"},
{"lineNum":"  119","line":"                        detail::make_action<Domain, meta_grammar>"},
{"lineNum":"  120","line":"                    >"},
{"lineNum":"  121","line":"                >"},
{"lineNum":"  122","line":"            {};"},
{"lineNum":"  123","line":"        };"},
{"lineNum":"  124","line":"#else"},
{"lineNum":"  125","line":"        // this part actually constitutes invalid C++ code, but it allows us to"},
{"lineNum":"  126","line":"        // convince VC7.1 to do what we want"},
{"lineNum":"  127","line":"        struct cases"},
{"lineNum":"  128","line":"        {"},
{"lineNum":"  129","line":"            template <typename Tag, typename Enable = void>"},
{"lineNum":"  130","line":"            struct case_"},
{"lineNum":"  131","line":"              : proto::not_<proto::_>"},
{"lineNum":"  132","line":"            {};"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  135","line":"            // terminals"},
{"lineNum":"  136","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  137","line":"            template <>"},
{"lineNum":"  138","line":"            struct case_<proto::tag::terminal>"},
{"lineNum":"  139","line":"              : proto::when<"},
{"lineNum":"  140","line":"                    proto::if_<use_terminal<Domain, proto::_value>()>,"},
{"lineNum":"  141","line":"                    detail::make_terminal<Domain>"},
{"lineNum":"  142","line":"                >"},
{"lineNum":"  143","line":"            {};"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"            template <typename Tag>"},
{"lineNum":"  146","line":"            struct case_<Tag>"},
{"lineNum":"  147","line":"              : proto::or_<"},
{"lineNum":"  148","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  149","line":"            // binary operators"},
{"lineNum":"  150","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  151","line":"                    proto::when<proto::binary_expr<"},
{"lineNum":"  152","line":"                        typename enable_if<use_operator<Domain, Tag>, Tag>::type"},
{"lineNum":"  153","line":"                          , meta_grammar, meta_grammar>"},
{"lineNum":"  154","line":"                      , detail::make_binary<Domain, Tag, meta_grammar>"},
{"lineNum":"  155","line":"                    >,"},
{"lineNum":"  156","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  157","line":"            // unary operators"},
{"lineNum":"  158","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  159","line":"                    proto::when<proto::unary_expr<"},
{"lineNum":"  160","line":"                        typename enable_if<use_operator<Domain, Tag>, Tag>::type"},
{"lineNum":"  161","line":"                          , meta_grammar>"},
{"lineNum":"  162","line":"                      , detail::make_unary<Domain, Tag, meta_grammar>"},
{"lineNum":"  163","line":"                    >"},
{"lineNum":"  164","line":"                >"},
{"lineNum":"  165","line":"            {};"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"            template <>"},
{"lineNum":"  168","line":"            struct case_<proto::tag::subscript>"},
{"lineNum":"  169","line":"              : proto::or_<"},
{"lineNum":"  170","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  171","line":"            // directives"},
{"lineNum":"  172","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  173","line":"                    proto::when<proto::binary_expr<proto::tag::subscript"},
{"lineNum":"  174","line":"                      , proto::and_<"},
{"lineNum":"  175","line":"                            proto::terminal<proto::_>"},
{"lineNum":"  176","line":"                          , proto::if_<use_directive<Domain, proto::_value >()> >"},
{"lineNum":"  177","line":"                      , meta_grammar>,"},
{"lineNum":"  178","line":"                        detail::make_directive<Domain, meta_grammar>"},
{"lineNum":"  179","line":"                    >,"},
{"lineNum":"  180","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  181","line":"            // semantic actions"},
{"lineNum":"  182","line":"            ///////////////////////////////////////////////////////////////////"},
{"lineNum":"  183","line":"                    proto::when<proto::binary_expr<proto::tag::subscript"},
{"lineNum":"  184","line":"                      , meta_grammar, proto::_>,"},
{"lineNum":"  185","line":"                        detail::make_action<Domain, meta_grammar>"},
{"lineNum":"  186","line":"                    >"},
{"lineNum":"  187","line":"                >"},
{"lineNum":"  188","line":"            {};"},
{"lineNum":"  189","line":"        };"},
{"lineNum":"  190","line":"#endif"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"        struct meta_grammar"},
{"lineNum":"  193","line":"          : proto::switch_<cases>"},
{"lineNum":"  194","line":"        {};"},
{"lineNum":"  195","line":"    };"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"    namespace result_of"},
{"lineNum":"  198","line":"    {"},
{"lineNum":"  199","line":"        // Default case"},
{"lineNum":"  200","line":"        template <typename Domain, typename Expr"},
{"lineNum":"  201","line":"          , typename Modifiers = unused_type, typename Enable = void>"},
{"lineNum":"  202","line":"        struct compile"},
{"lineNum":"  203","line":"        {"},
{"lineNum":"  204","line":"            typedef typename meta_compiler<Domain>::meta_grammar meta_grammar;"},
{"lineNum":"  205","line":"            typedef typename meta_grammar::"},
{"lineNum":"  206","line":"                template result<meta_grammar(Expr, mpl::void_, Modifiers)>::type"},
{"lineNum":"  207","line":"            type;"},
{"lineNum":"  208","line":"        };"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"        // If Expr is not a proto expression, make it a terminal"},
{"lineNum":"  211","line":"        template <typename Domain, typename Expr, typename Modifiers>"},
{"lineNum":"  212","line":"        struct compile<Domain, Expr, Modifiers,"},
{"lineNum":"  213","line":"            typename disable_if<proto::is_expr<Expr> >::type>"},
{"lineNum":"  214","line":"          : compile<Domain, typename proto::terminal<Expr>::type, Modifiers> {};"},
{"lineNum":"  215","line":"    }"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    namespace traits"},
{"lineNum":"  218","line":"    {"},
{"lineNum":"  219","line":"        // Check if Expr matches the domain\'s grammar"},
{"lineNum":"  220","line":"        template <typename Domain, typename Expr>"},
{"lineNum":"  221","line":"        struct matches :"},
{"lineNum":"  222","line":"            proto::matches<"},
{"lineNum":"  223","line":"                typename proto::result_of::as_expr<"},
{"lineNum":"  224","line":"                    typename remove_reference<Expr>::type>::type,"},
{"lineNum":"  225","line":"                typename meta_compiler<Domain>::meta_grammar"},
{"lineNum":"  226","line":"            >"},
{"lineNum":"  227","line":"        {"},
{"lineNum":"  228","line":"        };"},
{"lineNum":"  229","line":"    }"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"    namespace detail"},
{"lineNum":"  232","line":"    {"},
{"lineNum":"  233","line":"        template <typename Domain>"},
{"lineNum":"  234","line":"        struct compiler"},
{"lineNum":"  235","line":"        {"},
{"lineNum":"  236","line":"            // Default case"},
{"lineNum":"  237","line":"            template <typename Expr, typename Modifiers>"},
{"lineNum":"  238","line":"            static typename spirit::result_of::compile<Domain, Expr, Modifiers>::type"},
{"lineNum":"  239","line":"            compile(Expr const& expr, Modifiers modifiers, mpl::true_)"},
{"lineNum":"  240","line":"            {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  241","line":"                typename meta_compiler<Domain>::meta_grammar compiler;"},
{"lineNum":"  242","line":"                return compiler(expr, mpl::void_(), modifiers);"},
{"lineNum":"  243","line":"            }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"            // If Expr is not a proto expression, make it a terminal"},
{"lineNum":"  246","line":"            template <typename Expr, typename Modifiers>"},
{"lineNum":"  247","line":"            static typename spirit::result_of::compile<Domain, Expr, Modifiers>::type"},
{"lineNum":"  248","line":"            compile(Expr const& expr, Modifiers modifiers, mpl::false_)"},
{"lineNum":"  249","line":"            {"},
{"lineNum":"  250","line":"                typename meta_compiler<Domain>::meta_grammar compiler;"},
{"lineNum":"  251","line":"                typedef typename detail::as_meta_element<Expr>::type expr_;"},
{"lineNum":"  252","line":"                typename proto::terminal<expr_>::type term = {expr};"},
{"lineNum":"  253","line":"                return compiler(term, mpl::void_(), modifiers);"},
{"lineNum":"  254","line":"            }"},
{"lineNum":"  255","line":"        };"},
{"lineNum":"  256","line":"    }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"    template <typename Domain, typename Expr>"},
{"lineNum":"  259","line":"    inline typename result_of::compile<Domain, Expr, unused_type>::type"},
{"lineNum":"  260","line":"    compile(Expr const& expr)"},
{"lineNum":"  261","line":"    {"},
{"lineNum":"  262","line":"        typedef typename proto::is_expr<Expr>::type is_expr;"},
{"lineNum":"  263","line":"        return detail::compiler<Domain>::compile(expr, unused, is_expr());"},
{"lineNum":"  264","line":"    }"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"    template <typename Domain, typename Expr, typename Modifiers>"},
{"lineNum":"  267","line":"    inline typename result_of::compile<Domain, Expr, Modifiers>::type"},
{"lineNum":"  268","line":"    compile(Expr const& expr, Modifiers modifiers)"},
{"lineNum":"  269","line":"    {"},
{"lineNum":"  270","line":"        typedef typename proto::is_expr<Expr>::type is_expr;"},
{"lineNum":"  271","line":"        return detail::compiler<Domain>::compile(expr, modifiers, is_expr());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  272","line":"    }"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"    ///////////////////////////////////////////////////////////////////////////"},
{"lineNum":"  275","line":"    template <typename Elements, template <typename Subject> class generator>"},
{"lineNum":"  276","line":"    struct make_unary_composite"},
{"lineNum":"  277","line":"    {"},
{"lineNum":"  278","line":"        typedef typename"},
{"lineNum":"  279","line":"            fusion::result_of::value_at_c<Elements, 0>::type"},
{"lineNum":"  280","line":"        element_type;"},
{"lineNum":"  281","line":"        typedef generator<element_type> result_type;"},
{"lineNum":"  282","line":"        result_type operator()(Elements const& elements, unused_type) const"},
{"lineNum":"  283","line":"        {"},
{"lineNum":"  284","line":"            return result_type(fusion::at_c<0>(elements));"},
{"lineNum":"  285","line":"        }"},
{"lineNum":"  286","line":"    };"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"    template <typename Elements, template <typename Left, typename Right> class generator>"},
{"lineNum":"  289","line":"    struct make_binary_composite"},
{"lineNum":"  290","line":"    {"},
{"lineNum":"  291","line":"        typedef typename"},
{"lineNum":"  292","line":"            fusion::result_of::value_at_c<Elements, 0>::type"},
{"lineNum":"  293","line":"        left_type;"},
{"lineNum":"  294","line":"        typedef typename"},
{"lineNum":"  295","line":"            fusion::result_of::value_at_c<Elements, 1>::type"},
{"lineNum":"  296","line":"        right_type;"},
{"lineNum":"  297","line":"        typedef generator<left_type, right_type> result_type;"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"        result_type operator()(Elements const& elements, unused_type) const"},
{"lineNum":"  300","line":"        {"},
{"lineNum":"  301","line":"            return result_type(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  302","line":"                fusion::at_c<0>(elements)"},
{"lineNum":"  303","line":"              , fusion::at_c<1>(elements)"},
{"lineNum":"  304","line":"            );"},
{"lineNum":"  305","line":"        }"},
{"lineNum":"  306","line":"    };"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"    template <typename Elements, template <typename Elements_> class generator>"},
{"lineNum":"  309","line":"    struct make_nary_composite"},
{"lineNum":"  310","line":"    {"},
{"lineNum":"  311","line":"        typedef generator<Elements> result_type;"},
{"lineNum":"  312","line":"        result_type operator()(Elements const& elements, unused_type) const"},
{"lineNum":"  313","line":"        {"},
{"lineNum":"  314","line":"            return result_type(elements);"},
{"lineNum":"  315","line":"        }"},
{"lineNum":"  316","line":"    };"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"}}"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
