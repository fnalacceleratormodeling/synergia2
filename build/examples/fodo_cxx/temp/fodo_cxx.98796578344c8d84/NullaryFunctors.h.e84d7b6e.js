var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2008-2016 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    7","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    8","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"#ifndef EIGEN_NULLARY_FUNCTORS_H"},
{"lineNum":"   11","line":"#define EIGEN_NULLARY_FUNCTORS_H"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#include \"../InternalHeaderCheck.h\""},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"namespace Eigen {"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"namespace internal {"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"template<typename Scalar>"},
{"lineNum":"   20","line":"struct scalar_constant_op {"},
{"lineNum":"   21","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }","class":"lineNoCov","hits":"0","possible_hits":"67",},
{"lineNum":"   22","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }","class":"lineNoCov","hits":"0","possible_hits":"32",},
{"lineNum":"   23","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() () const { return m_other; }","class":"lineNoCov","hits":"0","possible_hits":"29",},
{"lineNum":"   24","line":"  template<typename PacketType>"},
{"lineNum":"   25","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const PacketType packetOp() const { return internal::pset1<PacketType>(m_other); }"},
{"lineNum":"   26","line":"  const Scalar m_other;"},
{"lineNum":"   27","line":"};"},
{"lineNum":"   28","line":"template<typename Scalar>"},
{"lineNum":"   29","line":"struct functor_traits<scalar_constant_op<Scalar> >"},
{"lineNum":"   30","line":"{ enum { Cost = 0 /* as the constant value should be loaded in register only once for the whole expression */,"},
{"lineNum":"   31","line":"         PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"template<typename Scalar> struct scalar_identity_op {"},
{"lineNum":"   34","line":"  EIGEN_EMPTY_STRUCT_CTOR(scalar_identity_op)"},
{"lineNum":"   35","line":"  template<typename IndexType>"},
{"lineNum":"   36","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType row, IndexType col) const { return row==col ? Scalar(1) : Scalar(0); }","class":"lineNoCov","hits":"0","possible_hits":"31",},
{"lineNum":"   37","line":"};"},
{"lineNum":"   38","line":"template<typename Scalar>"},
{"lineNum":"   39","line":"struct functor_traits<scalar_identity_op<Scalar> >"},
{"lineNum":"   40","line":"{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"template <typename Scalar, bool IsInteger> struct linspaced_op_impl;"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"template <typename Scalar>"},
{"lineNum":"   45","line":"struct linspaced_op_impl<Scalar,/*IsInteger*/false>"},
{"lineNum":"   46","line":"{"},
{"lineNum":"   47","line":"  typedef typename NumTraits<Scalar>::Real RealScalar;"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"  EIGEN_DEVICE_FUNC linspaced_op_impl(const Scalar& low, const Scalar& high, Index num_steps) :"},
{"lineNum":"   50","line":"    m_low(low), m_high(high), m_size1(num_steps==1 ? 1 : num_steps-1), m_step(num_steps==1 ? Scalar() : Scalar((high-low)/RealScalar(num_steps-1))),"},
{"lineNum":"   51","line":"    m_flip(numext::abs(high)<numext::abs(low))"},
{"lineNum":"   52","line":"  {}"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"  template<typename IndexType>"},
{"lineNum":"   55","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType i) const {"},
{"lineNum":"   56","line":"    if(m_flip)"},
{"lineNum":"   57","line":"      return (i==0)? m_low : Scalar(m_high - RealScalar(m_size1-i)*m_step);"},
{"lineNum":"   58","line":"    else"},
{"lineNum":"   59","line":"      return (i==m_size1)? m_high : Scalar(m_low + RealScalar(i)*m_step);"},
{"lineNum":"   60","line":"  }"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"  template<typename Packet, typename IndexType>"},
{"lineNum":"   63","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const"},
{"lineNum":"   64","line":"  {"},
{"lineNum":"   65","line":"    // Principle:"},
{"lineNum":"   66","line":"    // [low, ..., low] + ( [step, ..., step] * ( [i, ..., i] + [0, ..., size] ) )"},
{"lineNum":"   67","line":"    if(m_flip)"},
{"lineNum":"   68","line":"    {"},
{"lineNum":"   69","line":"      Packet pi = plset<Packet>(Scalar(i-m_size1));"},
{"lineNum":"   70","line":"      Packet res = padd(pset1<Packet>(m_high), pmul(pset1<Packet>(m_step), pi));"},
{"lineNum":"   71","line":"      if (EIGEN_PREDICT_TRUE(i != 0)) return res;"},
{"lineNum":"   72","line":"      Packet mask = pcmp_lt(pset1<Packet>(0), plset<Packet>(0));"},
{"lineNum":"   73","line":"      return pselect<Packet>(mask, res, pset1<Packet>(m_low));"},
{"lineNum":"   74","line":"    }"},
{"lineNum":"   75","line":"    else"},
{"lineNum":"   76","line":"    {"},
{"lineNum":"   77","line":"      Packet pi = plset<Packet>(Scalar(i));"},
{"lineNum":"   78","line":"      Packet res = padd(pset1<Packet>(m_low), pmul(pset1<Packet>(m_step), pi));"},
{"lineNum":"   79","line":"      if(EIGEN_PREDICT_TRUE(i != m_size1-unpacket_traits<Packet>::size+1)) return res;"},
{"lineNum":"   80","line":"      Packet mask = pcmp_lt(plset<Packet>(0), pset1<Packet>(unpacket_traits<Packet>::size-1));"},
{"lineNum":"   81","line":"      return pselect<Packet>(mask, res, pset1<Packet>(m_high));"},
{"lineNum":"   82","line":"    }"},
{"lineNum":"   83","line":"  }"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"  const Scalar m_low;"},
{"lineNum":"   86","line":"  const Scalar m_high;"},
{"lineNum":"   87","line":"  const Index m_size1;"},
{"lineNum":"   88","line":"  const Scalar m_step;"},
{"lineNum":"   89","line":"  const bool m_flip;"},
{"lineNum":"   90","line":"};"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"template <typename Scalar>"},
{"lineNum":"   93","line":"struct linspaced_op_impl<Scalar,/*IsInteger*/true>"},
{"lineNum":"   94","line":"{"},
{"lineNum":"   95","line":"  EIGEN_DEVICE_FUNC linspaced_op_impl(const Scalar& low, const Scalar& high, Index num_steps) :"},
{"lineNum":"   96","line":"    m_low(low),"},
{"lineNum":"   97","line":"    m_multiplier((high-low)/convert_index<Scalar>(num_steps<=1 ? 1 : num_steps-1)),"},
{"lineNum":"   98","line":"    m_divisor(convert_index<Scalar>((high>=low?num_steps:-num_steps)+(high-low))/((numext::abs(high-low)+1)==0?1:(numext::abs(high-low)+1))),"},
{"lineNum":"   99","line":"    m_use_divisor(num_steps>1 && (numext::abs(high-low)+1)<num_steps)"},
{"lineNum":"  100","line":"  {}"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"  template<typename IndexType>"},
{"lineNum":"  103","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  104","line":"  const Scalar operator() (IndexType i) const"},
{"lineNum":"  105","line":"  {"},
{"lineNum":"  106","line":"    if(m_use_divisor) return m_low + convert_index<Scalar>(i)/m_divisor;"},
{"lineNum":"  107","line":"    else              return m_low + convert_index<Scalar>(i)*m_multiplier;"},
{"lineNum":"  108","line":"  }"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"  const Scalar m_low;"},
{"lineNum":"  111","line":"  const Scalar m_multiplier;"},
{"lineNum":"  112","line":"  const Scalar m_divisor;"},
{"lineNum":"  113","line":"  const bool m_use_divisor;"},
{"lineNum":"  114","line":"};"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"// ----- Linspace functor ----------------------------------------------------------------"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"// Forward declaration (we default to random access which does not really give"},
{"lineNum":"  119","line":"// us a speed gain when using packet access but it allows to use the functor in"},
{"lineNum":"  120","line":"// nested expressions)."},
{"lineNum":"  121","line":"template <typename Scalar> struct linspaced_op;"},
{"lineNum":"  122","line":"template <typename Scalar> struct functor_traits< linspaced_op<Scalar> >"},
{"lineNum":"  123","line":"{"},
{"lineNum":"  124","line":"  enum"},
{"lineNum":"  125","line":"  {"},
{"lineNum":"  126","line":"    Cost = 1,"},
{"lineNum":"  127","line":"    PacketAccess =   (!NumTraits<Scalar>::IsInteger) && packet_traits<Scalar>::HasSetLinear && packet_traits<Scalar>::HasBlend,"},
{"lineNum":"  128","line":"                  /*&& ((!NumTraits<Scalar>::IsInteger) || packet_traits<Scalar>::HasDiv),*/ // <- vectorization for integer is currently disabled"},
{"lineNum":"  129","line":"    IsRepeatable = true"},
{"lineNum":"  130","line":"  };"},
{"lineNum":"  131","line":"};"},
{"lineNum":"  132","line":"template <typename Scalar> struct linspaced_op"},
{"lineNum":"  133","line":"{"},
{"lineNum":"  134","line":"  EIGEN_DEVICE_FUNC linspaced_op(const Scalar& low, const Scalar& high, Index num_steps)"},
{"lineNum":"  135","line":"    : impl((num_steps==1 ? high : low),high,num_steps)"},
{"lineNum":"  136","line":"  {}"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"  template<typename IndexType>"},
{"lineNum":"  139","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar operator() (IndexType i) const { return impl(i); }"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"  template<typename Packet,typename IndexType>"},
{"lineNum":"  142","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Packet packetOp(IndexType i) const { return impl.template packetOp<Packet>(i); }"},
{"lineNum":"  143","line":""},
{"lineNum":"  144","line":"  // This proxy object handles the actual required temporaries and the different"},
{"lineNum":"  145","line":"  // implementations (integer vs. floating point)."},
{"lineNum":"  146","line":"  const linspaced_op_impl<Scalar,NumTraits<Scalar>::IsInteger> impl;"},
{"lineNum":"  147","line":"};"},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"// Linear access is automatically determined from the operator() prototypes available for the given functor."},
{"lineNum":"  150","line":"// If it exposes an operator()(i,j), then we assume the i and j coefficients are required independently"},
{"lineNum":"  151","line":"// and linear access is not possible. In all other cases, linear access is enabled."},
{"lineNum":"  152","line":"// Users should not have to deal with this structure."},
{"lineNum":"  153","line":"template<typename Functor> struct functor_has_linear_access { enum { ret = !has_binary_operator<Functor>::value }; };"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"// For unreliable compilers, let\'s specialize the has_*ary_operator"},
{"lineNum":"  156","line":"// helpers so that at least built-in nullary functors work fine."},
{"lineNum":"  157","line":"#if !( (EIGEN_COMP_MSVC>1600) || (EIGEN_GNUC_AT_LEAST(4,8)) || (EIGEN_COMP_ICC>=1600))"},
{"lineNum":"  158","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  159","line":"struct has_nullary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 1}; };"},
{"lineNum":"  160","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  161","line":"struct has_unary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };"},
{"lineNum":"  162","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  163","line":"struct has_binary_operator<scalar_constant_op<Scalar>,IndexType> { enum { value = 0}; };"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  166","line":"struct has_nullary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };"},
{"lineNum":"  167","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  168","line":"struct has_unary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 0}; };"},
{"lineNum":"  169","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  170","line":"struct has_binary_operator<scalar_identity_op<Scalar>,IndexType> { enum { value = 1}; };"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  173","line":"struct has_nullary_operator<linspaced_op<Scalar>,IndexType> { enum { value = 0}; };"},
{"lineNum":"  174","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  175","line":"struct has_unary_operator<linspaced_op<Scalar>,IndexType> { enum { value = 1}; };"},
{"lineNum":"  176","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  177","line":"struct has_binary_operator<linspaced_op<Scalar>,IndexType> { enum { value = 0}; };"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  180","line":"struct has_nullary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 1}; };"},
{"lineNum":"  181","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  182","line":"struct has_unary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };"},
{"lineNum":"  183","line":"template<typename Scalar,typename IndexType>"},
{"lineNum":"  184","line":"struct has_binary_operator<scalar_random_op<Scalar>,IndexType> { enum { value = 0}; };"},
{"lineNum":"  185","line":"#endif"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"} // end namespace internal"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"} // end namespace Eigen"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"#endif // EIGEN_NULLARY_FUNCTORS_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 4, "covered" : 0,};
var merged_data = [];
