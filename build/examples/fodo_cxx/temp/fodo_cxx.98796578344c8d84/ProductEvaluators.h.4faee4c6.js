var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2006-2008 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2008-2010 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"// Copyright (C) 2011 Jitse Niesen <jitse@maths.leeds.ac.uk>"},
{"lineNum":"    7","line":"//"},
{"lineNum":"    8","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    9","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"   10","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"#ifndef EIGEN_PRODUCTEVALUATORS_H"},
{"lineNum":"   14","line":"#define EIGEN_PRODUCTEVALUATORS_H"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace Eigen {"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"namespace internal {"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"/** \\internal"},
{"lineNum":"   23","line":"  * Evaluator of a product expression."},
{"lineNum":"   24","line":"  * Since products require special treatments to handle all possible cases,"},
{"lineNum":"   25","line":"  * we simply defer the evaluation logic to a product_evaluator class"},
{"lineNum":"   26","line":"  * which offers more partial specialization possibilities."},
{"lineNum":"   27","line":"  *"},
{"lineNum":"   28","line":"  * \\sa class product_evaluator"},
{"lineNum":"   29","line":"  */"},
{"lineNum":"   30","line":"template<typename Lhs, typename Rhs, int Options>"},
{"lineNum":"   31","line":"struct evaluator<Product<Lhs, Rhs, Options> >"},
{"lineNum":"   32","line":" : public product_evaluator<Product<Lhs, Rhs, Options> >"},
{"lineNum":"   33","line":"{"},
{"lineNum":"   34","line":"  typedef Product<Lhs, Rhs, Options> XprType;"},
{"lineNum":"   35","line":"  typedef product_evaluator<XprType> Base;"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit evaluator(const XprType& xpr) : Base(xpr) {}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   38","line":"};"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"// Catch \"scalar * ( A * B )\" and transform it to \"(A*scalar) * B\""},
{"lineNum":"   41","line":"// TODO we should apply that rule only if that\'s really helpful"},
{"lineNum":"   42","line":"template<typename Lhs, typename Rhs, typename Scalar1, typename Scalar2, typename Plain1>"},
{"lineNum":"   43","line":"struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,"},
{"lineNum":"   44","line":"                                               const CwiseNullaryOp<internal::scalar_constant_op<Scalar1>, Plain1>,"},
{"lineNum":"   45","line":"                                               const Product<Lhs, Rhs, DefaultProduct> > >"},
{"lineNum":"   46","line":"{"},
{"lineNum":"   47","line":"  static const bool value = true;"},
{"lineNum":"   48","line":"};"},
{"lineNum":"   49","line":"template<typename Lhs, typename Rhs, typename Scalar1, typename Scalar2, typename Plain1>"},
{"lineNum":"   50","line":"struct evaluator<CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,"},
{"lineNum":"   51","line":"                               const CwiseNullaryOp<internal::scalar_constant_op<Scalar1>, Plain1>,"},
{"lineNum":"   52","line":"                               const Product<Lhs, Rhs, DefaultProduct> > >"},
{"lineNum":"   53","line":" : public evaluator<Product<EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar1,Lhs,product), Rhs, DefaultProduct> >"},
{"lineNum":"   54","line":"{"},
{"lineNum":"   55","line":"  typedef CwiseBinaryOp<internal::scalar_product_op<Scalar1,Scalar2>,"},
{"lineNum":"   56","line":"                               const CwiseNullaryOp<internal::scalar_constant_op<Scalar1>, Plain1>,"},
{"lineNum":"   57","line":"                               const Product<Lhs, Rhs, DefaultProduct> > XprType;"},
{"lineNum":"   58","line":"  typedef evaluator<Product<EIGEN_SCALAR_BINARYOP_EXPR_RETURN_TYPE(Scalar1,Lhs,product), Rhs, DefaultProduct> > Base;"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit evaluator(const XprType& xpr)"},
{"lineNum":"   61","line":"    : Base(xpr.lhs().functor().m_other * xpr.rhs().lhs() * xpr.rhs().rhs())"},
{"lineNum":"   62","line":"  {}"},
{"lineNum":"   63","line":"};"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"template<typename Lhs, typename Rhs, int DiagIndex>"},
{"lineNum":"   67","line":"struct evaluator<Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> >"},
{"lineNum":"   68","line":" : public evaluator<Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex> >"},
{"lineNum":"   69","line":"{"},
{"lineNum":"   70","line":"  typedef Diagonal<const Product<Lhs, Rhs, DefaultProduct>, DiagIndex> XprType;"},
{"lineNum":"   71","line":"  typedef evaluator<Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex> > Base;"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE explicit evaluator(const XprType& xpr)"},
{"lineNum":"   74","line":"    : Base(Diagonal<const Product<Lhs, Rhs, LazyProduct>, DiagIndex>("},
{"lineNum":"   75","line":"        Product<Lhs, Rhs, LazyProduct>(xpr.nestedExpression().lhs(), xpr.nestedExpression().rhs()),"},
{"lineNum":"   76","line":"        xpr.index() ))"},
{"lineNum":"   77","line":"  {}"},
{"lineNum":"   78","line":"};"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"// Helper class to perform a matrix product with the destination at hand."},
{"lineNum":"   82","line":"// Depending on the sizes of the factors, there are different evaluation strategies"},
{"lineNum":"   83","line":"// as controlled by internal::product_type."},
{"lineNum":"   84","line":"template< typename Lhs, typename Rhs,"},
{"lineNum":"   85","line":"          typename LhsShape = typename evaluator_traits<Lhs>::Shape,"},
{"lineNum":"   86","line":"          typename RhsShape = typename evaluator_traits<Rhs>::Shape,"},
{"lineNum":"   87","line":"          int ProductType = internal::product_type<Lhs,Rhs>::value>"},
{"lineNum":"   88","line":"struct generic_product_impl;"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"   91","line":"struct evaluator_assume_aliasing<Product<Lhs, Rhs, DefaultProduct> > {"},
{"lineNum":"   92","line":"  static const bool value = true;"},
{"lineNum":"   93","line":"};"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"// This is the default evaluator implementation for products:"},
{"lineNum":"   96","line":"// It creates a temporary and call generic_product_impl"},
{"lineNum":"   97","line":"template<typename Lhs, typename Rhs, int Options, int ProductTag, typename LhsShape, typename RhsShape>"},
{"lineNum":"   98","line":"struct product_evaluator<Product<Lhs, Rhs, Options>, ProductTag, LhsShape, RhsShape>"},
{"lineNum":"   99","line":"  : public evaluator<typename Product<Lhs, Rhs, Options>::PlainObject>"},
{"lineNum":"  100","line":"{"},
{"lineNum":"  101","line":"  typedef Product<Lhs, Rhs, Options> XprType;"},
{"lineNum":"  102","line":"  typedef typename XprType::PlainObject PlainObject;"},
{"lineNum":"  103","line":"  typedef evaluator<PlainObject> Base;"},
{"lineNum":"  104","line":"  enum {"},
{"lineNum":"  105","line":"    Flags = Base::Flags | EvalBeforeNestingBit"},
{"lineNum":"  106","line":"  };"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  109","line":"  explicit product_evaluator(const XprType& xpr)"},
{"lineNum":"  110","line":"    : m_result(xpr.rows(), xpr.cols())","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  111","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  112","line":"    ::new (static_cast<Base*>(this)) Base(m_result);"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"// FIXME shall we handle nested_eval here?,"},
{"lineNum":"  115","line":"// if so, then we must take care at removing the call to nested_eval in the specializations (e.g., in permutation_matrix_product, transposition_matrix_product, etc.)"},
{"lineNum":"  116","line":"//     typedef typename internal::nested_eval<Lhs,Rhs::ColsAtCompileTime>::type LhsNested;"},
{"lineNum":"  117","line":"//     typedef typename internal::nested_eval<Rhs,Lhs::RowsAtCompileTime>::type RhsNested;"},
{"lineNum":"  118","line":"//     typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;"},
{"lineNum":"  119","line":"//     typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;"},
{"lineNum":"  120","line":"//"},
{"lineNum":"  121","line":"//     const LhsNested lhs(xpr.lhs());"},
{"lineNum":"  122","line":"//     const RhsNested rhs(xpr.rhs());"},
{"lineNum":"  123","line":"//"},
{"lineNum":"  124","line":"//     generic_product_impl<LhsNestedCleaned, RhsNestedCleaned>::evalTo(m_result, lhs, rhs);"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"    generic_product_impl<Lhs, Rhs, LhsShape, RhsShape, ProductTag>::evalTo(m_result, xpr.lhs(), xpr.rhs());","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  127","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"protected:"},
{"lineNum":"  130","line":"  PlainObject m_result;"},
{"lineNum":"  131","line":"};"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"// The following three shortcuts are enabled only if the scalar types match exactly."},
{"lineNum":"  134","line":"// TODO: we could enable them for different scalar types when the product is not vectorized."},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"// Dense = Product"},
{"lineNum":"  137","line":"template< typename DstXprType, typename Lhs, typename Rhs, int Options, typename Scalar>"},
{"lineNum":"  138","line":"struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::assign_op<Scalar,Scalar>, Dense2Dense,"},
{"lineNum":"  139","line":"  typename enable_if<(Options==DefaultProduct || Options==AliasFreeProduct)>::type>"},
{"lineNum":"  140","line":"{"},
{"lineNum":"  141","line":"  typedef Product<Lhs,Rhs,Options> SrcXprType;"},
{"lineNum":"  142","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  143","line":"  void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<Scalar,Scalar> &)"},
{"lineNum":"  144","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  145","line":"    Index dstRows = src.rows();"},
{"lineNum":"  146","line":"    Index dstCols = src.cols();"},
{"lineNum":"  147","line":"    if((dst.rows()!=dstRows) || (dst.cols()!=dstCols))","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  148","line":"      dst.resize(dstRows, dstCols);","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  149","line":"    // FIXME shall we handle nested_eval here?"},
{"lineNum":"  150","line":"    generic_product_impl<Lhs, Rhs>::evalTo(dst, src.lhs(), src.rhs());","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  151","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  152","line":"};"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"// Dense += Product"},
{"lineNum":"  155","line":"template< typename DstXprType, typename Lhs, typename Rhs, int Options, typename Scalar>"},
{"lineNum":"  156","line":"struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::add_assign_op<Scalar,Scalar>, Dense2Dense,"},
{"lineNum":"  157","line":"  typename enable_if<(Options==DefaultProduct || Options==AliasFreeProduct)>::type>"},
{"lineNum":"  158","line":"{"},
{"lineNum":"  159","line":"  typedef Product<Lhs,Rhs,Options> SrcXprType;"},
{"lineNum":"  160","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  161","line":"  void run(DstXprType &dst, const SrcXprType &src, const internal::add_assign_op<Scalar,Scalar> &)"},
{"lineNum":"  162","line":"  {"},
{"lineNum":"  163","line":"    eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());"},
{"lineNum":"  164","line":"    // FIXME shall we handle nested_eval here?"},
{"lineNum":"  165","line":"    generic_product_impl<Lhs, Rhs>::addTo(dst, src.lhs(), src.rhs());"},
{"lineNum":"  166","line":"  }"},
{"lineNum":"  167","line":"};"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"// Dense -= Product"},
{"lineNum":"  170","line":"template< typename DstXprType, typename Lhs, typename Rhs, int Options, typename Scalar>"},
{"lineNum":"  171","line":"struct Assignment<DstXprType, Product<Lhs,Rhs,Options>, internal::sub_assign_op<Scalar,Scalar>, Dense2Dense,"},
{"lineNum":"  172","line":"  typename enable_if<(Options==DefaultProduct || Options==AliasFreeProduct)>::type>"},
{"lineNum":"  173","line":"{"},
{"lineNum":"  174","line":"  typedef Product<Lhs,Rhs,Options> SrcXprType;"},
{"lineNum":"  175","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  176","line":"  void run(DstXprType &dst, const SrcXprType &src, const internal::sub_assign_op<Scalar,Scalar> &)"},
{"lineNum":"  177","line":"  {"},
{"lineNum":"  178","line":"    eigen_assert(dst.rows() == src.rows() && dst.cols() == src.cols());"},
{"lineNum":"  179","line":"    // FIXME shall we handle nested_eval here?"},
{"lineNum":"  180","line":"    generic_product_impl<Lhs, Rhs>::subTo(dst, src.lhs(), src.rhs());"},
{"lineNum":"  181","line":"  }"},
{"lineNum":"  182","line":"};"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"// Dense ?= scalar * Product"},
{"lineNum":"  186","line":"// TODO we should apply that rule if that\'s really helpful"},
{"lineNum":"  187","line":"// for instance, this is not good for inner products"},
{"lineNum":"  188","line":"template< typename DstXprType, typename Lhs, typename Rhs, typename AssignFunc, typename Scalar, typename ScalarBis, typename Plain>"},
{"lineNum":"  189","line":"struct Assignment<DstXprType, CwiseBinaryOp<internal::scalar_product_op<ScalarBis,Scalar>, const CwiseNullaryOp<internal::scalar_constant_op<ScalarBis>,Plain>,"},
{"lineNum":"  190","line":"                                           const Product<Lhs,Rhs,DefaultProduct> >, AssignFunc, Dense2Dense>"},
{"lineNum":"  191","line":"{"},
{"lineNum":"  192","line":"  typedef CwiseBinaryOp<internal::scalar_product_op<ScalarBis,Scalar>,"},
{"lineNum":"  193","line":"                        const CwiseNullaryOp<internal::scalar_constant_op<ScalarBis>,Plain>,"},
{"lineNum":"  194","line":"                        const Product<Lhs,Rhs,DefaultProduct> > SrcXprType;"},
{"lineNum":"  195","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  196","line":"  void run(DstXprType &dst, const SrcXprType &src, const AssignFunc& func)"},
{"lineNum":"  197","line":"  {"},
{"lineNum":"  198","line":"    call_assignment_no_alias(dst, (src.lhs().functor().m_other * src.rhs().lhs())*src.rhs().rhs(), func);"},
{"lineNum":"  199","line":"  }"},
{"lineNum":"  200","line":"};"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"//----------------------------------------"},
{"lineNum":"  203","line":"// Catch \"Dense ?= xpr + Product<>\" expression to save one temporary"},
{"lineNum":"  204","line":"// FIXME we could probably enable these rules for any product, i.e., not only Dense and DefaultProduct"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"template<typename OtherXpr, typename Lhs, typename Rhs>"},
{"lineNum":"  207","line":"struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_sum_op<typename OtherXpr::Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, const OtherXpr,"},
{"lineNum":"  208","line":"                                               const Product<Lhs,Rhs,DefaultProduct> >, DenseShape > {"},
{"lineNum":"  209","line":"  static const bool value = true;"},
{"lineNum":"  210","line":"};"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"template<typename OtherXpr, typename Lhs, typename Rhs>"},
{"lineNum":"  213","line":"struct evaluator_assume_aliasing<CwiseBinaryOp<internal::scalar_difference_op<typename OtherXpr::Scalar,typename Product<Lhs,Rhs,DefaultProduct>::Scalar>, const OtherXpr,"},
{"lineNum":"  214","line":"                                               const Product<Lhs,Rhs,DefaultProduct> >, DenseShape > {"},
{"lineNum":"  215","line":"  static const bool value = true;"},
{"lineNum":"  216","line":"};"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"template<typename DstXprType, typename OtherXpr, typename ProductType, typename Func1, typename Func2>"},
{"lineNum":"  219","line":"struct assignment_from_xpr_op_product"},
{"lineNum":"  220","line":"{"},
{"lineNum":"  221","line":"  template<typename SrcXprType, typename InitialFunc>"},
{"lineNum":"  222","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  223","line":"  void run(DstXprType &dst, const SrcXprType &src, const InitialFunc& /*func*/)"},
{"lineNum":"  224","line":"  {"},
{"lineNum":"  225","line":"    call_assignment_no_alias(dst, src.lhs(), Func1());"},
{"lineNum":"  226","line":"    call_assignment_no_alias(dst, src.rhs(), Func2());"},
{"lineNum":"  227","line":"  }"},
{"lineNum":"  228","line":"};"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"#define EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(ASSIGN_OP,BINOP,ASSIGN_OP2) \\"},
{"lineNum":"  231","line":"  template< typename DstXprType, typename OtherXpr, typename Lhs, typename Rhs, typename DstScalar, typename SrcScalar, typename OtherScalar,typename ProdScalar> \\"},
{"lineNum":"  232","line":"  struct Assignment<DstXprType, CwiseBinaryOp<internal::BINOP<OtherScalar,ProdScalar>, const OtherXpr, \\"},
{"lineNum":"  233","line":"                                            const Product<Lhs,Rhs,DefaultProduct> >, internal::ASSIGN_OP<DstScalar,SrcScalar>, Dense2Dense> \\"},
{"lineNum":"  234","line":"    : assignment_from_xpr_op_product<DstXprType, OtherXpr, Product<Lhs,Rhs,DefaultProduct>, internal::ASSIGN_OP<DstScalar,OtherScalar>, internal::ASSIGN_OP2<DstScalar,ProdScalar> > \\"},
{"lineNum":"  235","line":"  {}"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(assign_op,    scalar_sum_op,add_assign_op);"},
{"lineNum":"  238","line":"EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(add_assign_op,scalar_sum_op,add_assign_op);"},
{"lineNum":"  239","line":"EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(sub_assign_op,scalar_sum_op,sub_assign_op);"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(assign_op,    scalar_difference_op,sub_assign_op);"},
{"lineNum":"  242","line":"EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(add_assign_op,scalar_difference_op,sub_assign_op);"},
{"lineNum":"  243","line":"EIGEN_CATCH_ASSIGN_XPR_OP_PRODUCT(sub_assign_op,scalar_difference_op,add_assign_op);"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"//----------------------------------------"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"  248","line":"struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,InnerProduct>"},
{"lineNum":"  249","line":"{"},
{"lineNum":"  250","line":"  template<typename Dst>"},
{"lineNum":"  251","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  252","line":"  {"},
{"lineNum":"  253","line":"    dst.coeffRef(0,0) = (lhs.transpose().cwiseProduct(rhs)).sum();"},
{"lineNum":"  254","line":"  }"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"  template<typename Dst>"},
{"lineNum":"  257","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  258","line":"  {"},
{"lineNum":"  259","line":"    dst.coeffRef(0,0) += (lhs.transpose().cwiseProduct(rhs)).sum();"},
{"lineNum":"  260","line":"  }"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"  template<typename Dst>"},
{"lineNum":"  263","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  264","line":"  { dst.coeffRef(0,0) -= (lhs.transpose().cwiseProduct(rhs)).sum(); }"},
{"lineNum":"  265","line":"};"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"/***********************************************************************"},
{"lineNum":"  269","line":"*  Implementation of outer dense * dense vector product"},
{"lineNum":"  270","line":"***********************************************************************/"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"// Column major result"},
{"lineNum":"  273","line":"template<typename Dst, typename Lhs, typename Rhs, typename Func>"},
{"lineNum":"  274","line":"void EIGEN_DEVICE_FUNC outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const false_type&)"},
{"lineNum":"  275","line":"{","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  276","line":"  evaluator<Rhs> rhsEval(rhs);"},
{"lineNum":"  277","line":"  ei_declare_local_nested_eval(Lhs,lhs,Rhs::SizeAtCompileTime,actual_lhs);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  278","line":"  // FIXME if cols is large enough, then it might be useful to make sure that lhs is sequentially stored"},
{"lineNum":"  279","line":"  // FIXME not very good if rhs is real and lhs complex while alpha is real too"},
{"lineNum":"  280","line":"  const Index cols = dst.cols();"},
{"lineNum":"  281","line":"  for (Index j=0; j<cols; ++j)","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  282","line":"    func(dst.col(j), rhsEval.coeff(Index(0),j) * actual_lhs);"},
{"lineNum":"  283","line":"}","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"// Row major result"},
{"lineNum":"  286","line":"template<typename Dst, typename Lhs, typename Rhs, typename Func>"},
{"lineNum":"  287","line":"void EIGEN_DEVICE_FUNC outer_product_selector_run(Dst& dst, const Lhs &lhs, const Rhs &rhs, const Func& func, const true_type&)"},
{"lineNum":"  288","line":"{","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  289","line":"  evaluator<Lhs> lhsEval(lhs);"},
{"lineNum":"  290","line":"  ei_declare_local_nested_eval(Rhs,rhs,Lhs::SizeAtCompileTime,actual_rhs);"},
{"lineNum":"  291","line":"  // FIXME if rows is large enough, then it might be useful to make sure that rhs is sequentially stored"},
{"lineNum":"  292","line":"  // FIXME not very good if lhs is real and rhs complex while alpha is real too"},
{"lineNum":"  293","line":"  const Index rows = dst.rows();"},
{"lineNum":"  294","line":"  for (Index i=0; i<rows; ++i)","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  295","line":"    func(dst.row(i), lhsEval.coeff(i,Index(0)) * actual_rhs);"},
{"lineNum":"  296","line":"}","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"  299","line":"struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,OuterProduct>"},
{"lineNum":"  300","line":"{"},
{"lineNum":"  301","line":"  template<typename T> struct is_row_major : internal::conditional<(int(T::Flags)&RowMajorBit), internal::true_type, internal::false_type>::type {};"},
{"lineNum":"  302","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"  // TODO it would be nice to be able to exploit our *_assign_op functors for that purpose"},
{"lineNum":"  305","line":"  struct set  { template<typename Dst, typename Src> EIGEN_DEVICE_FUNC void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };"},
{"lineNum":"  306","line":"  struct add  { template<typename Dst, typename Src> EIGEN_DEVICE_FUNC void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };"},
{"lineNum":"  307","line":"  struct sub  { template<typename Dst, typename Src> EIGEN_DEVICE_FUNC void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };"},
{"lineNum":"  308","line":"  struct adds {"},
{"lineNum":"  309","line":"    Scalar m_scale;"},
{"lineNum":"  310","line":"    explicit adds(const Scalar& s) : m_scale(s) {}"},
{"lineNum":"  311","line":"    template<typename Dst, typename Src> void EIGEN_DEVICE_FUNC operator()(const Dst& dst, const Src& src) const {"},
{"lineNum":"  312","line":"      dst.const_cast_derived() += m_scale * src;"},
{"lineNum":"  313","line":"    }"},
{"lineNum":"  314","line":"  };"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"  template<typename Dst>"},
{"lineNum":"  317","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  318","line":"  {"},
{"lineNum":"  319","line":"    internal::outer_product_selector_run(dst, lhs, rhs, set(), is_row_major<Dst>());"},
{"lineNum":"  320","line":"  }"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"  template<typename Dst>"},
{"lineNum":"  323","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  324","line":"  {"},
{"lineNum":"  325","line":"    internal::outer_product_selector_run(dst, lhs, rhs, add(), is_row_major<Dst>());"},
{"lineNum":"  326","line":"  }"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"  template<typename Dst>"},
{"lineNum":"  329","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  330","line":"  {"},
{"lineNum":"  331","line":"    internal::outer_product_selector_run(dst, lhs, rhs, sub(), is_row_major<Dst>());","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  332","line":"  }"},
{"lineNum":"  333","line":""},
{"lineNum":"  334","line":"  template<typename Dst>"},
{"lineNum":"  335","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"},
{"lineNum":"  336","line":"  {"},
{"lineNum":"  337","line":"    internal::outer_product_selector_run(dst, lhs, rhs, adds(alpha), is_row_major<Dst>());"},
{"lineNum":"  338","line":"  }"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"};"},
{"lineNum":"  341","line":""},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"// This base class provides default implementations for evalTo, addTo, subTo, in terms of scaleAndAddTo"},
{"lineNum":"  344","line":"template<typename Lhs, typename Rhs, typename Derived>"},
{"lineNum":"  345","line":"struct generic_product_impl_base"},
{"lineNum":"  346","line":"{"},
{"lineNum":"  347","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"  template<typename Dst>"},
{"lineNum":"  350","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  351","line":"  { dst.setZero(); scaleAndAddTo(dst, lhs, rhs, Scalar(1)); }","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"  template<typename Dst>"},
{"lineNum":"  354","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  355","line":"  { scaleAndAddTo(dst,lhs, rhs, Scalar(1)); }"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"  template<typename Dst>"},
{"lineNum":"  358","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  359","line":"  { scaleAndAddTo(dst, lhs, rhs, Scalar(-1)); }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  360","line":""},
{"lineNum":"  361","line":"  template<typename Dst>"},
{"lineNum":"  362","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void scaleAndAddTo(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"},
{"lineNum":"  363","line":"  { Derived::scaleAndAddTo(dst,lhs,rhs,alpha); }"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"};"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"  368","line":"struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemvProduct>"},
{"lineNum":"  369","line":"  : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,GemvProduct> >"},
{"lineNum":"  370","line":"{"},
{"lineNum":"  371","line":"  typedef typename nested_eval<Lhs,1>::type LhsNested;"},
{"lineNum":"  372","line":"  typedef typename nested_eval<Rhs,1>::type RhsNested;"},
{"lineNum":"  373","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  374","line":"  enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };"},
{"lineNum":"  375","line":"  typedef typename internal::remove_all<typename internal::conditional<int(Side)==OnTheRight,LhsNested,RhsNested>::type>::type MatrixType;"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"  template<typename Dest>"},
{"lineNum":"  378","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"},
{"lineNum":"  379","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  380","line":"    // Fallback to inner product if both the lhs and rhs is a runtime vector."},
{"lineNum":"  381","line":"    if (lhs.rows() == 1 && rhs.cols() == 1) {","class":"lineNoCov","hits":"0","possible_hits":"30",},
{"lineNum":"  382","line":"      dst.coeffRef(0,0) += alpha * lhs.row(0).conjugate().dot(rhs.col(0));","class":"lineNoCov","hits":"0","possible_hits":"42",},
{"lineNum":"  383","line":"      return;"},
{"lineNum":"  384","line":"    }"},
{"lineNum":"  385","line":"    LhsNested actual_lhs(lhs);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  386","line":"    RhsNested actual_rhs(rhs);","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  387","line":"    internal::gemv_dense_selector<Side,","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  388","line":"                            (int(MatrixType::Flags)&RowMajorBit) ? RowMajor : ColMajor,"},
{"lineNum":"  389","line":"                            bool(internal::blas_traits<MatrixType>::HasUsableDirectAccess)"},
{"lineNum":"  390","line":"                           >::run(actual_lhs, actual_rhs, dst, alpha);"},
{"lineNum":"  391","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  392","line":"};"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"  395","line":"struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode>"},
{"lineNum":"  396","line":"{"},
{"lineNum":"  397","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"  template<typename Dst>"},
{"lineNum":"  400","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  401","line":"  {"},
{"lineNum":"  402","line":"    // Same as: dst.noalias() = lhs.lazyProduct(rhs);"},
{"lineNum":"  403","line":"    // but easier on the compiler side"},
{"lineNum":"  404","line":"    call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::assign_op<typename Dst::Scalar,Scalar>());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  405","line":"  }"},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"  template<typename Dst>"},
{"lineNum":"  408","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void addTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  409","line":"  {"},
{"lineNum":"  410","line":"    // dst.noalias() += lhs.lazyProduct(rhs);"},
{"lineNum":"  411","line":"    call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::add_assign_op<typename Dst::Scalar,Scalar>());"},
{"lineNum":"  412","line":"  }"},
{"lineNum":"  413","line":""},
{"lineNum":"  414","line":"  template<typename Dst>"},
{"lineNum":"  415","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void subTo(Dst& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":"  416","line":"  {"},
{"lineNum":"  417","line":"    // dst.noalias() -= lhs.lazyProduct(rhs);"},
{"lineNum":"  418","line":"    call_assignment_no_alias(dst, lhs.lazyProduct(rhs), internal::sub_assign_op<typename Dst::Scalar,Scalar>());"},
{"lineNum":"  419","line":"  }"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"  // This is a special evaluation path called from generic_product_impl<...,GemmProduct> in file GeneralMatrixMatrix.h"},
{"lineNum":"  422","line":"  // This variant tries to extract scalar multiples from both the LHS and RHS and factor them out. For instance:"},
{"lineNum":"  423","line":"  //   dst {,+,-}= (s1*A)*(B*s2)"},
{"lineNum":"  424","line":"  // will be rewritten as:"},
{"lineNum":"  425","line":"  //   dst {,+,-}= (s1*s2) * (A.lazyProduct(B))"},
{"lineNum":"  426","line":"  // There are at least four benefits of doing so:"},
{"lineNum":"  427","line":"  //  1 - huge performance gain for heap-allocated matrix types as it save costly allocations."},
{"lineNum":"  428","line":"  //  2 - it is faster than simply by-passing the heap allocation through stack allocation."},
{"lineNum":"  429","line":"  //  3 - it makes this fallback consistent with the heavy GEMM routine."},
{"lineNum":"  430","line":"  //  4 - it fully by-passes huge stack allocation attempts when multiplying huge fixed-size matrices."},
{"lineNum":"  431","line":"  //      (see https://stackoverflow.com/questions/54738495)"},
{"lineNum":"  432","line":"  // For small fixed sizes matrices, however, the gains are less obvious, it is sometimes x2 faster, but sometimes x3 slower,"},
{"lineNum":"  433","line":"  // and the behavior depends also a lot on the compiler... This is why this re-writing strategy is currently"},
{"lineNum":"  434","line":"  // enabled only when falling back from the main GEMM."},
{"lineNum":"  435","line":"  template<typename Dst, typename Func>"},
{"lineNum":"  436","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  437","line":"  void eval_dynamic(Dst& dst, const Lhs& lhs, const Rhs& rhs, const Func &func)"},
{"lineNum":"  438","line":"  {"},
{"lineNum":"  439","line":"    enum {"},
{"lineNum":"  440","line":"      HasScalarFactor = blas_traits<Lhs>::HasScalarFactor || blas_traits<Rhs>::HasScalarFactor,"},
{"lineNum":"  441","line":"      ConjLhs = blas_traits<Lhs>::NeedToConjugate,"},
{"lineNum":"  442","line":"      ConjRhs = blas_traits<Rhs>::NeedToConjugate"},
{"lineNum":"  443","line":"    };"},
{"lineNum":"  444","line":"    // FIXME: in c++11 this should be auto, and extractScalarFactor should also return auto"},
{"lineNum":"  445","line":"    //        this is important for real*complex_mat"},
{"lineNum":"  446","line":"    Scalar actualAlpha = combine_scalar_factors<Scalar>(lhs, rhs);"},
{"lineNum":"  447","line":""},
{"lineNum":"  448","line":"    eval_dynamic_impl(dst,"},
{"lineNum":"  449","line":"                      blas_traits<Lhs>::extract(lhs).template conjugateIf<ConjLhs>(),"},
{"lineNum":"  450","line":"                      blas_traits<Rhs>::extract(rhs).template conjugateIf<ConjRhs>(),"},
{"lineNum":"  451","line":"                      func,"},
{"lineNum":"  452","line":"                      actualAlpha,"},
{"lineNum":"  453","line":"                      typename conditional<HasScalarFactor,true_type,false_type>::type());"},
{"lineNum":"  454","line":"  }"},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"protected:"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"  template<typename Dst, typename LhsT, typename RhsT, typename Func, typename Scalar>"},
{"lineNum":"  459","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  460","line":"  void eval_dynamic_impl(Dst& dst, const LhsT& lhs, const RhsT& rhs, const Func &func, const Scalar&  s /* == 1 */, false_type)"},
{"lineNum":"  461","line":"  {"},
{"lineNum":"  462","line":"    EIGEN_UNUSED_VARIABLE(s);"},
{"lineNum":"  463","line":"    eigen_internal_assert(s==Scalar(1));"},
{"lineNum":"  464","line":"    call_restricted_packet_assignment_no_alias(dst, lhs.lazyProduct(rhs), func);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  465","line":"  }"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"  template<typename Dst, typename LhsT, typename RhsT, typename Func, typename Scalar>"},
{"lineNum":"  468","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  469","line":"  void eval_dynamic_impl(Dst& dst, const LhsT& lhs, const RhsT& rhs, const Func &func, const Scalar& s, true_type)"},
{"lineNum":"  470","line":"  {"},
{"lineNum":"  471","line":"    call_restricted_packet_assignment_no_alias(dst, s * lhs.lazyProduct(rhs), func);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  472","line":"  }"},
{"lineNum":"  473","line":"};"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"// This specialization enforces the use of a coefficient-based evaluation strategy"},
{"lineNum":"  476","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"  477","line":"struct generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,LazyCoeffBasedProductMode>"},
{"lineNum":"  478","line":"  : generic_product_impl<Lhs,Rhs,DenseShape,DenseShape,CoeffBasedProductMode> {};"},
{"lineNum":"  479","line":""},
{"lineNum":"  480","line":"// Case 2: Evaluate coeff by coeff"},
{"lineNum":"  481","line":"//"},
{"lineNum":"  482","line":"// This is mostly taken from CoeffBasedProduct.h"},
{"lineNum":"  483","line":"// The main difference is that we add an extra argument to the etor_product_*_impl::run() function"},
{"lineNum":"  484","line":"// for the inner dimension of the product, because evaluator object do not know their size."},
{"lineNum":"  485","line":""},
{"lineNum":"  486","line":"template<int Traversal, int UnrollingIndex, typename Lhs, typename Rhs, typename RetScalar>"},
{"lineNum":"  487","line":"struct etor_product_coeff_impl;"},
{"lineNum":"  488","line":""},
{"lineNum":"  489","line":"template<int StorageOrder, int UnrollingIndex, typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  490","line":"struct etor_product_packet_impl;"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"template<typename Lhs, typename Rhs, int ProductTag>"},
{"lineNum":"  493","line":"struct product_evaluator<Product<Lhs, Rhs, LazyProduct>, ProductTag, DenseShape, DenseShape>"},
{"lineNum":"  494","line":"    : evaluator_base<Product<Lhs, Rhs, LazyProduct> >"},
{"lineNum":"  495","line":"{"},
{"lineNum":"  496","line":"  typedef Product<Lhs, Rhs, LazyProduct> XprType;"},
{"lineNum":"  497","line":"  typedef typename XprType::Scalar Scalar;"},
{"lineNum":"  498","line":"  typedef typename XprType::CoeffReturnType CoeffReturnType;"},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  501","line":"  explicit product_evaluator(const XprType& xpr)"},
{"lineNum":"  502","line":"    : m_lhs(xpr.lhs()),","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  503","line":"      m_rhs(xpr.rhs()),","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  504","line":"      m_lhsImpl(m_lhs),     // FIXME the creation of the evaluator objects should result in a no-op, but check that!","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  505","line":"      m_rhsImpl(m_rhs),     //       Moreover, they are only useful for the packet path, so we could completely disable them when not needed,"},
{"lineNum":"  506","line":"                            //       or perhaps declare them on the fly on the packet method... We have experiment to check what\'s best."},
{"lineNum":"  507","line":"      m_innerDim(xpr.lhs().cols())","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  508","line":"  {"},
{"lineNum":"  509","line":"    EIGEN_INTERNAL_CHECK_COST_VALUE(NumTraits<Scalar>::MulCost);"},
{"lineNum":"  510","line":"    EIGEN_INTERNAL_CHECK_COST_VALUE(NumTraits<Scalar>::AddCost);"},
{"lineNum":"  511","line":"    EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);"},
{"lineNum":"  512","line":"#if 0"},
{"lineNum":"  513","line":"    std::cerr << \"LhsOuterStrideBytes=  \" << LhsOuterStrideBytes << \"\\n\";"},
{"lineNum":"  514","line":"    std::cerr << \"RhsOuterStrideBytes=  \" << RhsOuterStrideBytes << \"\\n\";"},
{"lineNum":"  515","line":"    std::cerr << \"LhsAlignment=         \" << LhsAlignment << \"\\n\";"},
{"lineNum":"  516","line":"    std::cerr << \"RhsAlignment=         \" << RhsAlignment << \"\\n\";"},
{"lineNum":"  517","line":"    std::cerr << \"CanVectorizeLhs=      \" << CanVectorizeLhs << \"\\n\";"},
{"lineNum":"  518","line":"    std::cerr << \"CanVectorizeRhs=      \" << CanVectorizeRhs << \"\\n\";"},
{"lineNum":"  519","line":"    std::cerr << \"CanVectorizeInner=    \" << CanVectorizeInner << \"\\n\";"},
{"lineNum":"  520","line":"    std::cerr << \"EvalToRowMajor=       \" << EvalToRowMajor << \"\\n\";"},
{"lineNum":"  521","line":"    std::cerr << \"Alignment=            \" << Alignment << \"\\n\";"},
{"lineNum":"  522","line":"    std::cerr << \"Flags=                \" << Flags << \"\\n\";"},
{"lineNum":"  523","line":"#endif"},
{"lineNum":"  524","line":"  }"},
{"lineNum":"  525","line":""},
{"lineNum":"  526","line":"  // Everything below here is taken from CoeffBasedProduct.h"},
{"lineNum":"  527","line":""},
{"lineNum":"  528","line":"  typedef typename internal::nested_eval<Lhs,Rhs::ColsAtCompileTime>::type LhsNested;"},
{"lineNum":"  529","line":"  typedef typename internal::nested_eval<Rhs,Lhs::RowsAtCompileTime>::type RhsNested;"},
{"lineNum":"  530","line":""},
{"lineNum":"  531","line":"  typedef typename internal::remove_all<LhsNested>::type LhsNestedCleaned;"},
{"lineNum":"  532","line":"  typedef typename internal::remove_all<RhsNested>::type RhsNestedCleaned;"},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":"  typedef evaluator<LhsNestedCleaned> LhsEtorType;"},
{"lineNum":"  535","line":"  typedef evaluator<RhsNestedCleaned> RhsEtorType;"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"  enum {"},
{"lineNum":"  538","line":"    RowsAtCompileTime = LhsNestedCleaned::RowsAtCompileTime,"},
{"lineNum":"  539","line":"    ColsAtCompileTime = RhsNestedCleaned::ColsAtCompileTime,"},
{"lineNum":"  540","line":"    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(LhsNestedCleaned::ColsAtCompileTime, RhsNestedCleaned::RowsAtCompileTime),"},
{"lineNum":"  541","line":"    MaxRowsAtCompileTime = LhsNestedCleaned::MaxRowsAtCompileTime,"},
{"lineNum":"  542","line":"    MaxColsAtCompileTime = RhsNestedCleaned::MaxColsAtCompileTime"},
{"lineNum":"  543","line":"  };"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"  typedef typename find_best_packet<Scalar,RowsAtCompileTime>::type LhsVecPacketType;"},
{"lineNum":"  546","line":"  typedef typename find_best_packet<Scalar,ColsAtCompileTime>::type RhsVecPacketType;"},
{"lineNum":"  547","line":""},
{"lineNum":"  548","line":"  enum {"},
{"lineNum":"  549","line":""},
{"lineNum":"  550","line":"    LhsCoeffReadCost = LhsEtorType::CoeffReadCost,"},
{"lineNum":"  551","line":"    RhsCoeffReadCost = RhsEtorType::CoeffReadCost,"},
{"lineNum":"  552","line":"    CoeffReadCost = InnerSize==0 ? NumTraits<Scalar>::ReadCost"},
{"lineNum":"  553","line":"                  : InnerSize == Dynamic ? HugeCost"},
{"lineNum":"  554","line":"                    : InnerSize * (NumTraits<Scalar>::MulCost + int(LhsCoeffReadCost) + int(RhsCoeffReadCost))"},
{"lineNum":"  555","line":"                    + (InnerSize - 1) * NumTraits<Scalar>::AddCost,"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"    Unroll = CoeffReadCost <= EIGEN_UNROLLING_LIMIT,"},
{"lineNum":"  558","line":""},
{"lineNum":"  559","line":"    LhsFlags = LhsEtorType::Flags,"},
{"lineNum":"  560","line":"    RhsFlags = RhsEtorType::Flags,"},
{"lineNum":"  561","line":""},
{"lineNum":"  562","line":"    LhsRowMajor = LhsFlags & RowMajorBit,"},
{"lineNum":"  563","line":"    RhsRowMajor = RhsFlags & RowMajorBit,"},
{"lineNum":"  564","line":""},
{"lineNum":"  565","line":"    LhsVecPacketSize = unpacket_traits<LhsVecPacketType>::size,"},
{"lineNum":"  566","line":"    RhsVecPacketSize = unpacket_traits<RhsVecPacketType>::size,"},
{"lineNum":"  567","line":""},
{"lineNum":"  568","line":"    // Here, we don\'t care about alignment larger than the usable packet size."},
{"lineNum":"  569","line":"    LhsAlignment = EIGEN_PLAIN_ENUM_MIN(LhsEtorType::Alignment,LhsVecPacketSize*int(sizeof(typename LhsNestedCleaned::Scalar))),"},
{"lineNum":"  570","line":"    RhsAlignment = EIGEN_PLAIN_ENUM_MIN(RhsEtorType::Alignment,RhsVecPacketSize*int(sizeof(typename RhsNestedCleaned::Scalar))),"},
{"lineNum":"  571","line":""},
{"lineNum":"  572","line":"    SameType = is_same<typename LhsNestedCleaned::Scalar,typename RhsNestedCleaned::Scalar>::value,"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"    CanVectorizeRhs = bool(RhsRowMajor) && (RhsFlags & PacketAccessBit) && (ColsAtCompileTime!=1),"},
{"lineNum":"  575","line":"    CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit) && (RowsAtCompileTime!=1),"},
{"lineNum":"  576","line":""},
{"lineNum":"  577","line":"    EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1"},
{"lineNum":"  578","line":"                    : (MaxColsAtCompileTime==1&&MaxRowsAtCompileTime!=1) ? 0"},
{"lineNum":"  579","line":"                    : (bool(RhsRowMajor) && !CanVectorizeLhs),"},
{"lineNum":"  580","line":""},
{"lineNum":"  581","line":"    Flags = ((int(LhsFlags) | int(RhsFlags)) & HereditaryBits & ~RowMajorBit)"},
{"lineNum":"  582","line":"          | (EvalToRowMajor ? RowMajorBit : 0)"},
{"lineNum":"  583","line":"          // TODO enable vectorization for mixed types"},
{"lineNum":"  584","line":"          | (SameType && (CanVectorizeLhs || CanVectorizeRhs) ? PacketAccessBit : 0)"},
{"lineNum":"  585","line":"          | (XprType::IsVectorAtCompileTime ? LinearAccessBit : 0),"},
{"lineNum":"  586","line":""},
{"lineNum":"  587","line":"    LhsOuterStrideBytes = int(LhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename LhsNestedCleaned::Scalar)),"},
{"lineNum":"  588","line":"    RhsOuterStrideBytes = int(RhsNestedCleaned::OuterStrideAtCompileTime) * int(sizeof(typename RhsNestedCleaned::Scalar)),"},
{"lineNum":"  589","line":""},
{"lineNum":"  590","line":"    Alignment = bool(CanVectorizeLhs) ? (LhsOuterStrideBytes<=0 || (int(LhsOuterStrideBytes) % EIGEN_PLAIN_ENUM_MAX(1,LhsAlignment))!=0 ? 0 : LhsAlignment)"},
{"lineNum":"  591","line":"              : bool(CanVectorizeRhs) ? (RhsOuterStrideBytes<=0 || (int(RhsOuterStrideBytes) % EIGEN_PLAIN_ENUM_MAX(1,RhsAlignment))!=0 ? 0 : RhsAlignment)"},
{"lineNum":"  592","line":"              : 0,"},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"    /* CanVectorizeInner deserves special explanation. It does not affect the product flags. It is not used outside"},
{"lineNum":"  595","line":"     * of Product. If the Product itself is not a packet-access expression, there is still a chance that the inner"},
{"lineNum":"  596","line":"     * loop of the product might be vectorized. This is the meaning of CanVectorizeInner. Since it doesn\'t affect"},
{"lineNum":"  597","line":"     * the Flags, it is safe to make this value depend on ActualPacketAccessBit, that doesn\'t affect the ABI."},
{"lineNum":"  598","line":"     */"},
{"lineNum":"  599","line":"    CanVectorizeInner =    SameType"},
{"lineNum":"  600","line":"                        && LhsRowMajor"},
{"lineNum":"  601","line":"                        && (!RhsRowMajor)"},
{"lineNum":"  602","line":"                        && (int(LhsFlags) & int(RhsFlags) & ActualPacketAccessBit)"},
{"lineNum":"  603","line":"                        && (int(InnerSize) % packet_traits<Scalar>::size == 0)"},
{"lineNum":"  604","line":"  };"},
{"lineNum":"  605","line":""},
{"lineNum":"  606","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index row, Index col) const"},
{"lineNum":"  607","line":"  {"},
{"lineNum":"  608","line":"    return (m_lhs.row(row).transpose().cwiseProduct( m_rhs.col(col) )).sum();"},
{"lineNum":"  609","line":"  }"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"  /* Allow index-based non-packet access. It is impossible though to allow index-based packed access,"},
{"lineNum":"  612","line":"   * which is why we don\'t set the LinearAccessBit."},
{"lineNum":"  613","line":"   * TODO: this seems possible when the result is a vector"},
{"lineNum":"  614","line":"   */"},
{"lineNum":"  615","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  616","line":"  const CoeffReturnType coeff(Index index) const"},
{"lineNum":"  617","line":"  {"},
{"lineNum":"  618","line":"    const Index row = (RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1) ? 0 : index;"},
{"lineNum":"  619","line":"    const Index col = (RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1) ? index : 0;"},
{"lineNum":"  620","line":"    return (m_lhs.row(row).transpose().cwiseProduct( m_rhs.col(col) )).sum();"},
{"lineNum":"  621","line":"  }"},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"  template<int LoadMode, typename PacketType>"},
{"lineNum":"  624","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  625","line":"  const PacketType packet(Index row, Index col) const"},
{"lineNum":"  626","line":"  {"},
{"lineNum":"  627","line":"    PacketType res;"},
{"lineNum":"  628","line":"    typedef etor_product_packet_impl<bool(int(Flags)&RowMajorBit) ? RowMajor : ColMajor,"},
{"lineNum":"  629","line":"                                     Unroll ? int(InnerSize) : Dynamic,"},
{"lineNum":"  630","line":"                                     LhsEtorType, RhsEtorType, PacketType, LoadMode> PacketImpl;"},
{"lineNum":"  631","line":"    PacketImpl::run(row, col, m_lhsImpl, m_rhsImpl, m_innerDim, res);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  632","line":"    return res;"},
{"lineNum":"  633","line":"  }"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"  template<int LoadMode, typename PacketType>"},
{"lineNum":"  636","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  637","line":"  const PacketType packet(Index index) const"},
{"lineNum":"  638","line":"  {"},
{"lineNum":"  639","line":"    const Index row = (RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1) ? 0 : index;"},
{"lineNum":"  640","line":"    const Index col = (RowsAtCompileTime == 1 || MaxRowsAtCompileTime==1) ? index : 0;"},
{"lineNum":"  641","line":"    return packet<LoadMode,PacketType>(row,col);"},
{"lineNum":"  642","line":"  }"},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":"protected:"},
{"lineNum":"  645","line":"  typename internal::add_const_on_value_type<LhsNested>::type m_lhs;"},
{"lineNum":"  646","line":"  typename internal::add_const_on_value_type<RhsNested>::type m_rhs;"},
{"lineNum":"  647","line":""},
{"lineNum":"  648","line":"  LhsEtorType m_lhsImpl;"},
{"lineNum":"  649","line":"  RhsEtorType m_rhsImpl;"},
{"lineNum":"  650","line":""},
{"lineNum":"  651","line":"  // TODO: Get rid of m_innerDim if known at compile time"},
{"lineNum":"  652","line":"  Index m_innerDim;"},
{"lineNum":"  653","line":"};"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"template<typename Lhs, typename Rhs>"},
{"lineNum":"  656","line":"struct product_evaluator<Product<Lhs, Rhs, DefaultProduct>, LazyCoeffBasedProductMode, DenseShape, DenseShape>"},
{"lineNum":"  657","line":"  : product_evaluator<Product<Lhs, Rhs, LazyProduct>, CoeffBasedProductMode, DenseShape, DenseShape>"},
{"lineNum":"  658","line":"{"},
{"lineNum":"  659","line":"  typedef Product<Lhs, Rhs, DefaultProduct> XprType;"},
{"lineNum":"  660","line":"  typedef Product<Lhs, Rhs, LazyProduct> BaseProduct;"},
{"lineNum":"  661","line":"  typedef product_evaluator<BaseProduct, CoeffBasedProductMode, DenseShape, DenseShape> Base;"},
{"lineNum":"  662","line":"  enum {"},
{"lineNum":"  663","line":"    Flags = Base::Flags | EvalBeforeNestingBit"},
{"lineNum":"  664","line":"  };"},
{"lineNum":"  665","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE"},
{"lineNum":"  666","line":"  explicit product_evaluator(const XprType& xpr)"},
{"lineNum":"  667","line":"    : Base(BaseProduct(xpr.lhs(),xpr.rhs()))"},
{"lineNum":"  668","line":"  {}"},
{"lineNum":"  669","line":"};"},
{"lineNum":"  670","line":""},
{"lineNum":"  671","line":"/****************************************"},
{"lineNum":"  672","line":"*** Coeff based product, Packet path  ***"},
{"lineNum":"  673","line":"****************************************/"},
{"lineNum":"  674","line":""},
{"lineNum":"  675","line":"template<int UnrollingIndex, typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  676","line":"struct etor_product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>"},
{"lineNum":"  677","line":"{"},
{"lineNum":"  678","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)"},
{"lineNum":"  679","line":"  {"},
{"lineNum":"  680","line":"    etor_product_packet_impl<RowMajor, UnrollingIndex-1, Lhs, Rhs, Packet, LoadMode>::run(row, col, lhs, rhs, innerDim, res);"},
{"lineNum":"  681","line":"    res =  pmadd(pset1<Packet>(lhs.coeff(row, Index(UnrollingIndex-1))), rhs.template packet<LoadMode,Packet>(Index(UnrollingIndex-1), col), res);"},
{"lineNum":"  682","line":"  }"},
{"lineNum":"  683","line":"};"},
{"lineNum":"  684","line":""},
{"lineNum":"  685","line":"template<int UnrollingIndex, typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  686","line":"struct etor_product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>"},
{"lineNum":"  687","line":"{"},
{"lineNum":"  688","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet &res)"},
{"lineNum":"  689","line":"  {"},
{"lineNum":"  690","line":"    etor_product_packet_impl<ColMajor, UnrollingIndex-1, Lhs, Rhs, Packet, LoadMode>::run(row, col, lhs, rhs, innerDim, res);"},
{"lineNum":"  691","line":"    res =  pmadd(lhs.template packet<LoadMode,Packet>(row, Index(UnrollingIndex-1)), pset1<Packet>(rhs.coeff(Index(UnrollingIndex-1), col)), res);"},
{"lineNum":"  692","line":"  }"},
{"lineNum":"  693","line":"};"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"template<typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  696","line":"struct etor_product_packet_impl<RowMajor, 1, Lhs, Rhs, Packet, LoadMode>"},
{"lineNum":"  697","line":"{"},
{"lineNum":"  698","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index /*innerDim*/, Packet &res)"},
{"lineNum":"  699","line":"  {"},
{"lineNum":"  700","line":"    res = pmul(pset1<Packet>(lhs.coeff(row, Index(0))),rhs.template packet<LoadMode,Packet>(Index(0), col));"},
{"lineNum":"  701","line":"  }"},
{"lineNum":"  702","line":"};"},
{"lineNum":"  703","line":""},
{"lineNum":"  704","line":"template<typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  705","line":"struct etor_product_packet_impl<ColMajor, 1, Lhs, Rhs, Packet, LoadMode>"},
{"lineNum":"  706","line":"{"},
{"lineNum":"  707","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index /*innerDim*/, Packet &res)"},
{"lineNum":"  708","line":"  {"},
{"lineNum":"  709","line":"    res = pmul(lhs.template packet<LoadMode,Packet>(row, Index(0)), pset1<Packet>(rhs.coeff(Index(0), col)));"},
{"lineNum":"  710","line":"  }"},
{"lineNum":"  711","line":"};"},
{"lineNum":"  712","line":""},
{"lineNum":"  713","line":"template<typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  714","line":"struct etor_product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>"},
{"lineNum":"  715","line":"{"},
{"lineNum":"  716","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index /*row*/, Index /*col*/, const Lhs& /*lhs*/, const Rhs& /*rhs*/, Index /*innerDim*/, Packet &res)"},
{"lineNum":"  717","line":"  {"},
{"lineNum":"  718","line":"    res = pset1<Packet>(typename unpacket_traits<Packet>::type(0));"},
{"lineNum":"  719","line":"  }"},
{"lineNum":"  720","line":"};"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"template<typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  723","line":"struct etor_product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>"},
{"lineNum":"  724","line":"{"},
{"lineNum":"  725","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index /*row*/, Index /*col*/, const Lhs& /*lhs*/, const Rhs& /*rhs*/, Index /*innerDim*/, Packet &res)"},
{"lineNum":"  726","line":"  {"},
{"lineNum":"  727","line":"    res = pset1<Packet>(typename unpacket_traits<Packet>::type(0));"},
{"lineNum":"  728","line":"  }"},
{"lineNum":"  729","line":"};"},
{"lineNum":"  730","line":""},
{"lineNum":"  731","line":"template<typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  732","line":"struct etor_product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>"},
{"lineNum":"  733","line":"{"},
{"lineNum":"  734","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)"},
{"lineNum":"  735","line":"  {"},
{"lineNum":"  736","line":"    res = pset1<Packet>(typename unpacket_traits<Packet>::type(0));"},
{"lineNum":"  737","line":"    for(Index i = 0; i < innerDim; ++i)","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  738","line":"      res =  pmadd(pset1<Packet>(lhs.coeff(row, i)), rhs.template packet<LoadMode,Packet>(i, col), res);"},
{"lineNum":"  739","line":"  }"},
{"lineNum":"  740","line":"};"},
{"lineNum":"  741","line":""},
{"lineNum":"  742","line":"template<typename Lhs, typename Rhs, typename Packet, int LoadMode>"},
{"lineNum":"  743","line":"struct etor_product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>"},
{"lineNum":"  744","line":"{"},
{"lineNum":"  745","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Index innerDim, Packet& res)"},
{"lineNum":"  746","line":"  {"},
{"lineNum":"  747","line":"    res = pset1<Packet>(typename unpacket_traits<Packet>::type(0));"},
{"lineNum":"  748","line":"    for(Index i = 0; i < innerDim; ++i)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  749","line":"      res =  pmadd(lhs.template packet<LoadMode,Packet>(row, i), pset1<Packet>(rhs.coeff(i, col)), res);"},
{"lineNum":"  750","line":"  }"},
{"lineNum":"  751","line":"};"},
{"lineNum":"  752","line":""},
{"lineNum":"  753","line":""},
{"lineNum":"  754","line":"/***************************************************************************"},
{"lineNum":"  755","line":"* Triangular products"},
{"lineNum":"  756","line":"***************************************************************************/"},
{"lineNum":"  757","line":"template<int Mode, bool LhsIsTriangular,"},
{"lineNum":"  758","line":"         typename Lhs, bool LhsIsVector,"},
{"lineNum":"  759","line":"         typename Rhs, bool RhsIsVector>"},
{"lineNum":"  760","line":"struct triangular_product_impl;"},
{"lineNum":"  761","line":""},
{"lineNum":"  762","line":"template<typename Lhs, typename Rhs, int ProductTag>"},
{"lineNum":"  763","line":"struct generic_product_impl<Lhs,Rhs,TriangularShape,DenseShape,ProductTag>"},
{"lineNum":"  764","line":"  : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,TriangularShape,DenseShape,ProductTag> >"},
{"lineNum":"  765","line":"{"},
{"lineNum":"  766","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  767","line":""},
{"lineNum":"  768","line":"  template<typename Dest>"},
{"lineNum":"  769","line":"  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"},
{"lineNum":"  770","line":"  {"},
{"lineNum":"  771","line":"    triangular_product_impl<Lhs::Mode,true,typename Lhs::MatrixType,false,Rhs, Rhs::ColsAtCompileTime==1>","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  772","line":"        ::run(dst, lhs.nestedExpression(), rhs, alpha);"},
{"lineNum":"  773","line":"  }"},
{"lineNum":"  774","line":"};"},
{"lineNum":"  775","line":""},
{"lineNum":"  776","line":"template<typename Lhs, typename Rhs, int ProductTag>"},
{"lineNum":"  777","line":"struct generic_product_impl<Lhs,Rhs,DenseShape,TriangularShape,ProductTag>"},
{"lineNum":"  778","line":": generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,DenseShape,TriangularShape,ProductTag> >"},
{"lineNum":"  779","line":"{"},
{"lineNum":"  780","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  781","line":""},
{"lineNum":"  782","line":"  template<typename Dest>"},
{"lineNum":"  783","line":"  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"},
{"lineNum":"  784","line":"  {"},
{"lineNum":"  785","line":"    triangular_product_impl<Rhs::Mode,false,Lhs,Lhs::RowsAtCompileTime==1, typename Rhs::MatrixType, false>::run(dst, lhs, rhs.nestedExpression(), alpha);"},
{"lineNum":"  786","line":"  }"},
{"lineNum":"  787","line":"};"},
{"lineNum":"  788","line":""},
{"lineNum":"  789","line":""},
{"lineNum":"  790","line":"/***************************************************************************"},
{"lineNum":"  791","line":"* SelfAdjoint products"},
{"lineNum":"  792","line":"***************************************************************************/"},
{"lineNum":"  793","line":"template <typename Lhs, int LhsMode, bool LhsIsVector,"},
{"lineNum":"  794","line":"          typename Rhs, int RhsMode, bool RhsIsVector>"},
{"lineNum":"  795","line":"struct selfadjoint_product_impl;"},
{"lineNum":"  796","line":""},
{"lineNum":"  797","line":"template<typename Lhs, typename Rhs, int ProductTag>"},
{"lineNum":"  798","line":"struct generic_product_impl<Lhs,Rhs,SelfAdjointShape,DenseShape,ProductTag>"},
{"lineNum":"  799","line":"  : generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,SelfAdjointShape,DenseShape,ProductTag> >"},
{"lineNum":"  800","line":"{"},
{"lineNum":"  801","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  802","line":""},
{"lineNum":"  803","line":"  template<typename Dest>"},
{"lineNum":"  804","line":"  static EIGEN_DEVICE_FUNC"},
{"lineNum":"  805","line":"  void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"},
{"lineNum":"  806","line":"  {"},
{"lineNum":"  807","line":"    selfadjoint_product_impl<typename Lhs::MatrixType,Lhs::Mode,false,Rhs,0,Rhs::IsVectorAtCompileTime>::run(dst, lhs.nestedExpression(), rhs, alpha);"},
{"lineNum":"  808","line":"  }"},
{"lineNum":"  809","line":"};"},
{"lineNum":"  810","line":""},
{"lineNum":"  811","line":"template<typename Lhs, typename Rhs, int ProductTag>"},
{"lineNum":"  812","line":"struct generic_product_impl<Lhs,Rhs,DenseShape,SelfAdjointShape,ProductTag>"},
{"lineNum":"  813","line":": generic_product_impl_base<Lhs,Rhs,generic_product_impl<Lhs,Rhs,DenseShape,SelfAdjointShape,ProductTag> >"},
{"lineNum":"  814","line":"{"},
{"lineNum":"  815","line":"  typedef typename Product<Lhs,Rhs>::Scalar Scalar;"},
{"lineNum":"  816","line":""},
{"lineNum":"  817","line":"  template<typename Dest>"},
{"lineNum":"  818","line":"  static void scaleAndAddTo(Dest& dst, const Lhs& lhs, const Rhs& rhs, const Scalar& alpha)"},
{"lineNum":"  819","line":"  {"},
{"lineNum":"  820","line":"    selfadjoint_product_impl<Lhs,0,Lhs::IsVectorAtCompileTime,typename Rhs::MatrixType,Rhs::Mode,false>::run(dst, lhs, rhs.nestedExpression(), alpha);"},
{"lineNum":"  821","line":"  }"},
{"lineNum":"  822","line":"};"},
{"lineNum":"  823","line":""},
{"lineNum":"  824","line":""},
{"lineNum":"  825","line":"/***************************************************************************"},
{"lineNum":"  826","line":"* Diagonal products"},
{"lineNum":"  827","line":"***************************************************************************/"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"template<typename MatrixType, typename DiagonalType, typename Derived, int ProductOrder>"},
{"lineNum":"  830","line":"struct diagonal_product_evaluator_base"},
{"lineNum":"  831","line":"  : evaluator_base<Derived>"},
{"lineNum":"  832","line":"{"},
{"lineNum":"  833","line":"   typedef typename ScalarBinaryOpTraits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;"},
{"lineNum":"  834","line":"public:"},
{"lineNum":"  835","line":"  enum {"},
{"lineNum":"  836","line":"    CoeffReadCost = int(NumTraits<Scalar>::MulCost) + int(evaluator<MatrixType>::CoeffReadCost) + int(evaluator<DiagonalType>::CoeffReadCost),"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"    MatrixFlags = evaluator<MatrixType>::Flags,"},
{"lineNum":"  839","line":"    DiagFlags = evaluator<DiagonalType>::Flags,"},
{"lineNum":"  840","line":""},
{"lineNum":"  841","line":"    StorageOrder_ = (Derived::MaxRowsAtCompileTime==1 && Derived::MaxColsAtCompileTime!=1) ? RowMajor"},
{"lineNum":"  842","line":"                  : (Derived::MaxColsAtCompileTime==1 && Derived::MaxRowsAtCompileTime!=1) ? ColMajor"},
{"lineNum":"  843","line":"                  : MatrixFlags & RowMajorBit ? RowMajor : ColMajor,"},
{"lineNum":"  844","line":"    _SameStorageOrder = StorageOrder_ == (MatrixFlags & RowMajorBit ? RowMajor : ColMajor),"},
{"lineNum":"  845","line":""},
{"lineNum":"  846","line":"    _ScalarAccessOnDiag =  !((int(StorageOrder_) == ColMajor && int(ProductOrder) == OnTheLeft)"},
{"lineNum":"  847","line":"                           ||(int(StorageOrder_) == RowMajor && int(ProductOrder) == OnTheRight)),"},
{"lineNum":"  848","line":"    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,"},
{"lineNum":"  849","line":"    // FIXME currently we need same types, but in the future the next rule should be the one"},
{"lineNum":"  850","line":"    //_Vectorizable = bool(int(MatrixFlags)&PacketAccessBit) && ((!_PacketOnDiag) || (_SameTypes && bool(int(DiagFlags)&PacketAccessBit))),"},
{"lineNum":"  851","line":"    _Vectorizable =   bool(int(MatrixFlags)&PacketAccessBit)"},
{"lineNum":"  852","line":"                  &&  _SameTypes"},
{"lineNum":"  853","line":"                  && (_SameStorageOrder || (MatrixFlags&LinearAccessBit)==LinearAccessBit)"},
{"lineNum":"  854","line":"                  && (_ScalarAccessOnDiag || (bool(int(DiagFlags)&PacketAccessBit))),"},
{"lineNum":"  855","line":"    _LinearAccessMask = (MatrixType::RowsAtCompileTime==1 || MatrixType::ColsAtCompileTime==1) ? LinearAccessBit : 0,"},
{"lineNum":"  856","line":"    Flags = ((HereditaryBits|_LinearAccessMask) & (unsigned int)(MatrixFlags)) | (_Vectorizable ? PacketAccessBit : 0),"},
{"lineNum":"  857","line":"    Alignment = evaluator<MatrixType>::Alignment,"},
{"lineNum":"  858","line":""},
{"lineNum":"  859","line":"    AsScalarProduct =     (DiagonalType::SizeAtCompileTime==1)"},
{"lineNum":"  860","line":"                      ||  (DiagonalType::SizeAtCompileTime==Dynamic && MatrixType::RowsAtCompileTime==1 && ProductOrder==OnTheLeft)"},
{"lineNum":"  861","line":"                      ||  (DiagonalType::SizeAtCompileTime==Dynamic && MatrixType::ColsAtCompileTime==1 && ProductOrder==OnTheRight)"},
{"lineNum":"  862","line":"  };"},
{"lineNum":"  863","line":""},
{"lineNum":"  864","line":"  EIGEN_DEVICE_FUNC diagonal_product_evaluator_base(const MatrixType &mat, const DiagonalType &diag)"},
{"lineNum":"  865","line":"    : m_diagImpl(diag), m_matImpl(mat)"},
{"lineNum":"  866","line":"  {"},
{"lineNum":"  867","line":"    EIGEN_INTERNAL_CHECK_COST_VALUE(NumTraits<Scalar>::MulCost);"},
{"lineNum":"  868","line":"    EIGEN_INTERNAL_CHECK_COST_VALUE(CoeffReadCost);"},
{"lineNum":"  869","line":"  }"},
{"lineNum":"  870","line":""},
{"lineNum":"  871","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index idx) const"},
{"lineNum":"  872","line":"  {"},
{"lineNum":"  873","line":"    if(AsScalarProduct)"},
{"lineNum":"  874","line":"      return m_diagImpl.coeff(0) * m_matImpl.coeff(idx);"},
{"lineNum":"  875","line":"    else"},
{"lineNum":"  876","line":"      return m_diagImpl.coeff(idx) * m_matImpl.coeff(idx);"},
{"lineNum":"  877","line":"  }"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"protected:"},
{"lineNum":"  880","line":"  template<int LoadMode,typename PacketType>"},
{"lineNum":"  881","line":"  EIGEN_STRONG_INLINE PacketType packet_impl(Index row, Index col, Index id, internal::true_type) const"},
{"lineNum":"  882","line":"  {"},
{"lineNum":"  883","line":"    return internal::pmul(m_matImpl.template packet<LoadMode,PacketType>(row, col),"},
{"lineNum":"  884","line":"                          internal::pset1<PacketType>(m_diagImpl.coeff(id)));"},
{"lineNum":"  885","line":"  }"},
{"lineNum":"  886","line":""},
{"lineNum":"  887","line":"  template<int LoadMode,typename PacketType>"},
{"lineNum":"  888","line":"  EIGEN_STRONG_INLINE PacketType packet_impl(Index row, Index col, Index id, internal::false_type) const"},
{"lineNum":"  889","line":"  {"},
{"lineNum":"  890","line":"    enum {"},
{"lineNum":"  891","line":"      InnerSize = (MatrixType::Flags & RowMajorBit) ? MatrixType::ColsAtCompileTime : MatrixType::RowsAtCompileTime,"},
{"lineNum":"  892","line":"      DiagonalPacketLoadMode = EIGEN_PLAIN_ENUM_MIN(LoadMode,((InnerSize%16) == 0) ? int(Aligned16) : int(evaluator<DiagonalType>::Alignment)) // FIXME hardcoded 16!!"},
{"lineNum":"  893","line":"    };"},
{"lineNum":"  894","line":"    return internal::pmul(m_matImpl.template packet<LoadMode,PacketType>(row, col),"},
{"lineNum":"  895","line":"                          m_diagImpl.template packet<DiagonalPacketLoadMode,PacketType>(id));"},
{"lineNum":"  896","line":"  }"},
{"lineNum":"  897","line":""},
{"lineNum":"  898","line":"  evaluator<DiagonalType> m_diagImpl;"},
{"lineNum":"  899","line":"  evaluator<MatrixType>   m_matImpl;"},
{"lineNum":"  900","line":"};"},
{"lineNum":"  901","line":""},
{"lineNum":"  902","line":"// diagonal * dense"},
{"lineNum":"  903","line":"template<typename Lhs, typename Rhs, int ProductKind, int ProductTag>"},
{"lineNum":"  904","line":"struct product_evaluator<Product<Lhs, Rhs, ProductKind>, ProductTag, DiagonalShape, DenseShape>"},
{"lineNum":"  905","line":"  : diagonal_product_evaluator_base<Rhs, typename Lhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheLeft>"},
{"lineNum":"  906","line":"{"},
{"lineNum":"  907","line":"  typedef diagonal_product_evaluator_base<Rhs, typename Lhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheLeft> Base;"},
{"lineNum":"  908","line":"  using Base::m_diagImpl;"},
{"lineNum":"  909","line":"  using Base::m_matImpl;"},
{"lineNum":"  910","line":"  using Base::coeff;"},
{"lineNum":"  911","line":"  typedef typename Base::Scalar Scalar;"},
{"lineNum":"  912","line":""},
{"lineNum":"  913","line":"  typedef Product<Lhs, Rhs, ProductKind> XprType;"},
{"lineNum":"  914","line":"  typedef typename XprType::PlainObject PlainObject;"},
{"lineNum":"  915","line":"  typedef typename Lhs::DiagonalVectorType DiagonalType;"},
{"lineNum":"  916","line":""},
{"lineNum":"  917","line":""},
{"lineNum":"  918","line":"  enum { StorageOrder = Base::StorageOrder_ };"},
{"lineNum":"  919","line":""},
{"lineNum":"  920","line":"  EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)"},
{"lineNum":"  921","line":"    : Base(xpr.rhs(), xpr.lhs().diagonal())"},
{"lineNum":"  922","line":"  {"},
{"lineNum":"  923","line":"  }"},
{"lineNum":"  924","line":""},
{"lineNum":"  925","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const"},
{"lineNum":"  926","line":"  {"},
{"lineNum":"  927","line":"    return m_diagImpl.coeff(row) * m_matImpl.coeff(row, col);"},
{"lineNum":"  928","line":"  }"},
{"lineNum":"  929","line":""},
{"lineNum":"  930","line":"#ifndef EIGEN_GPUCC"},
{"lineNum":"  931","line":"  template<int LoadMode,typename PacketType>"},
{"lineNum":"  932","line":"  EIGEN_STRONG_INLINE PacketType packet(Index row, Index col) const"},
{"lineNum":"  933","line":"  {"},
{"lineNum":"  934","line":"    // FIXME: NVCC used to complain about the template keyword, but we have to check whether this is still the case."},
{"lineNum":"  935","line":"    // See also similar calls below."},
{"lineNum":"  936","line":"    return this->template packet_impl<LoadMode,PacketType>(row,col, row,"},
{"lineNum":"  937","line":"                                 typename internal::conditional<int(StorageOrder)==RowMajor, internal::true_type, internal::false_type>::type());"},
{"lineNum":"  938","line":"  }"},
{"lineNum":"  939","line":""},
{"lineNum":"  940","line":"  template<int LoadMode,typename PacketType>"},
{"lineNum":"  941","line":"  EIGEN_STRONG_INLINE PacketType packet(Index idx) const"},
{"lineNum":"  942","line":"  {"},
{"lineNum":"  943","line":"    return packet<LoadMode,PacketType>(int(StorageOrder)==ColMajor?idx:0,int(StorageOrder)==ColMajor?0:idx);"},
{"lineNum":"  944","line":"  }"},
{"lineNum":"  945","line":"#endif"},
{"lineNum":"  946","line":"};"},
{"lineNum":"  947","line":""},
{"lineNum":"  948","line":"// dense * diagonal"},
{"lineNum":"  949","line":"template<typename Lhs, typename Rhs, int ProductKind, int ProductTag>"},
{"lineNum":"  950","line":"struct product_evaluator<Product<Lhs, Rhs, ProductKind>, ProductTag, DenseShape, DiagonalShape>"},
{"lineNum":"  951","line":"  : diagonal_product_evaluator_base<Lhs, typename Rhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheRight>"},
{"lineNum":"  952","line":"{"},
{"lineNum":"  953","line":"  typedef diagonal_product_evaluator_base<Lhs, typename Rhs::DiagonalVectorType, Product<Lhs, Rhs, LazyProduct>, OnTheRight> Base;"},
{"lineNum":"  954","line":"  using Base::m_diagImpl;"},
{"lineNum":"  955","line":"  using Base::m_matImpl;"},
{"lineNum":"  956","line":"  using Base::coeff;"},
{"lineNum":"  957","line":"  typedef typename Base::Scalar Scalar;"},
{"lineNum":"  958","line":""},
{"lineNum":"  959","line":"  typedef Product<Lhs, Rhs, ProductKind> XprType;"},
{"lineNum":"  960","line":"  typedef typename XprType::PlainObject PlainObject;"},
{"lineNum":"  961","line":""},
{"lineNum":"  962","line":"  enum { StorageOrder = Base::StorageOrder_ };"},
{"lineNum":"  963","line":""},
{"lineNum":"  964","line":"  EIGEN_DEVICE_FUNC explicit product_evaluator(const XprType& xpr)"},
{"lineNum":"  965","line":"    : Base(xpr.lhs(), xpr.rhs().diagonal())"},
{"lineNum":"  966","line":"  {"},
{"lineNum":"  967","line":"  }"},
{"lineNum":"  968","line":""},
{"lineNum":"  969","line":"  EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const"},
{"lineNum":"  970","line":"  {"},
{"lineNum":"  971","line":"    return m_matImpl.coeff(row, col) * m_diagImpl.coeff(col);"},
{"lineNum":"  972","line":"  }"},
{"lineNum":"  973","line":""},
{"lineNum":"  974","line":"#ifndef EIGEN_GPUCC"},
{"lineNum":"  975","line":"  template<int LoadMode,typename PacketType>"},
{"lineNum":"  976","line":"  EIGEN_STRONG_INLINE PacketType packet(Index row, Index col) const"},
{"lineNum":"  977","line":"  {"},
{"lineNum":"  978","line":"    return this->template packet_impl<LoadMode,PacketType>(row,col, col,"},
{"lineNum":"  979","line":"                                 typename internal::conditional<int(StorageOrder)==ColMajor, internal::true_type, internal::false_type>::type());"},
{"lineNum":"  980","line":"  }"},
{"lineNum":"  981","line":""},
{"lineNum":"  982","line":"  template<int LoadMode,typename PacketType>"},
{"lineNum":"  983","line":"  EIGEN_STRONG_INLINE PacketType packet(Index idx) const"},
{"lineNum":"  984","line":"  {"},
{"lineNum":"  985","line":"    return packet<LoadMode,PacketType>(int(StorageOrder)==ColMajor?idx:0,int(StorageOrder)==ColMajor?0:idx);"},
{"lineNum":"  986","line":"  }"},
{"lineNum":"  987","line":"#endif"},
{"lineNum":"  988","line":"};"},
{"lineNum":"  989","line":""},
{"lineNum":"  990","line":"/***************************************************************************"},
{"lineNum":"  991","line":"* Products with permutation matrices"},
{"lineNum":"  992","line":"***************************************************************************/"},
{"lineNum":"  993","line":""},
{"lineNum":"  994","line":"/** \\internal"},
{"lineNum":"  995","line":"  * \\class permutation_matrix_product"},
{"lineNum":"  996","line":"  * Internal helper class implementing the product between a permutation matrix and a matrix."},
{"lineNum":"  997","line":"  * This class is specialized for DenseShape below and for SparseShape in SparseCore/SparsePermutation.h"},
{"lineNum":"  998","line":"  */"},
{"lineNum":"  999","line":"template<typename ExpressionType, int Side, bool Transposed, typename ExpressionShape>"},
{"lineNum":" 1000","line":"struct permutation_matrix_product;"},
{"lineNum":" 1001","line":""},
{"lineNum":" 1002","line":"template<typename ExpressionType, int Side, bool Transposed>"},
{"lineNum":" 1003","line":"struct permutation_matrix_product<ExpressionType, Side, Transposed, DenseShape>"},
{"lineNum":" 1004","line":"{"},
{"lineNum":" 1005","line":"    typedef typename nested_eval<ExpressionType, 1>::type MatrixType;"},
{"lineNum":" 1006","line":"    typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;"},
{"lineNum":" 1007","line":""},
{"lineNum":" 1008","line":"    template<typename Dest, typename PermutationType>"},
{"lineNum":" 1009","line":"    static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Dest& dst, const PermutationType& perm, const ExpressionType& xpr)"},
{"lineNum":" 1010","line":"    {"},
{"lineNum":" 1011","line":"      MatrixType mat(xpr);"},
{"lineNum":" 1012","line":"      const Index n = Side==OnTheLeft ? mat.rows() : mat.cols();"},
{"lineNum":" 1013","line":"      // FIXME we need an is_same for expression that is not sensitive to constness. For instance"},
{"lineNum":" 1014","line":"      // is_same_xpr<Block<const Matrix>, Block<Matrix> >::value should be true."},
{"lineNum":" 1015","line":"      //if(is_same<MatrixTypeCleaned,Dest>::value && extract_data(dst) == extract_data(mat))"},
{"lineNum":" 1016","line":"      if(is_same_dense(dst, mat))"},
{"lineNum":" 1017","line":"      {"},
{"lineNum":" 1018","line":"        // apply the permutation inplace"},
{"lineNum":" 1019","line":"        Matrix<bool,PermutationType::RowsAtCompileTime,1,0,PermutationType::MaxRowsAtCompileTime> mask(perm.size());"},
{"lineNum":" 1020","line":"        mask.fill(false);"},
{"lineNum":" 1021","line":"        Index r = 0;"},
{"lineNum":" 1022","line":"        while(r < perm.size())"},
{"lineNum":" 1023","line":"        {"},
{"lineNum":" 1024","line":"          // search for the next seed"},
{"lineNum":" 1025","line":"          while(r<perm.size() && mask[r]) r++;"},
{"lineNum":" 1026","line":"          if(r>=perm.size())"},
{"lineNum":" 1027","line":"            break;"},
{"lineNum":" 1028","line":"          // we got one, let\'s follow it until we are back to the seed"},
{"lineNum":" 1029","line":"          Index k0 = r++;"},
{"lineNum":" 1030","line":"          Index kPrev = k0;"},
{"lineNum":" 1031","line":"          mask.coeffRef(k0) = true;"},
{"lineNum":" 1032","line":"          for(Index k=perm.indices().coeff(k0); k!=k0; k=perm.indices().coeff(k))"},
{"lineNum":" 1033","line":"          {"},
{"lineNum":" 1034","line":"                  Block<Dest, Side==OnTheLeft ? 1 : Dest::RowsAtCompileTime, Side==OnTheRight ? 1 : Dest::ColsAtCompileTime>(dst, k)"},
{"lineNum":" 1035","line":"            .swap(Block<Dest, Side==OnTheLeft ? 1 : Dest::RowsAtCompileTime, Side==OnTheRight ? 1 : Dest::ColsAtCompileTime>"},
{"lineNum":" 1036","line":"                       (dst,((Side==OnTheLeft) ^ Transposed) ? k0 : kPrev));"},
{"lineNum":" 1037","line":""},
{"lineNum":" 1038","line":"            mask.coeffRef(k) = true;"},
{"lineNum":" 1039","line":"            kPrev = k;"},
{"lineNum":" 1040","line":"          }"},
{"lineNum":" 1041","line":"        }"},
{"lineNum":" 1042","line":"      }"},
{"lineNum":" 1043","line":"      else"},
{"lineNum":" 1044","line":"      {"},
{"lineNum":" 1045","line":"        for(Index i = 0; i < n; ++i)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":" 1046","line":"        {"},
{"lineNum":" 1047","line":"          Block<Dest, Side==OnTheLeft ? 1 : Dest::RowsAtCompileTime, Side==OnTheRight ? 1 : Dest::ColsAtCompileTime>"},
{"lineNum":" 1048","line":"               (dst, ((Side==OnTheLeft) ^ Transposed) ? perm.indices().coeff(i) : i)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 1049","line":""},
{"lineNum":" 1050","line":"          ="},
{"lineNum":" 1051","line":""},
{"lineNum":" 1052","line":"          Block<const MatrixTypeCleaned,Side==OnTheLeft ? 1 : MatrixTypeCleaned::RowsAtCompileTime,Side==OnTheRight ? 1 : MatrixTypeCleaned::ColsAtCompileTime>"},
{"lineNum":" 1053","line":"               (mat, ((Side==OnTheRight) ^ Transposed) ? perm.indices().coeff(i) : i);"},
{"lineNum":" 1054","line":"        }"},
{"lineNum":" 1055","line":"      }"},
{"lineNum":" 1056","line":"    }"},
{"lineNum":" 1057","line":"};"},
{"lineNum":" 1058","line":""},
{"lineNum":" 1059","line":"template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>"},
{"lineNum":" 1060","line":"struct generic_product_impl<Lhs, Rhs, PermutationShape, MatrixShape, ProductTag>"},
{"lineNum":" 1061","line":"{"},
{"lineNum":" 1062","line":"  template<typename Dest>"},
{"lineNum":" 1063","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":" 1064","line":"  {"},
{"lineNum":" 1065","line":"    permutation_matrix_product<Rhs, OnTheLeft, false, MatrixShape>::run(dst, lhs, rhs);"},
{"lineNum":" 1066","line":"  }"},
{"lineNum":" 1067","line":"};"},
{"lineNum":" 1068","line":""},
{"lineNum":" 1069","line":"template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>"},
{"lineNum":" 1070","line":"struct generic_product_impl<Lhs, Rhs, MatrixShape, PermutationShape, ProductTag>"},
{"lineNum":" 1071","line":"{"},
{"lineNum":" 1072","line":"  template<typename Dest>"},
{"lineNum":" 1073","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":" 1074","line":"  {"},
{"lineNum":" 1075","line":"    permutation_matrix_product<Lhs, OnTheRight, false, MatrixShape>::run(dst, rhs, lhs);"},
{"lineNum":" 1076","line":"  }"},
{"lineNum":" 1077","line":"};"},
{"lineNum":" 1078","line":""},
{"lineNum":" 1079","line":"template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>"},
{"lineNum":" 1080","line":"struct generic_product_impl<Inverse<Lhs>, Rhs, PermutationShape, MatrixShape, ProductTag>"},
{"lineNum":" 1081","line":"{"},
{"lineNum":" 1082","line":"  template<typename Dest>"},
{"lineNum":" 1083","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Inverse<Lhs>& lhs, const Rhs& rhs)"},
{"lineNum":" 1084","line":"  {"},
{"lineNum":" 1085","line":"    permutation_matrix_product<Rhs, OnTheLeft, true, MatrixShape>::run(dst, lhs.nestedExpression(), rhs);"},
{"lineNum":" 1086","line":"  }"},
{"lineNum":" 1087","line":"};"},
{"lineNum":" 1088","line":""},
{"lineNum":" 1089","line":"template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>"},
{"lineNum":" 1090","line":"struct generic_product_impl<Lhs, Inverse<Rhs>, MatrixShape, PermutationShape, ProductTag>"},
{"lineNum":" 1091","line":"{"},
{"lineNum":" 1092","line":"  template<typename Dest>"},
{"lineNum":" 1093","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Inverse<Rhs>& rhs)"},
{"lineNum":" 1094","line":"  {"},
{"lineNum":" 1095","line":"    permutation_matrix_product<Lhs, OnTheRight, true, MatrixShape>::run(dst, rhs.nestedExpression(), lhs);"},
{"lineNum":" 1096","line":"  }"},
{"lineNum":" 1097","line":"};"},
{"lineNum":" 1098","line":""},
{"lineNum":" 1099","line":""},
{"lineNum":" 1100","line":"/***************************************************************************"},
{"lineNum":" 1101","line":"* Products with transpositions matrices"},
{"lineNum":" 1102","line":"***************************************************************************/"},
{"lineNum":" 1103","line":""},
{"lineNum":" 1104","line":"// FIXME could we unify Transpositions and Permutation into a single \"shape\"??"},
{"lineNum":" 1105","line":""},
{"lineNum":" 1106","line":"/** \\internal"},
{"lineNum":" 1107","line":"  * \\class transposition_matrix_product"},
{"lineNum":" 1108","line":"  * Internal helper class implementing the product between a permutation matrix and a matrix."},
{"lineNum":" 1109","line":"  */"},
{"lineNum":" 1110","line":"template<typename ExpressionType, int Side, bool Transposed, typename ExpressionShape>"},
{"lineNum":" 1111","line":"struct transposition_matrix_product"},
{"lineNum":" 1112","line":"{"},
{"lineNum":" 1113","line":"  typedef typename nested_eval<ExpressionType, 1>::type MatrixType;"},
{"lineNum":" 1114","line":"  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;"},
{"lineNum":" 1115","line":""},
{"lineNum":" 1116","line":"  template<typename Dest, typename TranspositionType>"},
{"lineNum":" 1117","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void run(Dest& dst, const TranspositionType& tr, const ExpressionType& xpr)"},
{"lineNum":" 1118","line":"  {"},
{"lineNum":" 1119","line":"    MatrixType mat(xpr);"},
{"lineNum":" 1120","line":"    typedef typename TranspositionType::StorageIndex StorageIndex;"},
{"lineNum":" 1121","line":"    const Index size = tr.size();"},
{"lineNum":" 1122","line":"    StorageIndex j = 0;"},
{"lineNum":" 1123","line":""},
{"lineNum":" 1124","line":"    if(!is_same_dense(dst,mat))"},
{"lineNum":" 1125","line":"      dst = mat;"},
{"lineNum":" 1126","line":""},
{"lineNum":" 1127","line":"    for(Index k=(Transposed?size-1:0) ; Transposed?k>=0:k<size ; Transposed?--k:++k)"},
{"lineNum":" 1128","line":"      if(Index(j=tr.coeff(k))!=k)"},
{"lineNum":" 1129","line":"      {"},
{"lineNum":" 1130","line":"        if(Side==OnTheLeft)        dst.row(k).swap(dst.row(j));"},
{"lineNum":" 1131","line":"        else if(Side==OnTheRight)  dst.col(k).swap(dst.col(j));"},
{"lineNum":" 1132","line":"      }"},
{"lineNum":" 1133","line":"  }"},
{"lineNum":" 1134","line":"};"},
{"lineNum":" 1135","line":""},
{"lineNum":" 1136","line":"template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>"},
{"lineNum":" 1137","line":"struct generic_product_impl<Lhs, Rhs, TranspositionsShape, MatrixShape, ProductTag>"},
{"lineNum":" 1138","line":"{"},
{"lineNum":" 1139","line":"  template<typename Dest>"},
{"lineNum":" 1140","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":" 1141","line":"  {"},
{"lineNum":" 1142","line":"    transposition_matrix_product<Rhs, OnTheLeft, false, MatrixShape>::run(dst, lhs, rhs);"},
{"lineNum":" 1143","line":"  }"},
{"lineNum":" 1144","line":"};"},
{"lineNum":" 1145","line":""},
{"lineNum":" 1146","line":"template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>"},
{"lineNum":" 1147","line":"struct generic_product_impl<Lhs, Rhs, MatrixShape, TranspositionsShape, ProductTag>"},
{"lineNum":" 1148","line":"{"},
{"lineNum":" 1149","line":"  template<typename Dest>"},
{"lineNum":" 1150","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Rhs& rhs)"},
{"lineNum":" 1151","line":"  {"},
{"lineNum":" 1152","line":"    transposition_matrix_product<Lhs, OnTheRight, false, MatrixShape>::run(dst, rhs, lhs);"},
{"lineNum":" 1153","line":"  }"},
{"lineNum":" 1154","line":"};"},
{"lineNum":" 1155","line":""},
{"lineNum":" 1156","line":""},
{"lineNum":" 1157","line":"template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>"},
{"lineNum":" 1158","line":"struct generic_product_impl<Transpose<Lhs>, Rhs, TranspositionsShape, MatrixShape, ProductTag>"},
{"lineNum":" 1159","line":"{"},
{"lineNum":" 1160","line":"  template<typename Dest>"},
{"lineNum":" 1161","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Transpose<Lhs>& lhs, const Rhs& rhs)"},
{"lineNum":" 1162","line":"  {"},
{"lineNum":" 1163","line":"    transposition_matrix_product<Rhs, OnTheLeft, true, MatrixShape>::run(dst, lhs.nestedExpression(), rhs);"},
{"lineNum":" 1164","line":"  }"},
{"lineNum":" 1165","line":"};"},
{"lineNum":" 1166","line":""},
{"lineNum":" 1167","line":"template<typename Lhs, typename Rhs, int ProductTag, typename MatrixShape>"},
{"lineNum":" 1168","line":"struct generic_product_impl<Lhs, Transpose<Rhs>, MatrixShape, TranspositionsShape, ProductTag>"},
{"lineNum":" 1169","line":"{"},
{"lineNum":" 1170","line":"  template<typename Dest>"},
{"lineNum":" 1171","line":"  static EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE void evalTo(Dest& dst, const Lhs& lhs, const Transpose<Rhs>& rhs)"},
{"lineNum":" 1172","line":"  {"},
{"lineNum":" 1173","line":"    transposition_matrix_product<Lhs, OnTheRight, true, MatrixShape>::run(dst, rhs.nestedExpression(), lhs);"},
{"lineNum":" 1174","line":"  }"},
{"lineNum":" 1175","line":"};"},
{"lineNum":" 1176","line":""},
{"lineNum":" 1177","line":"} // end namespace internal"},
{"lineNum":" 1178","line":""},
{"lineNum":" 1179","line":"} // end namespace Eigen"},
{"lineNum":" 1180","line":""},
{"lineNum":" 1181","line":"#endif // EIGEN_PRODUCT_EVALUATORS_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 40, "covered" : 0,};
var merged_data = [];
