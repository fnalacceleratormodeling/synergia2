var data = {lines:[
{"lineNum":"    1","line":"/*! \\file polymorphic.hpp"},
{"lineNum":"    2","line":"    \\brief Support for pointers to polymorphic base classes"},
{"lineNum":"    3","line":"    \\ingroup OtherTypes */"},
{"lineNum":"    4","line":"/*"},
{"lineNum":"    5","line":"  Copyright (c) 2014, Randolph Voorhies, Shane Grant"},
{"lineNum":"    6","line":"  All rights reserved."},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"  Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    9","line":"  modification, are permitted provided that the following conditions are met:"},
{"lineNum":"   10","line":"      * Redistributions of source code must retain the above copyright"},
{"lineNum":"   11","line":"        notice, this list of conditions and the following disclaimer."},
{"lineNum":"   12","line":"      * Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   13","line":"        notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   14","line":"        documentation and/or other materials provided with the distribution."},
{"lineNum":"   15","line":"      * Neither the name of cereal nor the"},
{"lineNum":"   16","line":"        names of its contributors may be used to endorse or promote products"},
{"lineNum":"   17","line":"        derived from this software without specific prior written permission."},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"},
{"lineNum":"   20","line":"  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"},
{"lineNum":"   21","line":"  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"},
{"lineNum":"   22","line":"  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES OR SHANE GRANT BE LIABLE FOR ANY"},
{"lineNum":"   23","line":"  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"},
{"lineNum":"   24","line":"  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"},
{"lineNum":"   25","line":"  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"},
{"lineNum":"   26","line":"  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   27","line":"  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   28","line":"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   29","line":"*/"},
{"lineNum":"   30","line":"#ifndef CEREAL_TYPES_POLYMORPHIC_HPP_"},
{"lineNum":"   31","line":"#define CEREAL_TYPES_POLYMORPHIC_HPP_"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"#include \"cereal/cereal.hpp\""},
{"lineNum":"   34","line":"#include \"cereal/types/memory.hpp\""},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"#include \"cereal/details/util.hpp\""},
{"lineNum":"   37","line":"#include \"cereal/details/helpers.hpp\""},
{"lineNum":"   38","line":"#include \"cereal/details/traits.hpp\""},
{"lineNum":"   39","line":"#include \"cereal/details/polymorphic_impl.hpp\""},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"#if defined(_MSC_VER) && _MSC_VER < 1916"},
{"lineNum":"   42","line":"#define CEREAL_STATIC_CONSTEXPR static"},
{"lineNum":"   43","line":"#else"},
{"lineNum":"   44","line":"#define CEREAL_STATIC_CONSTEXPR static constexpr"},
{"lineNum":"   45","line":"#endif"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"//! Registers a derived polymorphic type with cereal"},
{"lineNum":"   48","line":"/*! Polymorphic types must be registered before smart"},
{"lineNum":"   49","line":"    pointers to them can be serialized.  Note that base"},
{"lineNum":"   50","line":"    classes do not need to be registered."},
{"lineNum":"   51","line":""},
{"lineNum":"   52","line":"    Registering a type lets cereal know how to properly"},
{"lineNum":"   53","line":"    serialize it when a smart pointer to a base object is"},
{"lineNum":"   54","line":"    used in conjunction with a derived class."},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"    This assumes that all relevant archives have also"},
{"lineNum":"   57","line":"    previously been registered.  Registration for archives"},
{"lineNum":"   58","line":"    is usually done in the header file in which they are"},
{"lineNum":"   59","line":"    defined.  This means that type registration needs to"},
{"lineNum":"   60","line":"    happen after specific archives to be used are included."},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"    It is recommended that type registration be done in"},
{"lineNum":"   63","line":"    the header file in which the type is declared."},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"    Registration can also be placed in a source file,"},
{"lineNum":"   66","line":"    but this may require the use of the"},
{"lineNum":"   67","line":"    CEREAL_REGISTER_DYNAMIC_INIT macro (see below)."},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"    Registration may be called repeatedly for the same"},
{"lineNum":"   70","line":"    type in different translation units to add support"},
{"lineNum":"   71","line":"    for additional archives if they are not initially"},
{"lineNum":"   72","line":"    available (included and registered)."},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"    When building serialization support as a DLL on"},
{"lineNum":"   75","line":"    Windows, registration must happen in the header file."},
{"lineNum":"   76","line":"    On Linux and Mac things should still work properly"},
{"lineNum":"   77","line":"    if placed in a source file, but see the above comments"},
{"lineNum":"   78","line":"    on registering in source files."},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"    Polymorphic support in cereal requires RTTI to be"},
{"lineNum":"   81","line":"    enabled */"},
{"lineNum":"   82","line":"#define CEREAL_REGISTER_TYPE(...)                                        \\"},
{"lineNum":"   83","line":"  namespace cereal {                                                     \\"},
{"lineNum":"   84","line":"  namespace detail {                                                     \\"},
{"lineNum":"   85","line":"  template <>                                                            \\"},
{"lineNum":"   86","line":"  struct binding_name<__VA_ARGS__>                                       \\"},
{"lineNum":"   87","line":"  {                                                                      \\"},
{"lineNum":"   88","line":"    CEREAL_STATIC_CONSTEXPR char const * name() { return #__VA_ARGS__; } \\"},
{"lineNum":"   89","line":"  };                                                                     \\"},
{"lineNum":"   90","line":"  } } /* end namespaces */                                               \\"},
{"lineNum":"   91","line":"  CEREAL_BIND_TO_ARCHIVES(__VA_ARGS__)"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"//! Registers a polymorphic type with cereal, giving it a"},
{"lineNum":"   94","line":"//! user defined name"},
{"lineNum":"   95","line":"/*! In some cases the default name used with"},
{"lineNum":"   96","line":"    CEREAL_REGISTER_TYPE (the name of the type) may not be"},
{"lineNum":"   97","line":"    suitable.  This macro allows any name to be associated"},
{"lineNum":"   98","line":"    with the type.  The name should be unique */"},
{"lineNum":"   99","line":"#define CEREAL_REGISTER_TYPE_WITH_NAME(T, Name)                     \\"},
{"lineNum":"  100","line":"  namespace cereal {                                                \\"},
{"lineNum":"  101","line":"  namespace detail {                                                \\"},
{"lineNum":"  102","line":"  template <>                                                       \\"},
{"lineNum":"  103","line":"  struct binding_name<T>                                            \\"},
{"lineNum":"  104","line":"  { CEREAL_STATIC_CONSTEXPR char const * name() { return Name; } }; \\"},
{"lineNum":"  105","line":"  } } /* end namespaces */                                          \\"},
{"lineNum":"  106","line":"  CEREAL_BIND_TO_ARCHIVES(T)"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"//! Registers the base-derived relationship for a polymorphic type"},
{"lineNum":"  109","line":"/*! When polymorphic serialization occurs, cereal needs to know how to"},
{"lineNum":"  110","line":"    properly cast between derived and base types for the polymorphic"},
{"lineNum":"  111","line":"    type. Normally this happens automatically whenever cereal::base_class"},
{"lineNum":"  112","line":"    or cereal::virtual_base_class are used to serialize a base class. In"},
{"lineNum":"  113","line":"    cases where neither of these is ever called but a base class still"},
{"lineNum":"  114","line":"    exists, this explicit registration is required."},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"    The Derived class should be the most derived type that will be serialized,"},
{"lineNum":"  117","line":"    and the Base type any possible base that has not been covered under a base"},
{"lineNum":"  118","line":"    class serialization that will be used to store a Derived pointer."},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"    Placement of this is the same as for CEREAL_REGISTER_TYPE. */"},
{"lineNum":"  121","line":"#define CEREAL_REGISTER_POLYMORPHIC_RELATION(Base, Derived)                     \\"},
{"lineNum":"  122","line":"  namespace cereal {                                                            \\"},
{"lineNum":"  123","line":"  namespace detail {                                                            \\"},
{"lineNum":"  124","line":"  template <>                                                                   \\"},
{"lineNum":"  125","line":"  struct PolymorphicRelation<Base, Derived>                                     \\"},
{"lineNum":"  126","line":"  { static void bind() { RegisterPolymorphicCaster<Base, Derived>::bind(); } }; \\"},
{"lineNum":"  127","line":"  } } /* end namespaces */"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"//! Adds a way to force initialization of a translation unit containing"},
{"lineNum":"  130","line":"//! calls to CEREAL_REGISTER_TYPE"},
{"lineNum":"  131","line":"/*! In C++, dynamic initialization of non-local variables of a translation"},
{"lineNum":"  132","line":"    unit may be deferred until \"the first odr-use of any function or variable"},
{"lineNum":"  133","line":"    defined in the same translation unit as the variable to be initialized.\""},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"    Informally, odr-use means that your program takes the address of or binds"},
{"lineNum":"  136","line":"    a reference directly to an object, which must have a definition."},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"    Since polymorphic type support in cereal relies on the dynamic"},
{"lineNum":"  139","line":"    initialization of certain global objects happening before"},
{"lineNum":"  140","line":"    serialization is performed, it is important to ensure that something"},
{"lineNum":"  141","line":"    from files that call CEREAL_REGISTER_TYPE is odr-used before serialization"},
{"lineNum":"  142","line":"    occurs, otherwise the registration will never take place.  This may often"},
{"lineNum":"  143","line":"    be the case when serialization is built as a shared library external from"},
{"lineNum":"  144","line":"    your main program."},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"    This macro, with any name of your choosing, should be placed into the"},
{"lineNum":"  147","line":"    source file that contains calls to CEREAL_REGISTER_TYPE."},
{"lineNum":"  148","line":""},
{"lineNum":"  149","line":"    Its counterpart, CEREAL_FORCE_DYNAMIC_INIT, should be placed in its"},
{"lineNum":"  150","line":"    associated header file such that it is included in the translation units"},
{"lineNum":"  151","line":"    (source files) in which you want the registration to appear."},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"    @relates CEREAL_FORCE_DYNAMIC_INIT"},
{"lineNum":"  154","line":"    */"},
{"lineNum":"  155","line":"#define CEREAL_REGISTER_DYNAMIC_INIT(LibName)                \\"},
{"lineNum":"  156","line":"  namespace cereal {                                         \\"},
{"lineNum":"  157","line":"  namespace detail {                                         \\"},
{"lineNum":"  158","line":"    void CEREAL_DLL_EXPORT dynamic_init_dummy_##LibName() {} \\"},
{"lineNum":"  159","line":"  } } /* end namespaces */"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"//! Forces dynamic initialization of polymorphic support in a"},
{"lineNum":"  162","line":"//! previously registered source file"},
{"lineNum":"  163","line":"/*! @sa CEREAL_REGISTER_DYNAMIC_INIT"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"    See CEREAL_REGISTER_DYNAMIC_INIT for detailed explanation"},
{"lineNum":"  166","line":"    of how this macro should be used.  The name used should"},
{"lineNum":"  167","line":"    match that for CEREAL_REGISTER_DYNAMIC_INIT. */"},
{"lineNum":"  168","line":"#define CEREAL_FORCE_DYNAMIC_INIT(LibName)                 \\"},
{"lineNum":"  169","line":"  namespace cereal {                                       \\"},
{"lineNum":"  170","line":"  namespace detail {                                       \\"},
{"lineNum":"  171","line":"    void CEREAL_DLL_EXPORT dynamic_init_dummy_##LibName(); \\"},
{"lineNum":"  172","line":"  } /* end detail */                                       \\"},
{"lineNum":"  173","line":"  } /* end cereal */                                       \\"},
{"lineNum":"  174","line":"  namespace {                                              \\"},
{"lineNum":"  175","line":"    struct dynamic_init_##LibName {                        \\"},
{"lineNum":"  176","line":"      dynamic_init_##LibName() {                           \\"},
{"lineNum":"  177","line":"        ::cereal::detail::dynamic_init_dummy_##LibName();  \\"},
{"lineNum":"  178","line":"      }                                                    \\"},
{"lineNum":"  179","line":"    } dynamic_init_instance_##LibName;                     \\"},
{"lineNum":"  180","line":"  } /* end anonymous namespace */"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"namespace cereal"},
{"lineNum":"  183","line":"{"},
{"lineNum":"  184","line":"  namespace polymorphic_detail"},
{"lineNum":"  185","line":"  {"},
{"lineNum":"  186","line":"    //! Error message used for unregistered polymorphic types"},
{"lineNum":"  187","line":"    /*! @internal */"},
{"lineNum":"  188","line":"    #define UNREGISTERED_POLYMORPHIC_EXCEPTION(LoadSave, Name)                                                                                      \\"},
{"lineNum":"  189","line":"      throw cereal::Exception(\"Trying to \" #LoadSave \" an unregistered polymorphic type (\" + Name + \").\\n\"                                          \\"},
{"lineNum":"  190","line":"                              \"Make sure your type is registered with CEREAL_REGISTER_TYPE and that the archive \"                                   \\"},
{"lineNum":"  191","line":"                              \"you are using was included (and registered with CEREAL_REGISTER_ARCHIVE) prior to calling CEREAL_REGISTER_TYPE.\\n\"   \\"},
{"lineNum":"  192","line":"                              \"If your type is already registered and you still see this error, you may need to use CEREAL_REGISTER_DYNAMIC_INIT.\");"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"    //! Get an input binding from the given archive by deserializing the type meta data"},
{"lineNum":"  195","line":"    /*! @internal */"},
{"lineNum":"  196","line":"    template<class Archive> inline"},
{"lineNum":"  197","line":"    typename ::cereal::detail::InputBindingMap<Archive>::Serializers getInputBinding(Archive & ar, std::uint32_t const nameid)"},
{"lineNum":"  198","line":"    {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  199","line":"      // If the nameid is zero, we serialized a null pointer"},
{"lineNum":"  200","line":"      if(nameid == 0)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  201","line":"      {"},
{"lineNum":"  202","line":"        typename ::cereal::detail::InputBindingMap<Archive>::Serializers emptySerializers;"},
{"lineNum":"  203","line":"        emptySerializers.shared_ptr = [](void*, std::shared_ptr<void> & ptr, std::type_info const &) { ptr.reset(); };","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  204","line":"        emptySerializers.unique_ptr = [](void*, std::unique_ptr<void, ::cereal::detail::EmptyDeleter<void>> & ptr, std::type_info const &) { ptr.reset( nullptr ); };","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  205","line":"        return emptySerializers;"},
{"lineNum":"  206","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"      std::string name;"},
{"lineNum":"  209","line":"      if(nameid & detail::msb_32bit)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  210","line":"      {"},
{"lineNum":"  211","line":"        ar( CEREAL_NVP_(\"polymorphic_name\", name) );","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  212","line":"        ar.registerPolymorphicName(nameid, name);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  213","line":"      }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  214","line":"      else"},
{"lineNum":"  215","line":"        name = ar.getPolymorphicName(nameid);","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"      auto const & bindingMap = detail::StaticObject<detail::InputBindingMap<Archive>>::getInstance().map;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"      auto binding = bindingMap.find(name);"},
{"lineNum":"  220","line":"      if(binding == bindingMap.end())","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  221","line":"        UNREGISTERED_POLYMORPHIC_EXCEPTION(load, name)","class":"lineNoCov","hits":"0","possible_hits":"30",},
{"lineNum":"  222","line":"      return binding->second;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  223","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"    //! Serialize a shared_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee"},
{"lineNum":"  226","line":"    /*! This check lets us try and skip doing polymorphic machinery if we can get away with"},
{"lineNum":"  227","line":"        using the derived class serialize function"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"        Note that on MSVC 2013 preview, is_default_constructible<T> returns true for abstract classes with"},
{"lineNum":"  230","line":"        default constructors, but on clang/gcc this will return false.  So we also need to check for that here."},
{"lineNum":"  231","line":"        @internal */"},
{"lineNum":"  232","line":"    template<class Archive, class T> inline"},
{"lineNum":"  233","line":"    typename std::enable_if<(traits::is_default_constructible<T>::value"},
{"lineNum":"  234","line":"                             || traits::has_load_and_construct<T, Archive>::value)"},
{"lineNum":"  235","line":"                             && !std::is_abstract<T>::value, bool>::type"},
{"lineNum":"  236","line":"    serialize_wrapper(Archive & ar, std::shared_ptr<T> & ptr, std::uint32_t const nameid)"},
{"lineNum":"  237","line":"    {"},
{"lineNum":"  238","line":"      if(nameid & detail::msb2_32bit)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  239","line":"      {"},
{"lineNum":"  240","line":"        ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper(ptr)) );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  241","line":"        return true;"},
{"lineNum":"  242","line":"      }"},
{"lineNum":"  243","line":"      return false;"},
{"lineNum":"  244","line":"    }"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"    //! Serialize a unique_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee"},
{"lineNum":"  247","line":"    /*! This check lets us try and skip doing polymorphic machinery if we can get away with"},
{"lineNum":"  248","line":"        using the derived class serialize function"},
{"lineNum":"  249","line":"        @internal */"},
{"lineNum":"  250","line":"    template<class Archive, class T, class D> inline"},
{"lineNum":"  251","line":"    typename std::enable_if<(traits::is_default_constructible<T>::value"},
{"lineNum":"  252","line":"                             || traits::has_load_and_construct<T, Archive>::value)"},
{"lineNum":"  253","line":"                             && !std::is_abstract<T>::value, bool>::type"},
{"lineNum":"  254","line":"    serialize_wrapper(Archive & ar, std::unique_ptr<T, D> & ptr, std::uint32_t const nameid)"},
{"lineNum":"  255","line":"    {"},
{"lineNum":"  256","line":"      if(nameid & detail::msb2_32bit)"},
{"lineNum":"  257","line":"      {"},
{"lineNum":"  258","line":"        ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper(ptr)) );"},
{"lineNum":"  259","line":"        return true;"},
{"lineNum":"  260","line":"      }"},
{"lineNum":"  261","line":"      return false;"},
{"lineNum":"  262","line":"    }"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"    //! Serialize a shared_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee"},
{"lineNum":"  265","line":"    /*! This case is for when we can\'t actually construct the shared pointer.  Normally this would be caught"},
{"lineNum":"  266","line":"        as the pointer itself is serialized, but since this is a polymorphic pointer, if we tried to serialize"},
{"lineNum":"  267","line":"        the pointer we\'d end up back here recursively.  So we have to catch the error here as well, if"},
{"lineNum":"  268","line":"        this was a polymorphic type serialized by its proper pointer type"},
{"lineNum":"  269","line":"        @internal */"},
{"lineNum":"  270","line":"    template<class Archive, class T> inline"},
{"lineNum":"  271","line":"    typename std::enable_if<(!traits::is_default_constructible<T>::value"},
{"lineNum":"  272","line":"                             && !traits::has_load_and_construct<T, Archive>::value)"},
{"lineNum":"  273","line":"                             || std::is_abstract<T>::value, bool>::type"},
{"lineNum":"  274","line":"    serialize_wrapper(Archive &, std::shared_ptr<T> &, std::uint32_t const nameid)"},
{"lineNum":"  275","line":"    {"},
{"lineNum":"  276","line":"      if(nameid & detail::msb2_32bit)","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  277","line":"        throw cereal::Exception(\"Cannot load a polymorphic type that is not default constructable and does not have a load_and_construct function\");","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  278","line":"      return false;"},
{"lineNum":"  279","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"    //! Serialize a unique_ptr if the 2nd msb in the nameid is set, and if we can actually construct the pointee"},
{"lineNum":"  282","line":"    /*! This case is for when we can\'t actually construct the unique pointer.  Normally this would be caught"},
{"lineNum":"  283","line":"        as the pointer itself is serialized, but since this is a polymorphic pointer, if we tried to serialize"},
{"lineNum":"  284","line":"        the pointer we\'d end up back here recursively.  So we have to catch the error here as well, if"},
{"lineNum":"  285","line":"        this was a polymorphic type serialized by its proper pointer type"},
{"lineNum":"  286","line":"        @internal */"},
{"lineNum":"  287","line":"    template<class Archive, class T, class D> inline"},
{"lineNum":"  288","line":"     typename std::enable_if<(!traits::is_default_constructible<T>::value"},
{"lineNum":"  289","line":"                               && !traits::has_load_and_construct<T, Archive>::value)"},
{"lineNum":"  290","line":"                               || std::is_abstract<T>::value, bool>::type"},
{"lineNum":"  291","line":"    serialize_wrapper(Archive &, std::unique_ptr<T, D> &, std::uint32_t const nameid)"},
{"lineNum":"  292","line":"    {"},
{"lineNum":"  293","line":"      if(nameid & detail::msb2_32bit)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  294","line":"        throw cereal::Exception(\"Cannot load a polymorphic type that is not default constructable and does not have a load_and_construct function\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  295","line":"      return false;"},
{"lineNum":"  296","line":"    }"},
{"lineNum":"  297","line":"  } // polymorphic_detail"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"  // ######################################################################"},
{"lineNum":"  300","line":"  // Pointer serialization for polymorphic types"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"  //! Saving std::shared_ptr for polymorphic types, abstract"},
{"lineNum":"  303","line":"  template <class Archive, class T> inline"},
{"lineNum":"  304","line":"  typename std::enable_if<std::is_polymorphic<T>::value && std::is_abstract<T>::value, void>::type"},
{"lineNum":"  305","line":"  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> const & ptr )"},
{"lineNum":"  306","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  307","line":"    if(!ptr)","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  308","line":"    {"},
{"lineNum":"  309","line":"      // same behavior as nullptr in memory implementation"},
{"lineNum":"  310","line":"      ar( CEREAL_NVP_(\"polymorphic_id\", std::uint32_t(0)) );","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  311","line":"      return;"},
{"lineNum":"  312","line":"    }"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"    std::type_info const & ptrinfo = typeid(*ptr.get());","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  315","line":"    static std::type_info const & tinfo = typeid(T);"},
{"lineNum":"  316","line":"    // ptrinfo can never be equal to T info since we can\'t have an instance"},
{"lineNum":"  317","line":"    // of an abstract object"},
{"lineNum":"  318","line":"    //  this implies we need to do the lookup"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"    auto const & bindingMap = detail::StaticObject<detail::OutputBindingMap<Archive>>::getInstance().map;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"    auto binding = bindingMap.find(std::type_index(ptrinfo));"},
{"lineNum":"  323","line":"    if(binding == bindingMap.end())","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  324","line":"      UNREGISTERED_POLYMORPHIC_EXCEPTION(save, cereal::util::demangle(ptrinfo.name()))","class":"lineNoCov","hits":"0","possible_hits":"44",},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"    binding->second.shared_ptr(&ar, ptr.get(), tinfo);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  327","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"22",},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"  //! Saving std::shared_ptr for polymorphic types, not abstract"},
{"lineNum":"  330","line":"  template <class Archive, class T> inline"},
{"lineNum":"  331","line":"  typename std::enable_if<std::is_polymorphic<T>::value && !std::is_abstract<T>::value, void>::type"},
{"lineNum":"  332","line":"  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> const & ptr )"},
{"lineNum":"  333","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  334","line":"    if(!ptr)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  335","line":"    {"},
{"lineNum":"  336","line":"      // same behavior as nullptr in memory implementation"},
{"lineNum":"  337","line":"      ar( CEREAL_NVP_(\"polymorphic_id\", std::uint32_t(0)) );"},
{"lineNum":"  338","line":"      return;"},
{"lineNum":"  339","line":"    }"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"    std::type_info const & ptrinfo = typeid(*ptr.get());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  342","line":"    static std::type_info const & tinfo = typeid(T);"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"    if(ptrinfo == tinfo)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  345","line":"    {"},
{"lineNum":"  346","line":"      // The 2nd msb signals that the following pointer does not need to be"},
{"lineNum":"  347","line":"      // cast with our polymorphic machinery"},
{"lineNum":"  348","line":"      ar( CEREAL_NVP_(\"polymorphic_id\", detail::msb2_32bit) );"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"      ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper(ptr)) );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"      return;"},
{"lineNum":"  353","line":"    }"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"    auto const & bindingMap = detail::StaticObject<detail::OutputBindingMap<Archive>>::getInstance().map;"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"    auto binding = bindingMap.find(std::type_index(ptrinfo));"},
{"lineNum":"  358","line":"    if(binding == bindingMap.end())"},
{"lineNum":"  359","line":"      UNREGISTERED_POLYMORPHIC_EXCEPTION(save, cereal::util::demangle(ptrinfo.name()))","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  360","line":""},
{"lineNum":"  361","line":"    binding->second.shared_ptr(&ar, ptr.get(), tinfo);"},
{"lineNum":"  362","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"  //! Loading std::shared_ptr for polymorphic types"},
{"lineNum":"  365","line":"  template <class Archive, class T> inline"},
{"lineNum":"  366","line":"  typename std::enable_if<std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  367","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> & ptr )"},
{"lineNum":"  368","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  369","line":"    std::uint32_t nameid;"},
{"lineNum":"  370","line":"    ar( CEREAL_NVP_(\"polymorphic_id\", nameid) );","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  371","line":""},
{"lineNum":"  372","line":"    // Check to see if we can skip all of this polymorphism business"},
{"lineNum":"  373","line":"    if(polymorphic_detail::serialize_wrapper(ar, ptr, nameid))","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  374","line":"      return;"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"    auto binding = polymorphic_detail::getInputBinding(ar, nameid);","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  377","line":"    std::shared_ptr<void> result;"},
{"lineNum":"  378","line":"    binding.shared_ptr(&ar, result, typeid(T));"},
{"lineNum":"  379","line":"    ptr = std::static_pointer_cast<T>(result);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  380","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"16",},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"  //! Saving std::weak_ptr for polymorphic types"},
{"lineNum":"  383","line":"  template <class Archive, class T> inline"},
{"lineNum":"  384","line":"  typename std::enable_if<std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  385","line":"  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::weak_ptr<T> const & ptr )"},
{"lineNum":"  386","line":"  {"},
{"lineNum":"  387","line":"    auto const sptr = ptr.lock();"},
{"lineNum":"  388","line":"    ar( CEREAL_NVP_(\"locked_ptr\", sptr) );"},
{"lineNum":"  389","line":"  }"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"  //! Loading std::weak_ptr for polymorphic types"},
{"lineNum":"  392","line":"  template <class Archive, class T> inline"},
{"lineNum":"  393","line":"  typename std::enable_if<std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  394","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::weak_ptr<T> & ptr )"},
{"lineNum":"  395","line":"  {"},
{"lineNum":"  396","line":"    std::shared_ptr<T> sptr;"},
{"lineNum":"  397","line":"    ar( CEREAL_NVP_(\"locked_ptr\", sptr) );"},
{"lineNum":"  398","line":"    ptr = sptr;"},
{"lineNum":"  399","line":"  }"},
{"lineNum":"  400","line":""},
{"lineNum":"  401","line":"  //! Saving std::unique_ptr for polymorphic types that are abstract"},
{"lineNum":"  402","line":"  template <class Archive, class T, class D> inline"},
{"lineNum":"  403","line":"  typename std::enable_if<std::is_polymorphic<T>::value && std::is_abstract<T>::value, void>::type"},
{"lineNum":"  404","line":"  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> const & ptr )"},
{"lineNum":"  405","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  406","line":"    if(!ptr)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  407","line":"    {"},
{"lineNum":"  408","line":"      // same behavior as nullptr in memory implementation"},
{"lineNum":"  409","line":"      ar( CEREAL_NVP_(\"polymorphic_id\", std::uint32_t(0)) );"},
{"lineNum":"  410","line":"      return;"},
{"lineNum":"  411","line":"    }"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"    std::type_info const & ptrinfo = typeid(*ptr.get());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  414","line":"    static std::type_info const & tinfo = typeid(T);"},
{"lineNum":"  415","line":"    // ptrinfo can never be equal to T info since we can\'t have an instance"},
{"lineNum":"  416","line":"    // of an abstract object"},
{"lineNum":"  417","line":"    //  this implies we need to do the lookup"},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"    auto const & bindingMap = detail::StaticObject<detail::OutputBindingMap<Archive>>::getInstance().map;"},
{"lineNum":"  420","line":""},
{"lineNum":"  421","line":"    auto binding = bindingMap.find(std::type_index(ptrinfo));"},
{"lineNum":"  422","line":"    if(binding == bindingMap.end())"},
{"lineNum":"  423","line":"      UNREGISTERED_POLYMORPHIC_EXCEPTION(save, cereal::util::demangle(ptrinfo.name()))","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"    binding->second.unique_ptr(&ar, ptr.get(), tinfo);"},
{"lineNum":"  426","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  427","line":""},
{"lineNum":"  428","line":"  //! Saving std::unique_ptr for polymorphic types, not abstract"},
{"lineNum":"  429","line":"  template <class Archive, class T, class D> inline"},
{"lineNum":"  430","line":"  typename std::enable_if<std::is_polymorphic<T>::value && !std::is_abstract<T>::value, void>::type"},
{"lineNum":"  431","line":"  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> const & ptr )"},
{"lineNum":"  432","line":"  {"},
{"lineNum":"  433","line":"    if(!ptr)"},
{"lineNum":"  434","line":"    {"},
{"lineNum":"  435","line":"      // same behavior as nullptr in memory implementation"},
{"lineNum":"  436","line":"      ar( CEREAL_NVP_(\"polymorphic_id\", std::uint32_t(0)) );"},
{"lineNum":"  437","line":"      return;"},
{"lineNum":"  438","line":"    }"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"    std::type_info const & ptrinfo = typeid(*ptr.get());"},
{"lineNum":"  441","line":"    static std::type_info const & tinfo = typeid(T);"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"    if(ptrinfo == tinfo)"},
{"lineNum":"  444","line":"    {"},
{"lineNum":"  445","line":"      // The 2nd msb signals that the following pointer does not need to be"},
{"lineNum":"  446","line":"      // cast with our polymorphic machinery"},
{"lineNum":"  447","line":"      ar( CEREAL_NVP_(\"polymorphic_id\", detail::msb2_32bit) );"},
{"lineNum":"  448","line":""},
{"lineNum":"  449","line":"      ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper(ptr)) );"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"      return;"},
{"lineNum":"  452","line":"    }"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"    auto const & bindingMap = detail::StaticObject<detail::OutputBindingMap<Archive>>::getInstance().map;"},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"    auto binding = bindingMap.find(std::type_index(ptrinfo));"},
{"lineNum":"  457","line":"    if(binding == bindingMap.end())"},
{"lineNum":"  458","line":"      UNREGISTERED_POLYMORPHIC_EXCEPTION(save, cereal::util::demangle(ptrinfo.name()))"},
{"lineNum":"  459","line":""},
{"lineNum":"  460","line":"    binding->second.unique_ptr(&ar, ptr.get(), tinfo);"},
{"lineNum":"  461","line":"  }"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"  //! Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types"},
{"lineNum":"  464","line":"  template <class Archive, class T, class D> inline"},
{"lineNum":"  465","line":"  typename std::enable_if<std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  466","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> & ptr )"},
{"lineNum":"  467","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  468","line":"    std::uint32_t nameid;"},
{"lineNum":"  469","line":"    ar( CEREAL_NVP_(\"polymorphic_id\", nameid) );"},
{"lineNum":"  470","line":""},
{"lineNum":"  471","line":"    // Check to see if we can skip all of this polymorphism business"},
{"lineNum":"  472","line":"    if(polymorphic_detail::serialize_wrapper(ar, ptr, nameid))"},
{"lineNum":"  473","line":"      return;"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"    auto binding = polymorphic_detail::getInputBinding(ar, nameid);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  476","line":"    std::unique_ptr<void, ::cereal::detail::EmptyDeleter<void>> result;"},
{"lineNum":"  477","line":"    binding.unique_ptr(&ar, result, typeid(T));"},
{"lineNum":"  478","line":"    ptr.reset(static_cast<T*>(result.release()));"},
{"lineNum":"  479","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"  #undef UNREGISTERED_POLYMORPHIC_EXCEPTION"},
{"lineNum":"  482","line":"} // namespace cereal"},
{"lineNum":"  483","line":"#endif // CEREAL_TYPES_POLYMORPHIC_HPP_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 52, "covered" : 0,};
var merged_data = [];
