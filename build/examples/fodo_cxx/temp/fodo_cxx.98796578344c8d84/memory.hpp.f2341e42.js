var data = {lines:[
{"lineNum":"    1","line":"/*! \\file memory.hpp"},
{"lineNum":"    2","line":"    \\brief Support for types found in \\<memory\\>"},
{"lineNum":"    3","line":"    \\ingroup STLSupport */"},
{"lineNum":"    4","line":"/*"},
{"lineNum":"    5","line":"  Copyright (c) 2014, Randolph Voorhies, Shane Grant"},
{"lineNum":"    6","line":"  All rights reserved."},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"  Redistribution and use in source and binary forms, with or without"},
{"lineNum":"    9","line":"  modification, are permitted provided that the following conditions are met:"},
{"lineNum":"   10","line":"      * Redistributions of source code must retain the above copyright"},
{"lineNum":"   11","line":"        notice, this list of conditions and the following disclaimer."},
{"lineNum":"   12","line":"      * Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   13","line":"        notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   14","line":"        documentation and/or other materials provided with the distribution."},
{"lineNum":"   15","line":"      * Neither the name of cereal nor the"},
{"lineNum":"   16","line":"        names of its contributors may be used to endorse or promote products"},
{"lineNum":"   17","line":"        derived from this software without specific prior written permission."},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND"},
{"lineNum":"   20","line":"  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED"},
{"lineNum":"   21","line":"  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE"},
{"lineNum":"   22","line":"  DISCLAIMED. IN NO EVENT SHALL RANDOLPH VOORHIES OR SHANE GRANT BE LIABLE FOR ANY"},
{"lineNum":"   23","line":"  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES"},
{"lineNum":"   24","line":"  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;"},
{"lineNum":"   25","line":"  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND"},
{"lineNum":"   26","line":"  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT"},
{"lineNum":"   27","line":"  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   28","line":"  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   29","line":"*/"},
{"lineNum":"   30","line":"#ifndef CEREAL_TYPES_SHARED_PTR_HPP_"},
{"lineNum":"   31","line":"#define CEREAL_TYPES_SHARED_PTR_HPP_"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"#include \"cereal/cereal.hpp\""},
{"lineNum":"   34","line":"#include <memory>"},
{"lineNum":"   35","line":"#include <cstring>"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"namespace cereal"},
{"lineNum":"   38","line":"{"},
{"lineNum":"   39","line":"  namespace memory_detail"},
{"lineNum":"   40","line":"  {"},
{"lineNum":"   41","line":"    //! A wrapper class to notify cereal that it is ok to serialize the contained pointer"},
{"lineNum":"   42","line":"    /*! This mechanism allows us to intercept and properly handle polymorphic pointers"},
{"lineNum":"   43","line":"        @internal */"},
{"lineNum":"   44","line":"    template<class T>"},
{"lineNum":"   45","line":"    struct PtrWrapper"},
{"lineNum":"   46","line":"    {"},
{"lineNum":"   47","line":"      PtrWrapper(T && p) : ptr(std::forward<T>(p)) {}"},
{"lineNum":"   48","line":"      T & ptr;"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"      PtrWrapper( PtrWrapper const & ) = default;"},
{"lineNum":"   51","line":"      PtrWrapper & operator=( PtrWrapper const & ) = delete;"},
{"lineNum":"   52","line":"    };"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"    //! Make a PtrWrapper"},
{"lineNum":"   55","line":"    /*! @internal */"},
{"lineNum":"   56","line":"    template<class T> inline"},
{"lineNum":"   57","line":"    PtrWrapper<T> make_ptr_wrapper(T && t)"},
{"lineNum":"   58","line":"    {"},
{"lineNum":"   59","line":"      return {std::forward<T>(t)};"},
{"lineNum":"   60","line":"    }"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"    //! A struct that acts as a wrapper around calling load_andor_construct"},
{"lineNum":"   63","line":"    /*! The purpose of this is to allow a load_and_construct call to properly enter into the"},
{"lineNum":"   64","line":"        \'data\' NVP of the ptr_wrapper"},
{"lineNum":"   65","line":"        @internal */"},
{"lineNum":"   66","line":"    template <class Archive, class T>"},
{"lineNum":"   67","line":"    struct LoadAndConstructLoadWrapper"},
{"lineNum":"   68","line":"    {"},
{"lineNum":"   69","line":"      LoadAndConstructLoadWrapper( T * ptr ) :"},
{"lineNum":"   70","line":"        construct( ptr )"},
{"lineNum":"   71","line":"      { }"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"      //! Constructor for embedding an early call for restoring shared_from_this"},
{"lineNum":"   74","line":"      template <class F>"},
{"lineNum":"   75","line":"      LoadAndConstructLoadWrapper( T * ptr, F && sharedFromThisFunc ) :"},
{"lineNum":"   76","line":"        construct( ptr, sharedFromThisFunc )"},
{"lineNum":"   77","line":"      { }"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"      inline void CEREAL_SERIALIZE_FUNCTION_NAME( Archive & ar )"},
{"lineNum":"   80","line":"      {"},
{"lineNum":"   81","line":"        ::cereal::detail::Construct<T, Archive>::load_andor_construct( ar, construct );"},
{"lineNum":"   82","line":"      }"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"      ::cereal::construct<T> construct;"},
{"lineNum":"   85","line":"    };"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"    //! A helper struct for saving and restoring the state of types that derive from"},
{"lineNum":"   88","line":"    //! std::enable_shared_from_this"},
{"lineNum":"   89","line":"    /*! This special struct is necessary because when a user uses load_and_construct,"},
{"lineNum":"   90","line":"        the weak_ptr (or whatever implementation defined variant) that allows"},
{"lineNum":"   91","line":"        enable_shared_from_this to function correctly will not be initialized properly."},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"        This internal weak_ptr can also be modified by the shared_ptr that is created"},
{"lineNum":"   94","line":"        during the serialization of a polymorphic pointer, where cereal creates a"},
{"lineNum":"   95","line":"        wrapper shared_ptr out of a void pointer to the real data."},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"        In the case of load_and_construct, this happens because it is the allocation"},
{"lineNum":"   98","line":"        of shared_ptr that perform this initialization, which we let happen on a buffer"},
{"lineNum":"   99","line":"        of memory (aligned_storage).  This buffer is then used for placement new"},
{"lineNum":"  100","line":"        later on, effectively overwriting any initialized weak_ptr with a default"},
{"lineNum":"  101","line":"        initialized one, eventually leading to issues when the user calls shared_from_this."},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"        To get around these issues, we will store the memory for the enable_shared_from_this"},
{"lineNum":"  104","line":"        portion of the class and replace it after whatever happens to modify it (e.g. the"},
{"lineNum":"  105","line":"        user performing construction or the wrapper shared_ptr in saving)."},
{"lineNum":"  106","line":""},
{"lineNum":"  107","line":"        Note that this goes into undefined behavior territory, but as of the initial writing"},
{"lineNum":"  108","line":"        of this, all standard library implementations of std::enable_shared_from_this are"},
{"lineNum":"  109","line":"        compatible with this memory manipulation. It is entirely possible that this may someday"},
{"lineNum":"  110","line":"        break or may not work with convoluted use cases."},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"        Example usage:"},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"        @code{.cpp}"},
{"lineNum":"  115","line":"        T * myActualPointer;"},
{"lineNum":"  116","line":"        {"},
{"lineNum":"  117","line":"          EnableSharedStateHelper<T> helper( myActualPointer ); // save the state"},
{"lineNum":"  118","line":"          std::shared_ptr<T> myPtr( myActualPointer ); // modifies the internal weak_ptr"},
{"lineNum":"  119","line":"          // helper restores state when it goes out of scope"},
{"lineNum":"  120","line":"        }"},
{"lineNum":"  121","line":"        @endcode"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"        When possible, this is designed to be used in an RAII fashion - it will save state on"},
{"lineNum":"  124","line":"        construction and restore it on destruction. The restore can be done at an earlier time"},
{"lineNum":"  125","line":"        (e.g. after construct() is called in load_and_construct) in which case the destructor will"},
{"lineNum":"  126","line":"        do nothing. Performing the restore immediately following construct() allows a user to call"},
{"lineNum":"  127","line":"        shared_from_this within their load_and_construct function."},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"        @tparam T Type pointed to by shared_ptr"},
{"lineNum":"  130","line":"        @internal */"},
{"lineNum":"  131","line":"    template <class T>"},
{"lineNum":"  132","line":"    class EnableSharedStateHelper"},
{"lineNum":"  133","line":"    {"},
{"lineNum":"  134","line":"      // typedefs for parent type and storage type"},
{"lineNum":"  135","line":"      using BaseType = typename ::cereal::traits::get_shared_from_this_base<T>::type;"},
{"lineNum":"  136","line":"      using ParentType = std::enable_shared_from_this<BaseType>;"},
{"lineNum":"  137","line":"      using StorageType = typename std::aligned_storage<sizeof(ParentType), CEREAL_ALIGNOF(ParentType)>::type;"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"      public:"},
{"lineNum":"  140","line":"        //! Saves the state of some type inheriting from enable_shared_from_this"},
{"lineNum":"  141","line":"        /*! @param ptr The raw pointer held by the shared_ptr */"},
{"lineNum":"  142","line":"        inline EnableSharedStateHelper( T * ptr ) :"},
{"lineNum":"  143","line":"          itsPtr( static_cast<ParentType *>( ptr ) ),"},
{"lineNum":"  144","line":"          itsState(),"},
{"lineNum":"  145","line":"          itsRestored( false )"},
{"lineNum":"  146","line":"        {"},
{"lineNum":"  147","line":"          std::memcpy( &itsState, itsPtr, sizeof(ParentType) );"},
{"lineNum":"  148","line":"        }"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"        //! Restores the state of the held pointer (can only be done once)"},
{"lineNum":"  151","line":"        inline void restore()"},
{"lineNum":"  152","line":"        {"},
{"lineNum":"  153","line":"          if( !itsRestored )"},
{"lineNum":"  154","line":"          {"},
{"lineNum":"  155","line":"            // void * cast needed when type has no trivial copy-assignment"},
{"lineNum":"  156","line":"            std::memcpy( static_cast<void *>(itsPtr), &itsState, sizeof(ParentType) );"},
{"lineNum":"  157","line":"            itsRestored = true;"},
{"lineNum":"  158","line":"          }"},
{"lineNum":"  159","line":"        }"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"        //! Restores the state of the held pointer if not done previously"},
{"lineNum":"  162","line":"        inline ~EnableSharedStateHelper()"},
{"lineNum":"  163","line":"        {"},
{"lineNum":"  164","line":"          restore();"},
{"lineNum":"  165","line":"        }"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"      private:"},
{"lineNum":"  168","line":"        ParentType * itsPtr;"},
{"lineNum":"  169","line":"        StorageType itsState;"},
{"lineNum":"  170","line":"        bool itsRestored;"},
{"lineNum":"  171","line":"    }; // end EnableSharedStateHelper"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"    //! Performs loading and construction for a shared pointer that is derived from"},
{"lineNum":"  174","line":"    //! std::enable_shared_from_this"},
{"lineNum":"  175","line":"    /*! @param ar The archive"},
{"lineNum":"  176","line":"        @param ptr Raw pointer held by the shared_ptr"},
{"lineNum":"  177","line":"        @internal */"},
{"lineNum":"  178","line":"    template <class Archive, class T> inline"},
{"lineNum":"  179","line":"    void loadAndConstructSharedPtr( Archive & ar, T * ptr, std::true_type /* has_shared_from_this */ )"},
{"lineNum":"  180","line":"    {"},
{"lineNum":"  181","line":"      memory_detail::EnableSharedStateHelper<T> state( ptr );"},
{"lineNum":"  182","line":"      memory_detail::LoadAndConstructLoadWrapper<Archive, T> loadWrapper( ptr, [&](){ state.restore(); } );"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"      // let the user perform their initialization, shared state will be restored as soon as construct()"},
{"lineNum":"  185","line":"      // is called"},
{"lineNum":"  186","line":"      ar( CEREAL_NVP_(\"data\", loadWrapper) );"},
{"lineNum":"  187","line":"    }"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"    //! Performs loading and construction for a shared pointer that is NOT derived from"},
{"lineNum":"  190","line":"    //! std::enable_shared_from_this"},
{"lineNum":"  191","line":"    /*! This is the typical case, where we simply pass the load wrapper to the"},
{"lineNum":"  192","line":"        archive."},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"        @param ar The archive"},
{"lineNum":"  195","line":"        @param ptr Raw pointer held by the shared_ptr"},
{"lineNum":"  196","line":"        @internal */"},
{"lineNum":"  197","line":"    template <class Archive, class T> inline"},
{"lineNum":"  198","line":"    void loadAndConstructSharedPtr( Archive & ar, T * ptr, std::false_type /* has_shared_from_this */ )"},
{"lineNum":"  199","line":"    {"},
{"lineNum":"  200","line":"      memory_detail::LoadAndConstructLoadWrapper<Archive, T> loadWrapper( ptr );"},
{"lineNum":"  201","line":"      ar( CEREAL_NVP_(\"data\", loadWrapper) );"},
{"lineNum":"  202","line":"    }"},
{"lineNum":"  203","line":"  } // end namespace memory_detail"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"  //! Saving std::shared_ptr for non polymorphic types"},
{"lineNum":"  206","line":"  template <class Archive, class T> inline"},
{"lineNum":"  207","line":"  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  208","line":"  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> const & ptr )"},
{"lineNum":"  209","line":"  {"},
{"lineNum":"  210","line":"    ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper( ptr )) );","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  211","line":"  }"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"  //! Loading std::shared_ptr, case when no user load and construct for non polymorphic types"},
{"lineNum":"  214","line":"  template <class Archive, class T> inline"},
{"lineNum":"  215","line":"  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  216","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::shared_ptr<T> & ptr )"},
{"lineNum":"  217","line":"  {"},
{"lineNum":"  218","line":"    ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper( ptr )) );","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  219","line":"  }"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"  //! Saving std::weak_ptr for non polymorphic types"},
{"lineNum":"  222","line":"  template <class Archive, class T> inline"},
{"lineNum":"  223","line":"  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  224","line":"  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::weak_ptr<T> const & ptr )"},
{"lineNum":"  225","line":"  {"},
{"lineNum":"  226","line":"    auto const sptr = ptr.lock();"},
{"lineNum":"  227","line":"    ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper( sptr )) );"},
{"lineNum":"  228","line":"  }"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"  //! Loading std::weak_ptr for non polymorphic types"},
{"lineNum":"  231","line":"  template <class Archive, class T> inline"},
{"lineNum":"  232","line":"  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  233","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::weak_ptr<T> & ptr )"},
{"lineNum":"  234","line":"  {"},
{"lineNum":"  235","line":"    std::shared_ptr<T> sptr;"},
{"lineNum":"  236","line":"    ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper( sptr )) );"},
{"lineNum":"  237","line":"    ptr = sptr;"},
{"lineNum":"  238","line":"  }"},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"  //! Saving std::unique_ptr for non polymorphic types"},
{"lineNum":"  241","line":"  template <class Archive, class T, class D> inline"},
{"lineNum":"  242","line":"  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  243","line":"  CEREAL_SAVE_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> const & ptr )"},
{"lineNum":"  244","line":"  {"},
{"lineNum":"  245","line":"    ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper( ptr )) );","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  246","line":"  }"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"  //! Loading std::unique_ptr, case when user provides load_and_construct for non polymorphic types"},
{"lineNum":"  249","line":"  template <class Archive, class T, class D> inline"},
{"lineNum":"  250","line":"  typename std::enable_if<!std::is_polymorphic<T>::value, void>::type"},
{"lineNum":"  251","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, std::unique_ptr<T, D> & ptr )"},
{"lineNum":"  252","line":"  {"},
{"lineNum":"  253","line":"    ar( CEREAL_NVP_(\"ptr_wrapper\", memory_detail::make_ptr_wrapper( ptr )) );","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  254","line":"  }"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"  // ######################################################################"},
{"lineNum":"  257","line":"  // Pointer wrapper implementations follow below"},
{"lineNum":"  258","line":""},
{"lineNum":"  259","line":"  //! Saving std::shared_ptr (wrapper implementation)"},
{"lineNum":"  260","line":"  /*! @internal */"},
{"lineNum":"  261","line":"  template <class Archive, class T> inline"},
{"lineNum":"  262","line":"  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::shared_ptr<T> const &> const & wrapper )"},
{"lineNum":"  263","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"74",},
{"lineNum":"  264","line":"    auto & ptr = wrapper.ptr;","class":"lineNoCov","hits":"0","possible_hits":"84",},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"    uint32_t id = ar.registerSharedPointer( ptr );","class":"lineNoCov","hits":"0","possible_hits":"212",},
{"lineNum":"  267","line":"    ar( CEREAL_NVP_(\"id\", id) );","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"    if( id & detail::msb_32bit )","class":"lineNoCov","hits":"0","possible_hits":"105",},
{"lineNum":"  270","line":"    {"},
{"lineNum":"  271","line":"      ar( CEREAL_NVP_(\"data\", *ptr) );","class":"lineNoCov","hits":"0","possible_hits":"34",},
{"lineNum":"  272","line":"    }"},
{"lineNum":"  273","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"128",},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"  //! Loading std::shared_ptr, case when user load and construct (wrapper implementation)"},
{"lineNum":"  276","line":"  /*! @internal */"},
{"lineNum":"  277","line":"  template <class Archive, class T> inline"},
{"lineNum":"  278","line":"  typename std::enable_if<traits::has_load_and_construct<T, Archive>::value, void>::type"},
{"lineNum":"  279","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::shared_ptr<T> &> & wrapper )"},
{"lineNum":"  280","line":"  {"},
{"lineNum":"  281","line":"    uint32_t id;"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"    ar( CEREAL_NVP_(\"id\", id) );"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"    if( id & detail::msb_32bit )"},
{"lineNum":"  286","line":"    {"},
{"lineNum":"  287","line":"      // Storage type for the pointer - since we can\'t default construct this type,"},
{"lineNum":"  288","line":"      // we\'ll allocate it using std::aligned_storage and use a custom deleter"},
{"lineNum":"  289","line":"      using ST = typename std::aligned_storage<sizeof(T), CEREAL_ALIGNOF(T)>::type;"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"      // Valid flag - set to true once construction finishes"},
{"lineNum":"  292","line":"      //  This prevents us from calling the destructor on"},
{"lineNum":"  293","line":"      //  uninitialized data."},
{"lineNum":"  294","line":"      auto valid = std::make_shared<bool>( false );"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"      // Allocate our storage, which we will treat as"},
{"lineNum":"  297","line":"      //  uninitialized until initialized with placement new"},
{"lineNum":"  298","line":"      using NonConstT = typename std::remove_const<T>::type;"},
{"lineNum":"  299","line":"      std::shared_ptr<NonConstT> ptr(reinterpret_cast<NonConstT *>(new ST()),"},
{"lineNum":"  300","line":"          [=]( NonConstT * t )"},
{"lineNum":"  301","line":"          {"},
{"lineNum":"  302","line":"            if( *valid )"},
{"lineNum":"  303","line":"              t->~T();"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"            delete reinterpret_cast<ST *>( t );"},
{"lineNum":"  306","line":"          } );"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"      // Register the pointer"},
{"lineNum":"  309","line":"      ar.registerSharedPointer( id, ptr );"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"      // Perform the actual loading and allocation"},
{"lineNum":"  312","line":"      memory_detail::loadAndConstructSharedPtr( ar, ptr.get(), typename ::cereal::traits::has_shared_from_this<NonConstT>::type() );"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"      // Mark pointer as valid (initialized)"},
{"lineNum":"  315","line":"      *valid = true;"},
{"lineNum":"  316","line":"      wrapper.ptr = std::move(ptr);"},
{"lineNum":"  317","line":"    }"},
{"lineNum":"  318","line":"    else"},
{"lineNum":"  319","line":"      wrapper.ptr = std::static_pointer_cast<T>(ar.getSharedPointer(id));"},
{"lineNum":"  320","line":"  }"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"  //! Loading std::shared_ptr, case when no user load and construct (wrapper implementation)"},
{"lineNum":"  323","line":"  /*! @internal */"},
{"lineNum":"  324","line":"  template <class Archive, class T> inline"},
{"lineNum":"  325","line":"  typename std::enable_if<!traits::has_load_and_construct<T, Archive>::value, void>::type"},
{"lineNum":"  326","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::shared_ptr<T> &> & wrapper )"},
{"lineNum":"  327","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"84",},
{"lineNum":"  328","line":"    uint32_t id;"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"    ar( CEREAL_NVP_(\"id\", id) );","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"    if( id & detail::msb_32bit )","class":"lineNoCov","hits":"0","possible_hits":"84",},
{"lineNum":"  333","line":"    {"},
{"lineNum":"  334","line":"      using NonConstT = typename std::remove_const<T>::type;"},
{"lineNum":"  335","line":"      std::shared_ptr<NonConstT> ptr( detail::Construct<NonConstT, Archive>::load_andor_construct() );","class":"lineNoCov","hits":"0","possible_hits":"47",},
{"lineNum":"  336","line":"      ar.registerSharedPointer( id, ptr );","class":"lineNoCov","hits":"0","possible_hits":"111",},
{"lineNum":"  337","line":"      ar( CEREAL_NVP_(\"data\", *ptr) );","class":"lineNoCov","hits":"0","possible_hits":"63",},
{"lineNum":"  338","line":"      wrapper.ptr = std::move(ptr);","class":"lineNoCov","hits":"0","possible_hits":"84",},
{"lineNum":"  339","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"82",},
{"lineNum":"  340","line":"    else"},
{"lineNum":"  341","line":"      wrapper.ptr = std::static_pointer_cast<T>(ar.getSharedPointer(id));","class":"lineNoCov","hits":"0","possible_hits":"168",},
{"lineNum":"  342","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"97",},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"  //! Saving std::unique_ptr (wrapper implementation)"},
{"lineNum":"  345","line":"  /*! @internal */"},
{"lineNum":"  346","line":"  template <class Archive, class T, class D> inline"},
{"lineNum":"  347","line":"  void CEREAL_SAVE_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::unique_ptr<T, D> const &> const & wrapper )"},
{"lineNum":"  348","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"47",},
{"lineNum":"  349","line":"    auto & ptr = wrapper.ptr;","class":"lineNoCov","hits":"0","possible_hits":"65",},
{"lineNum":"  350","line":""},
{"lineNum":"  351","line":"    // unique_ptr get one byte of metadata which signifies whether they were a nullptr"},
{"lineNum":"  352","line":"    // 0 == nullptr"},
{"lineNum":"  353","line":"    // 1 == not null"},
{"lineNum":"  354","line":""},
{"lineNum":"  355","line":"    if( !ptr )","class":"lineNoCov","hits":"0","possible_hits":"83",},
{"lineNum":"  356","line":"      ar( CEREAL_NVP_(\"valid\", uint8_t(0)) );","class":"lineNoCov","hits":"0","possible_hits":"45",},
{"lineNum":"  357","line":"    else"},
{"lineNum":"  358","line":"    {"},
{"lineNum":"  359","line":"      ar( CEREAL_NVP_(\"valid\", uint8_t(1)) );","class":"lineNoCov","hits":"0","possible_hits":"45",},
{"lineNum":"  360","line":"      ar( CEREAL_NVP_(\"data\", *ptr) );","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  361","line":"    }"},
{"lineNum":"  362","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"74",},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"  //! Loading std::unique_ptr, case when user provides load_and_construct (wrapper implementation)"},
{"lineNum":"  365","line":"  /*! @internal */"},
{"lineNum":"  366","line":"  template <class Archive, class T, class D> inline"},
{"lineNum":"  367","line":"  typename std::enable_if<traits::has_load_and_construct<T, Archive>::value, void>::type"},
{"lineNum":"  368","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::unique_ptr<T, D> &> & wrapper )"},
{"lineNum":"  369","line":"  {"},
{"lineNum":"  370","line":"    uint8_t isValid;"},
{"lineNum":"  371","line":"    ar( CEREAL_NVP_(\"valid\", isValid) );"},
{"lineNum":"  372","line":""},
{"lineNum":"  373","line":"    auto & ptr = wrapper.ptr;"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"    if( isValid )"},
{"lineNum":"  376","line":"    {"},
{"lineNum":"  377","line":"      using NonConstT = typename std::remove_const<T>::type;"},
{"lineNum":"  378","line":"      // Storage type for the pointer - since we can\'t default construct this type,"},
{"lineNum":"  379","line":"      // we\'ll allocate it using std::aligned_storage"},
{"lineNum":"  380","line":"      using ST = typename std::aligned_storage<sizeof(NonConstT), CEREAL_ALIGNOF(NonConstT)>::type;"},
{"lineNum":"  381","line":""},
{"lineNum":"  382","line":"      // Allocate storage - note the ST type so that deleter is correct if"},
{"lineNum":"  383","line":"      //                    an exception is thrown before we are initialized"},
{"lineNum":"  384","line":"      std::unique_ptr<ST> stPtr( new ST() );"},
{"lineNum":"  385","line":""},
{"lineNum":"  386","line":"      // Use wrapper to enter into \"data\" nvp of ptr_wrapper"},
{"lineNum":"  387","line":"      memory_detail::LoadAndConstructLoadWrapper<Archive, NonConstT> loadWrapper( reinterpret_cast<NonConstT *>( stPtr.get() ) );"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"      // Initialize storage"},
{"lineNum":"  390","line":"      ar( CEREAL_NVP_(\"data\", loadWrapper) );"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"      // Transfer ownership to correct unique_ptr type"},
{"lineNum":"  393","line":"      ptr.reset( reinterpret_cast<T *>( stPtr.release() ) );"},
{"lineNum":"  394","line":"    }"},
{"lineNum":"  395","line":"    else"},
{"lineNum":"  396","line":"      ptr.reset( nullptr );"},
{"lineNum":"  397","line":"  }"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"  //! Loading std::unique_ptr, case when no load_and_construct (wrapper implementation)"},
{"lineNum":"  400","line":"  /*! @internal */"},
{"lineNum":"  401","line":"  template <class Archive, class T, class D> inline"},
{"lineNum":"  402","line":"  typename std::enable_if<!traits::has_load_and_construct<T, Archive>::value, void>::type"},
{"lineNum":"  403","line":"  CEREAL_LOAD_FUNCTION_NAME( Archive & ar, memory_detail::PtrWrapper<std::unique_ptr<T, D> &> & wrapper )"},
{"lineNum":"  404","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"63",},
{"lineNum":"  405","line":"    uint8_t isValid;"},
{"lineNum":"  406","line":"    ar( CEREAL_NVP_(\"valid\", isValid) );","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"    if( isValid )","class":"lineNoCov","hits":"0","possible_hits":"103",},
{"lineNum":"  409","line":"    {"},
{"lineNum":"  410","line":"      using NonConstT = typename std::remove_const<T>::type;"},
{"lineNum":"  411","line":"      std::unique_ptr<NonConstT, D> ptr( detail::Construct<NonConstT, Archive>::load_andor_construct() );","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  412","line":"      ar( CEREAL_NVP_( \"data\", *ptr ) );","class":"lineNoCov","hits":"0","possible_hits":"59",},
{"lineNum":"  413","line":"      wrapper.ptr = std::move(ptr);","class":"lineNoCov","hits":"0","possible_hits":"74",},
{"lineNum":"  414","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"27",},
{"lineNum":"  415","line":"    else"},
{"lineNum":"  416","line":"    {"},
{"lineNum":"  417","line":"      wrapper.ptr.reset( nullptr );","class":"lineNoCov","hits":"0","possible_hits":"74",},
{"lineNum":"  418","line":"    }"},
{"lineNum":"  419","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"111",},
{"lineNum":"  420","line":"} // namespace cereal"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"// automatically include polymorphic support"},
{"lineNum":"  423","line":"#include \"cereal/types/polymorphic.hpp\""},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"#endif // CEREAL_TYPES_SHARED_PTR_HPP_"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 37, "covered" : 0,};
var merged_data = [];
