var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2006-2009 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_PARTIALLU_H"},
{"lineNum":"   12","line":"#define EIGEN_PARTIALLU_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"namespace internal {"},
{"lineNum":"   19","line":"template<typename MatrixType_> struct traits<PartialPivLU<MatrixType_> >"},
{"lineNum":"   20","line":" : traits<MatrixType_>"},
{"lineNum":"   21","line":"{"},
{"lineNum":"   22","line":"  typedef MatrixXpr XprKind;"},
{"lineNum":"   23","line":"  typedef SolverStorage StorageKind;"},
{"lineNum":"   24","line":"  typedef int StorageIndex;"},
{"lineNum":"   25","line":"  typedef traits<MatrixType_> BaseTraits;"},
{"lineNum":"   26","line":"  enum {"},
{"lineNum":"   27","line":"    Flags = BaseTraits::Flags & RowMajorBit,"},
{"lineNum":"   28","line":"    CoeffReadCost = Dynamic"},
{"lineNum":"   29","line":"  };"},
{"lineNum":"   30","line":"};"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"template<typename T,typename Derived>"},
{"lineNum":"   33","line":"struct enable_if_ref;"},
{"lineNum":"   34","line":"// {"},
{"lineNum":"   35","line":"//   typedef Derived type;"},
{"lineNum":"   36","line":"// };"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"template<typename T,typename Derived>"},
{"lineNum":"   39","line":"struct enable_if_ref<Ref<T>,Derived> {"},
{"lineNum":"   40","line":"  typedef Derived type;"},
{"lineNum":"   41","line":"};"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"} // end namespace internal"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"/** \\ingroup LU_Module"},
{"lineNum":"   46","line":"  *"},
{"lineNum":"   47","line":"  * \\class PartialPivLU"},
{"lineNum":"   48","line":"  *"},
{"lineNum":"   49","line":"  * \\brief LU decomposition of a matrix with partial pivoting, and related features"},
{"lineNum":"   50","line":"  *"},
{"lineNum":"   51","line":"  * \\tparam MatrixType_ the type of the matrix of which we are computing the LU decomposition"},
{"lineNum":"   52","line":"  *"},
{"lineNum":"   53","line":"  * This class represents a LU decomposition of a \\b square \\b invertible matrix, with partial pivoting: the matrix A"},
{"lineNum":"   54","line":"  * is decomposed as A = PLU where L is unit-lower-triangular, U is upper-triangular, and P"},
{"lineNum":"   55","line":"  * is a permutation matrix."},
{"lineNum":"   56","line":"  *"},
{"lineNum":"   57","line":"  * Typically, partial pivoting LU decomposition is only considered numerically stable for square invertible"},
{"lineNum":"   58","line":"  * matrices. Thus LAPACK\'s dgesv and dgesvx require the matrix to be square and invertible. The present class"},
{"lineNum":"   59","line":"  * does the same. It will assert that the matrix is square, but it won\'t (actually it can\'t) check that the"},
{"lineNum":"   60","line":"  * matrix is invertible: it is your task to check that you only use this decomposition on invertible matrices."},
{"lineNum":"   61","line":"  *"},
{"lineNum":"   62","line":"  * The guaranteed safe alternative, working for all matrices, is the full pivoting LU decomposition, provided"},
{"lineNum":"   63","line":"  * by class FullPivLU."},
{"lineNum":"   64","line":"  *"},
{"lineNum":"   65","line":"  * This is \\b not a rank-revealing LU decomposition. Many features are intentionally absent from this class,"},
{"lineNum":"   66","line":"  * such as rank computation. If you need these features, use class FullPivLU."},
{"lineNum":"   67","line":"  *"},
{"lineNum":"   68","line":"  * This LU decomposition is suitable to invert invertible matrices. It is what MatrixBase::inverse() uses"},
{"lineNum":"   69","line":"  * in the general case."},
{"lineNum":"   70","line":"  * On the other hand, it is \\b not suitable to determine whether a given matrix is invertible."},
{"lineNum":"   71","line":"  *"},
{"lineNum":"   72","line":"  * The data of the LU decomposition can be directly accessed through the methods matrixLU(), permutationP()."},
{"lineNum":"   73","line":"  *"},
{"lineNum":"   74","line":"  * This class supports the \\link InplaceDecomposition inplace decomposition \\endlink mechanism."},
{"lineNum":"   75","line":"  *"},
{"lineNum":"   76","line":"  * \\sa MatrixBase::partialPivLu(), MatrixBase::determinant(), MatrixBase::inverse(), MatrixBase::computeInverse(), class FullPivLU"},
{"lineNum":"   77","line":"  */"},
{"lineNum":"   78","line":"template<typename MatrixType_> class PartialPivLU"},
{"lineNum":"   79","line":"  : public SolverBase<PartialPivLU<MatrixType_> >"},
{"lineNum":"   80","line":"{"},
{"lineNum":"   81","line":"  public:"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"    typedef MatrixType_ MatrixType;"},
{"lineNum":"   84","line":"    typedef SolverBase<PartialPivLU> Base;"},
{"lineNum":"   85","line":"    friend class SolverBase<PartialPivLU>;"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"    EIGEN_GENERIC_PUBLIC_INTERFACE(PartialPivLU)"},
{"lineNum":"   88","line":"    enum {"},
{"lineNum":"   89","line":"      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,"},
{"lineNum":"   90","line":"      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime"},
{"lineNum":"   91","line":"    };"},
{"lineNum":"   92","line":"    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;"},
{"lineNum":"   93","line":"    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;"},
{"lineNum":"   94","line":"    typedef typename MatrixType::PlainObject PlainObject;"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"    /**"},
{"lineNum":"   97","line":"      * \\brief Default Constructor."},
{"lineNum":"   98","line":"      *"},
{"lineNum":"   99","line":"      * The default constructor is useful in cases in which the user intends to"},
{"lineNum":"  100","line":"      * perform decompositions via PartialPivLU::compute(const MatrixType&)."},
{"lineNum":"  101","line":"      */"},
{"lineNum":"  102","line":"    PartialPivLU();"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"    /** \\brief Default Constructor with memory preallocation"},
{"lineNum":"  105","line":"      *"},
{"lineNum":"  106","line":"      * Like the default constructor but with preallocation of the internal data"},
{"lineNum":"  107","line":"      * according to the specified problem \\a size."},
{"lineNum":"  108","line":"      * \\sa PartialPivLU()"},
{"lineNum":"  109","line":"      */"},
{"lineNum":"  110","line":"    explicit PartialPivLU(Index size);"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"    /** Constructor."},
{"lineNum":"  113","line":"      *"},
{"lineNum":"  114","line":"      * \\param matrix the matrix of which to compute the LU decomposition."},
{"lineNum":"  115","line":"      *"},
{"lineNum":"  116","line":"      * \\warning The matrix should have full rank (e.g. if it\'s square, it should be invertible)."},
{"lineNum":"  117","line":"      * If you need to deal with non-full rank, use class FullPivLU instead."},
{"lineNum":"  118","line":"      */"},
{"lineNum":"  119","line":"    template<typename InputType>"},
{"lineNum":"  120","line":"    explicit PartialPivLU(const EigenBase<InputType>& matrix);"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"    /** Constructor for \\link InplaceDecomposition inplace decomposition \\endlink"},
{"lineNum":"  123","line":"      *"},
{"lineNum":"  124","line":"      * \\param matrix the matrix of which to compute the LU decomposition."},
{"lineNum":"  125","line":"      *"},
{"lineNum":"  126","line":"      * \\warning The matrix should have full rank (e.g. if it\'s square, it should be invertible)."},
{"lineNum":"  127","line":"      * If you need to deal with non-full rank, use class FullPivLU instead."},
{"lineNum":"  128","line":"      */"},
{"lineNum":"  129","line":"    template<typename InputType>"},
{"lineNum":"  130","line":"    explicit PartialPivLU(EigenBase<InputType>& matrix);"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"    template<typename InputType>"},
{"lineNum":"  133","line":"    PartialPivLU& compute(const EigenBase<InputType>& matrix) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  134","line":"      m_lu = matrix.derived();"},
{"lineNum":"  135","line":"      compute();","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  136","line":"      return *this;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  137","line":"    }"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"    /** \\returns the LU decomposition matrix: the upper-triangular part is U, the"},
{"lineNum":"  140","line":"      * unit-lower-triangular part is L (at least for square matrices; in the non-square"},
{"lineNum":"  141","line":"      * case, special care is needed, see the documentation of class FullPivLU)."},
{"lineNum":"  142","line":"      *"},
{"lineNum":"  143","line":"      * \\sa matrixL(), matrixU()"},
{"lineNum":"  144","line":"      */"},
{"lineNum":"  145","line":"    inline const MatrixType& matrixLU() const"},
{"lineNum":"  146","line":"    {"},
{"lineNum":"  147","line":"      eigen_assert(m_isInitialized && \"PartialPivLU is not initialized.\");"},
{"lineNum":"  148","line":"      return m_lu;"},
{"lineNum":"  149","line":"    }"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"    /** \\returns the permutation matrix P."},
{"lineNum":"  152","line":"      */"},
{"lineNum":"  153","line":"    inline const PermutationType& permutationP() const"},
{"lineNum":"  154","line":"    {"},
{"lineNum":"  155","line":"      eigen_assert(m_isInitialized && \"PartialPivLU is not initialized.\");"},
{"lineNum":"  156","line":"      return m_p;"},
{"lineNum":"  157","line":"    }"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"    #ifdef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  160","line":"    /** This method returns the solution x to the equation Ax=b, where A is the matrix of which"},
{"lineNum":"  161","line":"      * *this is the LU decomposition."},
{"lineNum":"  162","line":"      *"},
{"lineNum":"  163","line":"      * \\param b the right-hand-side of the equation to solve. Can be a vector or a matrix,"},
{"lineNum":"  164","line":"      *          the only requirement in order for the equation to make sense is that"},
{"lineNum":"  165","line":"      *          b.rows()==A.rows(), where A is the matrix of which *this is the LU decomposition."},
{"lineNum":"  166","line":"      *"},
{"lineNum":"  167","line":"      * \\returns the solution."},
{"lineNum":"  168","line":"      *"},
{"lineNum":"  169","line":"      * Example: \\include PartialPivLU_solve.cpp"},
{"lineNum":"  170","line":"      * Output: \\verbinclude PartialPivLU_solve.out"},
{"lineNum":"  171","line":"      *"},
{"lineNum":"  172","line":"      * Since this PartialPivLU class assumes anyway that the matrix A is invertible, the solution"},
{"lineNum":"  173","line":"      * theoretically exists and is unique regardless of b."},
{"lineNum":"  174","line":"      *"},
{"lineNum":"  175","line":"      * \\sa TriangularView::solve(), inverse(), computeInverse()"},
{"lineNum":"  176","line":"      */"},
{"lineNum":"  177","line":"    template<typename Rhs>"},
{"lineNum":"  178","line":"    inline const Solve<PartialPivLU, Rhs>"},
{"lineNum":"  179","line":"    solve(const MatrixBase<Rhs>& b) const;"},
{"lineNum":"  180","line":"    #endif"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"    /** \\returns an estimate of the reciprocal condition number of the matrix of which \\c *this is"},
{"lineNum":"  183","line":"        the LU decomposition."},
{"lineNum":"  184","line":"      */"},
{"lineNum":"  185","line":"    inline RealScalar rcond() const"},
{"lineNum":"  186","line":"    {"},
{"lineNum":"  187","line":"      eigen_assert(m_isInitialized && \"PartialPivLU is not initialized.\");"},
{"lineNum":"  188","line":"      return internal::rcond_estimate_helper(m_l1_norm, *this);"},
{"lineNum":"  189","line":"    }"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"    /** \\returns the inverse of the matrix of which *this is the LU decomposition."},
{"lineNum":"  192","line":"      *"},
{"lineNum":"  193","line":"      * \\warning The matrix being decomposed here is assumed to be invertible. If you need to check for"},
{"lineNum":"  194","line":"      *          invertibility, use class FullPivLU instead."},
{"lineNum":"  195","line":"      *"},
{"lineNum":"  196","line":"      * \\sa MatrixBase::inverse(), LU::inverse()"},
{"lineNum":"  197","line":"      */"},
{"lineNum":"  198","line":"    inline const Inverse<PartialPivLU> inverse() const"},
{"lineNum":"  199","line":"    {"},
{"lineNum":"  200","line":"      eigen_assert(m_isInitialized && \"PartialPivLU is not initialized.\");"},
{"lineNum":"  201","line":"      return Inverse<PartialPivLU>(*this);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  202","line":"    }"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"    /** \\returns the determinant of the matrix of which"},
{"lineNum":"  205","line":"      * *this is the LU decomposition. It has only linear complexity"},
{"lineNum":"  206","line":"      * (that is, O(n) where n is the dimension of the square matrix)"},
{"lineNum":"  207","line":"      * as the LU decomposition has already been computed."},
{"lineNum":"  208","line":"      *"},
{"lineNum":"  209","line":"      * \\note For fixed-size matrices of size up to 4, MatrixBase::determinant() offers"},
{"lineNum":"  210","line":"      *       optimized paths."},
{"lineNum":"  211","line":"      *"},
{"lineNum":"  212","line":"      * \\warning a determinant can be very big or small, so for matrices"},
{"lineNum":"  213","line":"      * of large enough dimension, there is a risk of overflow/underflow."},
{"lineNum":"  214","line":"      *"},
{"lineNum":"  215","line":"      * \\sa MatrixBase::determinant()"},
{"lineNum":"  216","line":"      */"},
{"lineNum":"  217","line":"    Scalar determinant() const;"},
{"lineNum":"  218","line":""},
{"lineNum":"  219","line":"    MatrixType reconstructedMatrix() const;"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"    EIGEN_CONSTEXPR inline Index rows() const EIGEN_NOEXCEPT { return m_lu.rows(); }"},
{"lineNum":"  222","line":"    EIGEN_CONSTEXPR inline Index cols() const EIGEN_NOEXCEPT { return m_lu.cols(); }"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"    #ifndef EIGEN_PARSED_BY_DOXYGEN"},
{"lineNum":"  225","line":"    template<typename RhsType, typename DstType>"},
{"lineNum":"  226","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  227","line":"    void _solve_impl(const RhsType &rhs, DstType &dst) const {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  228","line":"     /* The decomposition PA = LU can be rewritten as A = P^{-1} L U."},
{"lineNum":"  229","line":"      * So we proceed as follows:"},
{"lineNum":"  230","line":"      * Step 1: compute c = Pb."},
{"lineNum":"  231","line":"      * Step 2: replace c by the solution x to Lx = c."},
{"lineNum":"  232","line":"      * Step 3: replace c by the solution x to Ux = c."},
{"lineNum":"  233","line":"      */"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"      // Step 1"},
{"lineNum":"  236","line":"      dst = permutationP() * rhs;"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"      // Step 2"},
{"lineNum":"  239","line":"      m_lu.template triangularView<UnitLower>().solveInPlace(dst);"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"      // Step 3"},
{"lineNum":"  242","line":"      m_lu.template triangularView<Upper>().solveInPlace(dst);"},
{"lineNum":"  243","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"    template<bool Conjugate, typename RhsType, typename DstType>"},
{"lineNum":"  246","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"  247","line":"    void _solve_impl_transposed(const RhsType &rhs, DstType &dst) const {"},
{"lineNum":"  248","line":"     /* The decomposition PA = LU can be rewritten as A^T = U^T L^T P."},
{"lineNum":"  249","line":"      * So we proceed as follows:"},
{"lineNum":"  250","line":"      * Step 1: compute c as the solution to L^T c = b"},
{"lineNum":"  251","line":"      * Step 2: replace c by the solution x to U^T x = c."},
{"lineNum":"  252","line":"      * Step 3: update  c = P^-1 c."},
{"lineNum":"  253","line":"      */"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"      eigen_assert(rhs.rows() == m_lu.cols());"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"      // Step 1"},
{"lineNum":"  258","line":"      dst = m_lu.template triangularView<Upper>().transpose()"},
{"lineNum":"  259","line":"                .template conjugateIf<Conjugate>().solve(rhs);"},
{"lineNum":"  260","line":"      // Step 2"},
{"lineNum":"  261","line":"      m_lu.template triangularView<UnitLower>().transpose()"},
{"lineNum":"  262","line":"          .template conjugateIf<Conjugate>().solveInPlace(dst);"},
{"lineNum":"  263","line":"      // Step 3"},
{"lineNum":"  264","line":"      dst = permutationP().transpose() * dst;"},
{"lineNum":"  265","line":"    }"},
{"lineNum":"  266","line":"    #endif"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"  protected:"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"    EIGEN_STATIC_ASSERT_NON_INTEGER(Scalar)"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"    void compute();"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"    MatrixType m_lu;"},
{"lineNum":"  275","line":"    PermutationType m_p;"},
{"lineNum":"  276","line":"    TranspositionType m_rowsTranspositions;"},
{"lineNum":"  277","line":"    RealScalar m_l1_norm;"},
{"lineNum":"  278","line":"    signed char m_det_p;"},
{"lineNum":"  279","line":"    bool m_isInitialized;"},
{"lineNum":"  280","line":"};"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"template<typename MatrixType>"},
{"lineNum":"  283","line":"PartialPivLU<MatrixType>::PartialPivLU()"},
{"lineNum":"  284","line":"  : m_lu(),"},
{"lineNum":"  285","line":"    m_p(),"},
{"lineNum":"  286","line":"    m_rowsTranspositions(),"},
{"lineNum":"  287","line":"    m_l1_norm(0),"},
{"lineNum":"  288","line":"    m_det_p(0),"},
{"lineNum":"  289","line":"    m_isInitialized(false)"},
{"lineNum":"  290","line":"{"},
{"lineNum":"  291","line":"}"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"template<typename MatrixType>"},
{"lineNum":"  294","line":"PartialPivLU<MatrixType>::PartialPivLU(Index size)"},
{"lineNum":"  295","line":"  : m_lu(size, size),"},
{"lineNum":"  296","line":"    m_p(size),"},
{"lineNum":"  297","line":"    m_rowsTranspositions(size),"},
{"lineNum":"  298","line":"    m_l1_norm(0),"},
{"lineNum":"  299","line":"    m_det_p(0),"},
{"lineNum":"  300","line":"    m_isInitialized(false)"},
{"lineNum":"  301","line":"{"},
{"lineNum":"  302","line":"}"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"template<typename MatrixType>"},
{"lineNum":"  305","line":"template<typename InputType>"},
{"lineNum":"  306","line":"PartialPivLU<MatrixType>::PartialPivLU(const EigenBase<InputType>& matrix)"},
{"lineNum":"  307","line":"  : m_lu(matrix.rows(),matrix.cols()),"},
{"lineNum":"  308","line":"    m_p(matrix.rows()),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  309","line":"    m_rowsTranspositions(matrix.rows()),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  310","line":"    m_l1_norm(0),","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  311","line":"    m_det_p(0),","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  312","line":"    m_isInitialized(false)"},
{"lineNum":"  313","line":"{","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  314","line":"  compute(matrix.derived());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  315","line":"}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"template<typename MatrixType>"},
{"lineNum":"  318","line":"template<typename InputType>"},
{"lineNum":"  319","line":"PartialPivLU<MatrixType>::PartialPivLU(EigenBase<InputType>& matrix)"},
{"lineNum":"  320","line":"  : m_lu(matrix.derived()),"},
{"lineNum":"  321","line":"    m_p(matrix.rows()),"},
{"lineNum":"  322","line":"    m_rowsTranspositions(matrix.rows()),"},
{"lineNum":"  323","line":"    m_l1_norm(0),"},
{"lineNum":"  324","line":"    m_det_p(0),"},
{"lineNum":"  325","line":"    m_isInitialized(false)"},
{"lineNum":"  326","line":"{"},
{"lineNum":"  327","line":"  compute();"},
{"lineNum":"  328","line":"}"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"namespace internal {"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"/** \\internal This is the blocked version of fullpivlu_unblocked() */"},
{"lineNum":"  333","line":"template<typename Scalar, int StorageOrder, typename PivIndex, int SizeAtCompileTime=Dynamic>"},
{"lineNum":"  334","line":"struct partial_lu_impl"},
{"lineNum":"  335","line":"{"},
{"lineNum":"  336","line":"  static const int UnBlockedBound = 16;"},
{"lineNum":"  337","line":"  static const bool UnBlockedAtCompileTime = SizeAtCompileTime!=Dynamic && SizeAtCompileTime<=UnBlockedBound;"},
{"lineNum":"  338","line":"  static const int ActualSizeAtCompileTime = UnBlockedAtCompileTime ? SizeAtCompileTime : Dynamic;"},
{"lineNum":"  339","line":"  // Remaining rows and columns at compile-time:"},
{"lineNum":"  340","line":"  static const int RRows = SizeAtCompileTime==2 ? 1 : Dynamic;"},
{"lineNum":"  341","line":"  static const int RCols = SizeAtCompileTime==2 ? 1 : Dynamic;"},
{"lineNum":"  342","line":"  typedef Matrix<Scalar, ActualSizeAtCompileTime, ActualSizeAtCompileTime, StorageOrder> MatrixType;"},
{"lineNum":"  343","line":"  typedef Ref<MatrixType> MatrixTypeRef;"},
{"lineNum":"  344","line":"  typedef Ref<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > BlockType;"},
{"lineNum":"  345","line":"  typedef typename MatrixType::RealScalar RealScalar;"},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"  /** \\internal performs the LU decomposition in-place of the matrix \\a lu"},
{"lineNum":"  348","line":"    * using an unblocked algorithm."},
{"lineNum":"  349","line":"    *"},
{"lineNum":"  350","line":"    * In addition, this function returns the row transpositions in the"},
{"lineNum":"  351","line":"    * vector \\a row_transpositions which must have a size equal to the number"},
{"lineNum":"  352","line":"    * of columns of the matrix \\a lu, and an integer \\a nb_transpositions"},
{"lineNum":"  353","line":"    * which returns the actual number of transpositions."},
{"lineNum":"  354","line":"    *"},
{"lineNum":"  355","line":"    * \\returns The index of the first pivot which is exactly zero if any, or a negative number otherwise."},
{"lineNum":"  356","line":"    */"},
{"lineNum":"  357","line":"  static Index unblocked_lu(MatrixTypeRef& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)"},
{"lineNum":"  358","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  359","line":"    typedef scalar_score_coeff_op<Scalar> Scoring;"},
{"lineNum":"  360","line":"    typedef typename Scoring::result_type Score;"},
{"lineNum":"  361","line":"    const Index rows = lu.rows();"},
{"lineNum":"  362","line":"    const Index cols = lu.cols();"},
{"lineNum":"  363","line":"    const Index size = (std::min)(rows,cols);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  364","line":"    // For small compile-time matrices it is worth processing the last row separately:"},
{"lineNum":"  365","line":"    //  speedup: +100% for 2x2, +10% for others."},
{"lineNum":"  366","line":"    const Index endk = UnBlockedAtCompileTime ? size-1 : size;"},
{"lineNum":"  367","line":"    nb_transpositions = 0;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  368","line":"    Index first_zero_pivot = -1;"},
{"lineNum":"  369","line":"    for(Index k = 0; k < endk; ++k)","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  370","line":"    {"},
{"lineNum":"  371","line":"      int rrows = internal::convert_index<int>(rows-k-1);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  372","line":"      int rcols = internal::convert_index<int>(cols-k-1);"},
{"lineNum":"  373","line":""},
{"lineNum":"  374","line":"      Index row_of_biggest_in_col;"},
{"lineNum":"  375","line":"      Score biggest_in_corner"},
{"lineNum":"  376","line":"        = lu.col(k).tail(rows-k).unaryExpr(Scoring()).maxCoeff(&row_of_biggest_in_col);","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  377","line":"      row_of_biggest_in_col += k;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"      row_transpositions[k] = PivIndex(row_of_biggest_in_col);","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"      if(biggest_in_corner != Score(0))","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  382","line":"      {"},
{"lineNum":"  383","line":"        if(k != row_of_biggest_in_col)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  384","line":"        {"},
{"lineNum":"  385","line":"          lu.row(k).swap(lu.row(row_of_biggest_in_col));"},
{"lineNum":"  386","line":"          ++nb_transpositions;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  387","line":"        }"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"        lu.col(k).tail(fix<RRows>(rrows)) /= lu.coeff(k,k);"},
{"lineNum":"  390","line":"      }"},
{"lineNum":"  391","line":"      else if(first_zero_pivot==-1)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  392","line":"      {"},
{"lineNum":"  393","line":"        // the pivot is exactly zero, we record the index of the first pivot which is exactly 0,"},
{"lineNum":"  394","line":"        // and continue the factorization such we still have A = PLU"},
{"lineNum":"  395","line":"        first_zero_pivot = k;"},
{"lineNum":"  396","line":"      }"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"      if(k<rows-1)","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  399","line":"        lu.bottomRightCorner(fix<RRows>(rrows),fix<RCols>(rcols)).noalias() -= lu.col(k).tail(fix<RRows>(rrows)) * lu.row(k).tail(fix<RCols>(rcols));"},
{"lineNum":"  400","line":"    }"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"    // special handling of the last entry"},
{"lineNum":"  403","line":"    if(UnBlockedAtCompileTime)"},
{"lineNum":"  404","line":"    {"},
{"lineNum":"  405","line":"      Index k = endk;"},
{"lineNum":"  406","line":"      row_transpositions[k] = PivIndex(k);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  407","line":"      if (Scoring()(lu(k, k)) == Score(0) && first_zero_pivot == -1)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  408","line":"        first_zero_pivot = k;"},
{"lineNum":"  409","line":"    }"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"    return first_zero_pivot;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  412","line":"  }"},
{"lineNum":"  413","line":""},
{"lineNum":"  414","line":"  /** \\internal performs the LU decomposition in-place of the matrix represented"},
{"lineNum":"  415","line":"    * by the variables \\a rows, \\a cols, \\a lu_data, and \\a lu_stride using a"},
{"lineNum":"  416","line":"    * recursive, blocked algorithm."},
{"lineNum":"  417","line":"    *"},
{"lineNum":"  418","line":"    * In addition, this function returns the row transpositions in the"},
{"lineNum":"  419","line":"    * vector \\a row_transpositions which must have a size equal to the number"},
{"lineNum":"  420","line":"    * of columns of the matrix \\a lu, and an integer \\a nb_transpositions"},
{"lineNum":"  421","line":"    * which returns the actual number of transpositions."},
{"lineNum":"  422","line":"    *"},
{"lineNum":"  423","line":"    * \\returns The index of the first pivot which is exactly zero if any, or a negative number otherwise."},
{"lineNum":"  424","line":"    *"},
{"lineNum":"  425","line":"    * \\note This very low level interface using pointers, etc. is to:"},
{"lineNum":"  426","line":"    *   1 - reduce the number of instantiations to the strict minimum"},
{"lineNum":"  427","line":"    *   2 - avoid infinite recursion of the instantiations with Block<Block<Block<...> > >"},
{"lineNum":"  428","line":"    */"},
{"lineNum":"  429","line":"  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)"},
{"lineNum":"  430","line":"  {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  431","line":"    MatrixTypeRef lu = MatrixType::Map(lu_data,rows, cols, OuterStride<>(luStride));"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"    const Index size = (std::min)(rows,cols);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"    // if the matrix is too small, no blocking:"},
{"lineNum":"  436","line":"    if(UnBlockedAtCompileTime || size<=UnBlockedBound)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  437","line":"    {"},
{"lineNum":"  438","line":"      return unblocked_lu(lu, row_transpositions, nb_transpositions);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  439","line":"    }"},
{"lineNum":"  440","line":""},
{"lineNum":"  441","line":"    // automatically adjust the number of subdivisions to the size"},
{"lineNum":"  442","line":"    // of the matrix so that there is enough sub blocks:"},
{"lineNum":"  443","line":"    Index blockSize;"},
{"lineNum":"  444","line":"    {"},
{"lineNum":"  445","line":"      blockSize = size/8;"},
{"lineNum":"  446","line":"      blockSize = (blockSize/16)*16;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  447","line":"      blockSize = (std::min)((std::max)(blockSize,Index(8)), maxBlockSize);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  448","line":"    }"},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"    nb_transpositions = 0;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  451","line":"    Index first_zero_pivot = -1;"},
{"lineNum":"  452","line":"    for(Index k = 0; k < size; k+=blockSize)","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  453","line":"    {"},
{"lineNum":"  454","line":"      Index bs = (std::min)(size-k,blockSize); // actual size of the block","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  455","line":"      Index trows = rows - k - bs; // trailing rows","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  456","line":"      Index tsize = size - k - bs; // trailing size","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"      // partition the matrix:"},
{"lineNum":"  459","line":"      //                          A00 | A01 | A02"},
{"lineNum":"  460","line":"      // lu  = A_0 | A_1 | A_2 =  A10 | A11 | A12"},
{"lineNum":"  461","line":"      //                          A20 | A21 | A22"},
{"lineNum":"  462","line":"      BlockType A_0 = lu.block(0,0,rows,k);"},
{"lineNum":"  463","line":"      BlockType A_2 = lu.block(0,k+bs,rows,tsize);"},
{"lineNum":"  464","line":"      BlockType A11 = lu.block(k,k,bs,bs);"},
{"lineNum":"  465","line":"      BlockType A12 = lu.block(k,k+bs,bs,tsize);"},
{"lineNum":"  466","line":"      BlockType A21 = lu.block(k+bs,k,trows,bs);"},
{"lineNum":"  467","line":"      BlockType A22 = lu.block(k+bs,k+bs,trows,tsize);"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"      PivIndex nb_transpositions_in_panel;"},
{"lineNum":"  470","line":"      // recursively call the blocked LU algorithm on [A11^T A21^T]^T"},
{"lineNum":"  471","line":"      // with a very small blocking size:"},
{"lineNum":"  472","line":"      Index ret = blocked_lu(trows+bs, bs, &lu.coeffRef(k,k), luStride,","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  473","line":"                   row_transpositions+k, nb_transpositions_in_panel, 16);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  474","line":"      if(ret>=0 && first_zero_pivot==-1)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  475","line":"        first_zero_pivot = k+ret;"},
{"lineNum":"  476","line":""},
{"lineNum":"  477","line":"      nb_transpositions += nb_transpositions_in_panel;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  478","line":"      // update permutations and apply them to A_0"},
{"lineNum":"  479","line":"      for(Index i=k; i<k+bs; ++i)","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  480","line":"      {"},
{"lineNum":"  481","line":"        Index piv = (row_transpositions[i] += internal::convert_index<PivIndex>(k));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  482","line":"        A_0.row(i).swap(A_0.row(piv));"},
{"lineNum":"  483","line":"      }"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"      if(trows)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  486","line":"      {"},
{"lineNum":"  487","line":"        // apply permutations to A_2"},
{"lineNum":"  488","line":"        for(Index i=k;i<k+bs; ++i)","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  489","line":"          A_2.row(i).swap(A_2.row(row_transpositions[i]));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"        // A12 = A11^-1 A12"},
{"lineNum":"  492","line":"        A11.template triangularView<UnitLower>().solveInPlace(A12);"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"        A22.noalias() -= A21 * A12;"},
{"lineNum":"  495","line":"      }"},
{"lineNum":"  496","line":"    }"},
{"lineNum":"  497","line":"    return first_zero_pivot;"},
{"lineNum":"  498","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  499","line":"};"},
{"lineNum":"  500","line":""},
{"lineNum":"  501","line":"/** \\internal performs the LU decomposition with partial pivoting in-place."},
{"lineNum":"  502","line":"  */"},
{"lineNum":"  503","line":"template<typename MatrixType, typename TranspositionType>"},
{"lineNum":"  504","line":"void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::StorageIndex& nb_transpositions)"},
{"lineNum":"  505","line":"{"},
{"lineNum":"  506","line":"  // Special-case of zero matrix."},
{"lineNum":"  507","line":"  if (lu.rows() == 0 || lu.cols() == 0) {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  508","line":"    nb_transpositions = 0;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  509","line":"    return;"},
{"lineNum":"  510","line":"  }"},
{"lineNum":"  511","line":"  eigen_assert(lu.cols() == row_transpositions.size());"},
{"lineNum":"  512","line":"  eigen_assert(row_transpositions.size() < 2 || (&row_transpositions.coeffRef(1)-&row_transpositions.coeffRef(0)) == 1);"},
{"lineNum":"  513","line":""},
{"lineNum":"  514","line":"  partial_lu_impl","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  515","line":"    < typename MatrixType::Scalar, MatrixType::Flags&RowMajorBit?RowMajor:ColMajor,"},
{"lineNum":"  516","line":"      typename TranspositionType::StorageIndex,"},
{"lineNum":"  517","line":"      EIGEN_SIZE_MIN_PREFER_FIXED(MatrixType::RowsAtCompileTime,MatrixType::ColsAtCompileTime)>"},
{"lineNum":"  518","line":"    ::blocked_lu(lu.rows(), lu.cols(), &lu.coeffRef(0,0), lu.outerStride(), &row_transpositions.coeffRef(0), nb_transpositions);"},
{"lineNum":"  519","line":"}","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"} // end namespace internal"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"template<typename MatrixType>"},
{"lineNum":"  524","line":"void PartialPivLU<MatrixType>::compute()"},
{"lineNum":"  525","line":"{","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  526","line":"  // the row permutation is stored as int indices, so just to be sure:"},
{"lineNum":"  527","line":"  eigen_assert(m_lu.rows()<NumTraits<int>::highest());"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"  if(m_lu.cols()>0)","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  530","line":"    m_l1_norm = m_lu.cwiseAbs().colwise().sum().maxCoeff();","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  531","line":"  else"},
{"lineNum":"  532","line":"    m_l1_norm = RealScalar(0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  533","line":""},
{"lineNum":"  534","line":"  eigen_assert(m_lu.rows() == m_lu.cols() && \"PartialPivLU is only for square (and moreover invertible) matrices\");"},
{"lineNum":"  535","line":"  const Index size = m_lu.rows();"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"  m_rowsTranspositions.resize(size);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"  typename TranspositionType::StorageIndex nb_transpositions;"},
{"lineNum":"  540","line":"  internal::partial_lu_inplace(m_lu, m_rowsTranspositions, nb_transpositions);"},
{"lineNum":"  541","line":"  m_det_p = (nb_transpositions%2) ? -1 : 1;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"  m_p = m_rowsTranspositions;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"  m_isInitialized = true;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  546","line":"}","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  547","line":""},
{"lineNum":"  548","line":"template<typename MatrixType>"},
{"lineNum":"  549","line":"typename PartialPivLU<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const"},
{"lineNum":"  550","line":"{"},
{"lineNum":"  551","line":"  eigen_assert(m_isInitialized && \"PartialPivLU is not initialized.\");"},
{"lineNum":"  552","line":"  return Scalar(m_det_p) * m_lu.diagonal().prod();","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"  553","line":"}"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"/** \\returns the matrix represented by the decomposition,"},
{"lineNum":"  556","line":" * i.e., it returns the product: P^{-1} L U."},
{"lineNum":"  557","line":" * This function is provided for debug purpose. */"},
{"lineNum":"  558","line":"template<typename MatrixType>"},
{"lineNum":"  559","line":"MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const"},
{"lineNum":"  560","line":"{"},
{"lineNum":"  561","line":"  eigen_assert(m_isInitialized && \"LU is not initialized.\");"},
{"lineNum":"  562","line":"  // LU"},
{"lineNum":"  563","line":"  MatrixType res = m_lu.template triangularView<UnitLower>().toDenseMatrix()"},
{"lineNum":"  564","line":"                 * m_lu.template triangularView<Upper>();"},
{"lineNum":"  565","line":""},
{"lineNum":"  566","line":"  // P^{-1}(LU)"},
{"lineNum":"  567","line":"  res = m_p.inverse() * res;"},
{"lineNum":"  568","line":""},
{"lineNum":"  569","line":"  return res;"},
{"lineNum":"  570","line":"}"},
{"lineNum":"  571","line":""},
{"lineNum":"  572","line":"/***** Implementation details *****************************************************/"},
{"lineNum":"  573","line":""},
{"lineNum":"  574","line":"namespace internal {"},
{"lineNum":"  575","line":""},
{"lineNum":"  576","line":"/***** Implementation of inverse() *****************************************************/"},
{"lineNum":"  577","line":"template<typename DstXprType, typename MatrixType>"},
{"lineNum":"  578","line":"struct Assignment<DstXprType, Inverse<PartialPivLU<MatrixType> >, internal::assign_op<typename DstXprType::Scalar,typename PartialPivLU<MatrixType>::Scalar>, Dense2Dense>"},
{"lineNum":"  579","line":"{"},
{"lineNum":"  580","line":"  typedef PartialPivLU<MatrixType> LuType;"},
{"lineNum":"  581","line":"  typedef Inverse<LuType> SrcXprType;"},
{"lineNum":"  582","line":"  static void run(DstXprType &dst, const SrcXprType &src, const internal::assign_op<typename DstXprType::Scalar,typename LuType::Scalar> &)"},
{"lineNum":"  583","line":"  {"},
{"lineNum":"  584","line":"    dst = src.nestedExpression().solve(MatrixType::Identity(src.rows(), src.cols()));"},
{"lineNum":"  585","line":"  }"},
{"lineNum":"  586","line":"};"},
{"lineNum":"  587","line":"} // end namespace internal"},
{"lineNum":"  588","line":""},
{"lineNum":"  589","line":"/******** MatrixBase methods *******/"},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"/** \\lu_module"},
{"lineNum":"  592","line":"  *"},
{"lineNum":"  593","line":"  * \\return the partial-pivoting LU decomposition of \\c *this."},
{"lineNum":"  594","line":"  *"},
{"lineNum":"  595","line":"  * \\sa class PartialPivLU"},
{"lineNum":"  596","line":"  */"},
{"lineNum":"  597","line":"template<typename Derived>"},
{"lineNum":"  598","line":"inline const PartialPivLU<typename MatrixBase<Derived>::PlainObject>"},
{"lineNum":"  599","line":"MatrixBase<Derived>::partialPivLu() const"},
{"lineNum":"  600","line":"{"},
{"lineNum":"  601","line":"  return PartialPivLU<PlainObject>(eval());","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  602","line":"}"},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"/** \\lu_module"},
{"lineNum":"  605","line":"  *"},
{"lineNum":"  606","line":"  * Synonym of partialPivLu()."},
{"lineNum":"  607","line":"  *"},
{"lineNum":"  608","line":"  * \\return the partial-pivoting LU decomposition of \\c *this."},
{"lineNum":"  609","line":"  *"},
{"lineNum":"  610","line":"  * \\sa class PartialPivLU"},
{"lineNum":"  611","line":"  */"},
{"lineNum":"  612","line":"template<typename Derived>"},
{"lineNum":"  613","line":"inline const PartialPivLU<typename MatrixBase<Derived>::PlainObject>"},
{"lineNum":"  614","line":"MatrixBase<Derived>::lu() const"},
{"lineNum":"  615","line":"{"},
{"lineNum":"  616","line":"  return PartialPivLU<PlainObject>(eval());"},
{"lineNum":"  617","line":"}"},
{"lineNum":"  618","line":""},
{"lineNum":"  619","line":"} // end namespace Eigen"},
{"lineNum":"  620","line":""},
{"lineNum":"  621","line":"#endif // EIGEN_PARTIALLU_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 65, "covered" : 0,};
var merged_data = [];
