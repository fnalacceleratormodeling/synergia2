var data = {lines:[
{"lineNum":"    1","line":"// This file is part of Eigen, a lightweight C++ template library"},
{"lineNum":"    2","line":"// for linear algebra."},
{"lineNum":"    3","line":"//"},
{"lineNum":"    4","line":"// Copyright (C) 2009 Benoit Jacob <jacob.benoit.1@gmail.com>"},
{"lineNum":"    5","line":"// Copyright (C) 2009 Gael Guennebaud <gael.guennebaud@inria.fr>"},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"// This Source Code Form is subject to the terms of the Mozilla"},
{"lineNum":"    8","line":"// Public License v. 2.0. If a copy of the MPL was not distributed"},
{"lineNum":"    9","line":"// with this file, You can obtain one at http://mozilla.org/MPL/2.0/."},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef EIGEN_JACOBI_H"},
{"lineNum":"   12","line":"#define EIGEN_JACOBI_H"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include \"./InternalHeaderCheck.h\""},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"namespace Eigen {"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"/** \\ingroup Jacobi_Module"},
{"lineNum":"   19","line":"  * \\jacobi_module"},
{"lineNum":"   20","line":"  * \\class JacobiRotation"},
{"lineNum":"   21","line":"  * \\brief Rotation given by a cosine-sine pair."},
{"lineNum":"   22","line":"  *"},
{"lineNum":"   23","line":"  * This class represents a Jacobi or Givens rotation."},
{"lineNum":"   24","line":"  * This is a 2D rotation in the plane \\c J of angle \\f$ \\theta \\f$ defined by"},
{"lineNum":"   25","line":"  * its cosine \\c c and sine \\c s as follow:"},
{"lineNum":"   26","line":"  * \\f$ J = \\left ( \\begin{array}{cc} c & \\overline s \\\\ -s  & \\overline c \\end{array} \\right ) \\f$"},
{"lineNum":"   27","line":"  *"},
{"lineNum":"   28","line":"  * You can apply the respective counter-clockwise rotation to a column vector \\c v by"},
{"lineNum":"   29","line":"  * applying its adjoint on the left: \\f$ v = J^* v \\f$ that translates to the following Eigen code:"},
{"lineNum":"   30","line":"  * \\code"},
{"lineNum":"   31","line":"  * v.applyOnTheLeft(J.adjoint());"},
{"lineNum":"   32","line":"  * \\endcode"},
{"lineNum":"   33","line":"  *"},
{"lineNum":"   34","line":"  * \\sa MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()"},
{"lineNum":"   35","line":"  */"},
{"lineNum":"   36","line":"template<typename Scalar> class JacobiRotation"},
{"lineNum":"   37","line":"{"},
{"lineNum":"   38","line":"  public:"},
{"lineNum":"   39","line":"    typedef typename NumTraits<Scalar>::Real RealScalar;"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"    /** Default constructor without any initialization. */"},
{"lineNum":"   42","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   43","line":"    JacobiRotation() {}"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"    /** Construct a planar rotation from a cosine-sine pair (\\a c, \\c s). */"},
{"lineNum":"   46","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   47","line":"    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"    EIGEN_DEVICE_FUNC Scalar& c() { return m_c; }"},
{"lineNum":"   50","line":"    EIGEN_DEVICE_FUNC Scalar c() const { return m_c; }"},
{"lineNum":"   51","line":"    EIGEN_DEVICE_FUNC Scalar& s() { return m_s; }"},
{"lineNum":"   52","line":"    EIGEN_DEVICE_FUNC Scalar s() const { return m_s; }"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"    /** Concatenates two planar rotation */"},
{"lineNum":"   55","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   56","line":"    JacobiRotation operator*(const JacobiRotation& other)"},
{"lineNum":"   57","line":"    {"},
{"lineNum":"   58","line":"      using numext::conj;"},
{"lineNum":"   59","line":"      return JacobiRotation(m_c * other.m_c - conj(m_s) * other.m_s,"},
{"lineNum":"   60","line":"                            conj(m_c * conj(other.m_s) + conj(m_s) * conj(other.m_c)));"},
{"lineNum":"   61","line":"    }"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"    /** Returns the transposed transformation */"},
{"lineNum":"   64","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   65","line":"    JacobiRotation transpose() const { using numext::conj; return JacobiRotation(m_c, -conj(m_s)); }"},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"    /** Returns the adjoint transformation */"},
{"lineNum":"   68","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   69","line":"    JacobiRotation adjoint() const { using numext::conj; return JacobiRotation(conj(m_c), -m_s); }"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"    template<typename Derived>"},
{"lineNum":"   72","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   73","line":"    bool makeJacobi(const MatrixBase<Derived>&, Index p, Index q);"},
{"lineNum":"   74","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   75","line":"    bool makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z);"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   78","line":"    void makeGivens(const Scalar& p, const Scalar& q, Scalar* r=0);"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"  protected:"},
{"lineNum":"   81","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   82","line":"    void makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type);"},
{"lineNum":"   83","line":"    EIGEN_DEVICE_FUNC"},
{"lineNum":"   84","line":"    void makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type);"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"    Scalar m_c, m_s;"},
{"lineNum":"   87","line":"};"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"/** Makes \\c *this as a Jacobi rotation \\a J such that applying \\a J on both the right and left sides of the selfadjoint 2x2 matrix"},
{"lineNum":"   90","line":"  * \\f$ B = \\left ( \\begin{array}{cc} x & y \\\\ \\overline y & z \\end{array} \\right )\\f$ yields a diagonal matrix \\f$ A = J^* B J \\f$"},
{"lineNum":"   91","line":"  *"},
{"lineNum":"   92","line":"  * \\sa MatrixBase::makeJacobi(const MatrixBase<Derived>&, Index, Index), MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()"},
{"lineNum":"   93","line":"  */"},
{"lineNum":"   94","line":"template<typename Scalar>"},
{"lineNum":"   95","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"   96","line":"bool JacobiRotation<Scalar>::makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z)"},
{"lineNum":"   97","line":"{"},
{"lineNum":"   98","line":"  using std::sqrt;"},
{"lineNum":"   99","line":"  using std::abs;"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"  RealScalar deno = RealScalar(2)*abs(y);"},
{"lineNum":"  102","line":"  if(deno < (std::numeric_limits<RealScalar>::min)())"},
{"lineNum":"  103","line":"  {"},
{"lineNum":"  104","line":"    m_c = Scalar(1);"},
{"lineNum":"  105","line":"    m_s = Scalar(0);"},
{"lineNum":"  106","line":"    return false;"},
{"lineNum":"  107","line":"  }"},
{"lineNum":"  108","line":"  else"},
{"lineNum":"  109","line":"  {"},
{"lineNum":"  110","line":"    RealScalar tau = (x-z)/deno;"},
{"lineNum":"  111","line":"    RealScalar w = sqrt(numext::abs2(tau) + RealScalar(1));"},
{"lineNum":"  112","line":"    RealScalar t;"},
{"lineNum":"  113","line":"    if(tau>RealScalar(0))"},
{"lineNum":"  114","line":"    {"},
{"lineNum":"  115","line":"      t = RealScalar(1) / (tau + w);"},
{"lineNum":"  116","line":"    }"},
{"lineNum":"  117","line":"    else"},
{"lineNum":"  118","line":"    {"},
{"lineNum":"  119","line":"      t = RealScalar(1) / (tau - w);"},
{"lineNum":"  120","line":"    }"},
{"lineNum":"  121","line":"    RealScalar sign_t = t > RealScalar(0) ? RealScalar(1) : RealScalar(-1);"},
{"lineNum":"  122","line":"    RealScalar n = RealScalar(1) / sqrt(numext::abs2(t)+RealScalar(1));"},
{"lineNum":"  123","line":"    m_s = - sign_t * (numext::conj(y) / abs(y)) * abs(t) * n;"},
{"lineNum":"  124","line":"    m_c = n;"},
{"lineNum":"  125","line":"    return true;"},
{"lineNum":"  126","line":"  }"},
{"lineNum":"  127","line":"}"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"/** Makes \\c *this as a Jacobi rotation \\c J such that applying \\a J on both the right and left sides of the 2x2 selfadjoint matrix"},
{"lineNum":"  130","line":"  * \\f$ B = \\left ( \\begin{array}{cc} \\text{this}_{pp} & \\text{this}_{pq} \\\\ (\\text{this}_{pq})^* & \\text{this}_{qq} \\end{array} \\right )\\f$ yields"},
{"lineNum":"  131","line":"  * a diagonal matrix \\f$ A = J^* B J \\f$"},
{"lineNum":"  132","line":"  *"},
{"lineNum":"  133","line":"  * Example: \\include Jacobi_makeJacobi.cpp"},
{"lineNum":"  134","line":"  * Output: \\verbinclude Jacobi_makeJacobi.out"},
{"lineNum":"  135","line":"  *"},
{"lineNum":"  136","line":"  * \\sa JacobiRotation::makeJacobi(RealScalar, Scalar, RealScalar), MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()"},
{"lineNum":"  137","line":"  */"},
{"lineNum":"  138","line":"template<typename Scalar>"},
{"lineNum":"  139","line":"template<typename Derived>"},
{"lineNum":"  140","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  141","line":"inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, Index p, Index q)"},
{"lineNum":"  142","line":"{"},
{"lineNum":"  143","line":"  return makeJacobi(numext::real(m.coeff(p,p)), m.coeff(p,q), numext::real(m.coeff(q,q)));"},
{"lineNum":"  144","line":"}"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"/** Makes \\c *this as a Givens rotation \\c G such that applying \\f$ G^* \\f$ to the left of the vector"},
{"lineNum":"  147","line":"  * \\f$ V = \\left ( \\begin{array}{c} p \\\\ q \\end{array} \\right )\\f$ yields:"},
{"lineNum":"  148","line":"  * \\f$ G^* V = \\left ( \\begin{array}{c} r \\\\ 0 \\end{array} \\right )\\f$."},
{"lineNum":"  149","line":"  *"},
{"lineNum":"  150","line":"  * The value of \\a r is returned if \\a r is not null (the default is null)."},
{"lineNum":"  151","line":"  * Also note that G is built such that the cosine is always real."},
{"lineNum":"  152","line":"  *"},
{"lineNum":"  153","line":"  * Example: \\include Jacobi_makeGivens.cpp"},
{"lineNum":"  154","line":"  * Output: \\verbinclude Jacobi_makeGivens.out"},
{"lineNum":"  155","line":"  *"},
{"lineNum":"  156","line":"  * This function implements the continuous Givens rotation generation algorithm"},
{"lineNum":"  157","line":"  * found in Anderson (2000), Discontinuous Plane Rotations and the Symmetric Eigenvalue Problem."},
{"lineNum":"  158","line":"  * LAPACK Working Note 150, University of Tennessee, UT-CS-00-454, December 4, 2000."},
{"lineNum":"  159","line":"  *"},
{"lineNum":"  160","line":"  * \\sa MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()"},
{"lineNum":"  161","line":"  */"},
{"lineNum":"  162","line":"template<typename Scalar>"},
{"lineNum":"  163","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  164","line":"void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r)"},
{"lineNum":"  165","line":"{"},
{"lineNum":"  166","line":"  makeGivens(p, q, r, typename internal::conditional<NumTraits<Scalar>::IsComplex, internal::true_type, internal::false_type>::type());"},
{"lineNum":"  167","line":"}"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"// specialization for complexes"},
{"lineNum":"  171","line":"template<typename Scalar>"},
{"lineNum":"  172","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  173","line":"void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)"},
{"lineNum":"  174","line":"{"},
{"lineNum":"  175","line":"  using std::sqrt;"},
{"lineNum":"  176","line":"  using std::abs;"},
{"lineNum":"  177","line":"  using numext::conj;"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"  if(q==Scalar(0))"},
{"lineNum":"  180","line":"  {"},
{"lineNum":"  181","line":"    m_c = numext::real(p)<0 ? Scalar(-1) : Scalar(1);"},
{"lineNum":"  182","line":"    m_s = 0;"},
{"lineNum":"  183","line":"    if(r) *r = m_c * p;"},
{"lineNum":"  184","line":"  }"},
{"lineNum":"  185","line":"  else if(p==Scalar(0))"},
{"lineNum":"  186","line":"  {"},
{"lineNum":"  187","line":"    m_c = 0;"},
{"lineNum":"  188","line":"    m_s = -q/abs(q);"},
{"lineNum":"  189","line":"    if(r) *r = abs(q);"},
{"lineNum":"  190","line":"  }"},
{"lineNum":"  191","line":"  else"},
{"lineNum":"  192","line":"  {"},
{"lineNum":"  193","line":"    RealScalar p1 = numext::norm1(p);"},
{"lineNum":"  194","line":"    RealScalar q1 = numext::norm1(q);"},
{"lineNum":"  195","line":"    if(p1>=q1)"},
{"lineNum":"  196","line":"    {"},
{"lineNum":"  197","line":"      Scalar ps = p / p1;"},
{"lineNum":"  198","line":"      RealScalar p2 = numext::abs2(ps);"},
{"lineNum":"  199","line":"      Scalar qs = q / p1;"},
{"lineNum":"  200","line":"      RealScalar q2 = numext::abs2(qs);"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"      RealScalar u = sqrt(RealScalar(1) + q2/p2);"},
{"lineNum":"  203","line":"      if(numext::real(p)<RealScalar(0))"},
{"lineNum":"  204","line":"        u = -u;"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"      m_c = Scalar(1)/u;"},
{"lineNum":"  207","line":"      m_s = -qs*conj(ps)*(m_c/p2);"},
{"lineNum":"  208","line":"      if(r) *r = p * u;"},
{"lineNum":"  209","line":"    }"},
{"lineNum":"  210","line":"    else"},
{"lineNum":"  211","line":"    {"},
{"lineNum":"  212","line":"      Scalar ps = p / q1;"},
{"lineNum":"  213","line":"      RealScalar p2 = numext::abs2(ps);"},
{"lineNum":"  214","line":"      Scalar qs = q / q1;"},
{"lineNum":"  215","line":"      RealScalar q2 = numext::abs2(qs);"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"      RealScalar u = q1 * sqrt(p2 + q2);"},
{"lineNum":"  218","line":"      if(numext::real(p)<RealScalar(0))"},
{"lineNum":"  219","line":"        u = -u;"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"      p1 = abs(p);"},
{"lineNum":"  222","line":"      ps = p/p1;"},
{"lineNum":"  223","line":"      m_c = p1/u;"},
{"lineNum":"  224","line":"      m_s = -conj(ps) * (q/u);"},
{"lineNum":"  225","line":"      if(r) *r = ps * u;"},
{"lineNum":"  226","line":"    }"},
{"lineNum":"  227","line":"  }"},
{"lineNum":"  228","line":"}"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"// specialization for reals"},
{"lineNum":"  231","line":"template<typename Scalar>"},
{"lineNum":"  232","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  233","line":"void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)"},
{"lineNum":"  234","line":"{"},
{"lineNum":"  235","line":"  using std::sqrt;"},
{"lineNum":"  236","line":"  using std::abs;"},
{"lineNum":"  237","line":"  if(q==Scalar(0))"},
{"lineNum":"  238","line":"  {"},
{"lineNum":"  239","line":"    m_c = p<Scalar(0) ? Scalar(-1) : Scalar(1);"},
{"lineNum":"  240","line":"    m_s = Scalar(0);"},
{"lineNum":"  241","line":"    if(r) *r = abs(p);"},
{"lineNum":"  242","line":"  }"},
{"lineNum":"  243","line":"  else if(p==Scalar(0))"},
{"lineNum":"  244","line":"  {"},
{"lineNum":"  245","line":"    m_c = Scalar(0);"},
{"lineNum":"  246","line":"    m_s = q<Scalar(0) ? Scalar(1) : Scalar(-1);"},
{"lineNum":"  247","line":"    if(r) *r = abs(q);"},
{"lineNum":"  248","line":"  }"},
{"lineNum":"  249","line":"  else if(abs(p) > abs(q))"},
{"lineNum":"  250","line":"  {"},
{"lineNum":"  251","line":"    Scalar t = q/p;"},
{"lineNum":"  252","line":"    Scalar u = sqrt(Scalar(1) + numext::abs2(t));"},
{"lineNum":"  253","line":"    if(p<Scalar(0))"},
{"lineNum":"  254","line":"      u = -u;"},
{"lineNum":"  255","line":"    m_c = Scalar(1)/u;"},
{"lineNum":"  256","line":"    m_s = -t * m_c;"},
{"lineNum":"  257","line":"    if(r) *r = p * u;"},
{"lineNum":"  258","line":"  }"},
{"lineNum":"  259","line":"  else"},
{"lineNum":"  260","line":"  {"},
{"lineNum":"  261","line":"    Scalar t = p/q;"},
{"lineNum":"  262","line":"    Scalar u = sqrt(Scalar(1) + numext::abs2(t));"},
{"lineNum":"  263","line":"    if(q<Scalar(0))"},
{"lineNum":"  264","line":"      u = -u;"},
{"lineNum":"  265","line":"    m_s = -Scalar(1)/u;"},
{"lineNum":"  266","line":"    m_c = -t * m_s;"},
{"lineNum":"  267","line":"    if(r) *r = q * u;"},
{"lineNum":"  268","line":"  }"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"}"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"/****************************************************************************************"},
{"lineNum":"  273","line":"*   Implementation of MatrixBase methods"},
{"lineNum":"  274","line":"****************************************************************************************/"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"namespace internal {"},
{"lineNum":"  277","line":"/** \\jacobi_module"},
{"lineNum":"  278","line":"  * Applies the clock wise 2D rotation \\a j to the set of 2D vectors of coordinates \\a x and \\a y:"},
{"lineNum":"  279","line":"  * \\f$ \\left ( \\begin{array}{cc} x \\\\ y \\end{array} \\right )  =  J \\left ( \\begin{array}{cc} x \\\\ y \\end{array} \\right ) \\f$"},
{"lineNum":"  280","line":"  *"},
{"lineNum":"  281","line":"  * \\sa MatrixBase::applyOnTheLeft(), MatrixBase::applyOnTheRight()"},
{"lineNum":"  282","line":"  */"},
{"lineNum":"  283","line":"template<typename VectorX, typename VectorY, typename OtherScalar>"},
{"lineNum":"  284","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  285","line":"void apply_rotation_in_the_plane(DenseBase<VectorX>& xpr_x, DenseBase<VectorY>& xpr_y, const JacobiRotation<OtherScalar>& j);"},
{"lineNum":"  286","line":"}"},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"/** \\jacobi_module"},
{"lineNum":"  289","line":"  * Applies the rotation in the plane \\a j to the rows \\a p and \\a q of \\c *this, i.e., it computes B = J * B,"},
{"lineNum":"  290","line":"  * with \\f$ B = \\left ( \\begin{array}{cc} \\text{*this.row}(p) \\\\ \\text{*this.row}(q) \\end{array} \\right ) \\f$."},
{"lineNum":"  291","line":"  *"},
{"lineNum":"  292","line":"  * \\sa class JacobiRotation, MatrixBase::applyOnTheRight(), internal::apply_rotation_in_the_plane()"},
{"lineNum":"  293","line":"  */"},
{"lineNum":"  294","line":"template<typename Derived>"},
{"lineNum":"  295","line":"template<typename OtherScalar>"},
{"lineNum":"  296","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  297","line":"inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)"},
{"lineNum":"  298","line":"{"},
{"lineNum":"  299","line":"  RowXpr x(this->row(p));"},
{"lineNum":"  300","line":"  RowXpr y(this->row(q));"},
{"lineNum":"  301","line":"  internal::apply_rotation_in_the_plane(x, y, j);"},
{"lineNum":"  302","line":"}"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"/** \\ingroup Jacobi_Module"},
{"lineNum":"  305","line":"  * Applies the rotation in the plane \\a j to the columns \\a p and \\a q of \\c *this, i.e., it computes B = B * J"},
{"lineNum":"  306","line":"  * with \\f$ B = \\left ( \\begin{array}{cc} \\text{*this.col}(p) & \\text{*this.col}(q) \\end{array} \\right ) \\f$."},
{"lineNum":"  307","line":"  *"},
{"lineNum":"  308","line":"  * \\sa class JacobiRotation, MatrixBase::applyOnTheLeft(), internal::apply_rotation_in_the_plane()"},
{"lineNum":"  309","line":"  */"},
{"lineNum":"  310","line":"template<typename Derived>"},
{"lineNum":"  311","line":"template<typename OtherScalar>"},
{"lineNum":"  312","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  313","line":"inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)"},
{"lineNum":"  314","line":"{"},
{"lineNum":"  315","line":"  ColXpr x(this->col(p));"},
{"lineNum":"  316","line":"  ColXpr y(this->col(q));"},
{"lineNum":"  317","line":"  internal::apply_rotation_in_the_plane(x, y, j.transpose());"},
{"lineNum":"  318","line":"}"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"namespace internal {"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"template<typename Scalar, typename OtherScalar,"},
{"lineNum":"  323","line":"         int SizeAtCompileTime, int MinAlignment, bool Vectorizable>"},
{"lineNum":"  324","line":"struct apply_rotation_in_the_plane_selector"},
{"lineNum":"  325","line":"{"},
{"lineNum":"  326","line":"  static EIGEN_DEVICE_FUNC"},
{"lineNum":"  327","line":"  inline void run(Scalar *x, Index incrx, Scalar *y, Index incry, Index size, OtherScalar c, OtherScalar s)"},
{"lineNum":"  328","line":"  {"},
{"lineNum":"  329","line":"    for(Index i=0; i<size; ++i)","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  330","line":"    {"},
{"lineNum":"  331","line":"      Scalar xi = *x;","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  332","line":"      Scalar yi = *y;","class":"lineNoCov","hits":"0","possible_hits":"23",},
{"lineNum":"  333","line":"      *x =  c * xi + numext::conj(s) * yi;","class":"lineNoCov","hits":"0","possible_hits":"23",},
{"lineNum":"  334","line":"      *y = -s * xi + numext::conj(c) * yi;","class":"lineNoCov","hits":"0","possible_hits":"23",},
{"lineNum":"  335","line":"      x += incrx;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  336","line":"      y += incry;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  337","line":"    }"},
{"lineNum":"  338","line":"  }"},
{"lineNum":"  339","line":"};"},
{"lineNum":"  340","line":""},
{"lineNum":"  341","line":"template<typename Scalar, typename OtherScalar,"},
{"lineNum":"  342","line":"         int SizeAtCompileTime, int MinAlignment>"},
{"lineNum":"  343","line":"struct apply_rotation_in_the_plane_selector<Scalar,OtherScalar,SizeAtCompileTime,MinAlignment,true /* vectorizable */>"},
{"lineNum":"  344","line":"{"},
{"lineNum":"  345","line":"  static inline void run(Scalar *x, Index incrx, Scalar *y, Index incry, Index size, OtherScalar c, OtherScalar s)"},
{"lineNum":"  346","line":"  {"},
{"lineNum":"  347","line":"    enum {"},
{"lineNum":"  348","line":"      PacketSize = packet_traits<Scalar>::size,"},
{"lineNum":"  349","line":"      OtherPacketSize = packet_traits<OtherScalar>::size"},
{"lineNum":"  350","line":"    };"},
{"lineNum":"  351","line":"    typedef typename packet_traits<Scalar>::type Packet;"},
{"lineNum":"  352","line":"    typedef typename packet_traits<OtherScalar>::type OtherPacket;"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"    /*** dynamic-size vectorized paths ***/"},
{"lineNum":"  355","line":"    if(SizeAtCompileTime == Dynamic && ((incrx==1 && incry==1) || PacketSize == 1))"},
{"lineNum":"  356","line":"    {"},
{"lineNum":"  357","line":"      // both vectors are sequentially stored in memory => vectorization"},
{"lineNum":"  358","line":"      enum { Peeling = 2 };"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"      Index alignedStart = internal::first_default_aligned(y, size);"},
{"lineNum":"  361","line":"      Index alignedEnd = alignedStart + ((size-alignedStart)/PacketSize)*PacketSize;"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"      const OtherPacket pc = pset1<OtherPacket>(c);"},
{"lineNum":"  364","line":"      const OtherPacket ps = pset1<OtherPacket>(s);"},
{"lineNum":"  365","line":"      conj_helper<OtherPacket,Packet,NumTraits<OtherScalar>::IsComplex,false> pcj;"},
{"lineNum":"  366","line":"      conj_helper<OtherPacket,Packet,false,false> pm;"},
{"lineNum":"  367","line":""},
{"lineNum":"  368","line":"      for(Index i=0; i<alignedStart; ++i)"},
{"lineNum":"  369","line":"      {"},
{"lineNum":"  370","line":"        Scalar xi = x[i];"},
{"lineNum":"  371","line":"        Scalar yi = y[i];"},
{"lineNum":"  372","line":"        x[i] =  c * xi + numext::conj(s) * yi;"},
{"lineNum":"  373","line":"        y[i] = -s * xi + numext::conj(c) * yi;"},
{"lineNum":"  374","line":"      }"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"      Scalar* EIGEN_RESTRICT px = x + alignedStart;"},
{"lineNum":"  377","line":"      Scalar* EIGEN_RESTRICT py = y + alignedStart;"},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"      if(internal::first_default_aligned(x, size)==alignedStart)"},
{"lineNum":"  380","line":"      {"},
{"lineNum":"  381","line":"        for(Index i=alignedStart; i<alignedEnd; i+=PacketSize)"},
{"lineNum":"  382","line":"        {"},
{"lineNum":"  383","line":"          Packet xi = pload<Packet>(px);"},
{"lineNum":"  384","line":"          Packet yi = pload<Packet>(py);"},
{"lineNum":"  385","line":"          pstore(px, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)));"},
{"lineNum":"  386","line":"          pstore(py, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)));"},
{"lineNum":"  387","line":"          px += PacketSize;"},
{"lineNum":"  388","line":"          py += PacketSize;"},
{"lineNum":"  389","line":"        }"},
{"lineNum":"  390","line":"      }"},
{"lineNum":"  391","line":"      else"},
{"lineNum":"  392","line":"      {"},
{"lineNum":"  393","line":"        Index peelingEnd = alignedStart + ((size-alignedStart)/(Peeling*PacketSize))*(Peeling*PacketSize);"},
{"lineNum":"  394","line":"        for(Index i=alignedStart; i<peelingEnd; i+=Peeling*PacketSize)"},
{"lineNum":"  395","line":"        {"},
{"lineNum":"  396","line":"          Packet xi   = ploadu<Packet>(px);"},
{"lineNum":"  397","line":"          Packet xi1  = ploadu<Packet>(px+PacketSize);"},
{"lineNum":"  398","line":"          Packet yi   = pload <Packet>(py);"},
{"lineNum":"  399","line":"          Packet yi1  = pload <Packet>(py+PacketSize);"},
{"lineNum":"  400","line":"          pstoreu(px, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)));"},
{"lineNum":"  401","line":"          pstoreu(px+PacketSize, padd(pm.pmul(pc,xi1),pcj.pmul(ps,yi1)));"},
{"lineNum":"  402","line":"          pstore (py, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)));"},
{"lineNum":"  403","line":"          pstore (py+PacketSize, psub(pcj.pmul(pc,yi1),pm.pmul(ps,xi1)));"},
{"lineNum":"  404","line":"          px += Peeling*PacketSize;"},
{"lineNum":"  405","line":"          py += Peeling*PacketSize;"},
{"lineNum":"  406","line":"        }"},
{"lineNum":"  407","line":"        if(alignedEnd!=peelingEnd)"},
{"lineNum":"  408","line":"        {"},
{"lineNum":"  409","line":"          Packet xi = ploadu<Packet>(x+peelingEnd);"},
{"lineNum":"  410","line":"          Packet yi = pload <Packet>(y+peelingEnd);"},
{"lineNum":"  411","line":"          pstoreu(x+peelingEnd, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)));"},
{"lineNum":"  412","line":"          pstore (y+peelingEnd, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)));"},
{"lineNum":"  413","line":"        }"},
{"lineNum":"  414","line":"      }"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"      for(Index i=alignedEnd; i<size; ++i)"},
{"lineNum":"  417","line":"      {"},
{"lineNum":"  418","line":"        Scalar xi = x[i];"},
{"lineNum":"  419","line":"        Scalar yi = y[i];"},
{"lineNum":"  420","line":"        x[i] =  c * xi + numext::conj(s) * yi;"},
{"lineNum":"  421","line":"        y[i] = -s * xi + numext::conj(c) * yi;"},
{"lineNum":"  422","line":"      }"},
{"lineNum":"  423","line":"    }"},
{"lineNum":"  424","line":""},
{"lineNum":"  425","line":"    /*** fixed-size vectorized path ***/"},
{"lineNum":"  426","line":"    else if(SizeAtCompileTime != Dynamic && MinAlignment>0) // FIXME should be compared to the required alignment"},
{"lineNum":"  427","line":"    {"},
{"lineNum":"  428","line":"      const OtherPacket pc = pset1<OtherPacket>(c);"},
{"lineNum":"  429","line":"      const OtherPacket ps = pset1<OtherPacket>(s);"},
{"lineNum":"  430","line":"      conj_helper<OtherPacket,Packet,NumTraits<OtherPacket>::IsComplex,false> pcj;"},
{"lineNum":"  431","line":"      conj_helper<OtherPacket,Packet,false,false> pm;"},
{"lineNum":"  432","line":"      Scalar* EIGEN_RESTRICT px = x;"},
{"lineNum":"  433","line":"      Scalar* EIGEN_RESTRICT py = y;"},
{"lineNum":"  434","line":"      for(Index i=0; i<size; i+=PacketSize)"},
{"lineNum":"  435","line":"      {"},
{"lineNum":"  436","line":"        Packet xi = pload<Packet>(px);"},
{"lineNum":"  437","line":"        Packet yi = pload<Packet>(py);"},
{"lineNum":"  438","line":"        pstore(px, padd(pm.pmul(pc,xi),pcj.pmul(ps,yi)));"},
{"lineNum":"  439","line":"        pstore(py, psub(pcj.pmul(pc,yi),pm.pmul(ps,xi)));"},
{"lineNum":"  440","line":"        px += PacketSize;"},
{"lineNum":"  441","line":"        py += PacketSize;"},
{"lineNum":"  442","line":"      }"},
{"lineNum":"  443","line":"    }"},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"    /*** non-vectorized path ***/"},
{"lineNum":"  446","line":"    else"},
{"lineNum":"  447","line":"    {"},
{"lineNum":"  448","line":"      apply_rotation_in_the_plane_selector<Scalar,OtherScalar,SizeAtCompileTime,MinAlignment,false>::run(x,incrx,y,incry,size,c,s);"},
{"lineNum":"  449","line":"    }"},
{"lineNum":"  450","line":"  }"},
{"lineNum":"  451","line":"};"},
{"lineNum":"  452","line":""},
{"lineNum":"  453","line":"template<typename VectorX, typename VectorY, typename OtherScalar>"},
{"lineNum":"  454","line":"EIGEN_DEVICE_FUNC"},
{"lineNum":"  455","line":"void /*EIGEN_DONT_INLINE*/ apply_rotation_in_the_plane(DenseBase<VectorX>& xpr_x, DenseBase<VectorY>& xpr_y, const JacobiRotation<OtherScalar>& j)"},
{"lineNum":"  456","line":"{"},
{"lineNum":"  457","line":"  typedef typename VectorX::Scalar Scalar;"},
{"lineNum":"  458","line":"  const bool Vectorizable =    (int(VectorX::Flags) & int(VectorY::Flags) & PacketAccessBit)"},
{"lineNum":"  459","line":"                            && (int(packet_traits<Scalar>::size) == int(packet_traits<OtherScalar>::size));"},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":"  eigen_assert(xpr_x.size() == xpr_y.size());"},
{"lineNum":"  462","line":"  Index size = xpr_x.size();"},
{"lineNum":"  463","line":"  Index incrx = xpr_x.derived().innerStride();"},
{"lineNum":"  464","line":"  Index incry = xpr_y.derived().innerStride();"},
{"lineNum":"  465","line":""},
{"lineNum":"  466","line":"  Scalar* EIGEN_RESTRICT x = &xpr_x.derived().coeffRef(0);"},
{"lineNum":"  467","line":"  Scalar* EIGEN_RESTRICT y = &xpr_y.derived().coeffRef(0);"},
{"lineNum":"  468","line":""},
{"lineNum":"  469","line":"  OtherScalar c = j.c();"},
{"lineNum":"  470","line":"  OtherScalar s = j.s();"},
{"lineNum":"  471","line":"  if (c==OtherScalar(1) && s==OtherScalar(0))","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  472","line":"    return;"},
{"lineNum":"  473","line":""},
{"lineNum":"  474","line":"  apply_rotation_in_the_plane_selector<"},
{"lineNum":"  475","line":"    Scalar,OtherScalar,"},
{"lineNum":"  476","line":"    VectorX::SizeAtCompileTime,"},
{"lineNum":"  477","line":"    EIGEN_PLAIN_ENUM_MIN(evaluator<VectorX>::Alignment, evaluator<VectorY>::Alignment),"},
{"lineNum":"  478","line":"    Vectorizable>::run(x,incrx,y,incry,size,c,s);"},
{"lineNum":"  479","line":"}"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"} // end namespace internal"},
{"lineNum":"  482","line":""},
{"lineNum":"  483","line":"} // end namespace Eigen"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"#endif // EIGEN_JACOBI_H"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 8, "covered" : 0,};
var merged_data = [];
