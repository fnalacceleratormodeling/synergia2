var data = {lines:[
{"lineNum":"    1","line":"///////////////////////////////////////////////////////////////////////////////"},
{"lineNum":"    2","line":"/// \\file traits.hpp"},
{"lineNum":"    3","line":"/// Contains definitions for child\\<\\>, child_c\\<\\>, left\\<\\>,"},
{"lineNum":"    4","line":"/// right\\<\\>, tag_of\\<\\>, and the helper functions child(), child_c(),"},
{"lineNum":"    5","line":"/// value(), left() and right()."},
{"lineNum":"    6","line":"//"},
{"lineNum":"    7","line":"//  Copyright 2008 Eric Niebler. Distributed under the Boost"},
{"lineNum":"    8","line":"//  Software License, Version 1.0. (See accompanying file"},
{"lineNum":"    9","line":"//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"#ifndef BOOST_PROTO_ARG_TRAITS_HPP_EAN_04_01_2005"},
{"lineNum":"   12","line":"#define BOOST_PROTO_ARG_TRAITS_HPP_EAN_04_01_2005"},
{"lineNum":"   13","line":""},
{"lineNum":"   14","line":"#include <boost/config.hpp>"},
{"lineNum":"   15","line":"#include <boost/detail/workaround.hpp>"},
{"lineNum":"   16","line":"#include <boost/preprocessor/iteration/iterate.hpp>"},
{"lineNum":"   17","line":"#include <boost/preprocessor/repetition/enum.hpp>"},
{"lineNum":"   18","line":"#include <boost/preprocessor/repetition/enum_params.hpp>"},
{"lineNum":"   19","line":"#include <boost/preprocessor/repetition/enum_trailing_params.hpp>"},
{"lineNum":"   20","line":"#include <boost/preprocessor/repetition/repeat.hpp>"},
{"lineNum":"   21","line":"#include <boost/preprocessor/repetition/repeat_from_to.hpp>"},
{"lineNum":"   22","line":"#include <boost/preprocessor/facilities/intercept.hpp>"},
{"lineNum":"   23","line":"#include <boost/preprocessor/arithmetic/sub.hpp>"},
{"lineNum":"   24","line":"#include <boost/static_assert.hpp>"},
{"lineNum":"   25","line":"#include <boost/mpl/bool.hpp>"},
{"lineNum":"   26","line":"#include <boost/proto/detail/template_arity.hpp>"},
{"lineNum":"   27","line":"#include <boost/type_traits/is_pod.hpp>"},
{"lineNum":"   28","line":"#include <boost/type_traits/is_same.hpp>"},
{"lineNum":"   29","line":"#include <boost/type_traits/add_const.hpp>"},
{"lineNum":"   30","line":"#include <boost/proto/proto_fwd.hpp>"},
{"lineNum":"   31","line":"#include <boost/proto/args.hpp>"},
{"lineNum":"   32","line":"#include <boost/proto/domain.hpp>"},
{"lineNum":"   33","line":"#include <boost/proto/transform/pass_through.hpp>"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"#if defined(_MSC_VER)"},
{"lineNum":"   36","line":"# pragma warning(push)"},
{"lineNum":"   37","line":"# if BOOST_WORKAROUND( BOOST_MSVC, >= 1400 )"},
{"lineNum":"   38","line":"#  pragma warning(disable: 4180) // warning C4180: qualifier applied to function type has no meaning; ignored"},
{"lineNum":"   39","line":"# endif"},
{"lineNum":"   40","line":"# pragma warning(disable : 4714) // function \'xxx\' marked as __forceinline not inlined"},
{"lineNum":"   41","line":"#endif"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"namespace boost { namespace proto"},
{"lineNum":"   44","line":"{"},
{"lineNum":"   45","line":"    namespace detail"},
{"lineNum":"   46","line":"    {"},
{"lineNum":"   47","line":"        template<typename T, typename Void = void>"},
{"lineNum":"   48","line":"        struct if_vararg"},
{"lineNum":"   49","line":"        {};"},
{"lineNum":"   50","line":""},
{"lineNum":"   51","line":"        template<typename T>"},
{"lineNum":"   52","line":"        struct if_vararg<T, typename T::proto_is_vararg_>"},
{"lineNum":"   53","line":"          : T"},
{"lineNum":"   54","line":"        {};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"        template<typename T, typename Void = void>"},
{"lineNum":"   57","line":"        struct is_callable2_"},
{"lineNum":"   58","line":"          : mpl::false_"},
{"lineNum":"   59","line":"        {};"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"        template<typename T>"},
{"lineNum":"   62","line":"        struct is_callable2_<T, typename T::proto_is_callable_>"},
{"lineNum":"   63","line":"          : mpl::true_"},
{"lineNum":"   64","line":"        {};"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"        template<typename T BOOST_PROTO_TEMPLATE_ARITY_PARAM(long Arity = boost::proto::detail::template_arity<T>::value)>"},
{"lineNum":"   67","line":"        struct is_callable_"},
{"lineNum":"   68","line":"          : is_callable2_<T>"},
{"lineNum":"   69","line":"        {};"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"    }"},
{"lineNum":"   72","line":""},
{"lineNum":"   73","line":"    /// \\brief Boolean metafunction which detects whether a type is"},
{"lineNum":"   74","line":"    /// a callable function object type or not."},
{"lineNum":"   75","line":"    ///"},
{"lineNum":"   76","line":"    /// <tt>is_callable\\<\\></tt> is used by the <tt>when\\<\\></tt> transform"},
{"lineNum":"   77","line":"    /// to determine whether a function type <tt>R(A1,A2,...AN)</tt> is a"},
{"lineNum":"   78","line":"    /// callable transform or an object transform. (The former are evaluated"},
{"lineNum":"   79","line":"    /// using <tt>call\\<\\></tt> and the later with <tt>make\\<\\></tt>.) If"},
{"lineNum":"   80","line":"    /// <tt>is_callable\\<R\\>::value</tt> is \\c true, the function type is"},
{"lineNum":"   81","line":"    /// a callable transform; otherwise, it is an object transform."},
{"lineNum":"   82","line":"    ///"},
{"lineNum":"   83","line":"    /// Unless specialized for a type \\c T, <tt>is_callable\\<T\\>::value</tt>"},
{"lineNum":"   84","line":"    /// is computed as follows:"},
{"lineNum":"   85","line":"    ///"},
{"lineNum":"   86","line":"    /// \\li If \\c T is a template type <tt>X\\<Y0,Y1,...YN\\></tt>, where all \\c Yx"},
{"lineNum":"   87","line":"    /// are types for \\c x in <tt>[0,N]</tt>, <tt>is_callable\\<T\\>::value</tt>"},
{"lineNum":"   88","line":"    /// is <tt>is_same\\<YN, proto::callable\\>::value</tt>."},
{"lineNum":"   89","line":"    /// \\li If \\c T has a nested type \\c proto_is_callable_ that is a typedef"},
{"lineNum":"   90","line":"    /// for \\c void, <tt>is_callable\\<T\\>::value</tt> is \\c true. (Note: this is"},
{"lineNum":"   91","line":"    /// the case for any type that derives from \\c proto::callable.)"},
{"lineNum":"   92","line":"    /// \\li Otherwise, <tt>is_callable\\<T\\>::value</tt> is \\c false."},
{"lineNum":"   93","line":"    template<typename T>"},
{"lineNum":"   94","line":"    struct is_callable"},
{"lineNum":"   95","line":"      : proto::detail::is_callable_<T>"},
{"lineNum":"   96","line":"    {};"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"    /// INTERNAL ONLY"},
{"lineNum":"   99","line":"    ///"},
{"lineNum":"  100","line":"    template<>"},
{"lineNum":"  101","line":"    struct is_callable<proto::_>"},
{"lineNum":"  102","line":"      : mpl::true_"},
{"lineNum":"  103","line":"    {};"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"    /// INTERNAL ONLY"},
{"lineNum":"  106","line":"    ///"},
{"lineNum":"  107","line":"    template<>"},
{"lineNum":"  108","line":"    struct is_callable<proto::callable>"},
{"lineNum":"  109","line":"      : mpl::false_"},
{"lineNum":"  110","line":"    {};"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"    /// INTERNAL ONLY"},
{"lineNum":"  113","line":"    ///"},
{"lineNum":"  114","line":"    template<typename PrimitiveTransform, typename X>"},
{"lineNum":"  115","line":"    struct is_callable<proto::transform<PrimitiveTransform, X> >"},
{"lineNum":"  116","line":"      : mpl::false_"},
{"lineNum":"  117","line":"    {};"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    #if BOOST_WORKAROUND(__GNUC__, == 3) || (BOOST_WORKAROUND(__GNUC__, == 4) && __GNUC_MINOR__ == 0)"},
{"lineNum":"  120","line":"    // work around GCC bug"},
{"lineNum":"  121","line":"    template<typename Tag, typename Args, long N>"},
{"lineNum":"  122","line":"    struct is_callable<proto::expr<Tag, Args, N> >"},
{"lineNum":"  123","line":"      : mpl::false_"},
{"lineNum":"  124","line":"    {};"},
{"lineNum":"  125","line":""},
{"lineNum":"  126","line":"    // work around GCC bug"},
{"lineNum":"  127","line":"    template<typename Tag, typename Args, long N>"},
{"lineNum":"  128","line":"    struct is_callable<proto::basic_expr<Tag, Args, N> >"},
{"lineNum":"  129","line":"      : mpl::false_"},
{"lineNum":"  130","line":"    {};"},
{"lineNum":"  131","line":"    #endif"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"    namespace detail"},
{"lineNum":"  134","line":"    {"},
{"lineNum":"  135","line":"        template<typename T, typename Void /*= void*/>"},
{"lineNum":"  136","line":"        struct is_transform_"},
{"lineNum":"  137","line":"          : mpl::false_"},
{"lineNum":"  138","line":"        {};"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"        template<typename T>"},
{"lineNum":"  141","line":"        struct is_transform_<T, typename T::proto_is_transform_>"},
{"lineNum":"  142","line":"          : mpl::true_"},
{"lineNum":"  143","line":"        {};"},
{"lineNum":"  144","line":"    }"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"    /// \\brief Boolean metafunction which detects whether a type is"},
{"lineNum":"  147","line":"    /// a PrimitiveTransform type or not."},
{"lineNum":"  148","line":"    ///"},
{"lineNum":"  149","line":"    /// <tt>is_transform\\<\\></tt> is used by the <tt>call\\<\\></tt> transform"},
{"lineNum":"  150","line":"    /// to determine whether the function types <tt>R()</tt>, <tt>R(A1)</tt>,"},
{"lineNum":"  151","line":"    /// and <tt>R(A1, A2)</tt> should be passed the expression, state and data"},
{"lineNum":"  152","line":"    /// parameters (as needed)."},
{"lineNum":"  153","line":"    ///"},
{"lineNum":"  154","line":"    /// Unless specialized for a type \\c T, <tt>is_transform\\<T\\>::value</tt>"},
{"lineNum":"  155","line":"    /// is computed as follows:"},
{"lineNum":"  156","line":"    ///"},
{"lineNum":"  157","line":"    /// \\li If \\c T has a nested type \\c proto_is_transform_ that is a typedef"},
{"lineNum":"  158","line":"    /// for \\c void, <tt>is_transform\\<T\\>::value</tt> is \\c true. (Note: this is"},
{"lineNum":"  159","line":"    /// the case for any type that derives from an instantiation of \\c proto::transform.)"},
{"lineNum":"  160","line":"    /// \\li Otherwise, <tt>is_transform\\<T\\>::value</tt> is \\c false."},
{"lineNum":"  161","line":"    template<typename T>"},
{"lineNum":"  162","line":"    struct is_transform"},
{"lineNum":"  163","line":"      : proto::detail::is_transform_<T>"},
{"lineNum":"  164","line":"    {};"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"    namespace detail"},
{"lineNum":"  167","line":"    {"},
{"lineNum":"  168","line":"        template<typename T, typename Void /*= void*/>"},
{"lineNum":"  169","line":"        struct is_aggregate_"},
{"lineNum":"  170","line":"          : is_pod<T>"},
{"lineNum":"  171","line":"        {};"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"        template<typename Tag, typename Args, long N>"},
{"lineNum":"  174","line":"        struct is_aggregate_<proto::expr<Tag, Args, N>, void>"},
{"lineNum":"  175","line":"          : mpl::true_"},
{"lineNum":"  176","line":"        {};"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"        template<typename Tag, typename Args, long N>"},
{"lineNum":"  179","line":"        struct is_aggregate_<proto::basic_expr<Tag, Args, N>, void>"},
{"lineNum":"  180","line":"          : mpl::true_"},
{"lineNum":"  181","line":"        {};"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"        template<typename T>"},
{"lineNum":"  184","line":"        struct is_aggregate_<T, typename T::proto_is_aggregate_>"},
{"lineNum":"  185","line":"          : mpl::true_"},
{"lineNum":"  186","line":"        {};"},
{"lineNum":"  187","line":"    }"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"    /// \\brief A Boolean metafunction that indicates whether a type requires"},
{"lineNum":"  190","line":"    /// aggregate initialization."},
{"lineNum":"  191","line":"    ///"},
{"lineNum":"  192","line":"    /// <tt>is_aggregate\\<\\></tt> is used by the <tt>make\\<\\></tt> transform"},
{"lineNum":"  193","line":"    /// to determine how to construct an object of some type \\c T, given some"},
{"lineNum":"  194","line":"    /// initialization arguments <tt>a0,a1,...aN</tt>."},
{"lineNum":"  195","line":"    /// If <tt>is_aggregate\\<T\\>::value</tt> is \\c true, then an object of"},
{"lineNum":"  196","line":"    /// type T will be initialized as <tt>T t = {a0,a1,...aN};</tt>. Otherwise,"},
{"lineNum":"  197","line":"    /// it will be initialized as <tt>T t(a0,a1,...aN)</tt>."},
{"lineNum":"  198","line":"    template<typename T>"},
{"lineNum":"  199","line":"    struct is_aggregate"},
{"lineNum":"  200","line":"      : proto::detail::is_aggregate_<T>"},
{"lineNum":"  201","line":"    {};"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"    /// \\brief A Boolean metafunction that indicates whether a given"},
{"lineNum":"  204","line":"    /// type \\c T is a Proto expression type."},
{"lineNum":"  205","line":"    ///"},
{"lineNum":"  206","line":"    /// If \\c T has a nested type \\c proto_is_expr_ that is a typedef"},
{"lineNum":"  207","line":"    /// for \\c void, <tt>is_expr\\<T\\>::value</tt> is \\c true. (Note, this"},
{"lineNum":"  208","line":"    /// is the case for <tt>proto::expr\\<\\></tt>, any type that is derived"},
{"lineNum":"  209","line":"    /// from <tt>proto::extends\\<\\></tt> or that uses the"},
{"lineNum":"  210","line":"    /// <tt>BOOST_PROTO_BASIC_EXTENDS()</tt> macro.) Otherwise,"},
{"lineNum":"  211","line":"    /// <tt>is_expr\\<T\\>::value</tt> is \\c false."},
{"lineNum":"  212","line":"    template<typename T, typename Void /* = void*/>"},
{"lineNum":"  213","line":"    struct is_expr"},
{"lineNum":"  214","line":"      : mpl::false_"},
{"lineNum":"  215","line":"    {};"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    /// \\brief A Boolean metafunction that indicates whether a given"},
{"lineNum":"  218","line":"    /// type \\c T is a Proto expression type."},
{"lineNum":"  219","line":"    ///"},
{"lineNum":"  220","line":"    /// If \\c T has a nested type \\c proto_is_expr_ that is a typedef"},
{"lineNum":"  221","line":"    /// for \\c void, <tt>is_expr\\<T\\>::value</tt> is \\c true. (Note, this"},
{"lineNum":"  222","line":"    /// is the case for <tt>proto::expr\\<\\></tt>, any type that is derived"},
{"lineNum":"  223","line":"    /// from <tt>proto::extends\\<\\></tt> or that uses the"},
{"lineNum":"  224","line":"    /// <tt>BOOST_PROTO_BASIC_EXTENDS()</tt> macro.) Otherwise,"},
{"lineNum":"  225","line":"    /// <tt>is_expr\\<T\\>::value</tt> is \\c false."},
{"lineNum":"  226","line":"    template<typename T>"},
{"lineNum":"  227","line":"    struct is_expr<T, typename T::proto_is_expr_>"},
{"lineNum":"  228","line":"      : mpl::true_"},
{"lineNum":"  229","line":"    {};"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"    template<typename T>"},
{"lineNum":"  232","line":"    struct is_expr<T &, void>"},
{"lineNum":"  233","line":"      : is_expr<T>"},
{"lineNum":"  234","line":"    {};"},
{"lineNum":"  235","line":""},
{"lineNum":"  236","line":"    /// \\brief A metafunction that returns the tag type of a"},
{"lineNum":"  237","line":"    /// Proto expression."},
{"lineNum":"  238","line":"    template<typename Expr>"},
{"lineNum":"  239","line":"    struct tag_of"},
{"lineNum":"  240","line":"    {"},
{"lineNum":"  241","line":"        typedef typename Expr::proto_tag type;"},
{"lineNum":"  242","line":"    };"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"    template<typename Expr>"},
{"lineNum":"  245","line":"    struct tag_of<Expr &>"},
{"lineNum":"  246","line":"    {"},
{"lineNum":"  247","line":"        typedef typename Expr::proto_tag type;"},
{"lineNum":"  248","line":"    };"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"    /// \\brief A metafunction that returns the arity of a"},
{"lineNum":"  251","line":"    /// Proto expression."},
{"lineNum":"  252","line":"    template<typename Expr>"},
{"lineNum":"  253","line":"    struct arity_of"},
{"lineNum":"  254","line":"      : Expr::proto_arity"},
{"lineNum":"  255","line":"    {};"},
{"lineNum":"  256","line":""},
{"lineNum":"  257","line":"    template<typename Expr>"},
{"lineNum":"  258","line":"    struct arity_of<Expr &>"},
{"lineNum":"  259","line":"      : Expr::proto_arity"},
{"lineNum":"  260","line":"    {};"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"    namespace result_of"},
{"lineNum":"  263","line":"    {"},
{"lineNum":"  264","line":"        /// \\brief A metafunction that computes the return type of the \\c as_expr()"},
{"lineNum":"  265","line":"        /// function."},
{"lineNum":"  266","line":"        template<typename T, typename Domain /*= default_domain*/>"},
{"lineNum":"  267","line":"        struct as_expr"},
{"lineNum":"  268","line":"        {"},
{"lineNum":"  269","line":"            typedef typename Domain::template as_expr<T>::result_type type;"},
{"lineNum":"  270","line":"        };"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"        /// \\brief A metafunction that computes the return type of the \\c as_child()"},
{"lineNum":"  273","line":"        /// function."},
{"lineNum":"  274","line":"        template<typename T, typename Domain /*= default_domain*/>"},
{"lineNum":"  275","line":"        struct as_child"},
{"lineNum":"  276","line":"        {"},
{"lineNum":"  277","line":"            typedef typename Domain::template as_child<T>::result_type type;"},
{"lineNum":"  278","line":"        };"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"        /// \\brief A metafunction that returns the type of the Nth child"},
{"lineNum":"  281","line":"        /// of a Proto expression, where N is an MPL Integral Constant."},
{"lineNum":"  282","line":"        ///"},
{"lineNum":"  283","line":"        /// <tt>result_of::child\\<Expr, N\\></tt> is equivalent to"},
{"lineNum":"  284","line":"        /// <tt>result_of::child_c\\<Expr, N::value\\></tt>."},
{"lineNum":"  285","line":"        template<typename Expr, typename N /* = mpl::long_<0>*/>"},
{"lineNum":"  286","line":"        struct child"},
{"lineNum":"  287","line":"          : child_c<Expr, N::value>"},
{"lineNum":"  288","line":"        {};"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"        /// \\brief A metafunction that returns the type of the value"},
{"lineNum":"  291","line":"        /// of a terminal Proto expression."},
{"lineNum":"  292","line":"        ///"},
{"lineNum":"  293","line":"        template<typename Expr>"},
{"lineNum":"  294","line":"        struct value"},
{"lineNum":"  295","line":"        {"},
{"lineNum":"  296","line":"            /// Verify that we are actually operating on a terminal"},
{"lineNum":"  297","line":"            BOOST_STATIC_ASSERT(0 == Expr::proto_arity_c);"},
{"lineNum":"  298","line":""},
{"lineNum":"  299","line":"            /// The raw type of the Nth child as it is stored within"},
{"lineNum":"  300","line":"            /// \\c Expr. This may be a value or a reference"},
{"lineNum":"  301","line":"            typedef typename Expr::proto_child0 value_type;"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"            /// The \"value\" type of the child, suitable for storage by value,"},
{"lineNum":"  304","line":"            /// computed as follows:"},
{"lineNum":"  305","line":"            /// \\li <tt>T const(&)[N]</tt> becomes <tt>T[N]</tt>"},
{"lineNum":"  306","line":"            /// \\li <tt>T[N]</tt> becomes <tt>T[N]</tt>"},
{"lineNum":"  307","line":"            /// \\li <tt>T(&)[N]</tt> becomes <tt>T[N]</tt>"},
{"lineNum":"  308","line":"            /// \\li <tt>R(&)(A0,...)</tt> becomes <tt>R(&)(A0,...)</tt>"},
{"lineNum":"  309","line":"            /// \\li <tt>T const &</tt> becomes <tt>T</tt>"},
{"lineNum":"  310","line":"            /// \\li <tt>T &</tt> becomes <tt>T</tt>"},
{"lineNum":"  311","line":"            /// \\li <tt>T</tt> becomes <tt>T</tt>"},
{"lineNum":"  312","line":"            typedef typename detail::term_traits<typename Expr::proto_child0>::value_type type;"},
{"lineNum":"  313","line":"        };"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"        template<typename Expr>"},
{"lineNum":"  316","line":"        struct value<Expr &>"},
{"lineNum":"  317","line":"        {"},
{"lineNum":"  318","line":"            /// Verify that we are actually operating on a terminal"},
{"lineNum":"  319","line":"            BOOST_STATIC_ASSERT(0 == Expr::proto_arity_c);"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"            /// The raw type of the Nth child as it is stored within"},
{"lineNum":"  322","line":"            /// \\c Expr. This may be a value or a reference"},
{"lineNum":"  323","line":"            typedef typename Expr::proto_child0 value_type;"},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"            /// The \"reference\" type of the child, suitable for storage by"},
{"lineNum":"  326","line":"            /// reference, computed as follows:"},
{"lineNum":"  327","line":"            /// \\li <tt>T const(&)[N]</tt> becomes <tt>T const(&)[N]</tt>"},
{"lineNum":"  328","line":"            /// \\li <tt>T[N]</tt> becomes <tt>T(&)[N]</tt>"},
{"lineNum":"  329","line":"            /// \\li <tt>T(&)[N]</tt> becomes <tt>T(&)[N]</tt>"},
{"lineNum":"  330","line":"            /// \\li <tt>R(&)(A0,...)</tt> becomes <tt>R(&)(A0,...)</tt>"},
{"lineNum":"  331","line":"            /// \\li <tt>T const &</tt> becomes <tt>T const &</tt>"},
{"lineNum":"  332","line":"            /// \\li <tt>T &</tt> becomes <tt>T &</tt>"},
{"lineNum":"  333","line":"            /// \\li <tt>T</tt> becomes <tt>T &</tt>"},
{"lineNum":"  334","line":"            typedef typename detail::term_traits<typename Expr::proto_child0>::reference type;"},
{"lineNum":"  335","line":"        };"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"        template<typename Expr>"},
{"lineNum":"  338","line":"        struct value<Expr const &>"},
{"lineNum":"  339","line":"        {"},
{"lineNum":"  340","line":"            /// Verify that we are actually operating on a terminal"},
{"lineNum":"  341","line":"            BOOST_STATIC_ASSERT(0 == Expr::proto_arity_c);"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"            /// The raw type of the Nth child as it is stored within"},
{"lineNum":"  344","line":"            /// \\c Expr. This may be a value or a reference"},
{"lineNum":"  345","line":"            typedef typename Expr::proto_child0 value_type;"},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"            /// The \"const reference\" type of the child, suitable for storage by"},
{"lineNum":"  348","line":"            /// const reference, computed as follows:"},
{"lineNum":"  349","line":"            /// \\li <tt>T const(&)[N]</tt> becomes <tt>T const(&)[N]</tt>"},
{"lineNum":"  350","line":"            /// \\li <tt>T[N]</tt> becomes <tt>T const(&)[N]</tt>"},
{"lineNum":"  351","line":"            /// \\li <tt>T(&)[N]</tt> becomes <tt>T(&)[N]</tt>"},
{"lineNum":"  352","line":"            /// \\li <tt>R(&)(A0,...)</tt> becomes <tt>R(&)(A0,...)</tt>"},
{"lineNum":"  353","line":"            /// \\li <tt>T const &</tt> becomes <tt>T const &</tt>"},
{"lineNum":"  354","line":"            /// \\li <tt>T &</tt> becomes <tt>T &</tt>"},
{"lineNum":"  355","line":"            /// \\li <tt>T</tt> becomes <tt>T const &</tt>"},
{"lineNum":"  356","line":"            typedef typename detail::term_traits<typename Expr::proto_child0>::const_reference type;"},
{"lineNum":"  357","line":"        };"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"        /// \\brief A metafunction that returns the type of the left child"},
{"lineNum":"  360","line":"        /// of a binary Proto expression."},
{"lineNum":"  361","line":"        ///"},
{"lineNum":"  362","line":"        /// <tt>result_of::left\\<Expr\\></tt> is equivalent to"},
{"lineNum":"  363","line":"        /// <tt>result_of::child_c\\<Expr, 0\\></tt>."},
{"lineNum":"  364","line":"        template<typename Expr>"},
{"lineNum":"  365","line":"        struct left"},
{"lineNum":"  366","line":"          : child_c<Expr, 0>"},
{"lineNum":"  367","line":"        {};"},
{"lineNum":"  368","line":""},
{"lineNum":"  369","line":"        /// \\brief A metafunction that returns the type of the right child"},
{"lineNum":"  370","line":"        /// of a binary Proto expression."},
{"lineNum":"  371","line":"        ///"},
{"lineNum":"  372","line":"        /// <tt>result_of::right\\<Expr\\></tt> is equivalent to"},
{"lineNum":"  373","line":"        /// <tt>result_of::child_c\\<Expr, 1\\></tt>."},
{"lineNum":"  374","line":"        template<typename Expr>"},
{"lineNum":"  375","line":"        struct right"},
{"lineNum":"  376","line":"          : child_c<Expr, 1>"},
{"lineNum":"  377","line":"        {};"},
{"lineNum":"  378","line":""},
{"lineNum":"  379","line":"    } // namespace result_of"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"    /// \\brief A metafunction for generating terminal expression types,"},
{"lineNum":"  382","line":"    /// a grammar element for matching terminal expressions, and a"},
{"lineNum":"  383","line":"    /// PrimitiveTransform that returns the current expression unchanged."},
{"lineNum":"  384","line":"    template<typename T>"},
{"lineNum":"  385","line":"    struct terminal"},
{"lineNum":"  386","line":"      : proto::transform<terminal<T>, int>"},
{"lineNum":"  387","line":"    {"},
{"lineNum":"  388","line":"        typedef proto::expr<proto::tag::terminal, term<T>, 0> type;"},
{"lineNum":"  389","line":"        typedef proto::basic_expr<proto::tag::terminal, term<T>, 0> proto_grammar;"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  392","line":"        struct impl : transform_impl<Expr, State, Data>"},
{"lineNum":"  393","line":"        {"},
{"lineNum":"  394","line":"            typedef Expr result_type;"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"            /// \\param e The current expression"},
{"lineNum":"  397","line":"            /// \\pre <tt>matches\\<Expr, terminal\\<T\\> \\>::value</tt> is \\c true."},
{"lineNum":"  398","line":"            /// \\return \\c e"},
{"lineNum":"  399","line":"            /// \\throw nothrow"},
{"lineNum":"  400","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  401","line":"            BOOST_PROTO_RETURN_TYPE_STRICT_LOOSE(result_type, typename impl::expr_param)"},
{"lineNum":"  402","line":"            operator ()("},
{"lineNum":"  403","line":"                typename impl::expr_param e"},
{"lineNum":"  404","line":"              , typename impl::state_param"},
{"lineNum":"  405","line":"              , typename impl::data_param"},
{"lineNum":"  406","line":"            ) const"},
{"lineNum":"  407","line":"            {"},
{"lineNum":"  408","line":"                return e;"},
{"lineNum":"  409","line":"            }"},
{"lineNum":"  410","line":"        };"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":"        /// INTERNAL ONLY"},
{"lineNum":"  413","line":"        typedef proto::tag::terminal proto_tag;"},
{"lineNum":"  414","line":"        /// INTERNAL ONLY"},
{"lineNum":"  415","line":"        typedef T proto_child0;"},
{"lineNum":"  416","line":"    };"},
{"lineNum":"  417","line":""},
{"lineNum":"  418","line":"    /// \\brief A metafunction for generating ternary conditional expression types,"},
{"lineNum":"  419","line":"    /// a grammar element for matching ternary conditional expressions, and a"},
{"lineNum":"  420","line":"    /// PrimitiveTransform that dispatches to the <tt>pass_through\\<\\></tt>"},
{"lineNum":"  421","line":"    /// transform."},
{"lineNum":"  422","line":"    template<typename T, typename U, typename V>"},
{"lineNum":"  423","line":"    struct if_else_"},
{"lineNum":"  424","line":"      : proto::transform<if_else_<T, U, V>, int>"},
{"lineNum":"  425","line":"    {"},
{"lineNum":"  426","line":"        typedef proto::expr<proto::tag::if_else_, list3<T, U, V>, 3> type;"},
{"lineNum":"  427","line":"        typedef proto::basic_expr<proto::tag::if_else_, list3<T, U, V>, 3> proto_grammar;"},
{"lineNum":"  428","line":""},
{"lineNum":"  429","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  430","line":"        struct impl"},
{"lineNum":"  431","line":"          : detail::pass_through_impl<if_else_, deduce_domain, Expr, State, Data>"},
{"lineNum":"  432","line":"        {};"},
{"lineNum":"  433","line":""},
{"lineNum":"  434","line":"        /// INTERNAL ONLY"},
{"lineNum":"  435","line":"        typedef proto::tag::if_else_ proto_tag;"},
{"lineNum":"  436","line":"        /// INTERNAL ONLY"},
{"lineNum":"  437","line":"        typedef T proto_child0;"},
{"lineNum":"  438","line":"        /// INTERNAL ONLY"},
{"lineNum":"  439","line":"        typedef U proto_child1;"},
{"lineNum":"  440","line":"        /// INTERNAL ONLY"},
{"lineNum":"  441","line":"        typedef V proto_child2;"},
{"lineNum":"  442","line":"    };"},
{"lineNum":"  443","line":""},
{"lineNum":"  444","line":"    /// \\brief A metafunction for generating nullary expression types with a"},
{"lineNum":"  445","line":"    /// specified tag type,"},
{"lineNum":"  446","line":"    /// a grammar element for matching nullary expressions, and a"},
{"lineNum":"  447","line":"    /// PrimitiveTransform that returns the current expression unchanged."},
{"lineNum":"  448","line":"    ///"},
{"lineNum":"  449","line":"    /// Use <tt>nullary_expr\\<_, _\\></tt> as a grammar element to match any"},
{"lineNum":"  450","line":"    /// nullary expression."},
{"lineNum":"  451","line":"    template<typename Tag, typename T>"},
{"lineNum":"  452","line":"    struct nullary_expr"},
{"lineNum":"  453","line":"      : proto::transform<nullary_expr<Tag, T>, int>"},
{"lineNum":"  454","line":"    {"},
{"lineNum":"  455","line":"        typedef proto::expr<Tag, term<T>, 0> type;"},
{"lineNum":"  456","line":"        typedef proto::basic_expr<Tag, term<T>, 0> proto_grammar;"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  459","line":"        struct impl : transform_impl<Expr, State, Data>"},
{"lineNum":"  460","line":"        {"},
{"lineNum":"  461","line":"            typedef Expr result_type;"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"            /// \\param e The current expression"},
{"lineNum":"  464","line":"            /// \\pre <tt>matches\\<Expr, nullary_expr\\<Tag, T\\> \\>::value</tt> is \\c true."},
{"lineNum":"  465","line":"            /// \\return \\c e"},
{"lineNum":"  466","line":"            /// \\throw nothrow"},
{"lineNum":"  467","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  468","line":"            BOOST_PROTO_RETURN_TYPE_STRICT_LOOSE(result_type, typename impl::expr_param)"},
{"lineNum":"  469","line":"            operator ()("},
{"lineNum":"  470","line":"                typename impl::expr_param e"},
{"lineNum":"  471","line":"              , typename impl::state_param"},
{"lineNum":"  472","line":"              , typename impl::data_param"},
{"lineNum":"  473","line":"            ) const"},
{"lineNum":"  474","line":"            {"},
{"lineNum":"  475","line":"                return e;"},
{"lineNum":"  476","line":"            }"},
{"lineNum":"  477","line":"        };"},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"        /// INTERNAL ONLY"},
{"lineNum":"  480","line":"        typedef Tag proto_tag;"},
{"lineNum":"  481","line":"        /// INTERNAL ONLY"},
{"lineNum":"  482","line":"        typedef T proto_child0;"},
{"lineNum":"  483","line":"    };"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"    /// \\brief A metafunction for generating unary expression types with a"},
{"lineNum":"  486","line":"    /// specified tag type,"},
{"lineNum":"  487","line":"    /// a grammar element for matching unary expressions, and a"},
{"lineNum":"  488","line":"    /// PrimitiveTransform that dispatches to the <tt>pass_through\\<\\></tt>"},
{"lineNum":"  489","line":"    /// transform."},
{"lineNum":"  490","line":"    ///"},
{"lineNum":"  491","line":"    /// Use <tt>unary_expr\\<_, _\\></tt> as a grammar element to match any"},
{"lineNum":"  492","line":"    /// unary expression."},
{"lineNum":"  493","line":"    template<typename Tag, typename T>"},
{"lineNum":"  494","line":"    struct unary_expr"},
{"lineNum":"  495","line":"      : proto::transform<unary_expr<Tag, T>, int>"},
{"lineNum":"  496","line":"    {"},
{"lineNum":"  497","line":"        typedef proto::expr<Tag, list1<T>, 1> type;"},
{"lineNum":"  498","line":"        typedef proto::basic_expr<Tag, list1<T>, 1> proto_grammar;"},
{"lineNum":"  499","line":""},
{"lineNum":"  500","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  501","line":"        struct impl"},
{"lineNum":"  502","line":"          : detail::pass_through_impl<unary_expr, deduce_domain, Expr, State, Data>"},
{"lineNum":"  503","line":"        {};"},
{"lineNum":"  504","line":""},
{"lineNum":"  505","line":"        /// INTERNAL ONLY"},
{"lineNum":"  506","line":"        typedef Tag proto_tag;"},
{"lineNum":"  507","line":"        /// INTERNAL ONLY"},
{"lineNum":"  508","line":"        typedef T proto_child0;"},
{"lineNum":"  509","line":"    };"},
{"lineNum":"  510","line":""},
{"lineNum":"  511","line":"    /// \\brief A metafunction for generating binary expression types with a"},
{"lineNum":"  512","line":"    /// specified tag type,"},
{"lineNum":"  513","line":"    /// a grammar element for matching binary expressions, and a"},
{"lineNum":"  514","line":"    /// PrimitiveTransform that dispatches to the <tt>pass_through\\<\\></tt>"},
{"lineNum":"  515","line":"    /// transform."},
{"lineNum":"  516","line":"    ///"},
{"lineNum":"  517","line":"    /// Use <tt>binary_expr\\<_, _, _\\></tt> as a grammar element to match any"},
{"lineNum":"  518","line":"    /// binary expression."},
{"lineNum":"  519","line":"    template<typename Tag, typename T, typename U>"},
{"lineNum":"  520","line":"    struct binary_expr"},
{"lineNum":"  521","line":"      : proto::transform<binary_expr<Tag, T, U>, int>"},
{"lineNum":"  522","line":"    {"},
{"lineNum":"  523","line":"        typedef proto::expr<Tag, list2<T, U>, 2> type;"},
{"lineNum":"  524","line":"        typedef proto::basic_expr<Tag, list2<T, U>, 2> proto_grammar;"},
{"lineNum":"  525","line":""},
{"lineNum":"  526","line":"        template<typename Expr, typename State, typename Data>"},
{"lineNum":"  527","line":"        struct impl"},
{"lineNum":"  528","line":"          : detail::pass_through_impl<binary_expr, deduce_domain, Expr, State, Data>"},
{"lineNum":"  529","line":"        {};"},
{"lineNum":"  530","line":""},
{"lineNum":"  531","line":"        /// INTERNAL ONLY"},
{"lineNum":"  532","line":"        typedef Tag proto_tag;"},
{"lineNum":"  533","line":"        /// INTERNAL ONLY"},
{"lineNum":"  534","line":"        typedef T proto_child0;"},
{"lineNum":"  535","line":"        /// INTERNAL ONLY"},
{"lineNum":"  536","line":"        typedef U proto_child1;"},
{"lineNum":"  537","line":"    };"},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"#define BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(Op)                                               \\"},
{"lineNum":"  540","line":"    template<typename T>                                                                        \\"},
{"lineNum":"  541","line":"    struct Op                                                                                   \\"},
{"lineNum":"  542","line":"      : proto::transform<Op<T>, int>                                                            \\"},
{"lineNum":"  543","line":"    {                                                                                           \\"},
{"lineNum":"  544","line":"        typedef proto::expr<proto::tag::Op, list1<T>, 1> type;                                  \\"},
{"lineNum":"  545","line":"        typedef proto::basic_expr<proto::tag::Op, list1<T>, 1> proto_grammar;                   \\"},
{"lineNum":"  546","line":"                                                                                                \\"},
{"lineNum":"  547","line":"        template<typename Expr, typename State, typename Data>                                  \\"},
{"lineNum":"  548","line":"        struct impl                                                                             \\"},
{"lineNum":"  549","line":"          : detail::pass_through_impl<Op, deduce_domain, Expr, State, Data>                     \\"},
{"lineNum":"  550","line":"        {};                                                                                     \\"},
{"lineNum":"  551","line":"                                                                                                \\"},
{"lineNum":"  552","line":"        typedef proto::tag::Op proto_tag;                                                       \\"},
{"lineNum":"  553","line":"        typedef T proto_child0;                                                                 \\"},
{"lineNum":"  554","line":"    };                                                                                          \\"},
{"lineNum":"  555","line":"    /**/"},
{"lineNum":"  556","line":""},
{"lineNum":"  557","line":"#define BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(Op)                                              \\"},
{"lineNum":"  558","line":"    template<typename T, typename U>                                                            \\"},
{"lineNum":"  559","line":"    struct Op                                                                                   \\"},
{"lineNum":"  560","line":"      : proto::transform<Op<T, U>, int>                                                         \\"},
{"lineNum":"  561","line":"    {                                                                                           \\"},
{"lineNum":"  562","line":"        typedef proto::expr<proto::tag::Op, list2<T, U>, 2> type;                               \\"},
{"lineNum":"  563","line":"        typedef proto::basic_expr<proto::tag::Op, list2<T, U>, 2> proto_grammar;                \\"},
{"lineNum":"  564","line":"                                                                                                \\"},
{"lineNum":"  565","line":"        template<typename Expr, typename State, typename Data>                                  \\"},
{"lineNum":"  566","line":"        struct impl                                                                             \\"},
{"lineNum":"  567","line":"          : detail::pass_through_impl<Op, deduce_domain, Expr, State, Data>                     \\"},
{"lineNum":"  568","line":"        {};                                                                                     \\"},
{"lineNum":"  569","line":"                                                                                                \\"},
{"lineNum":"  570","line":"        typedef proto::tag::Op proto_tag;                                                       \\"},
{"lineNum":"  571","line":"        typedef T proto_child0;                                                                 \\"},
{"lineNum":"  572","line":"        typedef U proto_child1;                                                                 \\"},
{"lineNum":"  573","line":"    };                                                                                          \\"},
{"lineNum":"  574","line":"    /**/"},
{"lineNum":"  575","line":""},
{"lineNum":"  576","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(unary_plus)"},
{"lineNum":"  577","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(negate)"},
{"lineNum":"  578","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(dereference)"},
{"lineNum":"  579","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(complement)"},
{"lineNum":"  580","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(address_of)"},
{"lineNum":"  581","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(logical_not)"},
{"lineNum":"  582","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(pre_inc)"},
{"lineNum":"  583","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(pre_dec)"},
{"lineNum":"  584","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(post_inc)"},
{"lineNum":"  585","line":"    BOOST_PROTO_DEFINE_UNARY_METAFUNCTION(post_dec)"},
{"lineNum":"  586","line":""},
{"lineNum":"  587","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(shift_left)"},
{"lineNum":"  588","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(shift_right)"},
{"lineNum":"  589","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(multiplies)"},
{"lineNum":"  590","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(divides)"},
{"lineNum":"  591","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(modulus)"},
{"lineNum":"  592","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(plus)"},
{"lineNum":"  593","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(minus)"},
{"lineNum":"  594","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(less)"},
{"lineNum":"  595","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(greater)"},
{"lineNum":"  596","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(less_equal)"},
{"lineNum":"  597","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(greater_equal)"},
{"lineNum":"  598","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(equal_to)"},
{"lineNum":"  599","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(not_equal_to)"},
{"lineNum":"  600","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(logical_or)"},
{"lineNum":"  601","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(logical_and)"},
{"lineNum":"  602","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(bitwise_or)"},
{"lineNum":"  603","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(bitwise_and)"},
{"lineNum":"  604","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(bitwise_xor)"},
{"lineNum":"  605","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(comma)"},
{"lineNum":"  606","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(mem_ptr)"},
{"lineNum":"  607","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(assign)"},
{"lineNum":"  608","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(shift_left_assign)"},
{"lineNum":"  609","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(shift_right_assign)"},
{"lineNum":"  610","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(multiplies_assign)"},
{"lineNum":"  611","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(divides_assign)"},
{"lineNum":"  612","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(modulus_assign)"},
{"lineNum":"  613","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(plus_assign)"},
{"lineNum":"  614","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(minus_assign)"},
{"lineNum":"  615","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(bitwise_or_assign)"},
{"lineNum":"  616","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(bitwise_and_assign)"},
{"lineNum":"  617","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(bitwise_xor_assign)"},
{"lineNum":"  618","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(subscript)"},
{"lineNum":"  619","line":"    BOOST_PROTO_DEFINE_BINARY_METAFUNCTION(member)"},
{"lineNum":"  620","line":""},
{"lineNum":"  621","line":"    #undef BOOST_PROTO_DEFINE_UNARY_METAFUNCTION"},
{"lineNum":"  622","line":"    #undef BOOST_PROTO_DEFINE_BINARY_METAFUNCTION"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"    #include <boost/proto/detail/traits.hpp>"},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"    namespace functional"},
{"lineNum":"  627","line":"    {"},
{"lineNum":"  628","line":"        /// \\brief A callable PolymorphicFunctionObject that is"},
{"lineNum":"  629","line":"        /// equivalent to the \\c as_expr() function."},
{"lineNum":"  630","line":"        template<typename Domain   /* = default_domain*/>"},
{"lineNum":"  631","line":"        struct as_expr"},
{"lineNum":"  632","line":"        {"},
{"lineNum":"  633","line":"            BOOST_PROTO_CALLABLE()"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"            template<typename Sig>"},
{"lineNum":"  636","line":"            struct result;"},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"            template<typename This, typename T>"},
{"lineNum":"  639","line":"            struct result<This(T)>"},
{"lineNum":"  640","line":"            {"},
{"lineNum":"  641","line":"                typedef typename Domain::template as_expr<T>::result_type type;"},
{"lineNum":"  642","line":"            };"},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":"            template<typename This, typename T>"},
{"lineNum":"  645","line":"            struct result<This(T &)>"},
{"lineNum":"  646","line":"            {"},
{"lineNum":"  647","line":"                typedef typename Domain::template as_expr<T>::result_type type;"},
{"lineNum":"  648","line":"            };"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"            /// \\brief Wrap an object in a Proto terminal if it isn\'t a"},
{"lineNum":"  651","line":"            /// Proto expression already."},
{"lineNum":"  652","line":"            /// \\param t The object to wrap."},
{"lineNum":"  653","line":"            /// \\return <tt>proto::as_expr\\<Domain\\>(t)</tt>"},
{"lineNum":"  654","line":"            template<typename T>"},
{"lineNum":"  655","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  656","line":"            typename add_const<typename result<as_expr(T &)>::type>::type"},
{"lineNum":"  657","line":"            operator ()(T &t) const"},
{"lineNum":"  658","line":"            {"},
{"lineNum":"  659","line":"                return typename Domain::template as_expr<T>()(t);"},
{"lineNum":"  660","line":"            }"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"            /// \\overload"},
{"lineNum":"  663","line":"            ///"},
{"lineNum":"  664","line":"            template<typename T>"},
{"lineNum":"  665","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  666","line":"            typename add_const<typename result<as_expr(T const &)>::type>::type"},
{"lineNum":"  667","line":"            operator ()(T const &t) const"},
{"lineNum":"  668","line":"            {"},
{"lineNum":"  669","line":"                return typename Domain::template as_expr<T const>()(t);"},
{"lineNum":"  670","line":"            }"},
{"lineNum":"  671","line":""},
{"lineNum":"  672","line":"            #if BOOST_WORKAROUND(BOOST_MSVC, == 1310)"},
{"lineNum":"  673","line":"            template<typename T, std::size_t N_>"},
{"lineNum":"  674","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  675","line":"            typename add_const<typename result<as_expr(T (&)[N_])>::type>::type"},
{"lineNum":"  676","line":"            operator ()(T (&t)[N_]) const"},
{"lineNum":"  677","line":"            {"},
{"lineNum":"  678","line":"                return typename Domain::template as_expr<T[N_]>()(t);"},
{"lineNum":"  679","line":"            }"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"            template<typename T, std::size_t N_>"},
{"lineNum":"  682","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  683","line":"            typename add_const<typename result<as_expr(T const (&)[N_])>::type>::type"},
{"lineNum":"  684","line":"            operator ()(T const (&t)[N_]) const"},
{"lineNum":"  685","line":"            {"},
{"lineNum":"  686","line":"                return typename Domain::template as_expr<T const[N_]>()(t);"},
{"lineNum":"  687","line":"            }"},
{"lineNum":"  688","line":"            #endif"},
{"lineNum":"  689","line":"        };"},
{"lineNum":"  690","line":""},
{"lineNum":"  691","line":"        /// \\brief A callable PolymorphicFunctionObject that is"},
{"lineNum":"  692","line":"        /// equivalent to the \\c as_child() function."},
{"lineNum":"  693","line":"        template<typename Domain   /* = default_domain*/>"},
{"lineNum":"  694","line":"        struct as_child"},
{"lineNum":"  695","line":"        {"},
{"lineNum":"  696","line":"            BOOST_PROTO_CALLABLE()"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"            template<typename Sig>"},
{"lineNum":"  699","line":"            struct result;"},
{"lineNum":"  700","line":""},
{"lineNum":"  701","line":"            template<typename This, typename T>"},
{"lineNum":"  702","line":"            struct result<This(T)>"},
{"lineNum":"  703","line":"            {"},
{"lineNum":"  704","line":"                typedef typename Domain::template as_child<T>::result_type type;"},
{"lineNum":"  705","line":"            };"},
{"lineNum":"  706","line":""},
{"lineNum":"  707","line":"            template<typename This, typename T>"},
{"lineNum":"  708","line":"            struct result<This(T &)>"},
{"lineNum":"  709","line":"            {"},
{"lineNum":"  710","line":"                typedef typename Domain::template as_child<T>::result_type type;"},
{"lineNum":"  711","line":"            };"},
{"lineNum":"  712","line":""},
{"lineNum":"  713","line":"            /// \\brief Wrap an object in a Proto terminal if it isn\'t a"},
{"lineNum":"  714","line":"            /// Proto expression already."},
{"lineNum":"  715","line":"            /// \\param t The object to wrap."},
{"lineNum":"  716","line":"            /// \\return <tt>proto::as_child\\<Domain\\>(t)</tt>"},
{"lineNum":"  717","line":"            template<typename T>"},
{"lineNum":"  718","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  719","line":"            typename add_const<typename result<as_child(T &)>::type>::type"},
{"lineNum":"  720","line":"            operator ()(T &t) const"},
{"lineNum":"  721","line":"            {"},
{"lineNum":"  722","line":"                return typename Domain::template as_child<T>()(t);"},
{"lineNum":"  723","line":"            }"},
{"lineNum":"  724","line":""},
{"lineNum":"  725","line":"            /// \\overload"},
{"lineNum":"  726","line":"            ///"},
{"lineNum":"  727","line":"            template<typename T>"},
{"lineNum":"  728","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  729","line":"            typename add_const<typename result<as_child(T const &)>::type>::type"},
{"lineNum":"  730","line":"            operator ()(T const &t) const"},
{"lineNum":"  731","line":"            {"},
{"lineNum":"  732","line":"                return typename Domain::template as_child<T const>()(t);"},
{"lineNum":"  733","line":"            }"},
{"lineNum":"  734","line":"        };"},
{"lineNum":"  735","line":""},
{"lineNum":"  736","line":"        /// \\brief A callable PolymorphicFunctionObject that is"},
{"lineNum":"  737","line":"        /// equivalent to the \\c child_c() function."},
{"lineNum":"  738","line":"        template<long N>"},
{"lineNum":"  739","line":"        struct child_c"},
{"lineNum":"  740","line":"        {"},
{"lineNum":"  741","line":"            BOOST_PROTO_CALLABLE()"},
{"lineNum":"  742","line":""},
{"lineNum":"  743","line":"            template<typename Sig>"},
{"lineNum":"  744","line":"            struct result;"},
{"lineNum":"  745","line":""},
{"lineNum":"  746","line":"            template<typename This, typename Expr>"},
{"lineNum":"  747","line":"            struct result<This(Expr)>"},
{"lineNum":"  748","line":"            {"},
{"lineNum":"  749","line":"                typedef typename result_of::child_c<Expr, N>::type type;"},
{"lineNum":"  750","line":"            };"},
{"lineNum":"  751","line":""},
{"lineNum":"  752","line":"            /// \\brief Return the Nth child of the given expression."},
{"lineNum":"  753","line":"            /// \\param expr The expression node."},
{"lineNum":"  754","line":"            /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true"},
{"lineNum":"  755","line":"            /// \\pre <tt>N \\< Expr::proto_arity::value</tt>"},
{"lineNum":"  756","line":"            /// \\return <tt>proto::child_c\\<N\\>(expr)</tt>"},
{"lineNum":"  757","line":"            /// \\throw nothrow"},
{"lineNum":"  758","line":"            template<typename Expr>"},
{"lineNum":"  759","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  760","line":"            typename result_of::child_c<Expr &, N>::type"},
{"lineNum":"  761","line":"            operator ()(Expr &e) const"},
{"lineNum":"  762","line":"            {"},
{"lineNum":"  763","line":"                return result_of::child_c<Expr &, N>::call(e);"},
{"lineNum":"  764","line":"            }"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"            /// \\overload"},
{"lineNum":"  767","line":"            ///"},
{"lineNum":"  768","line":"            template<typename Expr>"},
{"lineNum":"  769","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  770","line":"            typename result_of::child_c<Expr const &, N>::type"},
{"lineNum":"  771","line":"            operator ()(Expr const &e) const"},
{"lineNum":"  772","line":"            {"},
{"lineNum":"  773","line":"                return result_of::child_c<Expr const &, N>::call(e);"},
{"lineNum":"  774","line":"            }"},
{"lineNum":"  775","line":"        };"},
{"lineNum":"  776","line":""},
{"lineNum":"  777","line":"        /// \\brief A callable PolymorphicFunctionObject that is"},
{"lineNum":"  778","line":"        /// equivalent to the \\c child() function."},
{"lineNum":"  779","line":"        ///"},
{"lineNum":"  780","line":"        /// A callable PolymorphicFunctionObject that is"},
{"lineNum":"  781","line":"        /// equivalent to the \\c child() function. \\c N is required"},
{"lineNum":"  782","line":"        /// to be an MPL Integral Constant."},
{"lineNum":"  783","line":"        template<typename N /* = mpl::long_<0>*/>"},
{"lineNum":"  784","line":"        struct child"},
{"lineNum":"  785","line":"        {"},
{"lineNum":"  786","line":"            BOOST_PROTO_CALLABLE()"},
{"lineNum":"  787","line":""},
{"lineNum":"  788","line":"            template<typename Sig>"},
{"lineNum":"  789","line":"            struct result;"},
{"lineNum":"  790","line":""},
{"lineNum":"  791","line":"            template<typename This, typename Expr>"},
{"lineNum":"  792","line":"            struct result<This(Expr)>"},
{"lineNum":"  793","line":"            {"},
{"lineNum":"  794","line":"                typedef typename result_of::child<Expr, N>::type type;"},
{"lineNum":"  795","line":"            };"},
{"lineNum":"  796","line":""},
{"lineNum":"  797","line":"            /// \\brief Return the Nth child of the given expression."},
{"lineNum":"  798","line":"            /// \\param expr The expression node."},
{"lineNum":"  799","line":"            /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true"},
{"lineNum":"  800","line":"            /// \\pre <tt>N::value \\< Expr::proto_arity::value</tt>"},
{"lineNum":"  801","line":"            /// \\return <tt>proto::child\\<N\\>(expr)</tt>"},
{"lineNum":"  802","line":"            /// \\throw nothrow"},
{"lineNum":"  803","line":"            template<typename Expr>"},
{"lineNum":"  804","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  805","line":"            typename result_of::child<Expr &, N>::type"},
{"lineNum":"  806","line":"            operator ()(Expr &e) const"},
{"lineNum":"  807","line":"            {"},
{"lineNum":"  808","line":"                return result_of::child<Expr &, N>::call(e);"},
{"lineNum":"  809","line":"            }"},
{"lineNum":"  810","line":""},
{"lineNum":"  811","line":"            /// \\overload"},
{"lineNum":"  812","line":"            ///"},
{"lineNum":"  813","line":"            template<typename Expr>"},
{"lineNum":"  814","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  815","line":"            typename result_of::child<Expr const &, N>::type"},
{"lineNum":"  816","line":"            operator ()(Expr const &e) const"},
{"lineNum":"  817","line":"            {"},
{"lineNum":"  818","line":"                return result_of::child<Expr const &, N>::call(e);"},
{"lineNum":"  819","line":"            }"},
{"lineNum":"  820","line":"        };"},
{"lineNum":"  821","line":""},
{"lineNum":"  822","line":"        /// \\brief A callable PolymorphicFunctionObject that is"},
{"lineNum":"  823","line":"        /// equivalent to the \\c value() function."},
{"lineNum":"  824","line":"        struct value"},
{"lineNum":"  825","line":"        {"},
{"lineNum":"  826","line":"            BOOST_PROTO_CALLABLE()"},
{"lineNum":"  827","line":""},
{"lineNum":"  828","line":"            template<typename Sig>"},
{"lineNum":"  829","line":"            struct result;"},
{"lineNum":"  830","line":""},
{"lineNum":"  831","line":"            template<typename This, typename Expr>"},
{"lineNum":"  832","line":"            struct result<This(Expr)>"},
{"lineNum":"  833","line":"            {"},
{"lineNum":"  834","line":"                typedef typename result_of::value<Expr>::type type;"},
{"lineNum":"  835","line":"            };"},
{"lineNum":"  836","line":""},
{"lineNum":"  837","line":"            /// \\brief Return the value of the given terminal expression."},
{"lineNum":"  838","line":"            /// \\param expr The terminal expression node."},
{"lineNum":"  839","line":"            /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true"},
{"lineNum":"  840","line":"            /// \\pre <tt>0 == Expr::proto_arity::value</tt>"},
{"lineNum":"  841","line":"            /// \\return <tt>proto::value(expr)</tt>"},
{"lineNum":"  842","line":"            /// \\throw nothrow"},
{"lineNum":"  843","line":"            template<typename Expr>"},
{"lineNum":"  844","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  845","line":"            typename result_of::value<Expr &>::type"},
{"lineNum":"  846","line":"            operator ()(Expr &e) const"},
{"lineNum":"  847","line":"            {"},
{"lineNum":"  848","line":"                return e.proto_base().child0;"},
{"lineNum":"  849","line":"            }"},
{"lineNum":"  850","line":""},
{"lineNum":"  851","line":"            /// \\overload"},
{"lineNum":"  852","line":"            ///"},
{"lineNum":"  853","line":"            template<typename Expr>"},
{"lineNum":"  854","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  855","line":"            typename result_of::value<Expr const &>::type"},
{"lineNum":"  856","line":"            operator ()(Expr const &e) const"},
{"lineNum":"  857","line":"            {"},
{"lineNum":"  858","line":"                return e.proto_base().child0;"},
{"lineNum":"  859","line":"            }"},
{"lineNum":"  860","line":"        };"},
{"lineNum":"  861","line":""},
{"lineNum":"  862","line":"        /// \\brief A callable PolymorphicFunctionObject that is"},
{"lineNum":"  863","line":"        /// equivalent to the \\c left() function."},
{"lineNum":"  864","line":"        struct left"},
{"lineNum":"  865","line":"        {"},
{"lineNum":"  866","line":"            BOOST_PROTO_CALLABLE()"},
{"lineNum":"  867","line":""},
{"lineNum":"  868","line":"            template<typename Sig>"},
{"lineNum":"  869","line":"            struct result;"},
{"lineNum":"  870","line":""},
{"lineNum":"  871","line":"            template<typename This, typename Expr>"},
{"lineNum":"  872","line":"            struct result<This(Expr)>"},
{"lineNum":"  873","line":"            {"},
{"lineNum":"  874","line":"                typedef typename result_of::left<Expr>::type type;"},
{"lineNum":"  875","line":"            };"},
{"lineNum":"  876","line":""},
{"lineNum":"  877","line":"            /// \\brief Return the left child of the given binary expression."},
{"lineNum":"  878","line":"            /// \\param expr The expression node."},
{"lineNum":"  879","line":"            /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true"},
{"lineNum":"  880","line":"            /// \\pre <tt>2 == Expr::proto_arity::value</tt>"},
{"lineNum":"  881","line":"            /// \\return <tt>proto::left(expr)</tt>"},
{"lineNum":"  882","line":"            /// \\throw nothrow"},
{"lineNum":"  883","line":"            template<typename Expr>"},
{"lineNum":"  884","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  885","line":"            typename result_of::left<Expr &>::type"},
{"lineNum":"  886","line":"            operator ()(Expr &e) const"},
{"lineNum":"  887","line":"            {"},
{"lineNum":"  888","line":"                return e.proto_base().child0;"},
{"lineNum":"  889","line":"            }"},
{"lineNum":"  890","line":""},
{"lineNum":"  891","line":"            /// \\overload"},
{"lineNum":"  892","line":"            ///"},
{"lineNum":"  893","line":"            template<typename Expr>"},
{"lineNum":"  894","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  895","line":"            typename result_of::left<Expr const &>::type"},
{"lineNum":"  896","line":"            operator ()(Expr const &e) const"},
{"lineNum":"  897","line":"            {"},
{"lineNum":"  898","line":"                return e.proto_base().child0;"},
{"lineNum":"  899","line":"            }"},
{"lineNum":"  900","line":"        };"},
{"lineNum":"  901","line":""},
{"lineNum":"  902","line":"        /// \\brief A callable PolymorphicFunctionObject that is"},
{"lineNum":"  903","line":"        /// equivalent to the \\c right() function."},
{"lineNum":"  904","line":"        struct right"},
{"lineNum":"  905","line":"        {"},
{"lineNum":"  906","line":"            BOOST_PROTO_CALLABLE()"},
{"lineNum":"  907","line":""},
{"lineNum":"  908","line":"            template<typename Sig>"},
{"lineNum":"  909","line":"            struct result;"},
{"lineNum":"  910","line":""},
{"lineNum":"  911","line":"            template<typename This, typename Expr>"},
{"lineNum":"  912","line":"            struct result<This(Expr)>"},
{"lineNum":"  913","line":"            {"},
{"lineNum":"  914","line":"                typedef typename result_of::right<Expr>::type type;"},
{"lineNum":"  915","line":"            };"},
{"lineNum":"  916","line":""},
{"lineNum":"  917","line":"            /// \\brief Return the right child of the given binary expression."},
{"lineNum":"  918","line":"            /// \\param expr The expression node."},
{"lineNum":"  919","line":"            /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true"},
{"lineNum":"  920","line":"            /// \\pre <tt>2 == Expr::proto_arity::value</tt>"},
{"lineNum":"  921","line":"            /// \\return <tt>proto::right(expr)</tt>"},
{"lineNum":"  922","line":"            /// \\throw nothrow"},
{"lineNum":"  923","line":"            template<typename Expr>"},
{"lineNum":"  924","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  925","line":"            typename result_of::right<Expr &>::type"},
{"lineNum":"  926","line":"            operator ()(Expr &e) const"},
{"lineNum":"  927","line":"            {"},
{"lineNum":"  928","line":"                return e.proto_base().child1;"},
{"lineNum":"  929","line":"            }"},
{"lineNum":"  930","line":""},
{"lineNum":"  931","line":"            template<typename Expr>"},
{"lineNum":"  932","line":"            BOOST_FORCEINLINE"},
{"lineNum":"  933","line":"            typename result_of::right<Expr const &>::type"},
{"lineNum":"  934","line":"            operator ()(Expr const &e) const"},
{"lineNum":"  935","line":"            {"},
{"lineNum":"  936","line":"                return e.proto_base().child1;"},
{"lineNum":"  937","line":"            }"},
{"lineNum":"  938","line":"        };"},
{"lineNum":"  939","line":""},
{"lineNum":"  940","line":"    }"},
{"lineNum":"  941","line":""},
{"lineNum":"  942","line":"    /// \\brief A function that wraps non-Proto expression types in Proto"},
{"lineNum":"  943","line":"    /// terminals and leaves Proto expression types alone."},
{"lineNum":"  944","line":"    ///"},
{"lineNum":"  945","line":"    /// The <tt>as_expr()</tt> function turns objects into Proto terminals if"},
{"lineNum":"  946","line":"    /// they are not Proto expression types already. Non-Proto types are"},
{"lineNum":"  947","line":"    /// held by value, if possible. Types which are already Proto types are"},
{"lineNum":"  948","line":"    /// left alone and returned by reference."},
{"lineNum":"  949","line":"    ///"},
{"lineNum":"  950","line":"    /// This function can be called either with an explicitly specified"},
{"lineNum":"  951","line":"    /// \\c Domain parameter (i.e., <tt>as_expr\\<Domain\\>(t)</tt>), or"},
{"lineNum":"  952","line":"    /// without (i.e., <tt>as_expr(t)</tt>). If no domain is"},
{"lineNum":"  953","line":"    /// specified, \\c default_domain is assumed."},
{"lineNum":"  954","line":"    ///"},
{"lineNum":"  955","line":"    /// If <tt>is_expr\\<T\\>::value</tt> is \\c true, then the argument is"},
{"lineNum":"  956","line":"    /// returned unmodified, by reference. Otherwise, the argument is wrapped"},
{"lineNum":"  957","line":"    /// in a Proto terminal expression node according to the following rules."},
{"lineNum":"  958","line":"    /// If \\c T is a function type, let \\c A be <tt>T &</tt>. Otherwise, let"},
{"lineNum":"  959","line":"    /// \\c A be the type \\c T stripped of cv-qualifiers. Then, \\c as_expr()"},
{"lineNum":"  960","line":"    /// returns <tt>Domain()(terminal\\<A\\>::type::make(t))</tt>."},
{"lineNum":"  961","line":"    ///"},
{"lineNum":"  962","line":"    /// \\param t The object to wrap."},
{"lineNum":"  963","line":"    template<typename T>"},
{"lineNum":"  964","line":"    BOOST_FORCEINLINE"},
{"lineNum":"  965","line":"    typename add_const<typename result_of::as_expr<T, default_domain>::type>::type"},
{"lineNum":"  966","line":"    as_expr(T &t BOOST_PROTO_DISABLE_IF_IS_CONST(T) BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T))"},
{"lineNum":"  967","line":"    {"},
{"lineNum":"  968","line":"        return default_domain::as_expr<T>()(t);"},
{"lineNum":"  969","line":"    }"},
{"lineNum":"  970","line":""},
{"lineNum":"  971","line":"    /// \\overload"},
{"lineNum":"  972","line":"    ///"},
{"lineNum":"  973","line":"    template<typename T>"},
{"lineNum":"  974","line":"    BOOST_FORCEINLINE"},
{"lineNum":"  975","line":"    typename add_const<typename result_of::as_expr<T const, default_domain>::type>::type"},
{"lineNum":"  976","line":"    as_expr(T const &t)"},
{"lineNum":"  977","line":"    {"},
{"lineNum":"  978","line":"        return default_domain::as_expr<T const>()(t);"},
{"lineNum":"  979","line":"    }"},
{"lineNum":"  980","line":""},
{"lineNum":"  981","line":"    /// \\overload"},
{"lineNum":"  982","line":"    ///"},
{"lineNum":"  983","line":"    template<typename Domain, typename T>"},
{"lineNum":"  984","line":"    BOOST_FORCEINLINE"},
{"lineNum":"  985","line":"    typename add_const<typename result_of::as_expr<T, Domain>::type>::type"},
{"lineNum":"  986","line":"    as_expr(T &t BOOST_PROTO_DISABLE_IF_IS_CONST(T) BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T))"},
{"lineNum":"  987","line":"    {"},
{"lineNum":"  988","line":"        return typename Domain::template as_expr<T>()(t);"},
{"lineNum":"  989","line":"    }"},
{"lineNum":"  990","line":""},
{"lineNum":"  991","line":"    /// \\overload"},
{"lineNum":"  992","line":"    ///"},
{"lineNum":"  993","line":"    template<typename Domain, typename T>"},
{"lineNum":"  994","line":"    BOOST_FORCEINLINE"},
{"lineNum":"  995","line":"    typename add_const<typename result_of::as_expr<T const, Domain>::type>::type"},
{"lineNum":"  996","line":"    as_expr(T const &t)"},
{"lineNum":"  997","line":"    {"},
{"lineNum":"  998","line":"        return typename Domain::template as_expr<T const>()(t);"},
{"lineNum":"  999","line":"    }"},
{"lineNum":" 1000","line":""},
{"lineNum":" 1001","line":"    /// \\brief A function that wraps non-Proto expression types in Proto"},
{"lineNum":" 1002","line":"    /// terminals (by reference) and returns Proto expression types by"},
{"lineNum":" 1003","line":"    /// reference"},
{"lineNum":" 1004","line":"    ///"},
{"lineNum":" 1005","line":"    /// The <tt>as_child()</tt> function turns objects into Proto terminals if"},
{"lineNum":" 1006","line":"    /// they are not Proto expression types already. Non-Proto types are"},
{"lineNum":" 1007","line":"    /// held by reference. Types which are already Proto types are simply"},
{"lineNum":" 1008","line":"    /// returned as-is."},
{"lineNum":" 1009","line":"    ///"},
{"lineNum":" 1010","line":"    /// This function can be called either with an explicitly specified"},
{"lineNum":" 1011","line":"    /// \\c Domain parameter (i.e., <tt>as_child\\<Domain\\>(t)</tt>), or"},
{"lineNum":" 1012","line":"    /// without (i.e., <tt>as_child(t)</tt>). If no domain is"},
{"lineNum":" 1013","line":"    /// specified, \\c default_domain is assumed."},
{"lineNum":" 1014","line":"    ///"},
{"lineNum":" 1015","line":"    /// If <tt>is_expr\\<T\\>::value</tt> is \\c true, then the argument is"},
{"lineNum":" 1016","line":"    /// returned as-is. Otherwise, \\c as_child() returns"},
{"lineNum":" 1017","line":"    /// <tt>Domain()(terminal\\<T &\\>::type::make(t))</tt>."},
{"lineNum":" 1018","line":"    ///"},
{"lineNum":" 1019","line":"    /// \\param t The object to wrap."},
{"lineNum":" 1020","line":"    template<typename T>"},
{"lineNum":" 1021","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1022","line":"    typename add_const<typename result_of::as_child<T, default_domain>::type>::type"},
{"lineNum":" 1023","line":"    as_child(T &t BOOST_PROTO_DISABLE_IF_IS_CONST(T) BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T))"},
{"lineNum":" 1024","line":"    {"},
{"lineNum":" 1025","line":"        return default_domain::as_child<T>()(t);"},
{"lineNum":" 1026","line":"    }"},
{"lineNum":" 1027","line":""},
{"lineNum":" 1028","line":"    /// \\overload"},
{"lineNum":" 1029","line":"    ///"},
{"lineNum":" 1030","line":"    template<typename T>"},
{"lineNum":" 1031","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1032","line":"    typename add_const<typename result_of::as_child<T const, default_domain>::type>::type"},
{"lineNum":" 1033","line":"    as_child(T const &t)"},
{"lineNum":" 1034","line":"    {"},
{"lineNum":" 1035","line":"        return default_domain::as_child<T const>()(t);"},
{"lineNum":" 1036","line":"    }"},
{"lineNum":" 1037","line":""},
{"lineNum":" 1038","line":"    /// \\overload"},
{"lineNum":" 1039","line":"    ///"},
{"lineNum":" 1040","line":"    template<typename Domain, typename T>"},
{"lineNum":" 1041","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1042","line":"    typename add_const<typename result_of::as_child<T, Domain>::type>::type"},
{"lineNum":" 1043","line":"    as_child(T &t BOOST_PROTO_DISABLE_IF_IS_CONST(T) BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T))"},
{"lineNum":" 1044","line":"    {"},
{"lineNum":" 1045","line":"        return typename Domain::template as_child<T>()(t);"},
{"lineNum":" 1046","line":"    }"},
{"lineNum":" 1047","line":""},
{"lineNum":" 1048","line":"    /// \\overload"},
{"lineNum":" 1049","line":"    ///"},
{"lineNum":" 1050","line":"    template<typename Domain, typename T>"},
{"lineNum":" 1051","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1052","line":"    typename add_const<typename result_of::as_child<T const, Domain>::type>::type"},
{"lineNum":" 1053","line":"    as_child(T const &t)"},
{"lineNum":" 1054","line":"    {"},
{"lineNum":" 1055","line":"        return typename Domain::template as_child<T const>()(t);"},
{"lineNum":" 1056","line":"    }"},
{"lineNum":" 1057","line":""},
{"lineNum":" 1058","line":"    /// \\brief Return the Nth child of the specified Proto expression."},
{"lineNum":" 1059","line":"    ///"},
{"lineNum":" 1060","line":"    /// Return the Nth child of the specified Proto expression. If"},
{"lineNum":" 1061","line":"    /// \\c N is not specified, as in \\c child(expr), then \\c N is assumed"},
{"lineNum":" 1062","line":"    /// to be <tt>mpl::long_\\<0\\></tt>. The child is returned by"},
{"lineNum":" 1063","line":"    /// reference."},
{"lineNum":" 1064","line":"    ///"},
{"lineNum":" 1065","line":"    /// \\param expr The Proto expression."},
{"lineNum":" 1066","line":"    /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true."},
{"lineNum":" 1067","line":"    /// \\pre \\c N is an MPL Integral Constant."},
{"lineNum":" 1068","line":"    /// \\pre <tt>N::value \\< Expr::proto_arity::value</tt>"},
{"lineNum":" 1069","line":"    /// \\throw nothrow"},
{"lineNum":" 1070","line":"    /// \\return A reference to the Nth child"},
{"lineNum":" 1071","line":"    template<typename N, typename Expr>"},
{"lineNum":" 1072","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1073","line":"    typename result_of::child<Expr &, N>::type"},
{"lineNum":" 1074","line":"    child(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))"},
{"lineNum":" 1075","line":"    {"},
{"lineNum":" 1076","line":"        return result_of::child<Expr &, N>::call(e);"},
{"lineNum":" 1077","line":"    }"},
{"lineNum":" 1078","line":""},
{"lineNum":" 1079","line":"    /// \\overload"},
{"lineNum":" 1080","line":"    ///"},
{"lineNum":" 1081","line":"    template<typename N, typename Expr>"},
{"lineNum":" 1082","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1083","line":"    typename result_of::child<Expr const &, N>::type"},
{"lineNum":" 1084","line":"    child(Expr const &e)"},
{"lineNum":" 1085","line":"    {"},
{"lineNum":" 1086","line":"        return result_of::child<Expr const &, N>::call(e);"},
{"lineNum":" 1087","line":"    }"},
{"lineNum":" 1088","line":""},
{"lineNum":" 1089","line":"    /// \\overload"},
{"lineNum":" 1090","line":"    ///"},
{"lineNum":" 1091","line":"    template<typename Expr2>"},
{"lineNum":" 1092","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1093","line":"    typename detail::expr_traits<typename Expr2::proto_base_expr::proto_child0>::reference"},
{"lineNum":" 1094","line":"    child(Expr2 &expr2 BOOST_PROTO_DISABLE_IF_IS_CONST(Expr2))"},
{"lineNum":" 1095","line":"    {"},
{"lineNum":" 1096","line":"        return expr2.proto_base().child0;"},
{"lineNum":" 1097","line":"    }"},
{"lineNum":" 1098","line":""},
{"lineNum":" 1099","line":"    /// \\overload"},
{"lineNum":" 1100","line":"    ///"},
{"lineNum":" 1101","line":"    template<typename Expr2>"},
{"lineNum":" 1102","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1103","line":"    typename detail::expr_traits<typename Expr2::proto_base_expr::proto_child0>::const_reference"},
{"lineNum":" 1104","line":"    child(Expr2 const &expr2)"},
{"lineNum":" 1105","line":"    {"},
{"lineNum":" 1106","line":"        return expr2.proto_base().child0;","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":" 1107","line":"    }"},
{"lineNum":" 1108","line":""},
{"lineNum":" 1109","line":"    /// \\brief Return the Nth child of the specified Proto expression."},
{"lineNum":" 1110","line":"    ///"},
{"lineNum":" 1111","line":"    /// Return the Nth child of the specified Proto expression. The child"},
{"lineNum":" 1112","line":"    /// is returned by reference."},
{"lineNum":" 1113","line":"    ///"},
{"lineNum":" 1114","line":"    /// \\param expr The Proto expression."},
{"lineNum":" 1115","line":"    /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true."},
{"lineNum":" 1116","line":"    /// \\pre <tt>N \\< Expr::proto_arity::value</tt>"},
{"lineNum":" 1117","line":"    /// \\throw nothrow"},
{"lineNum":" 1118","line":"    /// \\return A reference to the Nth child"},
{"lineNum":" 1119","line":"    template<long N, typename Expr>"},
{"lineNum":" 1120","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1121","line":"    typename result_of::child_c<Expr &, N>::type"},
{"lineNum":" 1122","line":"    child_c(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))"},
{"lineNum":" 1123","line":"    {"},
{"lineNum":" 1124","line":"        return result_of::child_c<Expr &, N>::call(e);"},
{"lineNum":" 1125","line":"    }"},
{"lineNum":" 1126","line":""},
{"lineNum":" 1127","line":"    /// \\overload"},
{"lineNum":" 1128","line":"    ///"},
{"lineNum":" 1129","line":"    template<long N, typename Expr>"},
{"lineNum":" 1130","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1131","line":"    typename result_of::child_c<Expr const &, N>::type"},
{"lineNum":" 1132","line":"    child_c(Expr const &e)"},
{"lineNum":" 1133","line":"    {"},
{"lineNum":" 1134","line":"        return result_of::child_c<Expr const &, N>::call(e);"},
{"lineNum":" 1135","line":"    }"},
{"lineNum":" 1136","line":""},
{"lineNum":" 1137","line":"    /// \\brief Return the value stored within the specified Proto"},
{"lineNum":" 1138","line":"    /// terminal expression."},
{"lineNum":" 1139","line":"    ///"},
{"lineNum":" 1140","line":"    /// Return the value stored within the specified Proto"},
{"lineNum":" 1141","line":"    /// terminal expression. The value is returned by"},
{"lineNum":" 1142","line":"    /// reference."},
{"lineNum":" 1143","line":"    ///"},
{"lineNum":" 1144","line":"    /// \\param expr The Proto terminal expression."},
{"lineNum":" 1145","line":"    /// \\pre <tt>N::value == 0</tt>"},
{"lineNum":" 1146","line":"    /// \\throw nothrow"},
{"lineNum":" 1147","line":"    /// \\return A reference to the terminal\'s value"},
{"lineNum":" 1148","line":"    template<typename Expr>"},
{"lineNum":" 1149","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1150","line":"    typename result_of::value<Expr &>::type"},
{"lineNum":" 1151","line":"    value(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))"},
{"lineNum":" 1152","line":"    {"},
{"lineNum":" 1153","line":"        return e.proto_base().child0;"},
{"lineNum":" 1154","line":"    }"},
{"lineNum":" 1155","line":""},
{"lineNum":" 1156","line":"    /// \\overload"},
{"lineNum":" 1157","line":"    ///"},
{"lineNum":" 1158","line":"    template<typename Expr>"},
{"lineNum":" 1159","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1160","line":"    typename result_of::value<Expr const &>::type"},
{"lineNum":" 1161","line":"    value(Expr const &e)"},
{"lineNum":" 1162","line":"    {"},
{"lineNum":" 1163","line":"        return e.proto_base().child0;","class":"lineNoCov","hits":"0","possible_hits":"37",},
{"lineNum":" 1164","line":"    }"},
{"lineNum":" 1165","line":""},
{"lineNum":" 1166","line":"    /// \\brief Return the left child of the specified binary Proto"},
{"lineNum":" 1167","line":"    /// expression."},
{"lineNum":" 1168","line":"    ///"},
{"lineNum":" 1169","line":"    /// Return the left child of the specified binary Proto expression. The"},
{"lineNum":" 1170","line":"    /// child is returned by reference."},
{"lineNum":" 1171","line":"    ///"},
{"lineNum":" 1172","line":"    /// \\param expr The Proto expression."},
{"lineNum":" 1173","line":"    /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true."},
{"lineNum":" 1174","line":"    /// \\pre <tt>2 == Expr::proto_arity::value</tt>"},
{"lineNum":" 1175","line":"    /// \\throw nothrow"},
{"lineNum":" 1176","line":"    /// \\return A reference to the left child"},
{"lineNum":" 1177","line":"    template<typename Expr>"},
{"lineNum":" 1178","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1179","line":"    typename result_of::left<Expr &>::type"},
{"lineNum":" 1180","line":"    left(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))"},
{"lineNum":" 1181","line":"    {"},
{"lineNum":" 1182","line":"        return e.proto_base().child0;"},
{"lineNum":" 1183","line":"    }"},
{"lineNum":" 1184","line":""},
{"lineNum":" 1185","line":"    /// \\overload"},
{"lineNum":" 1186","line":"    ///"},
{"lineNum":" 1187","line":"    template<typename Expr>"},
{"lineNum":" 1188","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1189","line":"    typename result_of::left<Expr const &>::type"},
{"lineNum":" 1190","line":"    left(Expr const &e)"},
{"lineNum":" 1191","line":"    {"},
{"lineNum":" 1192","line":"        return e.proto_base().child0;"},
{"lineNum":" 1193","line":"    }"},
{"lineNum":" 1194","line":""},
{"lineNum":" 1195","line":"    /// \\brief Return the right child of the specified binary Proto"},
{"lineNum":" 1196","line":"    /// expression."},
{"lineNum":" 1197","line":"    ///"},
{"lineNum":" 1198","line":"    /// Return the right child of the specified binary Proto expression. The"},
{"lineNum":" 1199","line":"    /// child is returned by reference."},
{"lineNum":" 1200","line":"    ///"},
{"lineNum":" 1201","line":"    /// \\param expr The Proto expression."},
{"lineNum":" 1202","line":"    /// \\pre <tt>is_expr\\<Expr\\>::value</tt> is \\c true."},
{"lineNum":" 1203","line":"    /// \\pre <tt>2 == Expr::proto_arity::value</tt>"},
{"lineNum":" 1204","line":"    /// \\throw nothrow"},
{"lineNum":" 1205","line":"    /// \\return A reference to the right child"},
{"lineNum":" 1206","line":"    template<typename Expr>"},
{"lineNum":" 1207","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1208","line":"    typename result_of::right<Expr &>::type"},
{"lineNum":" 1209","line":"    right(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))"},
{"lineNum":" 1210","line":"    {"},
{"lineNum":" 1211","line":"        return e.proto_base().child1;"},
{"lineNum":" 1212","line":"    }"},
{"lineNum":" 1213","line":""},
{"lineNum":" 1214","line":"    /// \\overload"},
{"lineNum":" 1215","line":"    ///"},
{"lineNum":" 1216","line":"    template<typename Expr>"},
{"lineNum":" 1217","line":"    BOOST_FORCEINLINE"},
{"lineNum":" 1218","line":"    typename result_of::right<Expr const &>::type"},
{"lineNum":" 1219","line":"    right(Expr const &e)"},
{"lineNum":" 1220","line":"    {"},
{"lineNum":" 1221","line":"        return e.proto_base().child1;"},
{"lineNum":" 1222","line":"    }"},
{"lineNum":" 1223","line":""},
{"lineNum":" 1224","line":"    /// INTERNAL ONLY"},
{"lineNum":" 1225","line":"    ///"},
{"lineNum":" 1226","line":"    template<typename Domain>"},
{"lineNum":" 1227","line":"    struct is_callable<functional::as_expr<Domain> >"},
{"lineNum":" 1228","line":"      : mpl::true_"},
{"lineNum":" 1229","line":"    {};"},
{"lineNum":" 1230","line":""},
{"lineNum":" 1231","line":"    /// INTERNAL ONLY"},
{"lineNum":" 1232","line":"    ///"},
{"lineNum":" 1233","line":"    template<typename Domain>"},
{"lineNum":" 1234","line":"    struct is_callable<functional::as_child<Domain> >"},
{"lineNum":" 1235","line":"      : mpl::true_"},
{"lineNum":" 1236","line":"    {};"},
{"lineNum":" 1237","line":""},
{"lineNum":" 1238","line":"    /// INTERNAL ONLY"},
{"lineNum":" 1239","line":"    ///"},
{"lineNum":" 1240","line":"    template<long N>"},
{"lineNum":" 1241","line":"    struct is_callable<functional::child_c<N> >"},
{"lineNum":" 1242","line":"      : mpl::true_"},
{"lineNum":" 1243","line":"    {};"},
{"lineNum":" 1244","line":""},
{"lineNum":" 1245","line":"    /// INTERNAL ONLY"},
{"lineNum":" 1246","line":"    ///"},
{"lineNum":" 1247","line":"    template<typename N>"},
{"lineNum":" 1248","line":"    struct is_callable<functional::child<N> >"},
{"lineNum":" 1249","line":"      : mpl::true_"},
{"lineNum":" 1250","line":"    {};"},
{"lineNum":" 1251","line":""},
{"lineNum":" 1252","line":"}}"},
{"lineNum":" 1253","line":""},
{"lineNum":" 1254","line":"#if defined(_MSC_VER)"},
{"lineNum":" 1255","line":"# pragma warning(pop)"},
{"lineNum":" 1256","line":"#endif"},
{"lineNum":" 1257","line":""},
{"lineNum":" 1258","line":"#endif"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:41", "instrumented" : 2, "covered" : 0,};
var merged_data = [];
