var data = {lines:[
{"lineNum":"    1","line":"/*"},
{"lineNum":"    2","line":"//@HEADER"},
{"lineNum":"    3","line":"// ************************************************************************"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"//                        Kokkos v. 3.0"},
{"lineNum":"    6","line":"//       Copyright (2020) National Technology & Engineering"},
{"lineNum":"    7","line":"//               Solutions of Sandia, LLC (NTESS)."},
{"lineNum":"    8","line":"//"},
{"lineNum":"    9","line":"// Under the terms of Contract DE-NA0003525 with NTESS,"},
{"lineNum":"   10","line":"// the U.S. Government retains certain rights in this software."},
{"lineNum":"   11","line":"//"},
{"lineNum":"   12","line":"// Redistribution and use in source and binary forms, with or without"},
{"lineNum":"   13","line":"// modification, are permitted provided that the following conditions are"},
{"lineNum":"   14","line":"// met:"},
{"lineNum":"   15","line":"//"},
{"lineNum":"   16","line":"// 1. Redistributions of source code must retain the above copyright"},
{"lineNum":"   17","line":"// notice, this list of conditions and the following disclaimer."},
{"lineNum":"   18","line":"//"},
{"lineNum":"   19","line":"// 2. Redistributions in binary form must reproduce the above copyright"},
{"lineNum":"   20","line":"// notice, this list of conditions and the following disclaimer in the"},
{"lineNum":"   21","line":"// documentation and/or other materials provided with the distribution."},
{"lineNum":"   22","line":"//"},
{"lineNum":"   23","line":"// 3. Neither the name of the Corporation nor the names of the"},
{"lineNum":"   24","line":"// contributors may be used to endorse or promote products derived from"},
{"lineNum":"   25","line":"// this software without specific prior written permission."},
{"lineNum":"   26","line":"//"},
{"lineNum":"   27","line":"// THIS SOFTWARE IS PROVIDED BY NTESS \"AS IS\" AND ANY"},
{"lineNum":"   28","line":"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE"},
{"lineNum":"   29","line":"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"},
{"lineNum":"   30","line":"// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NTESS OR THE"},
{"lineNum":"   31","line":"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,"},
{"lineNum":"   32","line":"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,"},
{"lineNum":"   33","line":"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR"},
{"lineNum":"   34","line":"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF"},
{"lineNum":"   35","line":"// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING"},
{"lineNum":"   36","line":"// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS"},
{"lineNum":"   37","line":"// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// Questions? Contact Christian R. Trott (crtrott@sandia.gov)"},
{"lineNum":"   40","line":"//"},
{"lineNum":"   41","line":"// ************************************************************************"},
{"lineNum":"   42","line":"//@HEADER"},
{"lineNum":"   43","line":"*/"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"#ifndef KOKKOS_CORE_EXP_MD_RANGE_POLICY_HPP"},
{"lineNum":"   46","line":"#define KOKKOS_CORE_EXP_MD_RANGE_POLICY_HPP"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#include <initializer_list>"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"#include <Kokkos_Layout.hpp>"},
{"lineNum":"   51","line":"#include <Kokkos_Array.hpp>"},
{"lineNum":"   52","line":"#include <impl/KokkosExp_Host_IterateTile.hpp>"},
{"lineNum":"   53","line":"#include <Kokkos_ExecPolicy.hpp>"},
{"lineNum":"   54","line":"#include <type_traits>"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"namespace Kokkos {"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"// ------------------------------------------------------------------ //"},
{"lineNum":"   59","line":"// Moved to Kokkos_Layout.hpp for more general accessibility"},
{"lineNum":"   60","line":"/*"},
{"lineNum":"   61","line":"enum class Iterate"},
{"lineNum":"   62","line":"{"},
{"lineNum":"   63","line":"  Default, // Default for the device"},
{"lineNum":"   64","line":"  Left,    // Left indices stride fastest"},
{"lineNum":"   65","line":"  Right,   // Right indices stride fastest"},
{"lineNum":"   66","line":"};"},
{"lineNum":"   67","line":"*/"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"template <typename ExecSpace>"},
{"lineNum":"   70","line":"struct default_outer_direction {"},
{"lineNum":"   71","line":"  using type                     = Iterate;"},
{"lineNum":"   72","line":"  static constexpr Iterate value = Iterate::Right;"},
{"lineNum":"   73","line":"};"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"template <typename ExecSpace>"},
{"lineNum":"   76","line":"struct default_inner_direction {"},
{"lineNum":"   77","line":"  using type                     = Iterate;"},
{"lineNum":"   78","line":"  static constexpr Iterate value = Iterate::Right;"},
{"lineNum":"   79","line":"};"},
{"lineNum":"   80","line":""},
{"lineNum":"   81","line":"// Iteration Pattern"},
{"lineNum":"   82","line":"template <unsigned N, Iterate OuterDir = Iterate::Default,"},
{"lineNum":"   83","line":"          Iterate InnerDir = Iterate::Default>"},
{"lineNum":"   84","line":"struct Rank {"},
{"lineNum":"   85","line":"  static_assert(N != 0u, \"Kokkos Error: rank 0 undefined\");"},
{"lineNum":"   86","line":"  static_assert(N != 1u,"},
{"lineNum":"   87","line":"                \"Kokkos Error: rank 1 is not a multi-dimensional range\");"},
{"lineNum":"   88","line":"  static_assert(N < 7u, \"Kokkos Error: Unsupported rank...\");"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"  using iteration_pattern = Rank<N, OuterDir, InnerDir>;"},
{"lineNum":"   91","line":""},
{"lineNum":"   92","line":"  static constexpr int rank                = N;"},
{"lineNum":"   93","line":"  static constexpr Iterate outer_direction = OuterDir;"},
{"lineNum":"   94","line":"  static constexpr Iterate inner_direction = InnerDir;"},
{"lineNum":"   95","line":"};"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"namespace Impl {"},
{"lineNum":"   98","line":"// NOTE the comparison below is encapsulated to silent warnings about pointless"},
{"lineNum":"   99","line":"// comparison of unsigned integer with zero"},
{"lineNum":"  100","line":"template <class T>"},
{"lineNum":"  101","line":"constexpr std::enable_if_t<!std::is_signed<T>::value, bool>"},
{"lineNum":"  102","line":"is_less_than_value_initialized_variable(T) {"},
{"lineNum":"  103","line":"  return false;"},
{"lineNum":"  104","line":"}"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"template <class T>"},
{"lineNum":"  107","line":"constexpr std::enable_if_t<std::is_signed<T>::value, bool>"},
{"lineNum":"  108","line":"is_less_than_value_initialized_variable(T arg) {"},
{"lineNum":"  109","line":"  return arg < T{};","class":"lineNoCov","hits":"0","possible_hits":"19",},
{"lineNum":"  110","line":"}"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"// Checked narrowing conversion that calls abort if the cast changes the value"},
{"lineNum":"  113","line":"template <class To, class From>"},
{"lineNum":"  114","line":"constexpr To checked_narrow_cast(From arg) {"},
{"lineNum":"  115","line":"  constexpr const bool is_different_signedness ="},
{"lineNum":"  116","line":"      (std::is_signed<To>::value != std::is_signed<From>::value);"},
{"lineNum":"  117","line":"  auto const ret = static_cast<To>(arg);"},
{"lineNum":"  118","line":"  if (static_cast<From>(ret) != arg ||","class":"lineNoCov","hits":"0","possible_hits":"21",},
{"lineNum":"  119","line":"      (is_different_signedness &&"},
{"lineNum":"  120","line":"       is_less_than_value_initialized_variable(arg) !=","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  121","line":"           is_less_than_value_initialized_variable(ret))) {"},
{"lineNum":"  122","line":"    Kokkos::abort(\"unsafe narrowing conversion\");","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"  123","line":"  }"},
{"lineNum":"  124","line":"  return ret;"},
{"lineNum":"  125","line":"}"},
{"lineNum":"  126","line":"// NOTE prefer C array U[M] to std::initalizer_list<U> so that the number of"},
{"lineNum":"  127","line":"// elements can be deduced (https://stackoverflow.com/q/40241370)"},
{"lineNum":"  128","line":"// NOTE for some unfortunate reason the policy bounds are stored as signed"},
{"lineNum":"  129","line":"// integer arrays (point_type which is Kokkos::Array<std::int64_t>) so we"},
{"lineNum":"  130","line":"// specify the index type (actual policy index_type from the traits) and check"},
{"lineNum":"  131","line":"// ahead of time that narrowing conversions will be safe."},
{"lineNum":"  132","line":"template <class IndexType, class Array, class U, std::size_t M>"},
{"lineNum":"  133","line":"constexpr Array to_array_potentially_narrowing(const U (&init)[M]) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  134","line":"  using T = typename Array::value_type;"},
{"lineNum":"  135","line":"  Array a{};"},
{"lineNum":"  136","line":"  constexpr std::size_t N = a.size();"},
{"lineNum":"  137","line":"  static_assert(M <= N, \"\");"},
{"lineNum":"  138","line":"  auto* ptr = a.data();"},
{"lineNum":"  139","line":"  // NOTE equivalent to"},
{"lineNum":"  140","line":"  // std::transform(std::begin(init), std::end(init), a.data(),"},
{"lineNum":"  141","line":"  //                [](U x) { return static_cast<T>(x); });"},
{"lineNum":"  142","line":"  // except that std::transform is not constexpr."},
{"lineNum":"  143","line":"  for (auto x : init) {","class":"lineNoCov","hits":"0","possible_hits":"11",},
{"lineNum":"  144","line":"    *ptr++ = checked_narrow_cast<T>(x);"},
{"lineNum":"  145","line":"    (void)checked_narrow_cast<IndexType>(x);  // see note above"},
{"lineNum":"  146","line":"  }"},
{"lineNum":"  147","line":"  return a;"},
{"lineNum":"  148","line":"}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"// NOTE Making a copy even when std::is_same<Array, Kokkos::Array<U, M>>::value"},
{"lineNum":"  151","line":"// is true to reduce code complexity.  You may change this if you have a good"},
{"lineNum":"  152","line":"// reason to.  Intentionally not enabling std::array at this time but this may"},
{"lineNum":"  153","line":"// change too."},
{"lineNum":"  154","line":"template <class IndexType, class NVCC_WONT_LET_ME_CALL_YOU_Array, class U,"},
{"lineNum":"  155","line":"          std::size_t M>"},
{"lineNum":"  156","line":"constexpr NVCC_WONT_LET_ME_CALL_YOU_Array to_array_potentially_narrowing("},
{"lineNum":"  157","line":"    Kokkos::Array<U, M> const& other) {"},
{"lineNum":"  158","line":"  using T = typename NVCC_WONT_LET_ME_CALL_YOU_Array::value_type;"},
{"lineNum":"  159","line":"  NVCC_WONT_LET_ME_CALL_YOU_Array a{};"},
{"lineNum":"  160","line":"  constexpr std::size_t N = a.size();"},
{"lineNum":"  161","line":"  static_assert(M <= N, \"\");"},
{"lineNum":"  162","line":"  for (std::size_t i = 0; i < M; ++i) {"},
{"lineNum":"  163","line":"    a[i] = checked_narrow_cast<T>(other[i]);"},
{"lineNum":"  164","line":"    (void)checked_narrow_cast<IndexType>(other[i]);  // see note above"},
{"lineNum":"  165","line":"  }"},
{"lineNum":"  166","line":"  return a;"},
{"lineNum":"  167","line":"}"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"struct TileSizeProperties {"},
{"lineNum":"  170","line":"  int max_threads;"},
{"lineNum":"  171","line":"  int default_largest_tile_size;"},
{"lineNum":"  172","line":"  int default_tile_size;"},
{"lineNum":"  173","line":"  int max_total_tile_size;"},
{"lineNum":"  174","line":"};"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"template <typename ExecutionSpace>"},
{"lineNum":"  177","line":"TileSizeProperties get_tile_size_properties(const ExecutionSpace&) {"},
{"lineNum":"  178","line":"  // Host settings"},
{"lineNum":"  179","line":"  TileSizeProperties properties;"},
{"lineNum":"  180","line":"  properties.max_threads               = std::numeric_limits<int>::max();"},
{"lineNum":"  181","line":"  properties.default_largest_tile_size = 0;"},
{"lineNum":"  182","line":"  properties.default_tile_size         = 2;"},
{"lineNum":"  183","line":"  properties.max_total_tile_size       = std::numeric_limits<int>::max();"},
{"lineNum":"  184","line":"  return properties;"},
{"lineNum":"  185","line":"}"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"}  // namespace Impl"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"// multi-dimensional iteration pattern"},
{"lineNum":"  190","line":"template <typename... Properties>"},
{"lineNum":"  191","line":"struct MDRangePolicy : public Kokkos::Impl::PolicyTraits<Properties...> {"},
{"lineNum":"  192","line":"  using traits       = Kokkos::Impl::PolicyTraits<Properties...>;"},
{"lineNum":"  193","line":"  using range_policy = RangePolicy<Properties...>;"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"  typename traits::execution_space m_space;"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"  using impl_range_policy ="},
{"lineNum":"  198","line":"      RangePolicy<typename traits::execution_space,"},
{"lineNum":"  199","line":"                  typename traits::schedule_type, typename traits::index_type>;"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"  using execution_policy ="},
{"lineNum":"  202","line":"      MDRangePolicy<Properties...>;  // needed for is_execution_space"},
{"lineNum":"  203","line":"                                     // interrogation"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"  template <class... OtherProperties>"},
{"lineNum":"  206","line":"  friend struct MDRangePolicy;"},
{"lineNum":"  207","line":""},
{"lineNum":"  208","line":"  static_assert(!std::is_same<typename traits::iteration_pattern, void>::value,"},
{"lineNum":"  209","line":"                \"Kokkos Error: MD iteration pattern not defined\");"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"  using iteration_pattern = typename traits::iteration_pattern;"},
{"lineNum":"  212","line":"  using work_tag          = typename traits::work_tag;"},
{"lineNum":"  213","line":"  using launch_bounds     = typename traits::launch_bounds;"},
{"lineNum":"  214","line":"  using member_type       = typename range_policy::member_type;"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"  static constexpr int rank = iteration_pattern::rank;"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"  using index_type       = typename traits::index_type;"},
{"lineNum":"  219","line":"  using array_index_type = std::int64_t;"},
{"lineNum":"  220","line":"  using point_type = Kokkos::Array<array_index_type, rank>;  // was index_type"},
{"lineNum":"  221","line":"  using tile_type  = Kokkos::Array<array_index_type, rank>;"},
{"lineNum":"  222","line":"  // If point_type or tile_type is not templated on a signed integral type (if"},
{"lineNum":"  223","line":"  // it is unsigned), then if user passes in intializer_list of"},
{"lineNum":"  224","line":"  // runtime-determined values of signed integral type that are not const will"},
{"lineNum":"  225","line":"  // receive a compiler error due to an invalid case for implicit conversion -"},
{"lineNum":"  226","line":"  // \"conversion from integer or unscoped enumeration type to integer type that"},
{"lineNum":"  227","line":"  // cannot represent all values of the original, except where source is a"},
{"lineNum":"  228","line":"  // constant expression whose value can be stored exactly in the target type\""},
{"lineNum":"  229","line":"  // This would require the user to either pass a matching index_type parameter"},
{"lineNum":"  230","line":"  // as template parameter to the MDRangePolicy or static_cast the individual"},
{"lineNum":"  231","line":"  // values"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"  point_type m_lower          = {};"},
{"lineNum":"  234","line":"  point_type m_upper          = {};"},
{"lineNum":"  235","line":"  tile_type m_tile            = {};"},
{"lineNum":"  236","line":"  point_type m_tile_end       = {};","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  237","line":"  index_type m_num_tiles      = 1;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  238","line":"  index_type m_prod_tile_dims = 1;"},
{"lineNum":"  239","line":"  bool m_tune_tile_size       = false;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"  static constexpr auto outer_direction ="},
{"lineNum":"  242","line":"      (iteration_pattern::outer_direction != Iterate::Default)"},
{"lineNum":"  243","line":"          ? iteration_pattern::outer_direction"},
{"lineNum":"  244","line":"          : default_outer_direction<typename traits::execution_space>::value;"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"  static constexpr auto inner_direction ="},
{"lineNum":"  247","line":"      iteration_pattern::inner_direction != Iterate::Default"},
{"lineNum":"  248","line":"          ? iteration_pattern::inner_direction"},
{"lineNum":"  249","line":"          : default_inner_direction<typename traits::execution_space>::value;"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"  static constexpr auto Right = Iterate::Right;"},
{"lineNum":"  252","line":"  static constexpr auto Left  = Iterate::Left;"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"  KOKKOS_INLINE_FUNCTION const typename traits::execution_space& space() const {"},
{"lineNum":"  255","line":"    return m_space;"},
{"lineNum":"  256","line":"  }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"  MDRangePolicy() = default;"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"  template <typename LT, std::size_t LN, typename UT, std::size_t UN,"},
{"lineNum":"  261","line":"            typename TT = array_index_type, std::size_t TN = rank,"},
{"lineNum":"  262","line":"            typename = std::enable_if_t<std::is_integral<LT>::value &&"},
{"lineNum":"  263","line":"                                        std::is_integral<UT>::value &&"},
{"lineNum":"  264","line":"                                        std::is_integral<TT>::value>>"},
{"lineNum":"  265","line":"  MDRangePolicy(const LT (&lower)[LN], const UT (&upper)[UN],"},
{"lineNum":"  266","line":"                const TT (&tile)[TN] = {})"},
{"lineNum":"  267","line":"      : MDRangePolicy("},
{"lineNum":"  268","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_lower)>("},
{"lineNum":"  269","line":"                lower),"},
{"lineNum":"  270","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_upper)>("},
{"lineNum":"  271","line":"                upper),"},
{"lineNum":"  272","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_tile)>("},
{"lineNum":"  273","line":"                tile)) {"},
{"lineNum":"  274","line":"    static_assert("},
{"lineNum":"  275","line":"        LN == rank && UN == rank && TN <= rank,"},
{"lineNum":"  276","line":"        \"MDRangePolicy: Constructor initializer lists have wrong size\");"},
{"lineNum":"  277","line":"  }"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"  template <typename LT, std::size_t LN, typename UT, std::size_t UN,"},
{"lineNum":"  280","line":"            typename TT = array_index_type, std::size_t TN = rank,"},
{"lineNum":"  281","line":"            typename = std::enable_if_t<std::is_integral<LT>::value &&"},
{"lineNum":"  282","line":"                                        std::is_integral<UT>::value &&"},
{"lineNum":"  283","line":"                                        std::is_integral<TT>::value>>"},
{"lineNum":"  284","line":"  MDRangePolicy(const typename traits::execution_space& work_space,"},
{"lineNum":"  285","line":"                const LT (&lower)[LN], const UT (&upper)[UN],"},
{"lineNum":"  286","line":"                const TT (&tile)[TN] = {})"},
{"lineNum":"  287","line":"      : MDRangePolicy("},
{"lineNum":"  288","line":"            work_space,"},
{"lineNum":"  289","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_lower)>("},
{"lineNum":"  290","line":"                lower),"},
{"lineNum":"  291","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_upper)>(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  292","line":"                upper),"},
{"lineNum":"  293","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_tile)>("},
{"lineNum":"  294","line":"                tile)) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  295","line":"    static_assert("},
{"lineNum":"  296","line":"        LN == rank && UN == rank && TN <= rank,"},
{"lineNum":"  297","line":"        \"MDRangePolicy: Constructor initializer lists have wrong size\");"},
{"lineNum":"  298","line":"  }"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"  // NOTE: Keeping these two constructor despite the templated constructors"},
{"lineNum":"  301","line":"  // from Kokkos arrays for backwards compability to allow construction from"},
{"lineNum":"  302","line":"  // double-braced initializer lists."},
{"lineNum":"  303","line":"  MDRangePolicy(point_type const& lower, point_type const& upper,"},
{"lineNum":"  304","line":"                tile_type const& tile = tile_type{})"},
{"lineNum":"  305","line":"      : MDRangePolicy(typename traits::execution_space(), lower, upper, tile) {}"},
{"lineNum":"  306","line":""},
{"lineNum":"  307","line":"  MDRangePolicy(const typename traits::execution_space& work_space,"},
{"lineNum":"  308","line":"                point_type const& lower, point_type const& upper,"},
{"lineNum":"  309","line":"                tile_type const& tile = tile_type{})"},
{"lineNum":"  310","line":"      : m_space(work_space), m_lower(lower), m_upper(upper), m_tile(tile) {","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  311","line":"    init_helper(Impl::get_tile_size_properties(work_space));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  312","line":"  }"},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"  template <typename T, std::size_t NT = rank,"},
{"lineNum":"  315","line":"            typename = std::enable_if_t<std::is_integral<T>::value>>"},
{"lineNum":"  316","line":"  MDRangePolicy(Kokkos::Array<T, rank> const& lower,"},
{"lineNum":"  317","line":"                Kokkos::Array<T, rank> const& upper,"},
{"lineNum":"  318","line":"                Kokkos::Array<T, NT> const& tile = Kokkos::Array<T, NT>{})"},
{"lineNum":"  319","line":"      : MDRangePolicy(typename traits::execution_space(), lower, upper, tile) {}"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"  template <typename T, std::size_t NT = rank,"},
{"lineNum":"  322","line":"            typename = std::enable_if_t<std::is_integral<T>::value>>"},
{"lineNum":"  323","line":"  MDRangePolicy(const typename traits::execution_space& work_space,"},
{"lineNum":"  324","line":"                Kokkos::Array<T, rank> const& lower,"},
{"lineNum":"  325","line":"                Kokkos::Array<T, rank> const& upper,"},
{"lineNum":"  326","line":"                Kokkos::Array<T, NT> const& tile = Kokkos::Array<T, NT>{})"},
{"lineNum":"  327","line":"      : MDRangePolicy("},
{"lineNum":"  328","line":"            work_space,"},
{"lineNum":"  329","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_lower)>("},
{"lineNum":"  330","line":"                lower),"},
{"lineNum":"  331","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_upper)>("},
{"lineNum":"  332","line":"                upper),"},
{"lineNum":"  333","line":"            Impl::to_array_potentially_narrowing<index_type, decltype(m_tile)>("},
{"lineNum":"  334","line":"                tile)) {}"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"  template <class... OtherProperties>"},
{"lineNum":"  337","line":"  MDRangePolicy(const MDRangePolicy<OtherProperties...> p)"},
{"lineNum":"  338","line":"      : traits(p),  // base class may contain data such as desired occupancy"},
{"lineNum":"  339","line":"        m_space(p.m_space),"},
{"lineNum":"  340","line":"        m_lower(p.m_lower),"},
{"lineNum":"  341","line":"        m_upper(p.m_upper),"},
{"lineNum":"  342","line":"        m_tile(p.m_tile),"},
{"lineNum":"  343","line":"        m_tile_end(p.m_tile_end),"},
{"lineNum":"  344","line":"        m_num_tiles(p.m_num_tiles),"},
{"lineNum":"  345","line":"        m_prod_tile_dims(p.m_prod_tile_dims),"},
{"lineNum":"  346","line":"        m_tune_tile_size(p.m_tune_tile_size) {}"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"  void impl_change_tile_size(const point_type& tile) {"},
{"lineNum":"  349","line":"    m_tile = tile;"},
{"lineNum":"  350","line":"    init_helper(Impl::get_tile_size_properties(m_space));"},
{"lineNum":"  351","line":"  }"},
{"lineNum":"  352","line":"  bool impl_tune_tile_size() const { return m_tune_tile_size; }"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":" private:"},
{"lineNum":"  355","line":"  void init_helper(Impl::TileSizeProperties properties) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  356","line":"    m_prod_tile_dims = 1;"},
{"lineNum":"  357","line":"    int increment    = 1;"},
{"lineNum":"  358","line":"    int rank_start   = 0;"},
{"lineNum":"  359","line":"    int rank_end     = rank;"},
{"lineNum":"  360","line":"    if (inner_direction == Iterate::Right) {"},
{"lineNum":"  361","line":"      increment  = -1;"},
{"lineNum":"  362","line":"      rank_start = rank - 1;"},
{"lineNum":"  363","line":"      rank_end   = -1;"},
{"lineNum":"  364","line":"    }"},
{"lineNum":"  365","line":"    for (int i = rank_start; i != rank_end; i += increment) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  366","line":"      const index_type length = m_upper[i] - m_lower[i];","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  367","line":"      if (m_tile[i] <= 0) {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  368","line":"        m_tune_tile_size = true;","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  369","line":"        if ((inner_direction == Iterate::Right && (i < rank - 1)) ||"},
{"lineNum":"  370","line":"            (inner_direction == Iterate::Left && (i > 0))) {"},
{"lineNum":"  371","line":"          if (m_prod_tile_dims * properties.default_tile_size <","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  372","line":"              static_cast<index_type>(properties.max_total_tile_size)) {"},
{"lineNum":"  373","line":"            m_tile[i] = properties.default_tile_size;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  374","line":"          } else {"},
{"lineNum":"  375","line":"            m_tile[i] = 1;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  376","line":"          }"},
{"lineNum":"  377","line":"        } else {"},
{"lineNum":"  378","line":"          m_tile[i] = properties.default_largest_tile_size == 0","class":"lineNoCov","hits":"0","possible_hits":"14",},
{"lineNum":"  379","line":"                          ? std::max<int>(length, 1)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  380","line":"                          : properties.default_largest_tile_size;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  381","line":"        }"},
{"lineNum":"  382","line":"      }"},
{"lineNum":"  383","line":"      m_tile_end[i] =","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  384","line":"          static_cast<index_type>((length + m_tile[i] - 1) / m_tile[i]);","class":"lineNoCov","hits":"0","possible_hits":"24",},
{"lineNum":"  385","line":"      m_num_tiles *= m_tile_end[i];","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  386","line":"      m_prod_tile_dims *= m_tile[i];","class":"lineNoCov","hits":"0","possible_hits":"12",},
{"lineNum":"  387","line":"    }"},
{"lineNum":"  388","line":"    if (m_prod_tile_dims > static_cast<index_type>(properties.max_threads)) {","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  389","line":"      printf(\" Product of tile dimensions exceed maximum limit: %d\\n\",","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  390","line":"             static_cast<int>(properties.max_threads));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  391","line":"      Kokkos::abort(","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"  392","line":"          \"ExecSpace Error: MDRange tile dims exceed maximum number \""},
{"lineNum":"  393","line":"          \"of threads per block - choose smaller tile dims\");"},
{"lineNum":"  394","line":"    }"},
{"lineNum":"  395","line":"  }","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  396","line":"};"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"}  // namespace Kokkos"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"// For backward compatibility"},
{"lineNum":"  401","line":"namespace Kokkos {"},
{"lineNum":"  402","line":"namespace Experimental {"},
{"lineNum":"  403","line":"using Kokkos::Iterate;"},
{"lineNum":"  404","line":"using Kokkos::MDRangePolicy;"},
{"lineNum":"  405","line":"using Kokkos::Rank;"},
{"lineNum":"  406","line":"}  // namespace Experimental"},
{"lineNum":"  407","line":"}  // namespace Kokkos"},
{"lineNum":"  408","line":""},
{"lineNum":"  409","line":"#endif  // KOKKOS_CORE_EXP_MD_RANGE_POLICY_HPP"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "fodo_cxx", "date" : "2021-12-15 09:03:42", "instrumented" : 34, "covered" : 0,};
var merged_data = [];
